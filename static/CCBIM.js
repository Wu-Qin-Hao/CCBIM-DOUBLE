(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CCBIM"] = factory();
	else
		root["CCBIM"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 653);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(537), __esModule: true };

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(538), __esModule: true };

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__ = __webpack_require__(52);




function Vector3(x, y, z) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Vector3.prototype, {

		isVector3: true,

		set: function set(x, y, z) {

				this.x = x;
				this.y = y;
				this.z = z;

				return this;
		},

		setScalar: function setScalar(scalar) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;

				return this;
		},

		setX: function setX(x) {

				this.x = x;

				return this;
		},

		setY: function setY(y) {

				this.y = y;

				return this;
		},

		setZ: function setZ(z) {

				this.z = z;

				return this;
		},

		setComponent: function setComponent(index, value) {

				switch (index) {

						case 0:
								this.x = value;break;
						case 1:
								this.y = value;break;
						case 2:
								this.z = value;break;
						default:
								throw new Error('index is out of range: ' + index);

				}

				return this;
		},

		getComponent: function getComponent(index) {

				switch (index) {

						case 0:
								return this.x;
						case 1:
								return this.y;
						case 2:
								return this.z;
						default:
								throw new Error('index is out of range: ' + index);

				}
		},

		clone: function clone() {

				return new this.constructor(this.x, this.y, this.z);
		},

		copy: function copy(v) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;

				return this;
		},

		add: function add(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
						return this.addVectors(v, w);
				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;

				return this;
		},

		addScalar: function addScalar(s) {

				this.x += s;
				this.y += s;
				this.z += s;

				return this;
		},

		addVectors: function addVectors(a, b) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;

				return this;
		},

		addScaledVector: function addScaledVector(v, s) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;

				return this;
		},

		sub: function sub(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
						return this.subVectors(v, w);
				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;

				return this;
		},

		subScalar: function subScalar(s) {

				this.x -= s;
				this.y -= s;
				this.z -= s;

				return this;
		},

		subVectors: function subVectors(a, b) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;

				return this;
		},

		multiply: function multiply(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
						return this.multiplyVectors(v, w);
				}

				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;

				return this;
		},

		multiplyScalar: function multiplyScalar(scalar) {

				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;

				return this;
		},

		multiplyVectors: function multiplyVectors(a, b) {

				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;

				return this;
		},

		applyEuler: function () {

				var quaternion = new __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__["a" /* Quaternion */]();

				return function applyEuler(euler) {

						if (!(euler && euler.isEuler)) {

								console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
						}

						return this.applyQuaternion(quaternion.setFromEuler(euler));
				};
		}(),

		applyAxisAngle: function () {

				var quaternion = new __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__["a" /* Quaternion */]();

				return function applyAxisAngle(axis, angle) {

						return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
				};
		}(),

		applyMatrix3: function applyMatrix3(m) {

				var x = this.x,
				    y = this.y,
				    z = this.z;
				var e = m.elements;

				this.x = e[0] * x + e[3] * y + e[6] * z;
				this.y = e[1] * x + e[4] * y + e[7] * z;
				this.z = e[2] * x + e[5] * y + e[8] * z;

				return this;
		},

		applyMatrix4: function applyMatrix4(m) {

				var x = this.x,
				    y = this.y,
				    z = this.z;
				var e = m.elements;

				var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);

				this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
				this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
				this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;

				return this;
		},

		applyQuaternion: function applyQuaternion(q) {

				var x = this.x,
				    y = this.y,
				    z = this.z;
				var qx = q.x,
				    qy = q.y,
				    qz = q.z,
				    qw = q.w;

				var ix = qw * x + qy * z - qz * y;
				var iy = qw * y + qz * x - qx * z;
				var iz = qw * z + qx * y - qy * x;
				var iw = -qx * x - qy * y - qz * z;

				this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
				this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
				this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

				return this;
		},

		project: function project(camera) {

				return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		},

		unproject: function unproject(camera) {

				return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		},

		transformDirection: function transformDirection(m) {

				var x = this.x,
				    y = this.y,
				    z = this.z;
				var e = m.elements;

				this.x = e[0] * x + e[4] * y + e[8] * z;
				this.y = e[1] * x + e[5] * y + e[9] * z;
				this.z = e[2] * x + e[6] * y + e[10] * z;

				return this.normalize();
		},

		divide: function divide(v) {

				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;

				return this;
		},

		divideScalar: function divideScalar(scalar) {

				return this.multiplyScalar(1 / scalar);
		},

		min: function min(v) {

				this.x = Math.min(this.x, v.x);
				this.y = Math.min(this.y, v.y);
				this.z = Math.min(this.z, v.z);

				return this;
		},

		max: function max(v) {

				this.x = Math.max(this.x, v.x);
				this.y = Math.max(this.y, v.y);
				this.z = Math.max(this.z, v.z);

				return this;
		},

		clamp: function clamp(min, max) {

				this.x = Math.max(min.x, Math.min(max.x, this.x));
				this.y = Math.max(min.y, Math.min(max.y, this.y));
				this.z = Math.max(min.z, Math.min(max.z, this.z));

				return this;
		},

		clampScalar: function clampScalar(minVal, maxVal) {

				this.x = Math.max(minVal, Math.min(maxVal, this.x));
				this.y = Math.max(minVal, Math.min(maxVal, this.y));
				this.z = Math.max(minVal, Math.min(maxVal, this.z));

				return this;
		},

		clampLength: function clampLength(min, max) {

				var length = this.length();

				return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		},

		floor: function floor() {

				this.x = Math.floor(this.x);
				this.y = Math.floor(this.y);
				this.z = Math.floor(this.z);

				return this;
		},

		ceil: function ceil() {

				this.x = Math.ceil(this.x);
				this.y = Math.ceil(this.y);
				this.z = Math.ceil(this.z);

				return this;
		},

		round: function round() {

				this.x = Math.round(this.x);
				this.y = Math.round(this.y);
				this.z = Math.round(this.z);

				return this;
		},

		roundToZero: function roundToZero() {

				this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
				this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
				this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);

				return this;
		},

		negate: function negate() {

				this.x = -this.x;
				this.y = -this.y;
				this.z = -this.z;

				return this;
		},

		dot: function dot(v) {

				return this.x * v.x + this.y * v.y + this.z * v.z;
		},

		lengthSq: function lengthSq() {

				return this.x * this.x + this.y * this.y + this.z * this.z;
		},

		length: function length() {

				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		},

		manhattanLength: function manhattanLength() {

				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		},

		normalize: function normalize() {

				return this.divideScalar(this.length() || 1);
		},

		setLength: function setLength(length) {

				return this.normalize().multiplyScalar(length);
		},

		lerp: function lerp(v, alpha) {

				this.x += (v.x - this.x) * alpha;
				this.y += (v.y - this.y) * alpha;
				this.z += (v.z - this.z) * alpha;

				return this;
		},

		lerpVectors: function lerpVectors(v1, v2, alpha) {

				return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
		},

		cross: function cross(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
						return this.crossVectors(v, w);
				}

				return this.crossVectors(this, v);
		},

		crossVectors: function crossVectors(a, b) {

				var ax = a.x,
				    ay = a.y,
				    az = a.z;
				var bx = b.x,
				    by = b.y,
				    bz = b.z;

				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;

				return this;
		},

		projectOnVector: function projectOnVector(vector) {

				var scalar = vector.dot(this) / vector.lengthSq();

				return this.copy(vector).multiplyScalar(scalar);
		},

		projectOnPlane: function () {

				var v1 = new Vector3();

				return function projectOnPlane(planeNormal) {

						v1.copy(this).projectOnVector(planeNormal);

						return this.sub(v1);
				};
		}(),

		reflect: function () {

				var v1 = new Vector3();

				return function reflect(normal) {

						return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
				};
		}(),

		angleTo: function angleTo(v) {

				var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());

				return Math.acos(__WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].clamp(theta, -1, 1));
		},

		distanceTo: function distanceTo(v) {

				return Math.sqrt(this.distanceToSquared(v));
		},

		distanceToSquared: function distanceToSquared(v) {

				var dx = this.x - v.x,
				    dy = this.y - v.y,
				    dz = this.z - v.z;

				return dx * dx + dy * dy + dz * dz;
		},

		manhattanDistanceTo: function manhattanDistanceTo(v) {

				return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		},

		setFromSpherical: function setFromSpherical(s) {

				return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		},

		setFromSphericalCoords: function setFromSphericalCoords(radius, phi, theta) {

				var sinPhiRadius = Math.sin(phi) * radius;

				this.x = sinPhiRadius * Math.sin(theta);
				this.y = Math.cos(phi) * radius;
				this.z = sinPhiRadius * Math.cos(theta);

				return this;
		},

		setFromCylindrical: function setFromCylindrical(c) {

				return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		},

		setFromCylindricalCoords: function setFromCylindricalCoords(radius, theta, y) {

				this.x = radius * Math.sin(theta);
				this.y = y;
				this.z = radius * Math.cos(theta);

				return this;
		},

		setFromMatrixPosition: function setFromMatrixPosition(m) {

				var e = m.elements;

				this.x = e[12];
				this.y = e[13];
				this.z = e[14];

				return this;
		},

		setFromMatrixScale: function setFromMatrixScale(m) {

				var sx = this.setFromMatrixColumn(m, 0).length();
				var sy = this.setFromMatrixColumn(m, 1).length();
				var sz = this.setFromMatrixColumn(m, 2).length();

				this.x = sx;
				this.y = sy;
				this.z = sz;

				return this;
		},

		setFromMatrixColumn: function setFromMatrixColumn(m, index) {

				return this.fromArray(m.elements, index * 4);
		},

		equals: function equals(v) {

				return v.x === this.x && v.y === this.y && v.z === this.z;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				this.x = array[offset];
				this.y = array[offset + 1];
				this.z = array[offset + 2];

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				array[offset] = this.x;
				array[offset + 1] = this.y;
				array[offset + 2] = this.z;

				return array;
		},

		fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

				if (offset !== undefined) {

						console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
				}

				this.x = attribute.getX(index);
				this.y = attribute.getY(index);
				this.z = attribute.getZ(index);

				return this;
		}

});



/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return REVISION; });
/* unused harmony export MOUSE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_25", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_21", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_26", function() { return CullFaceFront; });
/* unused harmony export CullFaceFrontBack */
/* unused harmony export FrontFaceDirectionCW */
/* unused harmony export FrontFaceDirectionCCW */
/* unused harmony export BasicShadowMap */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Z", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return FlatShading; });
/* unused harmony export SmoothShading */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return NoColors; });
/* unused harmony export FaceColors */
/* unused harmony export VertexColors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_23", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_24", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_22", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_38", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_39", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_72", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_73", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_40", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_41", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_42", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_43", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_44", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_45", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_46", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_47", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_48", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_14", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_15", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_16", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_17", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_18", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_19", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_20", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_4", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_5", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_6", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "V", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_0", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_1", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_2", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_3", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_7", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_8", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_27", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_31", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_32", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_10", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_33", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_11", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_28", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_29", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_30", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_13", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_34", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_35", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_36", function() { return LuminanceAlphaFormat; });
/* unused harmony export RGBEFormat */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_9", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_12", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_37", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_49", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_50", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_51", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_52", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_53", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_54", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_55", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_56", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_57", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_58", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_59", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_60", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_61", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_62", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_63", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_64", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_65", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_66", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_67", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_68", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_69", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_70", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_71", function() { return RGBA_ASTC_12x12_Format; });
/* unused harmony export LoopOnce */
/* unused harmony export LoopRepeat */
/* unused harmony export LoopPingPong */
/* unused harmony export InterpolateDiscrete */
/* unused harmony export InterpolateLinear */
/* unused harmony export InterpolateSmooth */
/* unused harmony export ZeroCurvatureEnding */
/* unused harmony export ZeroSlopeEnding */
/* unused harmony export WrapAroundEnding */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DRAWMODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return INDEXUPDATEMODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return RGBEEncoding; });
/* unused harmony export LogLuvEncoding */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return ObjectSpaceNormalMap; });
/* unused harmony export TrackballMinRefLen */
/* unused harmony export TrackballMaxRefLen_PC */
/* unused harmony export TrackballMaxRefLen_Phone */
/* unused harmony export FirstPersonMoveRefLen */
/* unused harmony export FirstPersonStopRefLen */
var REVISION = '106dev';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;

var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var DRAWMODE = { TRIANGLES: 0, TRIANGLE_STRIP: 1, TRIANGLE_FAN: 2, LINES: 3, LINE_LOOP: 4, LINE_STRIP: 5 };
var INDEXUPDATEMODE = { UPDATEBUFFER: 1, SORTINDEXRANGE: 2, UNIONDRAWRANGE: 4 };
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var TrackballMinRefLen = 1;
var TrackballMaxRefLen_PC = -1;
var TrackballMaxRefLen_Phone = -1;
var FirstPersonMoveRefLen = 10000;
var FirstPersonStopRefLen = 150000;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector2; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__);




function Vector2(x, y) {

		this.x = x || 0;
		this.y = y || 0;
}

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default()(Vector2.prototype, {

		"width": {

				get: function get() {

						return this.x;
				},

				set: function set(value) {

						this.x = value;
				}

		},

		"height": {

				get: function get() {

						return this.y;
				},

				set: function set(value) {

						this.y = value;
				}

		}

});

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Vector2.prototype, {

		isVector2: true,

		set: function set(x, y) {

				this.x = x;
				this.y = y;

				return this;
		},

		setScalar: function setScalar(scalar) {

				this.x = scalar;
				this.y = scalar;

				return this;
		},

		setX: function setX(x) {

				this.x = x;

				return this;
		},

		setY: function setY(y) {

				this.y = y;

				return this;
		},

		setComponent: function setComponent(index, value) {

				switch (index) {

						case 0:
								this.x = value;break;
						case 1:
								this.y = value;break;
						default:
								throw new Error('index is out of range: ' + index);

				}

				return this;
		},

		getComponent: function getComponent(index) {

				switch (index) {

						case 0:
								return this.x;
						case 1:
								return this.y;
						default:
								throw new Error('index is out of range: ' + index);

				}
		},

		clone: function clone() {

				return new this.constructor(this.x, this.y);
		},

		copy: function copy(v) {

				this.x = v.x;
				this.y = v.y;

				return this;
		},

		add: function add(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
						return this.addVectors(v, w);
				}

				this.x += v.x;
				this.y += v.y;

				return this;
		},

		addScalar: function addScalar(s) {

				this.x += s;
				this.y += s;

				return this;
		},

		addVectors: function addVectors(a, b) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;

				return this;
		},

		addScaledVector: function addScaledVector(v, s) {

				this.x += v.x * s;
				this.y += v.y * s;

				return this;
		},

		sub: function sub(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
						return this.subVectors(v, w);
				}

				this.x -= v.x;
				this.y -= v.y;

				return this;
		},

		subScalar: function subScalar(s) {

				this.x -= s;
				this.y -= s;

				return this;
		},

		subVectors: function subVectors(a, b) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;

				return this;
		},

		multiply: function multiply(v) {

				this.x *= v.x;
				this.y *= v.y;

				return this;
		},

		multiplyScalar: function multiplyScalar(scalar) {

				this.x *= scalar;
				this.y *= scalar;

				return this;
		},

		divide: function divide(v) {

				this.x /= v.x;
				this.y /= v.y;

				return this;
		},

		divideScalar: function divideScalar(scalar) {

				return this.multiplyScalar(1 / scalar);
		},

		applyMatrix3: function applyMatrix3(m) {

				var x = this.x,
				    y = this.y;
				var e = m.elements;

				this.x = e[0] * x + e[3] * y + e[6];
				this.y = e[1] * x + e[4] * y + e[7];

				return this;
		},

		min: function min(v) {

				this.x = Math.min(this.x, v.x);
				this.y = Math.min(this.y, v.y);

				return this;
		},

		max: function max(v) {

				this.x = Math.max(this.x, v.x);
				this.y = Math.max(this.y, v.y);

				return this;
		},

		clamp: function clamp(min, max) {

				this.x = Math.max(min.x, Math.min(max.x, this.x));
				this.y = Math.max(min.y, Math.min(max.y, this.y));

				return this;
		},

		clampScalar: function clampScalar(minVal, maxVal) {

				this.x = Math.max(minVal, Math.min(maxVal, this.x));
				this.y = Math.max(minVal, Math.min(maxVal, this.y));

				return this;
		},

		clampLength: function clampLength(min, max) {

				var length = this.length();

				return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		},

		floor: function floor() {

				this.x = Math.floor(this.x);
				this.y = Math.floor(this.y);

				return this;
		},

		ceil: function ceil() {

				this.x = Math.ceil(this.x);
				this.y = Math.ceil(this.y);

				return this;
		},

		round: function round() {

				this.x = Math.round(this.x);
				this.y = Math.round(this.y);

				return this;
		},

		roundToZero: function roundToZero() {

				this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
				this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);

				return this;
		},

		negate: function negate() {

				this.x = -this.x;
				this.y = -this.y;

				return this;
		},

		dot: function dot(v) {

				return this.x * v.x + this.y * v.y;
		},

		cross: function cross(v) {

				return this.x * v.y - this.y * v.x;
		},

		lengthSq: function lengthSq() {

				return this.x * this.x + this.y * this.y;
		},

		length: function length() {

				return Math.sqrt(this.x * this.x + this.y * this.y);
		},

		manhattanLength: function manhattanLength() {

				return Math.abs(this.x) + Math.abs(this.y);
		},

		normalize: function normalize() {

				return this.divideScalar(this.length() || 1);
		},

		angle: function angle() {

				var angle = Math.atan2(this.y, this.x);

				if (angle < 0) angle += 2 * Math.PI;

				return angle;
		},

		distanceTo: function distanceTo(v) {

				return Math.sqrt(this.distanceToSquared(v));
		},

		distanceToSquared: function distanceToSquared(v) {

				var dx = this.x - v.x,
				    dy = this.y - v.y;
				return dx * dx + dy * dy;
		},

		manhattanDistanceTo: function manhattanDistanceTo(v) {

				return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		},

		setLength: function setLength(length) {

				return this.normalize().multiplyScalar(length);
		},

		lerp: function lerp(v, alpha) {

				this.x += (v.x - this.x) * alpha;
				this.y += (v.y - this.y) * alpha;

				return this;
		},

		lerpVectors: function lerpVectors(v1, v2, alpha) {

				return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
		},

		equals: function equals(v) {

				return v.x === this.x && v.y === this.y;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				this.x = array[offset];
				this.y = array[offset + 1];

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				array[offset] = this.x;
				array[offset + 1] = this.y;

				return array;
		},

		fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

				if (offset !== undefined) {

						console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
				}

				this.x = attribute.getX(index);
				this.y = attribute.getY(index);

				return this;
		},

		rotateAround: function rotateAround(center, angle) {

				var c = Math.cos(angle),
				    s = Math.sin(angle);

				var x = this.x - center.x;
				var y = this.y - center.y;

				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;

				return this;
		}

});



/***/ }),
/* 5 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var core = __webpack_require__(5);
var ctx = __webpack_require__(31);
var hide = __webpack_require__(42);
var has = __webpack_require__(41);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Matrix4; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(2);



function Matrix4() {

		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

		if (arguments.length > 0) {

				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
		}
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Matrix4.prototype, {

		isMatrix4: true,

		set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

				var te = this.elements;

				te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;
				te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;
				te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;
				te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;

				return this;
		},

		identity: function identity() {

				this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

				return this;
		},

		clone: function clone() {

				return new Matrix4().fromArray(this.elements);
		},

		copy: function copy(m) {

				var te = this.elements;
				var me = m.elements;

				te[0] = me[0];te[1] = me[1];te[2] = me[2];te[3] = me[3];
				te[4] = me[4];te[5] = me[5];te[6] = me[6];te[7] = me[7];
				te[8] = me[8];te[9] = me[9];te[10] = me[10];te[11] = me[11];
				te[12] = me[12];te[13] = me[13];te[14] = me[14];te[15] = me[15];

				return this;
		},

		copyPosition: function copyPosition(m) {

				var te = this.elements,
				    me = m.elements;

				te[12] = me[12];
				te[13] = me[13];
				te[14] = me[14];

				return this;
		},

		extractBasis: function extractBasis(xAxis, yAxis, zAxis) {

				xAxis.setFromMatrixColumn(this, 0);
				yAxis.setFromMatrixColumn(this, 1);
				zAxis.setFromMatrixColumn(this, 2);

				return this;
		},

		makeBasis: function makeBasis(xAxis, yAxis, zAxis) {

				this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);

				return this;
		},

		extractRotation: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function extractRotation(m) {

						var te = this.elements;
						var me = m.elements;

						var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
						var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
						var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();

						te[0] = me[0] * scaleX;
						te[1] = me[1] * scaleX;
						te[2] = me[2] * scaleX;
						te[3] = 0;

						te[4] = me[4] * scaleY;
						te[5] = me[5] * scaleY;
						te[6] = me[6] * scaleY;
						te[7] = 0;

						te[8] = me[8] * scaleZ;
						te[9] = me[9] * scaleZ;
						te[10] = me[10] * scaleZ;
						te[11] = 0;

						te[12] = 0;
						te[13] = 0;
						te[14] = 0;
						te[15] = 1;

						return this;
				};
		}(),

		makeRotationFromEuler: function makeRotationFromEuler(euler) {

				if (!(euler && euler.isEuler)) {

						console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
				}

				var te = this.elements;

				var x = euler.x,
				    y = euler.y,
				    z = euler.z;
				var a = Math.cos(x),
				    b = Math.sin(x);
				var c = Math.cos(y),
				    d = Math.sin(y);
				var e = Math.cos(z),
				    f = Math.sin(z);

				if (euler.order === 'XYZ') {

						var ae = a * e,
						    af = a * f,
						    be = b * e,
						    bf = b * f;

						te[0] = c * e;
						te[4] = -c * f;
						te[8] = d;

						te[1] = af + be * d;
						te[5] = ae - bf * d;
						te[9] = -b * c;

						te[2] = bf - ae * d;
						te[6] = be + af * d;
						te[10] = a * c;
				} else if (euler.order === 'YXZ') {

						var ce = c * e,
						    cf = c * f,
						    de = d * e,
						    df = d * f;

						te[0] = ce + df * b;
						te[4] = de * b - cf;
						te[8] = a * d;

						te[1] = a * f;
						te[5] = a * e;
						te[9] = -b;

						te[2] = cf * b - de;
						te[6] = df + ce * b;
						te[10] = a * c;
				} else if (euler.order === 'ZXY') {

						var ce = c * e,
						    cf = c * f,
						    de = d * e,
						    df = d * f;

						te[0] = ce - df * b;
						te[4] = -a * f;
						te[8] = de + cf * b;

						te[1] = cf + de * b;
						te[5] = a * e;
						te[9] = df - ce * b;

						te[2] = -a * d;
						te[6] = b;
						te[10] = a * c;
				} else if (euler.order === 'ZYX') {

						var ae = a * e,
						    af = a * f,
						    be = b * e,
						    bf = b * f;

						te[0] = c * e;
						te[4] = be * d - af;
						te[8] = ae * d + bf;

						te[1] = c * f;
						te[5] = bf * d + ae;
						te[9] = af * d - be;

						te[2] = -d;
						te[6] = b * c;
						te[10] = a * c;
				} else if (euler.order === 'YZX') {

						var ac = a * c,
						    ad = a * d,
						    bc = b * c,
						    bd = b * d;

						te[0] = c * e;
						te[4] = bd - ac * f;
						te[8] = bc * f + ad;

						te[1] = f;
						te[5] = a * e;
						te[9] = -b * e;

						te[2] = -d * e;
						te[6] = ad * f + bc;
						te[10] = ac - bd * f;
				} else if (euler.order === 'XZY') {

						var ac = a * c,
						    ad = a * d,
						    bc = b * c,
						    bd = b * d;

						te[0] = c * e;
						te[4] = -f;
						te[8] = d * e;

						te[1] = ac * f + bd;
						te[5] = a * e;
						te[9] = ad * f - bc;

						te[2] = bc * f - ad;
						te[6] = b * e;
						te[10] = bd * f + ac;
				}

				te[3] = 0;
				te[7] = 0;
				te[11] = 0;

				te[12] = 0;
				te[13] = 0;
				te[14] = 0;
				te[15] = 1;

				return this;
		},

		makeRotationFromQuaternion: function () {

				var zero = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](0, 0, 0);
				var one = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](1, 1, 1);

				return function makeRotationFromQuaternion(q) {

						return this.compose(zero, q, one);
				};
		}(),

		lookAt: function () {

				var x = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var y = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var z = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function lookAt(eye, target, up) {

						var te = this.elements;

						z.subVectors(eye, target);

						if (z.lengthSq() === 0) {

								z.z = 1;
						}

						z.normalize();
						x.crossVectors(up, z);

						if (x.lengthSq() === 0) {

								if (Math.abs(up.z) === 1) {

										z.x += 0.0001;
								} else {

										z.z += 0.0001;
								}

								z.normalize();
								x.crossVectors(up, z);
						}

						x.normalize();
						y.crossVectors(z, x);

						te[0] = x.x;te[4] = y.x;te[8] = z.x;
						te[1] = x.y;te[5] = y.y;te[9] = z.y;
						te[2] = x.z;te[6] = y.z;te[10] = z.z;

						return this;
				};
		}(),

		multiply: function multiply(m, n) {

				if (n !== undefined) {

						console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
						return this.multiplyMatrices(m, n);
				}

				return this.multiplyMatrices(this, m);
		},

		premultiply: function premultiply(m) {

				return this.multiplyMatrices(m, this);
		},

		multiplyMatrices: function multiplyMatrices(a, b) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[0],
				    a12 = ae[4],
				    a13 = ae[8],
				    a14 = ae[12];
				var a21 = ae[1],
				    a22 = ae[5],
				    a23 = ae[9],
				    a24 = ae[13];
				var a31 = ae[2],
				    a32 = ae[6],
				    a33 = ae[10],
				    a34 = ae[14];
				var a41 = ae[3],
				    a42 = ae[7],
				    a43 = ae[11],
				    a44 = ae[15];

				var b11 = be[0],
				    b12 = be[4],
				    b13 = be[8],
				    b14 = be[12];
				var b21 = be[1],
				    b22 = be[5],
				    b23 = be[9],
				    b24 = be[13];
				var b31 = be[2],
				    b32 = be[6],
				    b33 = be[10],
				    b34 = be[14];
				var b41 = be[3],
				    b42 = be[7],
				    b43 = be[11],
				    b44 = be[15];

				te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

				te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

				te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

				te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

				return this;
		},

		multiplyScalar: function multiplyScalar(s) {

				var te = this.elements;

				te[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;
				te[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;
				te[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;
				te[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;

				return this;
		},

		applyToBufferAttribute: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function applyToBufferAttribute(attribute) {

						for (var i = 0, l = attribute.count; i < l; i++) {

								v1.x = attribute.getX(i);
								v1.y = attribute.getY(i);
								v1.z = attribute.getZ(i);

								v1.applyMatrix4(this);

								attribute.setXYZ(i, v1.x, v1.y, v1.z);
						}

						return attribute;
				};
		}(),

		determinant: function determinant() {

				var te = this.elements;

				var n11 = te[0],
				    n12 = te[4],
				    n13 = te[8],
				    n14 = te[12];
				var n21 = te[1],
				    n22 = te[5],
				    n23 = te[9],
				    n24 = te[13];
				var n31 = te[2],
				    n32 = te[6],
				    n33 = te[10],
				    n34 = te[14];
				var n41 = te[3],
				    n42 = te[7],
				    n43 = te[11],
				    n44 = te[15];

				return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		},

		transpose: function transpose() {

				var te = this.elements;
				var tmp;

				tmp = te[1];te[1] = te[4];te[4] = tmp;
				tmp = te[2];te[2] = te[8];te[8] = tmp;
				tmp = te[6];te[6] = te[9];te[9] = tmp;

				tmp = te[3];te[3] = te[12];te[12] = tmp;
				tmp = te[7];te[7] = te[13];te[13] = tmp;
				tmp = te[11];te[11] = te[14];te[14] = tmp;

				return this;
		},

		setPosition: function setPosition(x, y, z) {

				var te = this.elements;

				if (x.isVector3) {

						te[12] = x.x;
						te[13] = x.y;
						te[14] = x.z;
				} else {

						te[12] = x;
						te[13] = y;
						te[14] = z;
				}

				return this;
		},

		getInverse: function getInverse(m, throwOnDegenerate) {
				var te = this.elements,
				    me = m.elements,
				    n11 = me[0],
				    n21 = me[1],
				    n31 = me[2],
				    n41 = me[3],
				    n12 = me[4],
				    n22 = me[5],
				    n32 = me[6],
				    n42 = me[7],
				    n13 = me[8],
				    n23 = me[9],
				    n33 = me[10],
				    n43 = me[11],
				    n14 = me[12],
				    n24 = me[13],
				    n34 = me[14],
				    n44 = me[15],
				    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

				if (det === 0) {

						var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

						if (throwOnDegenerate === true) {

								throw new Error(msg);
						} else {

								console.warn(msg);
						}

						return this.identity();
				}

				var detInv = 1 / det;

				te[0] = t11 * detInv;
				te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
				te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
				te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

				te[4] = t12 * detInv;
				te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
				te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
				te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

				te[8] = t13 * detInv;
				te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
				te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
				te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

				te[12] = t14 * detInv;
				te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
				te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
				te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

				return this;
		},

		scale: function scale(v) {

				var te = this.elements;
				var x = v.x,
				    y = v.y,
				    z = v.z;

				te[0] *= x;te[4] *= y;te[8] *= z;
				te[1] *= x;te[5] *= y;te[9] *= z;
				te[2] *= x;te[6] *= y;te[10] *= z;
				te[3] *= x;te[7] *= y;te[11] *= z;

				return this;
		},

		getMaxScaleOnAxis: function getMaxScaleOnAxis() {

				var te = this.elements;

				var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
				var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
				var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

				return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		},

		makeTranslation: function makeTranslation(x, y, z) {

				this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);

				return this;
		},

		makeRotationX: function makeRotationX(theta) {

				var c = Math.cos(theta),
				    s = Math.sin(theta);

				this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);

				return this;
		},

		makeRotationY: function makeRotationY(theta) {

				var c = Math.cos(theta),
				    s = Math.sin(theta);

				this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);

				return this;
		},

		makeRotationZ: function makeRotationZ(theta) {

				var c = Math.cos(theta),
				    s = Math.sin(theta);

				this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

				return this;
		},

		makeRotationAxis: function makeRotationAxis(axis, angle) {

				var c = Math.cos(angle);
				var s = Math.sin(angle);
				var t = 1 - c;
				var x = axis.x,
				    y = axis.y,
				    z = axis.z;
				var tx = t * x,
				    ty = t * y;

				this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);

				return this;
		},

		makeScale: function makeScale(x, y, z) {

				this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);

				return this;
		},

		makeShear: function makeShear(x, y, z) {

				this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);

				return this;
		},

		compose: function compose(position, quaternion, scale) {

				var te = this.elements;

				var x = quaternion._x,
				    y = quaternion._y,
				    z = quaternion._z,
				    w = quaternion._w;
				var x2 = x + x,
				    y2 = y + y,
				    z2 = z + z;
				var xx = x * x2,
				    xy = x * y2,
				    xz = x * z2;
				var yy = y * y2,
				    yz = y * z2,
				    zz = z * z2;
				var wx = w * x2,
				    wy = w * y2,
				    wz = w * z2;

				var sx = scale.x,
				    sy = scale.y,
				    sz = scale.z;

				te[0] = (1 - (yy + zz)) * sx;
				te[1] = (xy + wz) * sx;
				te[2] = (xz - wy) * sx;
				te[3] = 0;

				te[4] = (xy - wz) * sy;
				te[5] = (1 - (xx + zz)) * sy;
				te[6] = (yz + wx) * sy;
				te[7] = 0;

				te[8] = (xz + wy) * sz;
				te[9] = (yz - wx) * sz;
				te[10] = (1 - (xx + yy)) * sz;
				te[11] = 0;

				te[12] = position.x;
				te[13] = position.y;
				te[14] = position.z;
				te[15] = 1;

				return this;
		},

		decompose: function () {

				var vector = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var matrix = new Matrix4();

				return function decompose(position, quaternion, scale) {

						var te = this.elements;

						var sx = vector.set(te[0], te[1], te[2]).length();
						var sy = vector.set(te[4], te[5], te[6]).length();
						var sz = vector.set(te[8], te[9], te[10]).length();

						var det = this.determinant();
						if (det < 0) sx = -sx;

						position.x = te[12];
						position.y = te[13];
						position.z = te[14];

						matrix.copy(this);

						var invSX = 1 / sx;
						var invSY = 1 / sy;
						var invSZ = 1 / sz;

						matrix.elements[0] *= invSX;
						matrix.elements[1] *= invSX;
						matrix.elements[2] *= invSX;

						matrix.elements[4] *= invSY;
						matrix.elements[5] *= invSY;
						matrix.elements[6] *= invSY;

						matrix.elements[8] *= invSZ;
						matrix.elements[9] *= invSZ;
						matrix.elements[10] *= invSZ;

						quaternion.setFromRotationMatrix(matrix);

						scale.x = sx;
						scale.y = sy;
						scale.z = sz;

						return this;
				};
		}(),

		makePerspective: function makePerspective(left, right, top, bottom, near, far) {

				if (far === undefined) {

						console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
				}

				var te = this.elements;
				var x = 2 * near / (right - left);
				var y = 2 * near / (top - bottom);

				var a = (right + left) / (right - left);
				var b = (top + bottom) / (top - bottom);
				var c = -(far + near) / (far - near);
				var d = -2 * far * near / (far - near);

				te[0] = x;te[4] = 0;te[8] = a;te[12] = 0;
				te[1] = 0;te[5] = y;te[9] = b;te[13] = 0;
				te[2] = 0;te[6] = 0;te[10] = c;te[14] = d;
				te[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;

				return this;
		},

		makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {

				var te = this.elements;
				var w = 1.0 / (right - left);
				var h = 1.0 / (top - bottom);
				var p = 1.0 / (far - near);

				var x = (right + left) * w;
				var y = (top + bottom) * h;
				var z = (far + near) * p;

				te[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;
				te[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;
				te[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;
				te[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;

				return this;
		},

		equals: function equals(matrix) {

				var te = this.elements;
				var me = matrix.elements;

				for (var i = 0; i < 16; i++) {

						if (te[i] !== me[i]) return false;
				}

				return true;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				for (var i = 0; i < 16; i++) {

						this.elements[i] = array[i + offset];
				}

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				var te = this.elements;

				array[offset] = te[0];
				array[offset + 1] = te[1];
				array[offset + 2] = te[2];
				array[offset + 3] = te[3];

				array[offset + 4] = te[4];
				array[offset + 5] = te[5];
				array[offset + 6] = te[6];
				array[offset + 7] = te[7];

				array[offset + 8] = te[8];
				array[offset + 9] = te[9];
				array[offset + 10] = te[10];
				array[offset + 11] = te[11];

				array[offset + 12] = te[12];
				array[offset + 13] = te[13];
				array[offset + 14] = te[14];
				array[offset + 15] = te[15];

				return array;
		}

});



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _Math; });


var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		var lut = [];

		for (var i = 0; i < 256; i++) {

			lut[i] = (i < 16 ? '0' : '') + i.toString(16);
		}

		return function generateUUID() {

			var d0 = Math.random() * 0xffffffff | 0;
			var d1 = Math.random() * 0xffffffff | 0;
			var d2 = Math.random() * 0xffffffff | 0;
			var d3 = Math.random() * 0xffffffff | 0;
			var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];

			return uuid.toUpperCase();
		};
	}(),

	clamp: function clamp(value, min, max) {

		return Math.max(min, Math.min(max, value));
	},

	euclideanModulo: function euclideanModulo(n, m) {

		return (n % m + m) % m;
	},

	mapLinear: function mapLinear(x, a1, a2, b1, b2) {

		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	},

	lerp: function lerp(x, y, t) {

		return (1 - t) * x + t * y;
	},

	smoothstep: function smoothstep(x, min, max) {

		if (x <= min) return 0;
		if (x >= max) return 1;

		x = (x - min) / (max - min);

		return x * x * (3 - 2 * x);
	},

	smootherstep: function smootherstep(x, min, max) {

		if (x <= min) return 0;
		if (x >= max) return 1;

		x = (x - min) / (max - min);

		return x * x * x * (x * (x * 6 - 15) + 10);
	},

	randInt: function randInt(low, high) {

		return low + Math.floor(Math.random() * (high - low + 1));
	},

	randFloat: function randFloat(low, high) {

		return low + Math.random() * (high - low);
	},

	randFloatSpread: function randFloatSpread(range) {

		return range * (0.5 - Math.random());
	},

	degToRad: function degToRad(degrees) {

		return degrees * _Math.DEG2RAD;
	},

	radToDeg: function radToDeg(radians) {

		return radians * _Math.RAD2DEG;
	},

	isPowerOfTwo: function isPowerOfTwo(value) {

		return (value & value - 1) === 0 && value !== 0;
	},

	ceilPowerOfTwo: function ceilPowerOfTwo(value) {

		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	},

	floorPowerOfTwo: function floorPowerOfTwo(value) {

		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	},

	compareFloat: function compareFloat(f1, v2, prec) {
		if (!prec) {
			prec = 0.00001;
		}

		if (Math.abs(f1 - v2) - prec > 0) {
			return false;
		}
		return true;
	}

};



/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Color; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Math_js__ = __webpack_require__(8);



var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

function Color(r, g, b) {

		if (g === undefined && b === undefined) {
				return this.set(r);
		}

		return this.setRGB(r, g, b);
}

function hue2rgb(p, q, t) {

		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
}

function SRGBToLinear(c) {

		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function LinearToSRGB(c) {

		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function set(value) {

				if (value && value.isColor) {

						this.copy(value);
				} else if (typeof value === 'number') {

						this.setHex(value);
				} else if (typeof value === 'string') {

						this.setStyle(value);
				}

				return this;
		},

		setScalar: function setScalar(scalar) {

				this.r = scalar;
				this.g = scalar;
				this.b = scalar;

				return this;
		},

		setHex: function setHex(hex) {

				hex = Math.floor(hex);

				this.r = (hex >> 16 & 255) / 255;
				this.g = (hex >> 8 & 255) / 255;
				this.b = (hex & 255) / 255;

				return this;
		},

		setRGB: function setRGB(r, g, b) {

				this.r = r;
				this.g = g;
				this.b = b;

				return this;
		},

		setHSL: function setHSL(h, s, l) {
				h = __WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].euclideanModulo(h, 1);
				s = __WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].clamp(s, 0, 1);
				l = __WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].clamp(l, 0, 1);

				if (s === 0) {

						this.r = this.g = this.b = l;
				} else {

						var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
						var q = 2 * l - p;

						this.r = hue2rgb(q, p, h + 1 / 3);
						this.g = hue2rgb(q, p, h);
						this.b = hue2rgb(q, p, h - 1 / 3);
				}

				return this;
		},

		setStyle: function setStyle(style) {

				function handleAlpha(string) {

						if (string === undefined) return;

						if (parseFloat(string) < 1) {

								console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
						}
				}

				var m;

				if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {

						var color;
						var name = m[1];
						var components = m[2];

						switch (name) {

								case 'rgb':
								case 'rgba':

										if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
												this.r = Math.min(255, parseInt(color[1], 10)) / 255;
												this.g = Math.min(255, parseInt(color[2], 10)) / 255;
												this.b = Math.min(255, parseInt(color[3], 10)) / 255;

												handleAlpha(color[5]);

												return this;
										}

										if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
												this.r = Math.min(100, parseInt(color[1], 10)) / 100;
												this.g = Math.min(100, parseInt(color[2], 10)) / 100;
												this.b = Math.min(100, parseInt(color[3], 10)) / 100;

												handleAlpha(color[5]);

												return this;
										}

										break;

								case 'hsl':
								case 'hsla':

										if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
												var h = parseFloat(color[1]) / 360;
												var s = parseInt(color[2], 10) / 100;
												var l = parseInt(color[3], 10) / 100;

												handleAlpha(color[5]);

												return this.setHSL(h, s, l);
										}

										break;

						}
				} else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {

						var hex = m[1];
						var size = hex.length;

						if (size === 3) {
								this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
								this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
								this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

								return this;
						} else if (size === 6) {
								this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
								this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
								this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

								return this;
						}
				}

				if (style && style.length > 0) {
						var hex = ColorKeywords[style];

						if (hex !== undefined) {
								this.setHex(hex);
						} else {
								console.warn('THREE.Color: Unknown color ' + style);
						}
				}

				return this;
		},

		clone: function clone() {

				return new this.constructor(this.r, this.g, this.b);
		},

		copy: function copy(color) {

				this.r = color.r;
				this.g = color.g;
				this.b = color.b;

				return this;
		},

		copyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {

				if (gammaFactor === undefined) gammaFactor = 2.0;

				this.r = Math.pow(color.r, gammaFactor);
				this.g = Math.pow(color.g, gammaFactor);
				this.b = Math.pow(color.b, gammaFactor);

				return this;
		},

		copyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {

				if (gammaFactor === undefined) gammaFactor = 2.0;

				var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;

				this.r = Math.pow(color.r, safeInverse);
				this.g = Math.pow(color.g, safeInverse);
				this.b = Math.pow(color.b, safeInverse);

				return this;
		},

		convertGammaToLinear: function convertGammaToLinear(gammaFactor) {

				this.copyGammaToLinear(this, gammaFactor);

				return this;
		},

		convertLinearToGamma: function convertLinearToGamma(gammaFactor) {

				this.copyLinearToGamma(this, gammaFactor);

				return this;
		},

		copySRGBToLinear: function copySRGBToLinear(color) {

				this.r = SRGBToLinear(color.r);
				this.g = SRGBToLinear(color.g);
				this.b = SRGBToLinear(color.b);

				return this;
		},

		copyLinearToSRGB: function copyLinearToSRGB(color) {

				this.r = LinearToSRGB(color.r);
				this.g = LinearToSRGB(color.g);
				this.b = LinearToSRGB(color.b);

				return this;
		},

		convertSRGBToLinear: function convertSRGBToLinear() {

				this.copySRGBToLinear(this);

				return this;
		},

		convertLinearToSRGB: function convertLinearToSRGB() {

				this.copyLinearToSRGB(this);

				return this;
		},

		getHex: function getHex() {

				return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		},

		getHexString: function getHexString() {

				return ('000000' + this.getHex().toString(16)).slice(-6);
		},

		getHSL: function getHSL(target) {

				if (target === undefined) {

						console.warn('THREE.Color: .getHSL() target is now required');
						target = { h: 0, s: 0, l: 0 };
				}

				var r = this.r,
				    g = this.g,
				    b = this.b;

				var max = Math.max(r, g, b);
				var min = Math.min(r, g, b);

				var hue, saturation;
				var lightness = (min + max) / 2.0;

				if (min === max) {

						hue = 0;
						saturation = 0;
				} else {

						var delta = max - min;

						saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

						switch (max) {

								case r:
										hue = (g - b) / delta + (g < b ? 6 : 0);break;
								case g:
										hue = (b - r) / delta + 2;break;
								case b:
										hue = (r - g) / delta + 4;break;

						}

						hue /= 6;
				}

				target.h = hue;
				target.s = saturation;
				target.l = lightness;

				return target;
		},

		getStyle: function getStyle() {

				return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		},

		offsetHSL: function () {

				var hsl = {};

				return function (h, s, l) {

						this.getHSL(hsl);

						hsl.h += h;hsl.s += s;hsl.l += l;

						this.setHSL(hsl.h, hsl.s, hsl.l);

						return this;
				};
		}(),

		add: function add(color) {

				this.r += color.r;
				this.g += color.g;
				this.b += color.b;

				return this;
		},

		addColors: function addColors(color1, color2) {

				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;

				return this;
		},

		addScalar: function addScalar(s) {

				this.r += s;
				this.g += s;
				this.b += s;

				return this;
		},

		sub: function sub(color) {

				this.r = Math.max(0, this.r - color.r);
				this.g = Math.max(0, this.g - color.g);
				this.b = Math.max(0, this.b - color.b);

				return this;
		},

		multiply: function multiply(color) {

				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;

				return this;
		},

		multiplyScalar: function multiplyScalar(s) {

				this.r *= s;
				this.g *= s;
				this.b *= s;

				return this;
		},

		lerp: function lerp(color, alpha) {

				this.r += (color.r - this.r) * alpha;
				this.g += (color.g - this.g) * alpha;
				this.b += (color.b - this.b) * alpha;

				return this;
		},

		lerpHSL: function () {

				var hslA = { h: 0, s: 0, l: 0 };
				var hslB = { h: 0, s: 0, l: 0 };

				return function lerpHSL(color, alpha) {

						this.getHSL(hslA);
						color.getHSL(hslB);

						var h = __WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].lerp(hslA.h, hslB.h, alpha);
						var s = __WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].lerp(hslA.s, hslB.s, alpha);
						var l = __WEBPACK_IMPORTED_MODULE_1__Math_js__["a" /* _Math */].lerp(hslA.l, hslB.l, alpha);

						this.setHSL(h, s, l);

						return this;
				};
		}(),

		equals: function equals(c) {

				return c.r === this.r && c.g === this.g && c.b === this.b;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				this.r = array[offset];
				this.g = array[offset + 1];
				this.b = array[offset + 2];

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				array[offset] = this.r;
				array[offset + 1] = this.g;
				array[offset + 2] = this.b;

				return array;
		},

		toJSON: function toJSON() {

				return this.getHex();
		}

});



/***/ }),
/* 10 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = __webpack_require__(33);

var roots = __webpack_require__(221);

var Type, // cyclic
    Enum;

util.codegen = __webpack_require__(233);
util.fetch   = __webpack_require__(235);
util.path    = __webpack_require__(237);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = __webpack_require__(135);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = __webpack_require__(27);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (__webpack_require__(133))());
    }
});


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Float32BufferAttributeModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return BufferAttribute; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector4_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Color_js__ = __webpack_require__(9);







function BufferAttribute(array, itemSize, normalized) {

	if (Array.isArray(array)) {

		throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: -1 };

	this.version = 0;
}

Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {

	set: function set(value) {

		if (value === true) this.version++;
	}

});

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function onUploadCallback() {},

	setArray: function setArray(array) {

		if (Array.isArray(array)) {

			throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
		}

		this.count = array !== undefined ? array.length / this.itemSize : 0;
		this.array = array;

		return this;
	},

	setDynamic: function setDynamic(value) {

		this.dynamic = value;

		return this;
	},

	copy: function copy(source) {

		this.name = source.name;
		this.array = new source.array.constructor(source.array);
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.dynamic = source.dynamic;

		return this;
	},

	copyAt: function copyAt(index1, attribute, index2) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for (var i = 0, l = this.itemSize; i < l; i++) {

			this.array[index1 + i] = attribute.array[index2 + i];
		}

		return this;
	},

	copyArray: function copyArray(array) {

		this.array.set(array);

		return this;
	},

	copyColorsArray: function copyColorsArray(colors) {

		var array = this.array,
		    offset = 0;

		for (var i = 0, l = colors.length; i < l; i++) {

			var color = colors[i];

			if (color === undefined) {

				console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
				color = new __WEBPACK_IMPORTED_MODULE_5__math_Color_js__["a" /* Color */]();
			}

			array[offset++] = color.r;
			array[offset++] = color.g;
			array[offset++] = color.b;
		}

		return this;
	},

	copyVector2sArray: function copyVector2sArray(vectors) {

		var array = this.array,
		    offset = 0;

		for (var i = 0, l = vectors.length; i < l; i++) {

			var vector = vectors[i];

			if (vector === undefined) {

				console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
				vector = new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]();
			}

			array[offset++] = vector.x;
			array[offset++] = vector.y;
		}

		return this;
	},

	copyVector3sArray: function copyVector3sArray(vectors) {

		var array = this.array,
		    offset = 0;

		for (var i = 0, l = vectors.length; i < l; i++) {

			var vector = vectors[i];

			if (vector === undefined) {

				console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
				vector = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
			}

			array[offset++] = vector.x;
			array[offset++] = vector.y;
			array[offset++] = vector.z;
		}

		return this;
	},

	copyVector4sArray: function copyVector4sArray(vectors) {

		var array = this.array,
		    offset = 0;

		for (var i = 0, l = vectors.length; i < l; i++) {

			var vector = vectors[i];

			if (vector === undefined) {

				console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
				vector = new __WEBPACK_IMPORTED_MODULE_2__math_Vector4_js__["a" /* Vector4 */]();
			}

			array[offset++] = vector.x;
			array[offset++] = vector.y;
			array[offset++] = vector.z;
			array[offset++] = vector.w;
		}

		return this;
	},

	set: function set(value, offset) {

		if (offset === undefined) offset = 0;

		this.array.set(value, offset);

		return this;
	},

	getX: function getX(index) {

		return this.array[index * this.itemSize];
	},

	setX: function setX(index, x) {

		this.array[index * this.itemSize] = x;

		return this;
	},

	getY: function getY(index) {

		return this.array[index * this.itemSize + 1];
	},

	setY: function setY(index, y) {

		this.array[index * this.itemSize + 1] = y;

		return this;
	},

	getZ: function getZ(index) {

		return this.array[index * this.itemSize + 2];
	},

	setZ: function setZ(index, z) {

		this.array[index * this.itemSize + 2] = z;

		return this;
	},

	getW: function getW(index) {

		return this.array[index * this.itemSize + 3];
	},

	setW: function setW(index, w) {

		this.array[index * this.itemSize + 3] = w;

		return this;
	},

	setXY: function setXY(index, x, y) {

		index *= this.itemSize;

		this.array[index + 0] = x;
		this.array[index + 1] = y;

		return this;
	},

	setXYZ: function setXYZ(index, x, y, z) {

		index *= this.itemSize;

		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;

		return this;
	},

	setXYZW: function setXYZW(index, x, y, z, w) {

		index *= this.itemSize;

		this.array[index + 0] = x;
		this.array[index + 1] = y;
		this.array[index + 2] = z;
		this.array[index + 3] = w;

		return this;
	},

	onUpload: function onUpload(callback) {

		this.onUploadCallback = callback;

		return this;
	},

	clone: function clone() {

		return new this.constructor(this.array, this.itemSize).copy(this);
	},

	toJSON: function toJSON() {

		return {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call(this.array),
			normalized: this.normalized
		};
	}

});

function Int8BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}

Int8BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

function Uint8BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}

Uint8BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

function Uint8ClampedBufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}

Uint8ClampedBufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

function Int16BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}

Int16BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

function Uint16BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}

Uint16BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

function Int32BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}

Int32BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

function Uint32BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}

Uint32BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float32BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}

Float32BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

function Float32BufferAttributeModel(array, itemSize, normalized) {

	BufferAttribute.call(this, array, itemSize, normalized);
}

Float32BufferAttributeModel.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Float32BufferAttributeModel.prototype.constructor = Float32BufferAttributeModel;

function Float64BufferAttribute(array, itemSize, normalized) {

	BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}

Float64BufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(123)('wks');
var uid = __webpack_require__(85);
var Symbol = __webpack_require__(10).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Object3D; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Euler_js__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Layers_js__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__math_Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__math_Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__constants_js__ = __webpack_require__(3);














var object3DId = 0;

function Object3D() {

	Object.defineProperty(this, 'id', { value: object3DId++ });

	this.uuid = __WEBPACK_IMPORTED_MODULE_11__math_Math_js__["a" /* _Math */].generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
	var rotation = new __WEBPACK_IMPORTED_MODULE_8__math_Euler_js__["a" /* Euler */]();
	var quaternion = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();
	var scale = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](1, 1, 1);

	function onRotationChange() {

		quaternion.setFromEuler(rotation, false);
	}

	function onQuaternionChange() {

		rotation.setFromQuaternion(quaternion, undefined, false);
	}

	rotation._onChange(onRotationChange);
	quaternion._onChange(onQuaternionChange);

	__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_define_properties___default()(this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]()
		},
		normalMatrix: {
			value: new __WEBPACK_IMPORTED_MODULE_10__math_Matrix3_js__["a" /* Matrix3 */]()
		}
	});

	this.matrix = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
	this.matrixWorld = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new __WEBPACK_IMPORTED_MODULE_9__Layers_js__["a" /* Layers */]();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};
}

Object3D.DefaultUp = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_7__EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function onBeforeRender() {},
	onAfterRender: function onAfterRender() {},

	applyMatrix: function applyMatrix(matrix) {

		if (this.matrixAutoUpdate) this.updateMatrix();

		this.matrix.premultiply(matrix);

		this.matrix.decompose(this.position, this.quaternion, this.scale);
	},

	applyQuaternion: function applyQuaternion(q) {

		this.quaternion.premultiply(q);

		return this;
	},

	setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {

		this.quaternion.setFromAxisAngle(axis, angle);
	},

	setRotationFromEuler: function setRotationFromEuler(euler) {

		this.quaternion.setFromEuler(euler, true);
	},

	setRotationFromMatrix: function setRotationFromMatrix(m) {

		this.quaternion.setFromRotationMatrix(m);
	},

	setRotationFromQuaternion: function setRotationFromQuaternion(q) {

		this.quaternion.copy(q);
	},

	rotateOnAxis: function () {

		var q1 = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();

		return function rotateOnAxis(axis, angle) {

			q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(q1);

			return this;
		};
	}(),

	rotateOnWorldAxis: function () {

		var q1 = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();

		return function rotateOnWorldAxis(axis, angle) {

			q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(q1);

			return this;
		};
	}(),

	rotateX: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](1, 0, 0);

		return function rotateX(angle) {

			return this.rotateOnAxis(v1, angle);
		};
	}(),

	rotateY: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0);

		return function rotateY(angle) {

			return this.rotateOnAxis(v1, angle);
		};
	}(),

	rotateZ: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, 1);

		return function rotateZ(angle) {

			return this.rotateOnAxis(v1, angle);
		};
	}(),

	translateOnAxis: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

		return function translateOnAxis(axis, distance) {

			v1.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(v1.multiplyScalar(distance));

			return this;
		};
	}(),

	translateX: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](1, 0, 0);

		return function translateX(distance) {

			return this.translateOnAxis(v1, distance);
		};
	}(),

	translateY: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0);

		return function translateY(distance) {

			return this.translateOnAxis(v1, distance);
		};
	}(),

	translateZ: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, 1);

		return function translateZ(distance) {

			return this.translateOnAxis(v1, distance);
		};
	}(),

	localToWorld: function localToWorld(vector) {

		return vector.applyMatrix4(this.matrixWorld);
	},

	worldToLocal: function () {

		var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();

		return function worldToLocal(vector) {

			return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
		};
	}(),

	lookAt: function () {

		var q1 = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();
		var m1 = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();
		var target = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
		var position = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

		return function lookAt(x, y, z) {

			if (x.isVector3) {

				target.copy(x);
			} else {

				target.set(x, y, z);
			}

			var parent = this.parent;

			this.updateWorldMatrix(true, false);

			position.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {

				m1.lookAt(position, target, this.up);
			} else {

				m1.lookAt(target, position, this.up);
			}

			this.quaternion.setFromRotationMatrix(m1);

			if (parent) {

				m1.extractRotation(parent.matrixWorld);
				q1.setFromRotationMatrix(m1);
				this.quaternion.premultiply(q1.inverse());
			}
		};
	}(),

	add: function add(object) {

		if (arguments.length > 1) {

			for (var i = 0; i < arguments.length; i++) {

				this.add(arguments[i]);
			}

			return this;
		}

		if (object === this) {

			console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
			return this;
		}

		if (object && object.isObject3D) {

			if (object.parent !== null) {

				object.parent.remove(object);
			}

			object.parent = this;
			this.children.push(object);

			object.dispatchEvent({ type: 'added' });
		} else {

			console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
		}

		return this;
	},

	remove: function remove(object) {

		if (arguments.length > 1) {

			for (var i = 0; i < arguments.length; i++) {

				this.remove(arguments[i]);
			}

			return this;
		}

		var index = this.children.indexOf(object);

		if (index !== -1) {

			object.parent = null;
			this.children.splice(index, 1);

			object.dispatchEvent({ type: 'removed' });
		}

		return this;
	},

	removeAll: function removeAll() {

		for (var i = 0; i < this.children.length; i++) {

			var object = this.children[i];
			if (object.type === 'Group') {
				object.removeAll();
			}
			object.parent = null;

			object.dispose();
		}
		this.children = [];

		return this;
	},

	dispose: function dispose() {
		this.dispatchEvent({ type: 'dispose' });
	},

	attach: function () {

		var m = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4_js__["a" /* Matrix4 */]();

		return function attach(object) {

			this.updateWorldMatrix(true, false);

			m.getInverse(this.matrixWorld);

			if (object.parent !== null) {

				object.parent.updateWorldMatrix(true, false);

				m.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix(m);

			object.updateWorldMatrix(false, false);

			this.add(object);

			return this;
		};
	}(),

	getObjectById: function getObjectById(id) {

		return this.getObjectByProperty('id', id);
	},

	getObjectByName: function getObjectByName(name) {

		return this.getObjectByProperty('name', name);
	},

	getObjectByProperty: function getObjectByProperty(name, value) {

		if (this[name] === value) return this;

		for (var i = 0, l = this.children.length; i < l; i++) {

			var child = this.children[i];
			var object = child.getObjectByProperty(name, value);

			if (object !== undefined) {

				return object;
			}
		}

		return undefined;
	},

	getWorldPosition: function getWorldPosition(target) {

		if (target === undefined) {

			console.warn('THREE.Object3D: .getWorldPosition() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
		}

		this.updateMatrixWorld(true);

		return target.setFromMatrixPosition(this.matrixWorld);
	},

	getWorldQuaternion: function () {

		var position = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
		var scale = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

		return function getWorldQuaternion(target) {

			if (target === undefined) {

				console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
				target = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();
			}

			this.updateMatrixWorld(true);

			this.matrixWorld.decompose(position, target, scale);

			return target;
		};
	}(),

	getWorldScale: function () {

		var position = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
		var quaternion = new __WEBPACK_IMPORTED_MODULE_4__math_Quaternion_js__["a" /* Quaternion */]();

		return function getWorldScale(target) {

			if (target === undefined) {

				console.warn('THREE.Object3D: .getWorldScale() target is now required');
				target = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
			}

			this.updateMatrixWorld(true);

			this.matrixWorld.decompose(position, quaternion, target);

			return target;
		};
	}(),

	getWorldDirection: function getWorldDirection(target) {

		if (target === undefined) {

			console.warn('THREE.Object3D: .getWorldDirection() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
		}

		this.updateMatrixWorld(true);

		var e = this.matrixWorld.elements;

		return target.set(e[8], e[9], e[10]).normalize();
	},

	raycast: function raycast() {},

	traverse: function traverse(callback) {

		callback(this);

		var children = this.children;

		for (var i = 0, l = children.length; i < l; i++) {

			children[i].traverse(callback);
		}
	},

	traverseVisible: function traverseVisible(callback) {

		if (this.visible === false) return;

		callback(this);

		var children = this.children;

		for (var i = 0, l = children.length; i < l; i++) {

			children[i].traverseVisible(callback);
		}
	},

	traverseAncestors: function traverseAncestors(callback) {

		var parent = this.parent;

		if (parent !== null) {

			callback(parent);

			parent.traverseAncestors(callback);
		}
	},

	updateMatrix: function updateMatrix() {

		this.matrix.compose(this.position, this.quaternion, this.scale);

		this.matrixWorldNeedsUpdate = true;
	},

	updateMatrixWorld: function updateMatrixWorld(force) {

		if (this.matrixAutoUpdate) this.updateMatrix();

		if (this.matrixWorldNeedsUpdate || force) {

			if (this.parent === null) {

				this.matrixWorld.copy(this.matrix);
			} else {

				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			}

			this.matrixWorldNeedsUpdate = false;

			force = true;
		}

		var children = this.children;

		for (var i = 0, l = children.length; i < l; i++) {

			children[i].updateMatrixWorld(force);
		}
	},

	updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {

		var parent = this.parent;

		if (updateParents === true && parent !== null) {

			parent.updateWorldMatrix(true, false);
		}

		if (this.matrixAutoUpdate) this.updateMatrix();

		if (this.parent === null) {

			this.matrixWorld.copy(this.matrix);
		} else {

			this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
		}

		if (updateChildren === true) {

			var children = this.children;

			for (var i = 0, l = children.length; i < l; i++) {

				children[i].updateWorldMatrix(false, true);
			}
		}
	},

	toJSON: function toJSON(meta) {
		var isRootObject = meta === undefined || typeof meta === 'string';

		var output = {};

		if (isRootObject) {
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};
		}

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if (this.name !== '') object.name = this.name;
		if (this.castShadow === true) object.castShadow = true;
		if (this.receiveShadow === true) object.receiveShadow = true;
		if (this.visible === false) object.visible = false;
		if (this.frustumCulled === false) object.frustumCulled = false;
		if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
		if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.userData) !== '{}') object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

		if (this.isMesh && this.drawMode !== __WEBPACK_IMPORTED_MODULE_12__constants_js__["y" /* TrianglesDrawMode */]) object.drawMode = this.drawMode;

		function serialize(library, element) {

			if (library[element.uuid] === undefined) {

				library[element.uuid] = element.toJSON(meta);
			}

			return element.uuid;
		}

		if (this.isMesh || this.isLine || this.isPoints) {

			object.geometry = serialize(meta.geometries, this.geometry);

			var parameters = this.geometry.parameters;

			if (parameters !== undefined && parameters.shapes !== undefined) {

				var shapes = parameters.shapes;

				if (Array.isArray(shapes)) {

					for (var i = 0, l = shapes.length; i < l; i++) {

						var shape = shapes[i];

						serialize(meta.shapes, shape);
					}
				} else {

					serialize(meta.shapes, shapes);
				}
			}
		}

		if (this.material !== undefined) {

			if (Array.isArray(this.material)) {

				var uuids = [];

				for (var i = 0, l = this.material.length; i < l; i++) {

					uuids.push(serialize(meta.materials, this.material[i]));
				}

				object.material = uuids;
			} else {

				object.material = serialize(meta.materials, this.material);
			}
		}

		if (this.children.length > 0) {

			object.children = [];

			for (var i = 0; i < this.children.length; i++) {

				object.children.push(this.children[i].toJSON(meta).object);
			}
		}

		if (isRootObject) {

			var geometries = extractFromCache(meta.geometries);
			var materials = extractFromCache(meta.materials);
			var textures = extractFromCache(meta.textures);
			var images = extractFromCache(meta.images);
			var shapes = extractFromCache(meta.shapes);

			if (geometries.length > 0) output.geometries = geometries;
			if (materials.length > 0) output.materials = materials;
			if (textures.length > 0) output.textures = textures;
			if (images.length > 0) output.images = images;
			if (shapes.length > 0) output.shapes = shapes;
		}

		output.object = object;

		return output;

		function extractFromCache(cache) {

			var values = [];
			for (var key in cache) {

				var data = cache[key];
				delete data.metadata;
				values.push(data);
			}
			return values;
		}
	},

	clone: function clone(recursive) {

		return new this.constructor().copy(this, recursive);
	},

	copy: function copy(source, recursive) {

		if (recursive === undefined) recursive = true;

		this.name = source.name;

		this.up.copy(source.up);

		this.position.copy(source.position);
		this.quaternion.copy(source.quaternion);
		this.scale.copy(source.scale);

		this.matrix.copy(source.matrix);
		this.matrixWorld.copy(source.matrixWorld);

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(source.userData));

		if (recursive === true) {

			for (var i = 0; i < source.children.length; i++) {

				var child = source.children[i];
				this.add(child.clone());
			}
		}

		return this;
	}

});



/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(533), __esModule: true };

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(144);
var isBuffer = __webpack_require__(608);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Box3_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__DirectGeometry_js__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__math_Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__math_Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__utils_js__ = __webpack_require__(100);
















var bufferGeometryId = 1;

function BufferGeometry() {

		Object.defineProperty(this, 'id', { value: bufferGeometryId += 2 });

		this.uuid = __WEBPACK_IMPORTED_MODULE_13__math_Math_js__["a" /* _Math */].generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};
}

BufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_6__EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function getIndex() {

				return this.index;
		},

		setIndex: function setIndex(index) {

				if (Array.isArray(index)) {

						this.index = new (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__utils_js__["a" /* arrayMax */])(index) > 65535 ? __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["d" /* Uint32BufferAttribute */] : __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["f" /* Uint16BufferAttribute */])(index, 1);
				} else {

						this.index = index;
				}
		},

		addAttribute: function addAttribute(name, attribute) {

				if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {

						console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');

						return this.addAttribute(name, new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](arguments[1], arguments[2]));
				}

				if (name === 'index') {

						console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
						this.setIndex(attribute);

						return this;
				}

				this.attributes[name] = attribute;

				return this;
		},

		getAttribute: function getAttribute(name) {

				return this.attributes[name];
		},

		removeAttribute: function removeAttribute(name) {

				delete this.attributes[name];

				return this;
		},

		addGroup: function addGroup(start, count, materialIndex) {

				this.groups.push({

						start: start,
						count: count,
						materialIndex: materialIndex !== undefined ? materialIndex : 0

				});
		},

		clearGroups: function clearGroups() {

				this.groups = [];
		},

		setDrawRange: function setDrawRange(start, count) {

				this.drawRange.start = start;
				this.drawRange.count = count;
		},

		applyMatrix: function applyMatrix(matrix) {

				var position = this.attributes.position;

				if (position !== undefined) {

						matrix.applyToBufferAttribute(position);
						position.needsUpdate = true;
				}

				var normal = this.attributes.normal;

				if (normal !== undefined) {

						var normalMatrix = new __WEBPACK_IMPORTED_MODULE_12__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);

						normalMatrix.applyToBufferAttribute(normal);
						normal.needsUpdate = true;
				}

				var tangent = this.attributes.tangent;

				if (tangent !== undefined) {

						var normalMatrix = new __WEBPACK_IMPORTED_MODULE_12__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);

						normalMatrix.applyToBufferAttribute(tangent);
						tangent.needsUpdate = true;
				}

				if (this.boundingBox !== null) {

						this.computeBoundingBox();
				}

				if (this.boundingSphere !== null) {

						this.computeBoundingSphere();
				}

				return this;
		},

		rotateX: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_11__math_Matrix4_js__["a" /* Matrix4 */]();

				return function rotateX(angle) {

						m1.makeRotationX(angle);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		rotateY: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_11__math_Matrix4_js__["a" /* Matrix4 */]();

				return function rotateY(angle) {

						m1.makeRotationY(angle);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		rotateZ: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_11__math_Matrix4_js__["a" /* Matrix4 */]();

				return function rotateZ(angle) {

						m1.makeRotationZ(angle);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		translate: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_11__math_Matrix4_js__["a" /* Matrix4 */]();

				return function translate(x, y, z) {

						m1.makeTranslation(x, y, z);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		scale: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_11__math_Matrix4_js__["a" /* Matrix4 */]();

				return function scale(x, y, z) {

						m1.makeScale(x, y, z);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		lookAt: function () {

				var obj = new __WEBPACK_IMPORTED_MODULE_10__Object3D_js__["a" /* Object3D */]();

				return function lookAt(vector) {

						obj.lookAt(vector);

						obj.updateMatrix();

						this.applyMatrix(obj.matrix);
				};
		}(),

		center: function () {

				var offset = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();

				return function center() {

						this.computeBoundingBox();

						this.boundingBox.getCenter(offset).negate();

						this.translate(offset.x, offset.y, offset.z);

						return this;
				};
		}(),

		setFromObject: function setFromObject(object) {

				var geometry = object.geometry;

				if (object.isPoints || object.isLine) {

						var positions = new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.vertices.length * 3, 3);
						var colors = new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.colors.length * 3, 3);

						this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
						this.addAttribute('color', colors.copyColorsArray(geometry.colors));

						if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {

								var lineDistances = new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.lineDistances.length, 1);

								this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
						}

						if (geometry.boundingSphere !== null) {

								this.boundingSphere = geometry.boundingSphere.clone();
						}

						if (geometry.boundingBox !== null) {

								this.boundingBox = geometry.boundingBox.clone();
						}
				} else if (object.isMesh) {

						if (geometry && geometry.isGeometry) {

								this.fromGeometry(geometry);
						}
				}

				return this;
		},

		setFromPoints: function setFromPoints(points) {

				var position = [];

				for (var i = 0, l = points.length; i < l; i++) {

						var point = points[i];
						position.push(point.x, point.y, point.z || 0);
				}

				this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](position, 3));

				return this;
		},

		updateFromObject: function updateFromObject(object) {

				var geometry = object.geometry;

				if (object.isMesh) {

						var direct = geometry.__directGeometry;

						if (geometry.elementsNeedUpdate === true) {

								direct = undefined;
								geometry.elementsNeedUpdate = false;
						}

						if (direct === undefined) {

								return this.fromGeometry(geometry);
						}

						direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
						direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
						direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
						direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
						direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

						geometry.verticesNeedUpdate = false;
						geometry.normalsNeedUpdate = false;
						geometry.colorsNeedUpdate = false;
						geometry.uvsNeedUpdate = false;
						geometry.groupsNeedUpdate = false;

						geometry = direct;
				}

				var attribute;

				if (geometry.verticesNeedUpdate === true) {

						attribute = this.attributes.position;

						if (attribute !== undefined) {

								attribute.copyVector3sArray(geometry.vertices);
								attribute.needsUpdate = true;
						}

						geometry.verticesNeedUpdate = false;
				}

				if (geometry.normalsNeedUpdate === true) {

						attribute = this.attributes.normal;

						if (attribute !== undefined) {

								attribute.copyVector3sArray(geometry.normals);
								attribute.needsUpdate = true;
						}

						geometry.normalsNeedUpdate = false;
				}

				if (geometry.colorsNeedUpdate === true) {

						attribute = this.attributes.color;

						if (attribute !== undefined) {

								attribute.copyColorsArray(geometry.colors);
								attribute.needsUpdate = true;
						}

						geometry.colorsNeedUpdate = false;
				}

				if (geometry.uvsNeedUpdate) {

						attribute = this.attributes.uv;

						if (attribute !== undefined) {

								attribute.copyVector2sArray(geometry.uvs);
								attribute.needsUpdate = true;
						}

						geometry.uvsNeedUpdate = false;
				}

				if (geometry.lineDistancesNeedUpdate) {

						attribute = this.attributes.lineDistance;

						if (attribute !== undefined) {

								attribute.copyArray(geometry.lineDistances);
								attribute.needsUpdate = true;
						}

						geometry.lineDistancesNeedUpdate = false;
				}

				if (geometry.groupsNeedUpdate) {

						geometry.computeGroups(object.geometry);
						this.groups = geometry.groups;

						geometry.groupsNeedUpdate = false;
				}

				return this;
		},

		fromGeometry: function fromGeometry(geometry) {

				geometry.__directGeometry = new __WEBPACK_IMPORTED_MODULE_9__DirectGeometry_js__["a" /* DirectGeometry */]().fromGeometry(geometry);

				return this.fromDirectGeometry(geometry.__directGeometry);
		},

		fromDirectGeometry: function fromDirectGeometry(geometry) {

				var positions = new Float32Array(geometry.vertices.length * 3);
				this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](positions, 3).copyVector3sArray(geometry.vertices));

				if (geometry.normals.length > 0) {

						var normals = new Float32Array(geometry.normals.length * 3);
						this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](normals, 3).copyVector3sArray(geometry.normals));
				}

				if (geometry.colors.length > 0) {

						var colors = new Float32Array(geometry.colors.length * 3);
						this.addAttribute('color', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](colors, 3).copyColorsArray(geometry.colors));
				}

				if (geometry.uvs.length > 0) {

						var uvs = new Float32Array(geometry.uvs.length * 2);
						this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](uvs, 2).copyVector2sArray(geometry.uvs));
				}

				if (geometry.uvs2.length > 0) {

						var uvs2 = new Float32Array(geometry.uvs2.length * 2);
						this.addAttribute('uv2', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](uvs2, 2).copyVector2sArray(geometry.uvs2));
				}

				this.groups = geometry.groups;

				for (var name in geometry.morphTargets) {

						var array = [];
						var morphTargets = geometry.morphTargets[name];

						for (var i = 0, l = morphTargets.length; i < l; i++) {

								var morphTarget = morphTargets[i];

								var attribute = new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](morphTarget.data.length * 3, 3);
								attribute.name = morphTarget.name;

								array.push(attribute.copyVector3sArray(morphTarget.data));
						}

						this.morphAttributes[name] = array;
				}

				if (geometry.skinIndices.length > 0) {

						var skinIndices = new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.skinIndices.length * 4, 4);
						this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
				}

				if (geometry.skinWeights.length > 0) {

						var skinWeights = new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["b" /* Float32BufferAttribute */](geometry.skinWeights.length * 4, 4);
						this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
				}

				if (geometry.boundingSphere !== null) {

						this.boundingSphere = geometry.boundingSphere.clone();
				}

				if (geometry.boundingBox !== null) {

						this.boundingBox = geometry.boundingBox.clone();
				}

				return this;
		},

		computeBoundingBox: function () {

				var box = new __WEBPACK_IMPORTED_MODULE_5__math_Box3_js__["a" /* Box3 */]();

				return function computeBoundingBox() {

						if (this.boundingBox === null) {

								this.boundingBox = new __WEBPACK_IMPORTED_MODULE_5__math_Box3_js__["a" /* Box3 */]();
						}

						var position = this.attributes.position;
						var morphAttributesPosition = this.morphAttributes.position;

						if (position !== undefined) {

								this.boundingBox.setFromBufferAttribute(position);

								if (morphAttributesPosition) {

										for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {

												var morphAttribute = morphAttributesPosition[i];
												box.setFromBufferAttribute(morphAttribute);

												this.boundingBox.expandByPoint(box.min);
												this.boundingBox.expandByPoint(box.max);
										}
								}
						} else {

								this.boundingBox.makeEmpty();
						}

						if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

								console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
						}
				};
		}(),

		computeBoundingSphere: function () {

				var box = new __WEBPACK_IMPORTED_MODULE_5__math_Box3_js__["a" /* Box3 */]();
				var boxMorphTargets = new __WEBPACK_IMPORTED_MODULE_5__math_Box3_js__["a" /* Box3 */]();
				var vector = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();

				return function computeBoundingSphere() {

						if (this.boundingSphere === null) {

								this.boundingSphere = new __WEBPACK_IMPORTED_MODULE_8__math_Sphere_js__["a" /* Sphere */]();
						}

						var position = this.attributes.position;
						var morphAttributesPosition = this.morphAttributes.position;

						if (position) {

								var center = this.boundingSphere.center;

								box.setFromBufferAttribute(position);

								if (morphAttributesPosition) {

										for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {

												var morphAttribute = morphAttributesPosition[i];
												boxMorphTargets.setFromBufferAttribute(morphAttribute);

												box.expandByPoint(boxMorphTargets.min);
												box.expandByPoint(boxMorphTargets.max);
										}
								}

								box.getCenter(center);

								var maxRadiusSq = 0;

								for (var i = 0, il = position.count; i < il; i++) {

										vector.fromBufferAttribute(position, i);

										maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
								}

								if (morphAttributesPosition) {

										for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {

												var morphAttribute = morphAttributesPosition[i];

												for (var j = 0, jl = morphAttribute.count; j < jl; j++) {

														vector.fromBufferAttribute(morphAttribute, j);

														maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
												}
										}
								}

								this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

								if (isNaN(this.boundingSphere.radius)) {

										console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
								}
						}
				};
		}(),

		computeFaceNormals: function computeFaceNormals() {},

		computeVertexNormals: function computeVertexNormals() {

				var index = this.index;
				var attributes = this.attributes;

				if (attributes.position) {

						var positions = attributes.position.array;

						if (attributes.normal === undefined) {

								this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](new Float32Array(positions.length), 3));
						} else {

								var array = attributes.normal.array;

								for (var i = 0, il = array.length; i < il; i++) {

										array[i] = 0;
								}
						}

						var normals = attributes.normal.array;

						var vA, vB, vC;
						var pA = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */](),
						    pB = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */](),
						    pC = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
						var cb = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */](),
						    ab = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();

						if (index) {

								var indices = index.array;

								for (var i = 0, il = index.count; i < il; i += 3) {

										vA = indices[i + 0] * 3;
										vB = indices[i + 1] * 3;
										vC = indices[i + 2] * 3;

										pA.fromArray(positions, vA);
										pB.fromArray(positions, vB);
										pC.fromArray(positions, vC);

										cb.subVectors(pC, pB);
										ab.subVectors(pA, pB);
										cb.cross(ab);

										normals[vA] += cb.x;
										normals[vA + 1] += cb.y;
										normals[vA + 2] += cb.z;

										normals[vB] += cb.x;
										normals[vB + 1] += cb.y;
										normals[vB + 2] += cb.z;

										normals[vC] += cb.x;
										normals[vC + 1] += cb.y;
										normals[vC + 2] += cb.z;
								}
						} else {

								for (var i = 0, il = positions.length; i < il; i += 9) {

										pA.fromArray(positions, i);
										pB.fromArray(positions, i + 3);
										pC.fromArray(positions, i + 6);

										cb.subVectors(pC, pB);
										ab.subVectors(pA, pB);
										cb.cross(ab);

										normals[i] = cb.x;
										normals[i + 1] = cb.y;
										normals[i + 2] = cb.z;

										normals[i + 3] = cb.x;
										normals[i + 4] = cb.y;
										normals[i + 5] = cb.z;

										normals[i + 6] = cb.x;
										normals[i + 7] = cb.y;
										normals[i + 8] = cb.z;
								}
						}

						this.normalizeNormals();

						attributes.normal.needsUpdate = true;
				}
		},

		merge: function merge(geometry, offset) {

				if (!(geometry && geometry.isBufferGeometry)) {

						console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
						return;
				}

				if (offset === undefined) {

						offset = 0;

						console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
				}

				var attributes = this.attributes;

				for (var key in attributes) {

						if (geometry.attributes[key] === undefined) continue;

						var attribute1 = attributes[key];
						var attributeArray1 = attribute1.array;

						var attribute2 = geometry.attributes[key];
						var attributeArray2 = attribute2.array;

						var attributeOffset = attribute2.itemSize * offset;
						var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

						for (var i = 0, j = attributeOffset; i < length; i++, j++) {

								attributeArray1[j] = attributeArray2[i];
						}
				}

				return this;
		},

		normalizeNormals: function () {

				var vector = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();

				return function normalizeNormals() {

						var normals = this.attributes.normal;

						for (var i = 0, il = normals.count; i < il; i++) {

								vector.x = normals.getX(i);
								vector.y = normals.getY(i);
								vector.z = normals.getZ(i);

								vector.normalize();

								normals.setXYZ(i, vector.x, vector.y, vector.z);
						}
				};
		}(),

		toNonIndexed: function toNonIndexed() {

				function convertBufferAttribute(attribute, indices) {

						var array = attribute.array;
						var itemSize = attribute.itemSize;

						var array2 = new array.constructor(indices.length * itemSize);

						var index = 0,
						    index2 = 0;

						for (var i = 0, l = indices.length; i < l; i++) {

								index = indices[i] * itemSize;

								for (var j = 0; j < itemSize; j++) {

										array2[index2++] = array[index++];
								}
						}

						return new __WEBPACK_IMPORTED_MODULE_7__BufferAttribute_js__["k" /* BufferAttribute */](array2, itemSize);
				}

				if (this.index === null) {

						console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
						return this;
				}

				var geometry2 = new BufferGeometry();

				var indices = this.index.array;
				var attributes = this.attributes;

				for (var name in attributes) {

						var attribute = attributes[name];

						var newAttribute = convertBufferAttribute(attribute, indices);

						geometry2.addAttribute(name, newAttribute);
				}

				var morphAttributes = this.morphAttributes;

				for (name in morphAttributes) {

						var morphArray = [];
						var morphAttribute = morphAttributes[name];

						for (var i = 0, il = morphAttribute.length; i < il; i++) {

								var attribute = morphAttribute[i];

								var newAttribute = convertBufferAttribute(attribute, indices);

								morphArray.push(newAttribute);
						}

						geometry2.morphAttributes[name] = morphArray;
				}

				var groups = this.groups;

				for (var i = 0, l = groups.length; i < l; i++) {

						var group = groups[i];
						geometry2.addGroup(group.start, group.count, group.materialIndex);
				}

				return geometry2;
		},

		toJSON: function toJSON() {

				var data = {
						metadata: {
								version: 4.5,
								type: 'BufferGeometry',
								generator: 'BufferGeometry.toJSON'
						}
				};

				data.uuid = this.uuid;
				data.type = this.type;
				if (this.name !== '') data.name = this.name;
				if (__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default()(this.userData).length > 0) data.userData = this.userData;

				if (this.parameters !== undefined) {

						var parameters = this.parameters;

						for (var key in parameters) {

								if (parameters[key] !== undefined) data[key] = parameters[key];
						}

						return data;
				}

				data.data = { attributes: {} };

				var index = this.index;

				if (index !== null) {

						data.data.index = {
								type: index.array.constructor.name,
								array: Array.prototype.slice.call(index.array)
						};
				}

				var attributes = this.attributes;

				for (var key in attributes) {

						var attribute = attributes[key];

						var attributeData = attribute.toJSON();

						if (attribute.name !== '') attributeData.name = attribute.name;

						data.data.attributes[key] = attributeData;
				}

				var morphAttributes = {};
				var hasMorphAttributes = false;

				for (var key in this.morphAttributes) {

						var attributeArray = this.morphAttributes[key];

						var array = [];

						for (var i = 0, il = attributeArray.length; i < il; i++) {

								var attribute = attributeArray[i];

								var attributeData = attribute.toJSON();

								if (attribute.name !== '') attributeData.name = attribute.name;

								array.push(attributeData);
						}

						if (array.length > 0) {

								morphAttributes[key] = array;

								hasMorphAttributes = true;
						}
				}

				if (hasMorphAttributes) data.data.morphAttributes = morphAttributes;

				var groups = this.groups;

				if (groups.length > 0) {

						data.data.groups = JSON.parse(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(groups));
				}

				var boundingSphere = this.boundingSphere;

				if (boundingSphere !== null) {

						data.data.boundingSphere = {
								center: boundingSphere.center.toArray(),
								radius: boundingSphere.radius
						};
				}

				return data;
		},

		clone: function clone() {

				return new BufferGeometry().copy(this);
		},

		copy: function copy(source) {

				var name, i, l;

				this.index = null;
				this.attributes = {};
				this.morphAttributes = {};
				this.groups = [];
				this.boundingBox = null;
				this.boundingSphere = null;

				this.name = source.name;

				var index = source.index;

				if (index !== null) {

						this.setIndex(index.clone());
				}

				var attributes = source.attributes;

				for (name in attributes) {

						var attribute = attributes[name];
						this.addAttribute(name, attribute.clone());
				}

				var morphAttributes = source.morphAttributes;

				for (name in morphAttributes) {

						var array = [];
						var morphAttribute = morphAttributes[name];

						for (i = 0, l = morphAttribute.length; i < l; i++) {

								array.push(morphAttribute[i].clone());
						}

						this.morphAttributes[name] = array;
				}

				var groups = source.groups;

				for (i = 0, l = groups.length; i < l; i++) {

						var group = groups[i];
						this.addGroup(group.start, group.count, group.materialIndex);
				}

				var boundingBox = source.boundingBox;

				if (boundingBox !== null) {

						this.boundingBox = boundingBox.clone();
				}

				var boundingSphere = source.boundingSphere;

				if (boundingSphere !== null) {

						this.boundingSphere = boundingSphere.clone();
				}

				this.drawRange.start = source.drawRange.start;
				this.drawRange.count = source.drawRange.count;

				this.userData = source.userData;

				return this;
		},

		dispose: function dispose() {

				this.dispatchEvent({ type: 'dispose' });
		}

});



/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventDispatcher; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);



function EventDispatcher() {}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(EventDispatcher.prototype, {

		addEventListener: function addEventListener(type, listener) {

				if (this._listeners === undefined) this._listeners = {};

				var listeners = this._listeners;

				if (listeners[type] === undefined) {

						listeners[type] = [];
				}

				if (listeners[type].indexOf(listener) === -1) {

						listeners[type].push(listener);
				}
		},

		hasEventListener: function hasEventListener(type, listener) {

				if (this._listeners === undefined) return false;

				var listeners = this._listeners;

				return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		},

		removeEventListener: function removeEventListener(type, listener) {

				if (this._listeners === undefined) return;

				var listeners = this._listeners;
				var listenerArray = listeners[type];

				if (listenerArray !== undefined) {

						var index = listenerArray.indexOf(listener);

						if (index !== -1) {

								listenerArray.splice(index, 1);
						}
				}
		},

		dispatchEvent: function dispatchEvent(event) {

				if (this._listeners === undefined) return;

				var listeners = this._listeners;
				var listenerArray = listeners[event.type];

				if (listenerArray !== undefined) {

						event.target = this;

						var array = listenerArray.slice(0);

						for (var i = 0, l = array.length; i < l; i++) {

								array[i].call(this, event);
						}
				}
		}

});



/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(40)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(530), __esModule: true };

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(190);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(23);
var IE8_DOM_DEFINE = __webpack_require__(200);
var toPrimitive = __webpack_require__(125);
var dP = Object.defineProperty;

exports.f = __webpack_require__(20) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Curve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__ = __webpack_require__(7);






function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;
}

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(Curve.prototype, {

		getPoint: function getPoint() {

				console.warn('THREE.Curve: .getPoint() not implemented.');
				return null;
		},

		getPointAt: function getPointAt(u, optionalTarget) {

				var t = this.getUtoTmapping(u);
				return this.getPoint(t, optionalTarget);
		},

		getPoints: function getPoints(divisions) {

				if (divisions === undefined) divisions = 5;

				var points = [];

				for (var d = 0; d <= divisions; d++) {

						points.push(this.getPoint(d / divisions));
				}

				return points;
		},

		getSpacedPoints: function getSpacedPoints(divisions) {

				if (divisions === undefined) divisions = 5;

				var points = [];

				for (var d = 0; d <= divisions; d++) {

						points.push(this.getPointAt(d / divisions));
				}

				return points;
		},

		getLength: function getLength() {

				var lengths = this.getLengths();
				return lengths[lengths.length - 1];
		},

		getLengths: function getLengths(divisions) {

				if (divisions === undefined) divisions = this.arcLengthDivisions;

				if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {

						return this.cacheArcLengths;
				}

				this.needsUpdate = false;

				var cache = [];
				var current,
				    last = this.getPoint(0);
				var p,
				    sum = 0;

				cache.push(0);

				for (p = 1; p <= divisions; p++) {

						current = this.getPoint(p / divisions);
						sum += current.distanceTo(last);
						cache.push(sum);
						last = current;
				}

				this.cacheArcLengths = cache;

				return cache;
		},

		updateArcLengths: function updateArcLengths() {

				this.needsUpdate = true;
				this.getLengths();
		},

		getUtoTmapping: function getUtoTmapping(u, distance) {

				var arcLengths = this.getLengths();

				var i = 0,
				    il = arcLengths.length;

				var targetArcLength;

				if (distance) {

						targetArcLength = distance;
				} else {

						targetArcLength = u * arcLengths[il - 1];
				}

				var low = 0,
				    high = il - 1,
				    comparison;

				while (low <= high) {

						i = Math.floor(low + (high - low) / 2);

						comparison = arcLengths[i] - targetArcLength;

						if (comparison < 0) {

								low = i + 1;
						} else if (comparison > 0) {

								high = i - 1;
						} else {

								high = i;
								break;
						}
				}

				i = high;

				if (arcLengths[i] === targetArcLength) {

						return i / (il - 1);
				}

				var lengthBefore = arcLengths[i];
				var lengthAfter = arcLengths[i + 1];

				var segmentLength = lengthAfter - lengthBefore;

				var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

				var t = (i + segmentFraction) / (il - 1);

				return t;
		},

		getTangent: function getTangent(t) {

				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;

				if (t1 < 0) t1 = 0;
				if (t2 > 1) t2 = 1;

				var pt1 = this.getPoint(t1);
				var pt2 = this.getPoint(t2);

				var vec = pt2.clone().sub(pt1);
				return vec.normalize();
		},

		getTangentAt: function getTangentAt(u) {

				var t = this.getUtoTmapping(u);
				return this.getTangent(t);
		},

		computeFrenetFrames: function computeFrenetFrames(segments, closed) {

				var normal = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

				var tangents = [];
				var normals = [];
				var binormals = [];

				var vec = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
				var mat = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__["a" /* Matrix4 */]();

				var i, u, theta;

				for (i = 0; i <= segments; i++) {

						u = i / segments;

						tangents[i] = this.getTangentAt(u);
						tangents[i].normalize();
				}

				normals[0] = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
				binormals[0] = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
				var min = Number.MAX_VALUE;
				var tx = Math.abs(tangents[0].x);
				var ty = Math.abs(tangents[0].y);
				var tz = Math.abs(tangents[0].z);

				if (tx <= min) {

						min = tx;
						normal.set(1, 0, 0);
				}

				if (ty <= min) {

						min = ty;
						normal.set(0, 1, 0);
				}

				if (tz <= min) {

						normal.set(0, 0, 1);
				}

				vec.crossVectors(tangents[0], normal).normalize();

				normals[0].crossVectors(tangents[0], vec);
				binormals[0].crossVectors(tangents[0], normals[0]);

				for (i = 1; i <= segments; i++) {

						normals[i] = normals[i - 1].clone();

						binormals[i] = binormals[i - 1].clone();

						vec.crossVectors(tangents[i - 1], tangents[i]);

						if (vec.length() > __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default.a) {

								vec.normalize();

								theta = Math.acos(__WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].clamp(tangents[i - 1].dot(tangents[i]), -1, 1));

								normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
						}

						binormals[i].crossVectors(tangents[i], normals[i]);
				}

				if (closed === true) {

						theta = Math.acos(__WEBPACK_IMPORTED_MODULE_2__math_Math_js__["a" /* _Math */].clamp(normals[0].dot(normals[segments]), -1, 1));
						theta /= segments;

						if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {

								theta = -theta;
						}

						for (i = 1; i <= segments; i++) {
								normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
								binormals[i].crossVectors(tangents[i], normals[i]);
						}
				}

				return {
						tangents: tangents,
						normals: normals,
						binormals: binormals
				};
		},

		clone: function clone() {

				return new this.constructor().copy(this);
		},

		copy: function copy(source) {

				this.arcLengthDivisions = source.arcLengthDivisions;

				return this;
		},

		toJSON: function toJSON() {

				var data = {
						metadata: {
								version: 4.5,
								type: 'Curve',
								generator: 'Curve.toJSON'
						}
				};

				data.arcLengthDivisions = this.arcLengthDivisions;
				data.type = this.type;

				return data;
		},

		fromJSON: function fromJSON(json) {

				this.arcLengthDivisions = json.arcLengthDivisions;

				return this;
		}

});



/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(543), __esModule: true };

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(61);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = __webpack_require__(75),
    util = __webpack_require__(11);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Matrix3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(2);



function Matrix3() {

		this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

		if (arguments.length > 0) {

				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
		}
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Matrix3.prototype, {

		isMatrix3: true,

		set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {

				var te = this.elements;

				te[0] = n11;te[1] = n21;te[2] = n31;
				te[3] = n12;te[4] = n22;te[5] = n32;
				te[6] = n13;te[7] = n23;te[8] = n33;

				return this;
		},

		identity: function identity() {

				this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);

				return this;
		},

		clone: function clone() {

				return new this.constructor().fromArray(this.elements);
		},

		copy: function copy(m) {

				var te = this.elements;
				var me = m.elements;

				te[0] = me[0];te[1] = me[1];te[2] = me[2];
				te[3] = me[3];te[4] = me[4];te[5] = me[5];
				te[6] = me[6];te[7] = me[7];te[8] = me[8];

				return this;
		},

		setFromMatrix4: function setFromMatrix4(m) {

				var me = m.elements;

				this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);

				return this;
		},

		applyToBufferAttribute: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function applyToBufferAttribute(attribute) {

						for (var i = 0, l = attribute.count; i < l; i++) {

								v1.x = attribute.getX(i);
								v1.y = attribute.getY(i);
								v1.z = attribute.getZ(i);

								v1.applyMatrix3(this);

								attribute.setXYZ(i, v1.x, v1.y, v1.z);
						}

						return attribute;
				};
		}(),

		multiply: function multiply(m) {

				return this.multiplyMatrices(this, m);
		},

		premultiply: function premultiply(m) {

				return this.multiplyMatrices(m, this);
		},

		multiplyMatrices: function multiplyMatrices(a, b) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[0],
				    a12 = ae[3],
				    a13 = ae[6];
				var a21 = ae[1],
				    a22 = ae[4],
				    a23 = ae[7];
				var a31 = ae[2],
				    a32 = ae[5],
				    a33 = ae[8];

				var b11 = be[0],
				    b12 = be[3],
				    b13 = be[6];
				var b21 = be[1],
				    b22 = be[4],
				    b23 = be[7];
				var b31 = be[2],
				    b32 = be[5],
				    b33 = be[8];

				te[0] = a11 * b11 + a12 * b21 + a13 * b31;
				te[3] = a11 * b12 + a12 * b22 + a13 * b32;
				te[6] = a11 * b13 + a12 * b23 + a13 * b33;

				te[1] = a21 * b11 + a22 * b21 + a23 * b31;
				te[4] = a21 * b12 + a22 * b22 + a23 * b32;
				te[7] = a21 * b13 + a22 * b23 + a23 * b33;

				te[2] = a31 * b11 + a32 * b21 + a33 * b31;
				te[5] = a31 * b12 + a32 * b22 + a33 * b32;
				te[8] = a31 * b13 + a32 * b23 + a33 * b33;

				return this;
		},

		multiplyScalar: function multiplyScalar(s) {

				var te = this.elements;

				te[0] *= s;te[3] *= s;te[6] *= s;
				te[1] *= s;te[4] *= s;te[7] *= s;
				te[2] *= s;te[5] *= s;te[8] *= s;

				return this;
		},

		determinant: function determinant() {

				var te = this.elements;

				var a = te[0],
				    b = te[1],
				    c = te[2],
				    d = te[3],
				    e = te[4],
				    f = te[5],
				    g = te[6],
				    h = te[7],
				    i = te[8];

				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		},

		getInverse: function getInverse(matrix, throwOnDegenerate) {

				if (matrix && matrix.isMatrix4) {

						console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
				}

				var me = matrix.elements,
				    te = this.elements,
				    n11 = me[0],
				    n21 = me[1],
				    n31 = me[2],
				    n12 = me[3],
				    n22 = me[4],
				    n32 = me[5],
				    n13 = me[6],
				    n23 = me[7],
				    n33 = me[8],
				    t11 = n33 * n22 - n32 * n23,
				    t12 = n32 * n13 - n33 * n12,
				    t13 = n23 * n12 - n22 * n13,
				    det = n11 * t11 + n21 * t12 + n31 * t13;

				if (det === 0) {

						var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

						if (throwOnDegenerate === true) {

								throw new Error(msg);
						} else {

								console.warn(msg);
						}

						return this.identity();
				}

				var detInv = 1 / det;

				te[0] = t11 * detInv;
				te[1] = (n31 * n23 - n33 * n21) * detInv;
				te[2] = (n32 * n21 - n31 * n22) * detInv;

				te[3] = t12 * detInv;
				te[4] = (n33 * n11 - n31 * n13) * detInv;
				te[5] = (n31 * n12 - n32 * n11) * detInv;

				te[6] = t13 * detInv;
				te[7] = (n21 * n13 - n23 * n11) * detInv;
				te[8] = (n22 * n11 - n21 * n12) * detInv;

				return this;
		},

		transpose: function transpose() {

				var tmp,
				    m = this.elements;

				tmp = m[1];m[1] = m[3];m[3] = tmp;
				tmp = m[2];m[2] = m[6];m[6] = tmp;
				tmp = m[5];m[5] = m[7];m[7] = tmp;

				return this;
		},

		getNormalMatrix: function getNormalMatrix(matrix4) {

				return this.setFromMatrix4(matrix4).getInverse(this).transpose();
		},

		transposeIntoArray: function transposeIntoArray(r) {

				var m = this.elements;

				r[0] = m[0];
				r[1] = m[3];
				r[2] = m[6];
				r[3] = m[1];
				r[4] = m[4];
				r[5] = m[7];
				r[6] = m[2];
				r[7] = m[5];
				r[8] = m[8];

				return this;
		},

		setUvTransform: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {

				var c = Math.cos(rotation);
				var s = Math.sin(rotation);

				this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
		},

		scale: function scale(sx, sy) {

				var te = this.elements;

				te[0] *= sx;te[3] *= sx;te[6] *= sx;
				te[1] *= sy;te[4] *= sy;te[7] *= sy;

				return this;
		},

		rotate: function rotate(theta) {

				var c = Math.cos(theta);
				var s = Math.sin(theta);

				var te = this.elements;

				var a11 = te[0],
				    a12 = te[3],
				    a13 = te[6];
				var a21 = te[1],
				    a22 = te[4],
				    a23 = te[7];

				te[0] = c * a11 + s * a21;
				te[3] = c * a12 + s * a22;
				te[6] = c * a13 + s * a23;

				te[1] = -s * a11 + c * a21;
				te[4] = -s * a12 + c * a22;
				te[7] = -s * a13 + c * a23;

				return this;
		},

		translate: function translate(tx, ty) {

				var te = this.elements;

				te[0] += tx * te[2];te[3] += tx * te[5];te[6] += tx * te[8];
				te[1] += ty * te[2];te[4] += ty * te[5];te[7] += ty * te[8];

				return this;
		},

		equals: function equals(matrix) {

				var te = this.elements;
				var me = matrix.elements;

				for (var i = 0; i < 9; i++) {

						if (te[i] !== me[i]) return false;
				}

				return true;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				for (var i = 0; i < 9; i++) {

						this.elements[i] = array[i + offset];
				}

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				var te = this.elements;

				array[offset] = te[0];
				array[offset + 1] = te[1];
				array[offset + 2] = te[2];

				array[offset + 3] = te[3];
				array[offset + 4] = te[4];
				array[offset + 5] = te[5];

				array[offset + 6] = te[6];
				array[offset + 7] = te[7];
				array[offset + 8] = te[8];

				return array;
		}

});



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Sphere; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Box3_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Vector3_js__ = __webpack_require__(2);




function Sphere(center, radius) {

	this.center = center !== undefined ? center : new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
	this.radius = radius !== undefined ? radius : 0;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Sphere.prototype, {

	set: function set(center, radius) {

		this.center.copy(center);
		this.radius = radius;

		return this;
	},

	setFromPoints: function () {

		var box = new __WEBPACK_IMPORTED_MODULE_1__Box3_js__["a" /* Box3 */]();

		return function setFromPoints(points, optionalCenter) {

			var center = this.center;

			if (optionalCenter !== undefined) {

				center.copy(optionalCenter);
			} else {

				box.setFromPoints(points).getCenter(center);
			}

			var maxRadiusSq = 0;

			for (var i = 0, il = points.length; i < il; i++) {

				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);

			return this;
		};
	}(),

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	copy: function copy(sphere) {

		this.center.copy(sphere.center);
		this.radius = sphere.radius;

		return this;
	},

	empty: function empty() {

		return this.radius <= 0;
	},

	containsPoint: function containsPoint(point) {

		return point.distanceToSquared(this.center) <= this.radius * this.radius;
	},

	distanceToPoint: function distanceToPoint(point) {

		return point.distanceTo(this.center) - this.radius;
	},

	intersectsSphere: function intersectsSphere(sphere) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	},

	intersectsBox: function intersectsBox(box) {

		return box.intersectsSphere(this);
	},

	intersectsPlane: function intersectsPlane(plane) {

		return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	},

	clampPoint: function clampPoint(point, target) {

		var deltaLengthSq = this.center.distanceToSquared(point);

		if (target === undefined) {

			console.warn('THREE.Sphere: .clampPoint() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
		}

		target.copy(point);

		if (deltaLengthSq > this.radius * this.radius) {

			target.sub(this.center).normalize();
			target.multiplyScalar(this.radius).add(this.center);
		}

		return target;
	},

	getBoundingBox: function getBoundingBox(target) {

		if (target === undefined) {

			console.warn('THREE.Sphere: .getBoundingBox() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_1__Box3_js__["a" /* Box3 */]();
		}

		target.set(this.center, this.center);
		target.expandByScalar(this.radius);

		return target;
	},

	applyMatrix4: function applyMatrix4(matrix) {

		this.center.applyMatrix4(matrix);
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;
	},

	translate: function translate(offset) {

		this.center.add(offset);

		return this;
	},

	equals: function equals(sphere) {

		return sphere.center.equals(this.center) && sphere.radius === this.radius;
	}

});



/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Texture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__extras_ImageUtils_js__ = __webpack_require__(264);











var textureId = 0;

function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

	Object.defineProperty(this, 'id', { value: textureId++ });

	this.uuid = __WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : __WEBPACK_IMPORTED_MODULE_3__constants_js__["r" /* ClampToEdgeWrapping */];
	this.wrapT = wrapT !== undefined ? wrapT : __WEBPACK_IMPORTED_MODULE_3__constants_js__["r" /* ClampToEdgeWrapping */];

	this.magFilter = magFilter !== undefined ? magFilter : __WEBPACK_IMPORTED_MODULE_3__constants_js__["a" /* LinearFilter */];
	this.minFilter = minFilter !== undefined ? minFilter : __WEBPACK_IMPORTED_MODULE_3__constants_js__["s" /* LinearMipMapLinearFilter */];

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : __WEBPACK_IMPORTED_MODULE_3__constants_js__["c" /* RGBAFormat */];
	this.type = type !== undefined ? type : __WEBPACK_IMPORTED_MODULE_3__constants_js__["t" /* UnsignedByteType */];

	this.offset = new __WEBPACK_IMPORTED_MODULE_5__math_Vector2_js__["a" /* Vector2 */](0, 0);
	this.repeat = new __WEBPACK_IMPORTED_MODULE_5__math_Vector2_js__["a" /* Vector2 */](1, 1);
	this.center = new __WEBPACK_IMPORTED_MODULE_5__math_Vector2_js__["a" /* Vector2 */](0, 0);
	this.rotation = 0;

	this.matrixAutoUpdate = true;
	this.matrix = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix3_js__["a" /* Matrix3 */]();

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;
	this.encoding = encoding !== undefined ? encoding : __WEBPACK_IMPORTED_MODULE_3__constants_js__["u" /* LinearEncoding */];

	this.version = 0;
	this.onUpdate = null;
}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = __WEBPACK_IMPORTED_MODULE_3__constants_js__["v" /* UVMapping */];

Texture.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

	constructor: Texture,

	isTexture: true,

	updateMatrix: function updateMatrix() {

		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
	},

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	copy: function copy(source) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice(0);

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy(source.offset);
		this.repeat.copy(source.repeat);
		this.center.copy(source.center);
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy(source.matrix);

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;
	},

	toJSON: function toJSON(meta) {

		var isRootObject = meta === undefined || typeof meta === 'string';

		if (!isRootObject && meta.textures[this.uuid] !== undefined) {

			return meta.textures[this.uuid];
		}

		var output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,

			wrap: [this.wrapS, this.wrapT],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if (this.image !== undefined) {

			var image = this.image;

			if (image.uuid === undefined) {

				image.uuid = __WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].generateUUID();
			}

			if (!isRootObject && meta.images[image.uuid] === undefined) {

				var url;

				if (Array.isArray(image)) {

					url = [];

					for (var i = 0, l = image.length; i < l; i++) {

						url.push(__WEBPACK_IMPORTED_MODULE_7__extras_ImageUtils_js__["a" /* ImageUtils */].getDataURL(image[i]));
					}
				} else {

					url = __WEBPACK_IMPORTED_MODULE_7__extras_ImageUtils_js__["a" /* ImageUtils */].getDataURL(image);
				}

				meta.images[image.uuid] = {
					uuid: image.uuid,
					url: url
				};
			}

			output.image = image.uuid;
		}

		if (!isRootObject) {

			meta.textures[this.uuid] = output;
		}

		return output;
	},

	dispose: function dispose() {

		this.dispatchEvent({ type: 'dispose' });
	},

	transformUv: function transformUv(uv) {

		if (this.mapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["v" /* UVMapping */]) return uv;

		uv.applyMatrix3(this.matrix);

		if (uv.x < 0 || uv.x > 1) {

			switch (this.wrapS) {

				case __WEBPACK_IMPORTED_MODULE_3__constants_js__["w" /* RepeatWrapping */]:

					uv.x = uv.x - Math.floor(uv.x);
					break;

				case __WEBPACK_IMPORTED_MODULE_3__constants_js__["r" /* ClampToEdgeWrapping */]:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case __WEBPACK_IMPORTED_MODULE_3__constants_js__["x" /* MirroredRepeatWrapping */]:

					if (Math.abs(Math.floor(uv.x) % 2) === 1) {

						uv.x = Math.ceil(uv.x) - uv.x;
					} else {

						uv.x = uv.x - Math.floor(uv.x);
					}
					break;

			}
		}

		if (uv.y < 0 || uv.y > 1) {

			switch (this.wrapT) {

				case __WEBPACK_IMPORTED_MODULE_3__constants_js__["w" /* RepeatWrapping */]:

					uv.y = uv.y - Math.floor(uv.y);
					break;

				case __WEBPACK_IMPORTED_MODULE_3__constants_js__["r" /* ClampToEdgeWrapping */]:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case __WEBPACK_IMPORTED_MODULE_3__constants_js__["x" /* MirroredRepeatWrapping */]:

					if (Math.abs(Math.floor(uv.y) % 2) === 1) {

						uv.y = Math.ceil(uv.y) - uv.y;
					} else {

						uv.y = uv.y - Math.floor(uv.y);
					}
					break;

			}
		}

		if (this.flipY) {

			uv.y = 1 - uv.y;
		}

		return uv;
	}

});

Object.defineProperty(Texture.prototype, "needsUpdate", {

	set: function set(value) {

		if (value === true) this.version++;
	}

});



/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(67);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(138);

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(232);

// base class of rpc.Service
util.EventEmitter = __webpack_require__(234);

// float handling accross browsers
util.float = __webpack_require__(236);

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(139);

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(239);

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(238);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(618);

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof global !== "undefined" && global
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(651)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(633);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Material; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Math_js__ = __webpack_require__(8);







var materialId = 0;

function Material() {

	Object.defineProperty(this, 'id', { value: materialId++ });

	this.uuid = __WEBPACK_IMPORTED_MODULE_5__math_Math_js__["a" /* _Math */].generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;
	this.lights = true;

	this.blending = __WEBPACK_IMPORTED_MODULE_4__constants_js__["i" /* NormalBlending */];
	this.side = __WEBPACK_IMPORTED_MODULE_4__constants_js__["j" /* FrontSide */];
	this.flatShading = false;
	this.vertexTangents = false;
	this.vertexColors = __WEBPACK_IMPORTED_MODULE_4__constants_js__["k" /* NoColors */];

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = __WEBPACK_IMPORTED_MODULE_4__constants_js__["l" /* SrcAlphaFactor */];
	this.blendDst = __WEBPACK_IMPORTED_MODULE_4__constants_js__["m" /* OneMinusSrcAlphaFactor */];
	this.blendEquation = __WEBPACK_IMPORTED_MODULE_4__constants_js__["n" /* AddEquation */];
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = __WEBPACK_IMPORTED_MODULE_4__constants_js__["o" /* LessEqualDepth */];
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.userData = {};

	this.needsUpdate = true;

	this.instanceMaterial = false;

	this.vertexOffset = false;
	this.vertexOffsetValue = 0.0;
}

Material.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_3__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function onBeforeCompile() {},

	setValues: function setValues(values) {

		if (values === undefined) return;

		for (var key in values) {

			var newValue = values[key];

			if (newValue === undefined) {

				console.warn("THREE.Material: '" + key + "' parameter is undefined.");
				continue;
			}

			if (key === 'shading') {

				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = newValue === __WEBPACK_IMPORTED_MODULE_4__constants_js__["p" /* FlatShading */] ? true : false;
				continue;
			}

			var currentValue = this[key];

			if (currentValue === undefined) {

				console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
				continue;
			}

			if (currentValue && currentValue.isColor) {

				currentValue.set(newValue);
			} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {

				currentValue.copy(newValue);
			} else {

				this[key] = newValue;
			}
		}
	},

	toJSON: function toJSON(meta) {

		var isRoot = meta === undefined || typeof meta === 'string';

		if (isRoot) {

			meta = {
				textures: {},
				images: {}
			};
		}

		var data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		data.uuid = this.uuid;
		data.type = this.type;

		if (this.name !== '') data.name = this.name;

		if (this.color && this.color.isColor) data.color = this.color.getHex();

		if (this.roughness !== undefined) data.roughness = this.roughness;
		if (this.metalness !== undefined) data.metalness = this.metalness;

		if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
		if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;

		if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
		if (this.shininess !== undefined) data.shininess = this.shininess;
		if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
		if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;

		if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
		if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
		if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
		if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

		if (this.aoMap && this.aoMap.isTexture) {

			data.aoMap = this.aoMap.toJSON(meta).uuid;
			data.aoMapIntensity = this.aoMapIntensity;
		}

		if (this.bumpMap && this.bumpMap.isTexture) {

			data.bumpMap = this.bumpMap.toJSON(meta).uuid;
			data.bumpScale = this.bumpScale;
		}

		if (this.normalMap && this.normalMap.isTexture) {

			data.normalMap = this.normalMap.toJSON(meta).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();
		}

		if (this.displacementMap && this.displacementMap.isTexture) {

			data.displacementMap = this.displacementMap.toJSON(meta).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;
		}

		if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
		if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

		if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
		if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

		if (this.envMap && this.envMap.isTexture) {

			data.envMap = this.envMap.toJSON(meta).uuid;
			data.reflectivity = this.reflectivity;
			data.refractionRatio = this.refractionRatio;

			if (this.combine !== undefined) data.combine = this.combine;
			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
		}

		if (this.gradientMap && this.gradientMap.isTexture) {

			data.gradientMap = this.gradientMap.toJSON(meta).uuid;
		}

		if (this.size !== undefined) data.size = this.size;
		if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;

		if (this.blending !== __WEBPACK_IMPORTED_MODULE_4__constants_js__["i" /* NormalBlending */]) data.blending = this.blending;
		if (this.flatShading === true) data.flatShading = this.flatShading;
		if (this.side !== __WEBPACK_IMPORTED_MODULE_4__constants_js__["j" /* FrontSide */]) data.side = this.side;
		if (this.vertexColors !== __WEBPACK_IMPORTED_MODULE_4__constants_js__["k" /* NoColors */]) data.vertexColors = this.vertexColors;

		if (this.opacity < 1) data.opacity = this.opacity;
		if (this.transparent === true) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;

		if (this.polygonOffset === true) data.polygonOffset = true;
		if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
		if (this.dashSize !== undefined) data.dashSize = this.dashSize;
		if (this.gapSize !== undefined) data.gapSize = this.gapSize;
		if (this.scale !== undefined) data.scale = this.scale;

		if (this.dithering === true) data.dithering = true;

		if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
		if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;

		if (this.wireframe === true) data.wireframe = this.wireframe;
		if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
		if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
		if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;

		if (this.morphTargets === true) data.morphTargets = true;
		if (this.morphNormals === true) data.morphNormals = true;
		if (this.skinning === true) data.skinning = true;

		if (this.visible === false) data.visible = false;
		if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.userData) !== '{}') data.userData = this.userData;

		function extractFromCache(cache) {

			var values = [];

			for (var key in cache) {

				var data = cache[key];
				delete data.metadata;
				values.push(data);
			}

			return values;
		}

		if (isRoot) {

			var textures = extractFromCache(meta.textures);
			var images = extractFromCache(meta.images);

			if (textures.length > 0) data.textures = textures;
			if (images.length > 0) data.images = images;
		}

		return data;
	},

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	copy: function copy(source) {

		this.name = source.name;

		this.fog = source.fog;
		this.lights = source.lights;

		this.blending = source.blending;
		this.side = source.side;
		this.flatShading = source.flatShading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;
		this.userData = JSON.parse(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(source.userData));

		this.clipShadows = source.clipShadows;
		this.clipIntersection = source.clipIntersection;

		var srcPlanes = source.clippingPlanes,
		    dstPlanes = null;

		if (srcPlanes !== null) {

			var n = srcPlanes.length;
			dstPlanes = new Array(n);

			for (var i = 0; i !== n; ++i) {
				dstPlanes[i] = srcPlanes[i].clone();
			}
		}

		this.clippingPlanes = dstPlanes;

		this.shadowSide = source.shadowSide;

		return this;
	},

	dispose: function dispose() {

		this.dispatchEvent({ type: 'dispose' });
	}

});



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Vector4; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__);




function Vector4(x, y, z, w) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = w !== undefined ? w : 1;
}

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default()(Vector4.prototype, {

		"width": {

				get: function get() {

						return this.z;
				},

				set: function set(value) {

						this.z = value;
				}

		},

		"height": {

				get: function get() {

						return this.w;
				},

				set: function set(value) {

						this.w = value;
				}

		}

});

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Vector4.prototype, {

		isVector4: true,

		set: function set(x, y, z, w) {

				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;

				return this;
		},

		setScalar: function setScalar(scalar) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;

				return this;
		},

		setX: function setX(x) {

				this.x = x;

				return this;
		},

		setY: function setY(y) {

				this.y = y;

				return this;
		},

		setZ: function setZ(z) {

				this.z = z;

				return this;
		},

		setW: function setW(w) {

				this.w = w;

				return this;
		},

		setComponent: function setComponent(index, value) {

				switch (index) {

						case 0:
								this.x = value;break;
						case 1:
								this.y = value;break;
						case 2:
								this.z = value;break;
						case 3:
								this.w = value;break;
						default:
								throw new Error('index is out of range: ' + index);

				}

				return this;
		},

		getComponent: function getComponent(index) {

				switch (index) {

						case 0:
								return this.x;
						case 1:
								return this.y;
						case 2:
								return this.z;
						case 3:
								return this.w;
						default:
								throw new Error('index is out of range: ' + index);

				}
		},

		clone: function clone() {

				return new this.constructor(this.x, this.y, this.z, this.w);
		},

		copy: function copy(v) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = v.w !== undefined ? v.w : 1;

				return this;
		},

		add: function add(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
						return this.addVectors(v, w);
				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;

				return this;
		},

		addScalar: function addScalar(s) {

				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;

				return this;
		},

		addVectors: function addVectors(a, b) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;

				return this;
		},

		addScaledVector: function addScaledVector(v, s) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;

				return this;
		},

		sub: function sub(v, w) {

				if (w !== undefined) {

						console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
						return this.subVectors(v, w);
				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;

				return this;
		},

		subScalar: function subScalar(s) {

				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;

				return this;
		},

		subVectors: function subVectors(a, b) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;

				return this;
		},

		multiplyScalar: function multiplyScalar(scalar) {

				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;

				return this;
		},

		applyMatrix4: function applyMatrix4(m) {

				var x = this.x,
				    y = this.y,
				    z = this.z,
				    w = this.w;
				var e = m.elements;

				this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
				this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
				this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
				this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

				return this;
		},

		divideScalar: function divideScalar(scalar) {

				return this.multiplyScalar(1 / scalar);
		},

		setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {

				this.w = 2 * Math.acos(q.w);

				var s = Math.sqrt(1 - q.w * q.w);

				if (s < 0.0001) {

						this.x = 1;
						this.y = 0;
						this.z = 0;
				} else {

						this.x = q.x / s;
						this.y = q.y / s;
						this.z = q.z / s;
				}

				return this;
		},

		setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {

				var angle,
				    x,
				    y,
				    z,
				    epsilon = 0.01,
				    epsilon2 = 0.1,
				    te = m.elements,
				    m11 = te[0],
				    m12 = te[4],
				    m13 = te[8],
				    m21 = te[1],
				    m22 = te[5],
				    m23 = te[9],
				    m31 = te[2],
				    m32 = te[6],
				    m33 = te[10];

				if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {

						if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {

								this.set(1, 0, 0, 0);

								return this;
						}

						angle = Math.PI;

						var xx = (m11 + 1) / 2;
						var yy = (m22 + 1) / 2;
						var zz = (m33 + 1) / 2;
						var xy = (m12 + m21) / 4;
						var xz = (m13 + m31) / 4;
						var yz = (m23 + m32) / 4;

						if (xx > yy && xx > zz) {

								if (xx < epsilon) {

										x = 0;
										y = 0.707106781;
										z = 0.707106781;
								} else {

										x = Math.sqrt(xx);
										y = xy / x;
										z = xz / x;
								}
						} else if (yy > zz) {

								if (yy < epsilon) {

										x = 0.707106781;
										y = 0;
										z = 0.707106781;
								} else {

										y = Math.sqrt(yy);
										x = xy / y;
										z = yz / y;
								}
						} else {

								if (zz < epsilon) {

										x = 0.707106781;
										y = 0.707106781;
										z = 0;
								} else {

										z = Math.sqrt(zz);
										x = xz / z;
										y = yz / z;
								}
						}

						this.set(x, y, z, angle);

						return this;
				}

				var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));

				if (Math.abs(s) < 0.001) s = 1;

				this.x = (m32 - m23) / s;
				this.y = (m13 - m31) / s;
				this.z = (m21 - m12) / s;
				this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

				return this;
		},

		min: function min(v) {

				this.x = Math.min(this.x, v.x);
				this.y = Math.min(this.y, v.y);
				this.z = Math.min(this.z, v.z);
				this.w = Math.min(this.w, v.w);

				return this;
		},

		max: function max(v) {

				this.x = Math.max(this.x, v.x);
				this.y = Math.max(this.y, v.y);
				this.z = Math.max(this.z, v.z);
				this.w = Math.max(this.w, v.w);

				return this;
		},

		clamp: function clamp(min, max) {

				this.x = Math.max(min.x, Math.min(max.x, this.x));
				this.y = Math.max(min.y, Math.min(max.y, this.y));
				this.z = Math.max(min.z, Math.min(max.z, this.z));
				this.w = Math.max(min.w, Math.min(max.w, this.w));

				return this;
		},

		clampScalar: function () {

				var min, max;

				return function clampScalar(minVal, maxVal) {

						if (min === undefined) {

								min = new Vector4();
								max = new Vector4();
						}

						min.set(minVal, minVal, minVal, minVal);
						max.set(maxVal, maxVal, maxVal, maxVal);

						return this.clamp(min, max);
				};
		}(),

		clampLength: function clampLength(min, max) {

				var length = this.length();

				return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		},

		floor: function floor() {

				this.x = Math.floor(this.x);
				this.y = Math.floor(this.y);
				this.z = Math.floor(this.z);
				this.w = Math.floor(this.w);

				return this;
		},

		ceil: function ceil() {

				this.x = Math.ceil(this.x);
				this.y = Math.ceil(this.y);
				this.z = Math.ceil(this.z);
				this.w = Math.ceil(this.w);

				return this;
		},

		round: function round() {

				this.x = Math.round(this.x);
				this.y = Math.round(this.y);
				this.z = Math.round(this.z);
				this.w = Math.round(this.w);

				return this;
		},

		roundToZero: function roundToZero() {

				this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
				this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
				this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
				this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);

				return this;
		},

		negate: function negate() {

				this.x = -this.x;
				this.y = -this.y;
				this.z = -this.z;
				this.w = -this.w;

				return this;
		},

		dot: function dot(v) {

				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		},

		lengthSq: function lengthSq() {

				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		},

		length: function length() {

				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		},

		manhattanLength: function manhattanLength() {

				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		},

		normalize: function normalize() {

				return this.divideScalar(this.length() || 1);
		},

		setLength: function setLength(length) {

				return this.normalize().multiplyScalar(length);
		},

		lerp: function lerp(v, alpha) {

				this.x += (v.x - this.x) * alpha;
				this.y += (v.y - this.y) * alpha;
				this.z += (v.z - this.z) * alpha;
				this.w += (v.w - this.w) * alpha;

				return this;
		},

		lerpVectors: function lerpVectors(v1, v2, alpha) {

				return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
		},

		equals: function equals(v) {

				return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				this.x = array[offset];
				this.y = array[offset + 1];
				this.z = array[offset + 2];
				this.w = array[offset + 3];

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				array[offset] = this.x;
				array[offset + 1] = this.y;
				array[offset + 2] = this.z;
				array[offset + 3] = this.w;

				return array;
		},

		fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

				if (offset !== undefined) {

						console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
				}

				this.x = attribute.getX(index);
				this.y = attribute.getY(index);
				this.z = attribute.getZ(index);
				this.w = attribute.getW(index);

				return this;
		}

});



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = cloneUniforms;
/* harmony export (immutable) */ __webpack_exports__["c"] = clone;
/* harmony export (immutable) */ __webpack_exports__["d"] = mergeUniforms;
/* unused harmony export merge */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniformsUtils; });

function cloneUniforms(src) {

	var dst = {};

	for (var u in src) {

		dst[u] = {};

		for (var p in src[u]) {

			var property = src[u][p];

			if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {

				dst[u][p] = property.clone();
			} else if (Array.isArray(property)) {

				dst[u][p] = property.slice();
			} else {

				dst[u][p] = property;
			}
		}
	}

	return dst;
}

function clone(src) {

	return cloneUniforms(src);
}

function mergeUniforms(uniforms) {

	var merged = {};

	for (var u = 0; u < uniforms.length; u++) {

		var tmp = cloneUniforms(uniforms[u]);

		for (var p in tmp) {

			merged[p] = tmp[p];
		}
	}

	return merged;
}
function merge(uniforms) {
	return mergeUniforms(uniforms);
}

var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };



/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(532), __esModule: true };

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(525);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(21);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(24);
var createDesc = __webpack_require__(72);
module.exports = __webpack_require__(20) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Geometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Face3_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Box3_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__math_Math_js__ = __webpack_require__(8);














var geometryId = 0;

function Geometry() {

		Object.defineProperty(this, 'id', { value: geometryId += 2 });

		this.uuid = __WEBPACK_IMPORTED_MODULE_12__math_Math_js__["a" /* _Math */].generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
}

Geometry.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function applyMatrix(matrix) {

				var normalMatrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);

				for (var i = 0, il = this.vertices.length; i < il; i++) {

						var vertex = this.vertices[i];
						vertex.applyMatrix4(matrix);
				}

				for (var i = 0, il = this.faces.length; i < il; i++) {

						var face = this.faces[i];
						face.normal.applyMatrix3(normalMatrix).normalize();

						for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

								face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
						}
				}

				if (this.boundingBox !== null) {

						this.computeBoundingBox();
				}

				if (this.boundingSphere !== null) {

						this.computeBoundingSphere();
				}

				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;

				return this;
		},

		rotateX: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

				return function rotateX(angle) {

						m1.makeRotationX(angle);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		rotateY: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

				return function rotateY(angle) {

						m1.makeRotationY(angle);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		rotateZ: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

				return function rotateZ(angle) {

						m1.makeRotationZ(angle);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		translate: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

				return function translate(x, y, z) {

						m1.makeTranslation(x, y, z);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		scale: function () {

				var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

				return function scale(x, y, z) {

						m1.makeScale(x, y, z);

						this.applyMatrix(m1);

						return this;
				};
		}(),

		lookAt: function () {

				var obj = new __WEBPACK_IMPORTED_MODULE_11__Object3D_js__["a" /* Object3D */]();

				return function lookAt(vector) {

						obj.lookAt(vector);

						obj.updateMatrix();

						this.applyMatrix(obj.matrix);
				};
		}(),

		fromBufferGeometry: function fromBufferGeometry(geometry) {

				var scope = this;

				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;

				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

				if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

				for (var i = 0; i < positions.length; i += 3) {

						scope.vertices.push(new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]().fromArray(positions, i));

						if (colors !== undefined) {

								scope.colors.push(new __WEBPACK_IMPORTED_MODULE_10__math_Color_js__["a" /* Color */]().fromArray(colors, i));
						}
				}

				function addFace(a, b, c, materialIndex) {

						var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];

						var vertexNormals = normals === undefined ? [] : [new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]().fromArray(normals, a * 3), new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]().fromArray(normals, b * 3), new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]().fromArray(normals, c * 3)];

						var face = new __WEBPACK_IMPORTED_MODULE_3__Face3_js__["a" /* Face3 */](a, b, c, vertexNormals, vertexColors, materialIndex);

						scope.faces.push(face);

						if (uvs !== undefined) {

								scope.faceVertexUvs[0].push([new __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__["a" /* Vector2 */]().fromArray(uvs, a * 2), new __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__["a" /* Vector2 */]().fromArray(uvs, b * 2), new __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__["a" /* Vector2 */]().fromArray(uvs, c * 2)]);
						}

						if (uvs2 !== undefined) {

								scope.faceVertexUvs[1].push([new __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__["a" /* Vector2 */]().fromArray(uvs2, a * 2), new __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__["a" /* Vector2 */]().fromArray(uvs2, b * 2), new __WEBPACK_IMPORTED_MODULE_9__math_Vector2_js__["a" /* Vector2 */]().fromArray(uvs2, c * 2)]);
						}
				}

				var groups = geometry.groups;

				if (groups.length > 0) {

						for (var i = 0; i < groups.length; i++) {

								var group = groups[i];

								var start = group.start;
								var count = group.count;

								for (var j = start, jl = start + count; j < jl; j += 3) {

										if (indices !== undefined) {

												addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
										} else {

												addFace(j, j + 1, j + 2, group.materialIndex);
										}
								}
						}
				} else {

						if (indices !== undefined) {

								for (var i = 0; i < indices.length; i += 3) {

										addFace(indices[i], indices[i + 1], indices[i + 2]);
								}
						} else {

								for (var i = 0; i < positions.length / 3; i += 3) {

										addFace(i, i + 1, i + 2);
								}
						}
				}

				this.computeFaceNormals();

				if (geometry.boundingBox !== null) {

						this.boundingBox = geometry.boundingBox.clone();
				}

				if (geometry.boundingSphere !== null) {

						this.boundingSphere = geometry.boundingSphere.clone();
				}

				return this;
		},

		center: function () {

				var offset = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();

				return function center() {

						this.computeBoundingBox();

						this.boundingBox.getCenter(offset).negate();

						this.translate(offset.x, offset.y, offset.z);

						return this;
				};
		}(),

		normalize: function normalize() {

				this.computeBoundingSphere();

				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;

				var s = radius === 0 ? 1 : 1.0 / radius;

				var matrix = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();
				matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);

				this.applyMatrix(matrix);

				return this;
		},

		computeFaceNormals: function computeFaceNormals() {

				var cb = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */](),
				    ab = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();

				for (var f = 0, fl = this.faces.length; f < fl; f++) {

						var face = this.faces[f];

						var vA = this.vertices[face.a];
						var vB = this.vertices[face.b];
						var vC = this.vertices[face.c];

						cb.subVectors(vC, vB);
						ab.subVectors(vA, vB);
						cb.cross(ab);

						cb.normalize();

						face.normal.copy(cb);
				}
		},

		computeVertexNormals: function computeVertexNormals(areaWeighted) {

				if (areaWeighted === undefined) areaWeighted = true;

				var v, vl, f, fl, face, vertices;

				vertices = new Array(this.vertices.length);

				for (v = 0, vl = this.vertices.length; v < vl; v++) {

						vertices[v] = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();
				}

				if (areaWeighted) {

						var vA, vB, vC;
						var cb = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */](),
						    ab = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();

						for (f = 0, fl = this.faces.length; f < fl; f++) {

								face = this.faces[f];

								vA = this.vertices[face.a];
								vB = this.vertices[face.b];
								vC = this.vertices[face.c];

								cb.subVectors(vC, vB);
								ab.subVectors(vA, vB);
								cb.cross(ab);

								vertices[face.a].add(cb);
								vertices[face.b].add(cb);
								vertices[face.c].add(cb);
						}
				} else {

						this.computeFaceNormals();

						for (f = 0, fl = this.faces.length; f < fl; f++) {

								face = this.faces[f];

								vertices[face.a].add(face.normal);
								vertices[face.b].add(face.normal);
								vertices[face.c].add(face.normal);
						}
				}

				for (v = 0, vl = this.vertices.length; v < vl; v++) {

						vertices[v].normalize();
				}

				for (f = 0, fl = this.faces.length; f < fl; f++) {

						face = this.faces[f];

						var vertexNormals = face.vertexNormals;

						if (vertexNormals.length === 3) {

								vertexNormals[0].copy(vertices[face.a]);
								vertexNormals[1].copy(vertices[face.b]);
								vertexNormals[2].copy(vertices[face.c]);
						} else {

								vertexNormals[0] = vertices[face.a].clone();
								vertexNormals[1] = vertices[face.b].clone();
								vertexNormals[2] = vertices[face.c].clone();
						}
				}

				if (this.faces.length > 0) {

						this.normalsNeedUpdate = true;
				}
		},

		computeFlatVertexNormals: function computeFlatVertexNormals() {

				var f, fl, face;

				this.computeFaceNormals();

				for (f = 0, fl = this.faces.length; f < fl; f++) {

						face = this.faces[f];

						var vertexNormals = face.vertexNormals;

						if (vertexNormals.length === 3) {

								vertexNormals[0].copy(face.normal);
								vertexNormals[1].copy(face.normal);
								vertexNormals[2].copy(face.normal);
						} else {

								vertexNormals[0] = face.normal.clone();
								vertexNormals[1] = face.normal.clone();
								vertexNormals[2] = face.normal.clone();
						}
				}

				if (this.faces.length > 0) {

						this.normalsNeedUpdate = true;
				}
		},

		computeMorphNormals: function computeMorphNormals() {

				var i, il, f, fl, face;

				for (f = 0, fl = this.faces.length; f < fl; f++) {

						face = this.faces[f];

						if (!face.__originalFaceNormal) {

								face.__originalFaceNormal = face.normal.clone();
						} else {

								face.__originalFaceNormal.copy(face.normal);
						}

						if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

						for (i = 0, il = face.vertexNormals.length; i < il; i++) {

								if (!face.__originalVertexNormals[i]) {

										face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
								} else {

										face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
								}
						}
				}

				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;

				for (i = 0, il = this.morphTargets.length; i < il; i++) {

						if (!this.morphNormals[i]) {

								this.morphNormals[i] = {};
								this.morphNormals[i].faceNormals = [];
								this.morphNormals[i].vertexNormals = [];

								var dstNormalsFace = this.morphNormals[i].faceNormals;
								var dstNormalsVertex = this.morphNormals[i].vertexNormals;

								var faceNormal, vertexNormals;

								for (f = 0, fl = this.faces.length; f < fl; f++) {

										faceNormal = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();
										vertexNormals = { a: new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */](), b: new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */](), c: new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]() };

										dstNormalsFace.push(faceNormal);
										dstNormalsVertex.push(vertexNormals);
								}
						}

						var morphNormals = this.morphNormals[i];

						tmpGeo.vertices = this.morphTargets[i].vertices;

						tmpGeo.computeFaceNormals();
						tmpGeo.computeVertexNormals();

						var faceNormal, vertexNormals;

						for (f = 0, fl = this.faces.length; f < fl; f++) {

								face = this.faces[f];

								faceNormal = morphNormals.faceNormals[f];
								vertexNormals = morphNormals.vertexNormals[f];

								faceNormal.copy(face.normal);

								vertexNormals.a.copy(face.vertexNormals[0]);
								vertexNormals.b.copy(face.vertexNormals[1]);
								vertexNormals.c.copy(face.vertexNormals[2]);
						}
				}

				for (f = 0, fl = this.faces.length; f < fl; f++) {

						face = this.faces[f];

						face.normal = face.__originalFaceNormal;
						face.vertexNormals = face.__originalVertexNormals;
				}
		},

		computeBoundingBox: function computeBoundingBox() {

				if (this.boundingBox === null) {

						this.boundingBox = new __WEBPACK_IMPORTED_MODULE_6__math_Box3_js__["a" /* Box3 */]();
				}

				this.boundingBox.setFromPoints(this.vertices);
		},

		computeBoundingSphere: function computeBoundingSphere() {

				if (this.boundingSphere === null) {

						this.boundingSphere = new __WEBPACK_IMPORTED_MODULE_5__math_Sphere_js__["a" /* Sphere */]();
				}

				this.boundingSphere.setFromPoints(this.vertices);
		},

		merge: function merge(geometry, matrix, materialIndexOffset) {

				if (!(geometry && geometry.isGeometry)) {

						console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
						return;
				}

				var normalMatrix,
				    vertexOffset = this.vertices.length,
				    vertices1 = this.vertices,
				    vertices2 = geometry.vertices,
				    faces1 = this.faces,
				    faces2 = geometry.faces,
				    uvs1 = this.faceVertexUvs[0],
				    uvs2 = geometry.faceVertexUvs[0],
				    colors1 = this.colors,
				    colors2 = geometry.colors;

				if (materialIndexOffset === undefined) materialIndexOffset = 0;

				if (matrix !== undefined) {

						normalMatrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);
				}

				for (var i = 0, il = vertices2.length; i < il; i++) {

						var vertex = vertices2[i];

						var vertexCopy = vertex.clone();

						if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);

						vertices1.push(vertexCopy);
				}

				for (var i = 0, il = colors2.length; i < il; i++) {

						colors1.push(colors2[i].clone());
				}

				for (i = 0, il = faces2.length; i < il; i++) {

						var face = faces2[i],
						    faceCopy,
						    normal,
						    color,
						    faceVertexNormals = face.vertexNormals,
						    faceVertexColors = face.vertexColors;

						faceCopy = new __WEBPACK_IMPORTED_MODULE_3__Face3_js__["a" /* Face3 */](face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
						faceCopy.normal.copy(face.normal);

						if (normalMatrix !== undefined) {

								faceCopy.normal.applyMatrix3(normalMatrix).normalize();
						}

						for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {

								normal = faceVertexNormals[j].clone();

								if (normalMatrix !== undefined) {

										normal.applyMatrix3(normalMatrix).normalize();
								}

								faceCopy.vertexNormals.push(normal);
						}

						faceCopy.color.copy(face.color);

						for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {

								color = faceVertexColors[j];
								faceCopy.vertexColors.push(color.clone());
						}

						faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

						faces1.push(faceCopy);
				}

				for (i = 0, il = uvs2.length; i < il; i++) {

						var uv = uvs2[i],
						    uvCopy = [];

						if (uv === undefined) {

								continue;
						}

						for (var j = 0, jl = uv.length; j < jl; j++) {

								uvCopy.push(uv[j].clone());
						}

						uvs1.push(uvCopy);
				}
		},

		mergeMesh: function mergeMesh(mesh) {

				if (!(mesh && mesh.isMesh)) {

						console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
						return;
				}

				if (mesh.matrixAutoUpdate) mesh.updateMatrix();

				this.merge(mesh.geometry, mesh.matrix);
		},

		mergeVertices: function mergeVertices() {

				var verticesMap = {};
				var unique = [],
				    changes = [];

				var v, key;
				var precisionPoints = 4;
				var precision = Math.pow(10, precisionPoints);
				var i, il, face;
				var indices, j, jl;

				for (i = 0, il = this.vertices.length; i < il; i++) {

						v = this.vertices[i];
						key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

						if (verticesMap[key] === undefined) {

								verticesMap[key] = i;
								unique.push(this.vertices[i]);
								changes[i] = unique.length - 1;
						} else {
								changes[i] = changes[verticesMap[key]];
						}
				}

				var faceIndicesToRemove = [];

				for (i = 0, il = this.faces.length; i < il; i++) {

						face = this.faces[i];

						face.a = changes[face.a];
						face.b = changes[face.b];
						face.c = changes[face.c];

						indices = [face.a, face.b, face.c];

						for (var n = 0; n < 3; n++) {

								if (indices[n] === indices[(n + 1) % 3]) {

										faceIndicesToRemove.push(i);
										break;
								}
						}
				}

				for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {

						var idx = faceIndicesToRemove[i];

						this.faces.splice(idx, 1);

						for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {

								this.faceVertexUvs[j].splice(idx, 1);
						}
				}

				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;
		},

		setFromPoints: function setFromPoints(points) {

				this.vertices = [];

				for (var i = 0, l = points.length; i < l; i++) {

						var point = points[i];
						this.vertices.push(new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */](point.x, point.y, point.z || 0));
				}

				return this;
		},

		sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {

				var faces = this.faces;
				var length = faces.length;

				for (var i = 0; i < length; i++) {

						faces[i]._id = i;
				}

				function materialIndexSort(a, b) {

						return a.materialIndex - b.materialIndex;
				}

				faces.sort(materialIndexSort);

				var uvs1 = this.faceVertexUvs[0];
				var uvs2 = this.faceVertexUvs[1];

				var newUvs1, newUvs2;

				if (uvs1 && uvs1.length === length) newUvs1 = [];
				if (uvs2 && uvs2.length === length) newUvs2 = [];

				for (var i = 0; i < length; i++) {

						var id = faces[i]._id;

						if (newUvs1) newUvs1.push(uvs1[id]);
						if (newUvs2) newUvs2.push(uvs2[id]);
				}

				if (newUvs1) this.faceVertexUvs[0] = newUvs1;
				if (newUvs2) this.faceVertexUvs[1] = newUvs2;
		},

		toJSON: function toJSON() {

				var data = {
						metadata: {
								version: 4.5,
								type: 'Geometry',
								generator: 'Geometry.toJSON'
						}
				};

				data.uuid = this.uuid;
				data.type = this.type;
				if (this.name !== '') data.name = this.name;

				if (this.parameters !== undefined) {

						var parameters = this.parameters;

						for (var key in parameters) {

								if (parameters[key] !== undefined) data[key] = parameters[key];
						}

						return data;
				}

				var vertices = [];

				for (var i = 0; i < this.vertices.length; i++) {

						var vertex = this.vertices[i];
						vertices.push(vertex.x, vertex.y, vertex.z);
				}

				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};

				for (var i = 0; i < this.faces.length; i++) {

						var face = this.faces[i];

						var hasMaterial = true;
						var hasFaceUv = false;
						var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
						var hasFaceNormal = face.normal.length() > 0;
						var hasFaceVertexNormal = face.vertexNormals.length > 0;
						var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
						var hasFaceVertexColor = face.vertexColors.length > 0;

						var faceType = 0;

						faceType = setBit(faceType, 0, 0);
						faceType = setBit(faceType, 1, hasMaterial);
						faceType = setBit(faceType, 2, hasFaceUv);
						faceType = setBit(faceType, 3, hasFaceVertexUv);
						faceType = setBit(faceType, 4, hasFaceNormal);
						faceType = setBit(faceType, 5, hasFaceVertexNormal);
						faceType = setBit(faceType, 6, hasFaceColor);
						faceType = setBit(faceType, 7, hasFaceVertexColor);

						faces.push(faceType);
						faces.push(face.a, face.b, face.c);
						faces.push(face.materialIndex);

						if (hasFaceVertexUv) {

								var faceVertexUvs = this.faceVertexUvs[0][i];

								faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
						}

						if (hasFaceNormal) {

								faces.push(getNormalIndex(face.normal));
						}

						if (hasFaceVertexNormal) {

								var vertexNormals = face.vertexNormals;

								faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
						}

						if (hasFaceColor) {

								faces.push(getColorIndex(face.color));
						}

						if (hasFaceVertexColor) {

								var vertexColors = face.vertexColors;

								faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
						}
				}

				function setBit(value, position, enabled) {

						return enabled ? value | 1 << position : value & ~(1 << position);
				}

				function getNormalIndex(normal) {

						var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

						if (normalsHash[hash] !== undefined) {

								return normalsHash[hash];
						}

						normalsHash[hash] = normals.length / 3;
						normals.push(normal.x, normal.y, normal.z);

						return normalsHash[hash];
				}

				function getColorIndex(color) {

						var hash = color.r.toString() + color.g.toString() + color.b.toString();

						if (colorsHash[hash] !== undefined) {

								return colorsHash[hash];
						}

						colorsHash[hash] = colors.length;
						colors.push(color.getHex());

						return colorsHash[hash];
				}

				function getUvIndex(uv) {

						var hash = uv.x.toString() + uv.y.toString();

						if (uvsHash[hash] !== undefined) {

								return uvsHash[hash];
						}

						uvsHash[hash] = uvs.length / 2;
						uvs.push(uv.x, uv.y);

						return uvsHash[hash];
				}

				data.data = {};

				data.data.vertices = vertices;
				data.data.normals = normals;
				if (colors.length > 0) data.data.colors = colors;
				if (uvs.length > 0) data.data.uvs = [uvs];
				data.data.faces = faces;

				return data;
		},

		clone: function clone() {

				return new Geometry().copy(this);
		},

		copy: function copy(source) {

				var i, il, j, jl, k, kl;

				this.vertices = [];
				this.colors = [];
				this.faces = [];
				this.faceVertexUvs = [[]];
				this.morphTargets = [];
				this.morphNormals = [];
				this.skinWeights = [];
				this.skinIndices = [];
				this.lineDistances = [];
				this.boundingBox = null;
				this.boundingSphere = null;

				this.name = source.name;

				var vertices = source.vertices;

				for (i = 0, il = vertices.length; i < il; i++) {

						this.vertices.push(vertices[i].clone());
				}

				var colors = source.colors;

				for (i = 0, il = colors.length; i < il; i++) {

						this.colors.push(colors[i].clone());
				}

				var faces = source.faces;

				for (i = 0, il = faces.length; i < il; i++) {

						this.faces.push(faces[i].clone());
				}

				for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {

						var faceVertexUvs = source.faceVertexUvs[i];

						if (this.faceVertexUvs[i] === undefined) {

								this.faceVertexUvs[i] = [];
						}

						for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {

								var uvs = faceVertexUvs[j],
								    uvsCopy = [];

								for (k = 0, kl = uvs.length; k < kl; k++) {

										var uv = uvs[k];

										uvsCopy.push(uv.clone());
								}

								this.faceVertexUvs[i].push(uvsCopy);
						}
				}

				var morphTargets = source.morphTargets;

				for (i = 0, il = morphTargets.length; i < il; i++) {

						var morphTarget = {};
						morphTarget.name = morphTargets[i].name;

						if (morphTargets[i].vertices !== undefined) {

								morphTarget.vertices = [];

								for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {

										morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
								}
						}

						if (morphTargets[i].normals !== undefined) {

								morphTarget.normals = [];

								for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {

										morphTarget.normals.push(morphTargets[i].normals[j].clone());
								}
						}

						this.morphTargets.push(morphTarget);
				}

				var morphNormals = source.morphNormals;

				for (i = 0, il = morphNormals.length; i < il; i++) {

						var morphNormal = {};

						if (morphNormals[i].vertexNormals !== undefined) {

								morphNormal.vertexNormals = [];

								for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {

										var srcVertexNormal = morphNormals[i].vertexNormals[j];
										var destVertexNormal = {};

										destVertexNormal.a = srcVertexNormal.a.clone();
										destVertexNormal.b = srcVertexNormal.b.clone();
										destVertexNormal.c = srcVertexNormal.c.clone();

										morphNormal.vertexNormals.push(destVertexNormal);
								}
						}

						if (morphNormals[i].faceNormals !== undefined) {

								morphNormal.faceNormals = [];

								for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {

										morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
								}
						}

						this.morphNormals.push(morphNormal);
				}

				var skinWeights = source.skinWeights;

				for (i = 0, il = skinWeights.length; i < il; i++) {

						this.skinWeights.push(skinWeights[i].clone());
				}

				var skinIndices = source.skinIndices;

				for (i = 0, il = skinIndices.length; i < il; i++) {

						this.skinIndices.push(skinIndices[i].clone());
				}

				var lineDistances = source.lineDistances;

				for (i = 0, il = lineDistances.length; i < il; i++) {

						this.lineDistances.push(lineDistances[i]);
				}

				var boundingBox = source.boundingBox;

				if (boundingBox !== null) {

						this.boundingBox = boundingBox.clone();
				}

				var boundingSphere = source.boundingSphere;

				if (boundingSphere !== null) {

						this.boundingSphere = boundingSphere.clone();
				}

				this.elementsNeedUpdate = source.elementsNeedUpdate;
				this.verticesNeedUpdate = source.verticesNeedUpdate;
				this.uvsNeedUpdate = source.uvsNeedUpdate;
				this.normalsNeedUpdate = source.normalsNeedUpdate;
				this.colorsNeedUpdate = source.colorsNeedUpdate;
				this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
				this.groupsNeedUpdate = source.groupsNeedUpdate;

				return this;
		},

		dispose: function dispose() {

				this.dispatchEvent({ type: 'dispose' });
		}

});



/***/ }),
/* 45 */
/***/ (function(module, exports) {


var flatbuffers = {};

flatbuffers.Offset;

flatbuffers.Table;

flatbuffers.SIZEOF_SHORT = 2;

flatbuffers.SIZEOF_INT = 4;

flatbuffers.FILE_IDENTIFIER_LENGTH = 4;

flatbuffers.Encoding = {
  UTF8_BYTES: 1,
  UTF16_STRING: 2
};

flatbuffers.int32 = new Int32Array(2);

flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);

flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);

flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

flatbuffers.Long = function (low, high) {
  this.low = low | 0;

  this.high = high | 0;
};

flatbuffers.Long.create = function (low, high) {
  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
};

flatbuffers.Long.prototype.toFloat64 = function () {
  return (this.low >>> 0) + this.high * 0x100000000;
};

flatbuffers.Long.prototype.equals = function (other) {
  return this.low == other.low && this.high == other.high;
};

flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);

flatbuffers.Builder = function (opt_initial_size) {
  if (!opt_initial_size) {
    var initial_size = 1024;
  } else {
    var initial_size = opt_initial_size;
  }

  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);

  this.space = initial_size;

  this.minalign = 1;

  this.vtable = null;

  this.vtable_in_use = 0;

  this.isNested = false;

  this.object_start = 0;

  this.vtables = [];

  this.vector_num_elems = 0;

  this.force_defaults = false;
};

flatbuffers.Builder.prototype.forceDefaults = function (forceDefaults) {
  this.force_defaults = forceDefaults;
};

flatbuffers.Builder.prototype.dataBuffer = function () {
  return this.bb;
};

flatbuffers.Builder.prototype.asUint8Array = function () {
  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
};

flatbuffers.Builder.prototype.prep = function (size, additional_bytes) {
  if (size > this.minalign) {
    this.minalign = size;
  }

  var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;

  while (this.space < align_size + size + additional_bytes) {
    var old_buf_size = this.bb.capacity();
    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
    this.space += this.bb.capacity() - old_buf_size;
  }

  this.pad(align_size);
};

flatbuffers.Builder.prototype.pad = function (byte_size) {
  for (var i = 0; i < byte_size; i++) {
    this.bb.writeInt8(--this.space, 0);
  }
};

flatbuffers.Builder.prototype.writeInt8 = function (value) {
  this.bb.writeInt8(this.space -= 1, value);
};

flatbuffers.Builder.prototype.writeInt16 = function (value) {
  this.bb.writeInt16(this.space -= 2, value);
};

flatbuffers.Builder.prototype.writeInt32 = function (value) {
  this.bb.writeInt32(this.space -= 4, value);
};

flatbuffers.Builder.prototype.writeInt64 = function (value) {
  this.bb.writeInt64(this.space -= 8, value);
};

flatbuffers.Builder.prototype.writeFloat32 = function (value) {
  this.bb.writeFloat32(this.space -= 4, value);
};

flatbuffers.Builder.prototype.writeFloat64 = function (value) {
  this.bb.writeFloat64(this.space -= 8, value);
};

flatbuffers.Builder.prototype.addInt8 = function (value) {
  this.prep(1, 0);
  this.writeInt8(value);
};

flatbuffers.Builder.prototype.addInt16 = function (value) {
  this.prep(2, 0);
  this.writeInt16(value);
};

flatbuffers.Builder.prototype.addInt32 = function (value) {
  this.prep(4, 0);
  this.writeInt32(value);
};

flatbuffers.Builder.prototype.addInt64 = function (value) {
  this.prep(8, 0);
  this.writeInt64(value);
};

flatbuffers.Builder.prototype.addFloat32 = function (value) {
  this.prep(4, 0);
  this.writeFloat32(value);
};

flatbuffers.Builder.prototype.addFloat64 = function (value) {
  this.prep(8, 0);
  this.writeFloat64(value);
};

flatbuffers.Builder.prototype.addFieldInt8 = function (voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt8(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldInt16 = function (voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt16(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldInt32 = function (voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt32(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldInt64 = function (voffset, value, defaultValue) {
  if (this.force_defaults || !value.equals(defaultValue)) {
    this.addInt64(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldFloat32 = function (voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addFloat32(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldFloat64 = function (voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addFloat64(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldOffset = function (voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addOffset(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.addFieldStruct = function (voffset, value, defaultValue) {
  if (value != defaultValue) {
    this.nested(value);
    this.slot(voffset);
  }
};

flatbuffers.Builder.prototype.nested = function (obj) {
  if (obj != this.offset()) {
    throw new Error('FlatBuffers: struct must be serialized inline.');
  }
};

flatbuffers.Builder.prototype.notNested = function () {
  if (this.isNested) {
    throw new Error('FlatBuffers: object serialization must not be nested.');
  }
};

flatbuffers.Builder.prototype.slot = function (voffset) {
  this.vtable[voffset] = this.offset();
};

flatbuffers.Builder.prototype.offset = function () {
  return this.bb.capacity() - this.space;
};

flatbuffers.Builder.growByteBuffer = function (bb) {
  var old_buf_size = bb.capacity();

  if (old_buf_size & 0xC0000000) {
    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
  }

  var new_buf_size = old_buf_size << 1;
  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
  nbb.setPosition(new_buf_size - old_buf_size);
  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
  return nbb;
};

flatbuffers.Builder.prototype.addOffset = function (offset) {
  this.prep(flatbuffers.SIZEOF_INT, 0);
  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
};

flatbuffers.Builder.prototype.startObject = function (numfields) {
  this.notNested();
  if (this.vtable == null) {
    this.vtable = [];
  }
  this.vtable_in_use = numfields;
  for (var i = 0; i < numfields; i++) {
    this.vtable[i] = 0;
  }
  this.isNested = true;
  this.object_start = this.offset();
};

flatbuffers.Builder.prototype.endObject = function () {
  if (this.vtable == null || !this.isNested) {
    throw new Error('FlatBuffers: endObject called without startObject');
  }

  this.addInt32(0);
  var vtableloc = this.offset();

  var i = this.vtable_in_use - 1;
  for (; i >= 0 && this.vtable[i] == 0; i--) {}
  var trimmed_size = i + 1;

  for (; i >= 0; i--) {
    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
  }

  var standard_fields = 2;
  this.addInt16(vtableloc - this.object_start);
  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
  this.addInt16(len);

  var existing_vtable = 0;
  var vt1 = this.space;
  outer_loop: for (i = 0; i < this.vtables.length; i++) {
    var vt2 = this.bb.capacity() - this.vtables[i];
    if (len == this.bb.readInt16(vt2)) {
      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
          continue outer_loop;
        }
      }
      existing_vtable = this.vtables[i];
      break;
    }
  }

  if (existing_vtable) {
    this.space = this.bb.capacity() - vtableloc;

    this.bb.writeInt32(this.space, existing_vtable - vtableloc);
  } else {
    this.vtables.push(this.offset());

    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
  }

  this.isNested = false;
  return vtableloc;
};

flatbuffers.Builder.prototype.finish = function (root_table, opt_file_identifier) {
  if (opt_file_identifier) {
    var file_identifier = opt_file_identifier;
    this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH);
    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: file identifier must be length ' + flatbuffers.FILE_IDENTIFIER_LENGTH);
    }
    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
      this.writeInt8(file_identifier.charCodeAt(i));
    }
  }
  this.prep(this.minalign, flatbuffers.SIZEOF_INT);
  this.addOffset(root_table);
  this.bb.setPosition(this.space);
};

flatbuffers.Builder.prototype.requiredField = function (table, field) {
  var table_start = this.bb.capacity() - table;
  var vtable_start = table_start - this.bb.readInt32(table_start);
  var ok = this.bb.readInt16(vtable_start + field) != 0;

  if (!ok) {
    throw new Error('FlatBuffers: field ' + field + ' must be set');
  }
};

flatbuffers.Builder.prototype.startVector = function (elem_size, num_elems, alignment) {
  this.notNested();
  this.vector_num_elems = num_elems;
  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
  this.prep(alignment, elem_size * num_elems);
};

flatbuffers.Builder.prototype.endVector = function () {
  this.writeInt32(this.vector_num_elems);
  return this.offset();
};

flatbuffers.Builder.prototype.createString = function (s) {
  if (s instanceof Uint8Array) {
    var utf8 = s;
  } else {
    var utf8 = [];
    var i = 0;

    while (i < s.length) {
      var codePoint;

      var a = s.charCodeAt(i++);
      if (a < 0xD800 || a >= 0xDC00) {
        codePoint = a;
      } else {
        var b = s.charCodeAt(i++);
        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
      }

      if (codePoint < 0x80) {
        utf8.push(codePoint);
      } else {
        if (codePoint < 0x800) {
          utf8.push(codePoint >> 6 & 0x1F | 0xC0);
        } else {
          if (codePoint < 0x10000) {
            utf8.push(codePoint >> 12 & 0x0F | 0xE0);
          } else {
            utf8.push(codePoint >> 18 & 0x07 | 0xF0, codePoint >> 12 & 0x3F | 0x80);
          }
          utf8.push(codePoint >> 6 & 0x3F | 0x80);
        }
        utf8.push(codePoint & 0x3F | 0x80);
      }
    }
  }

  this.addInt8(0);
  this.startVector(1, utf8.length, 1);
  this.bb.setPosition(this.space -= utf8.length);
  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
    bytes[offset++] = utf8[i];
  }
  return this.endVector();
};

flatbuffers.Builder.prototype.createLong = function (low, high) {
  return flatbuffers.Long.create(low, high);
};

flatbuffers.ByteBuffer = function (bytes) {
  this.bytes_ = bytes;

  this.position_ = 0;
};

flatbuffers.ByteBuffer.allocate = function (byte_size) {
  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
};

flatbuffers.ByteBuffer.prototype.bytes = function () {
  return this.bytes_;
};

flatbuffers.ByteBuffer.prototype.position = function () {
  return this.position_;
};

flatbuffers.ByteBuffer.prototype.setPosition = function (position) {
  this.position_ = position;
};

flatbuffers.ByteBuffer.prototype.capacity = function () {
  return this.bytes_.length;
};

flatbuffers.ByteBuffer.prototype.readInt8 = function (offset) {
  return this.readUint8(offset) << 24 >> 24;
};

flatbuffers.ByteBuffer.prototype.readUint8 = function (offset) {
  return this.bytes_[offset];
};

flatbuffers.ByteBuffer.prototype.readInt16 = function (offset) {
  return this.readUint16(offset) << 16 >> 16;
};

flatbuffers.ByteBuffer.prototype.readUint16 = function (offset) {
  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
};

flatbuffers.ByteBuffer.prototype.readInt32 = function (offset) {
  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
};

flatbuffers.ByteBuffer.prototype.readUint32 = function (offset) {
  return this.readInt32(offset) >>> 0;
};

flatbuffers.ByteBuffer.prototype.readInt64 = function (offset) {
  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
};

flatbuffers.ByteBuffer.prototype.readUint64 = function (offset) {
  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
};

flatbuffers.ByteBuffer.prototype.readFloat32 = function (offset) {
  flatbuffers.int32[0] = this.readInt32(offset);
  return flatbuffers.float32[0];
};

flatbuffers.ByteBuffer.prototype.readFloat64 = function (offset) {
  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
  return flatbuffers.float64[0];
};

flatbuffers.ByteBuffer.prototype.writeInt8 = function (offset, value) {
  this.bytes_[offset] = value;
};

flatbuffers.ByteBuffer.prototype.writeUint8 = function (offset, value) {
  this.bytes_[offset] = value;
};

flatbuffers.ByteBuffer.prototype.writeInt16 = function (offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
};

flatbuffers.ByteBuffer.prototype.writeUint16 = function (offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
};

flatbuffers.ByteBuffer.prototype.writeInt32 = function (offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
  this.bytes_[offset + 2] = value >> 16;
  this.bytes_[offset + 3] = value >> 24;
};

flatbuffers.ByteBuffer.prototype.writeUint32 = function (offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
  this.bytes_[offset + 2] = value >> 16;
  this.bytes_[offset + 3] = value >> 24;
};

flatbuffers.ByteBuffer.prototype.writeInt64 = function (offset, value) {
  this.writeInt32(offset, value.low);
  this.writeInt32(offset + 4, value.high);
};

flatbuffers.ByteBuffer.prototype.writeUint64 = function (offset, value) {
  this.writeUint32(offset, value.low);
  this.writeUint32(offset + 4, value.high);
};

flatbuffers.ByteBuffer.prototype.writeFloat32 = function (offset, value) {
  flatbuffers.float32[0] = value;
  this.writeInt32(offset, flatbuffers.int32[0]);
};

flatbuffers.ByteBuffer.prototype.writeFloat64 = function (offset, value) {
  flatbuffers.float64[0] = value;
  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
};

flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function () {
  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
    throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
  }
  var result = "";
  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
    result += String.fromCharCode(this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));
  }
  return result;
};

flatbuffers.ByteBuffer.prototype.__offset = function (bb_pos, vtable_offset) {
  var vtable = bb_pos - this.readInt32(bb_pos);
  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
};

flatbuffers.ByteBuffer.prototype.__union = function (t, offset) {
  t.bb_pos = offset + this.readInt32(offset);
  t.bb = this;
  return t;
};

flatbuffers.ByteBuffer.prototype.__string = function (offset, opt_encoding) {
  offset += this.readInt32(offset);

  var length = this.readInt32(offset);
  var result = '';
  var i = 0;

  offset += flatbuffers.SIZEOF_INT;

  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
    return this.bytes_.subarray(offset, offset + length);
  }

  while (i < length) {
    var codePoint;

    var a = this.readUint8(offset + i++);
    if (a < 0xC0) {
      codePoint = a;
    } else {
      var b = this.readUint8(offset + i++);
      if (a < 0xE0) {
        codePoint = (a & 0x1F) << 6 | b & 0x3F;
      } else {
        var c = this.readUint8(offset + i++);
        if (a < 0xF0) {
          codePoint = (a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F;
        } else {
          var d = this.readUint8(offset + i++);
          codePoint = (a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F;
        }
      }
    }

    if (codePoint < 0x10000) {
      result += String.fromCharCode(codePoint);
    } else {
      codePoint -= 0x10000;
      result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & (1 << 10) - 1) + 0xDC00);
    }
  }

  return result;
};

flatbuffers.ByteBuffer.prototype.__indirect = function (offset) {
  return offset + this.readInt32(offset);
};

flatbuffers.ByteBuffer.prototype.__vector = function (offset) {
  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
};

flatbuffers.ByteBuffer.prototype.__vector_len = function (offset) {
  return this.readInt32(offset + this.readInt32(offset));
};

flatbuffers.ByteBuffer.prototype.__has_identifier = function (ident) {
  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
    throw new Error('FlatBuffers: file identifier must be length ' + flatbuffers.FILE_IDENTIFIER_LENGTH);
  }
  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
      return false;
    }
  }
  return true;
};

flatbuffers.ByteBuffer.prototype.createLong = function (low, high) {
  return flatbuffers.Long.create(low, high);
};

this.flatbuffers = flatbuffers;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(539), __esModule: true };

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(565)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(116)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(572);
var global = __webpack_require__(10);
var hide = __webpack_require__(42);
var Iterators = __webpack_require__(57);
var TO_STRING_TAG = __webpack_require__(13)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Field;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(61);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = __webpack_require__(27),
    types = __webpack_require__(62),
    util  = __webpack_require__(11);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__renderers_shaders_UniformsUtils_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__renderers_shaders_ShaderChunk_default_vertex_glsl_js__ = __webpack_require__(319);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__renderers_shaders_ShaderChunk_default_fragment_glsl_js__ = __webpack_require__(318);











function ShaderMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_3__Material_js__["a" /* Material */].call(this);

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = __WEBPACK_IMPORTED_MODULE_5__renderers_shaders_ShaderChunk_default_vertex_glsl_js__["a" /* default */];
	this.fragmentShader = __WEBPACK_IMPORTED_MODULE_6__renderers_shaders_ShaderChunk_default_fragment_glsl_js__["a" /* default */];

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;
	this.clipping = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.extensions = {
		derivatives: false,
		fragDepth: false,
		drawBuffers: false,
		shaderTextureLOD: false };

	this.defaultAttributeValues = {
		'color': [1, 1, 1],
		'uv': [0, 0],
		'uv2': [0, 0]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	if (parameters !== undefined) {

		if (parameters.attributes !== undefined) {

			console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
		}

		this.setValues(parameters);
	}
}

ShaderMaterial.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_3__Material_js__["a" /* Material */].prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_3__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__renderers_shaders_UniformsUtils_js__["b" /* cloneUniforms */])(source.uniforms);

	this.defines = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, source.defines);

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;
};

ShaderMaterial.prototype.toJSON = function (meta) {

	var data = __WEBPACK_IMPORTED_MODULE_3__Material_js__["a" /* Material */].prototype.toJSON.call(this, meta);

	data.uniforms = {};

	for (var name in this.uniforms) {

		var uniform = this.uniforms[name];
		var value = uniform.value;

		if (value && value.isTexture) {

			data.uniforms[name] = {
				type: 't',
				value: value.toJSON(meta).uuid
			};
		} else if (value && value.isColor) {

			data.uniforms[name] = {
				type: 'c',
				value: value.getHex()
			};
		} else if (value && value.isVector2) {

			data.uniforms[name] = {
				type: 'v2',
				value: value.toArray()
			};
		} else if (value && value.isVector3) {

			data.uniforms[name] = {
				type: 'v3',
				value: value.toArray()
			};
		} else if (value && value.isVector4) {

			data.uniforms[name] = {
				type: 'v4',
				value: value.toArray()
			};
		} else if (value && value.isMatrix3) {

			data.uniforms[name] = {
				type: 'm3',
				value: value.toArray()
			};
		} else if (value && value.isMatrix4) {

			data.uniforms[name] = {
				type: 'm4',
				value: value.toArray()
			};
		} else {

			data.uniforms[name] = {
				value: value
			};
		}
	}

	if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(this.defines).length > 0) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	var extensions = {};

	for (var key in this.extensions) {

		if (this.extensions[key] === true) extensions[key] = true;
	}

	if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(extensions).length > 0) data.extensions = extensions;

	return data;
};



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Box3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(2);



function Box3(min, max) {

		this.min = min !== undefined ? min : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](+Infinity, +Infinity, +Infinity);
		this.max = max !== undefined ? max : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](-Infinity, -Infinity, -Infinity);
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Box3.prototype, {

		isBox3: true,

		set: function set(min, max) {

				this.min.copy(min);
				this.max.copy(max);

				return this;
		},

		setFromArray: function setFromArray(array) {

				var minX = +Infinity;
				var minY = +Infinity;
				var minZ = +Infinity;

				var maxX = -Infinity;
				var maxY = -Infinity;
				var maxZ = -Infinity;

				for (var i = 0, l = array.length; i < l; i += 3) {

						var x = array[i];
						var y = array[i + 1];
						var z = array[i + 2];

						if (x < minX) minX = x;
						if (y < minY) minY = y;
						if (z < minZ) minZ = z;

						if (x > maxX) maxX = x;
						if (y > maxY) maxY = y;
						if (z > maxZ) maxZ = z;
				}

				this.min.set(minX, minY, minZ);
				this.max.set(maxX, maxY, maxZ);

				return this;
		},

		setFromBufferAttribute: function setFromBufferAttribute(attribute) {

				var minX = +Infinity;
				var minY = +Infinity;
				var minZ = +Infinity;

				var maxX = -Infinity;
				var maxY = -Infinity;
				var maxZ = -Infinity;

				for (var i = 0, l = attribute.count; i < l; i++) {

						var x = attribute.getX(i);
						var y = attribute.getY(i);
						var z = attribute.getZ(i);

						if (x < minX) minX = x;
						if (y < minY) minY = y;
						if (z < minZ) minZ = z;

						if (x > maxX) maxX = x;
						if (y > maxY) maxY = y;
						if (z > maxZ) maxZ = z;
				}

				this.min.set(minX, minY, minZ);
				this.max.set(maxX, maxY, maxZ);

				return this;
		},

		setFromPoints: function setFromPoints(points) {

				this.makeEmpty();

				for (var i = 0, il = points.length; i < il; i++) {

						this.expandByPoint(points[i]);
				}

				return this;
		},

		setFromCenterAndSize: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function setFromCenterAndSize(center, size) {

						var halfSize = v1.copy(size).multiplyScalar(0.5);

						this.min.copy(center).sub(halfSize);
						this.max.copy(center).add(halfSize);

						return this;
				};
		}(),

		setFromObject: function setFromObject(object) {

				this.makeEmpty();

				return this.expandByObject(object);
		},

		clone: function clone() {

				return new this.constructor().copy(this);
		},

		copy: function copy(box) {

				this.min.copy(box.min);
				this.max.copy(box.max);

				return this;
		},

		makeEmpty: function makeEmpty() {

				this.min.x = this.min.y = this.min.z = +Infinity;
				this.max.x = this.max.y = this.max.z = -Infinity;

				return this;
		},

		isEmpty: function isEmpty() {

				return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		},

		getCenter: function getCenter(target) {

				if (target === undefined) {

						console.warn('THREE.Box3: .getCenter() target is now required');
						target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				}

				return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		},

		getSize: function getSize(target) {

				if (target === undefined) {

						console.warn('THREE.Box3: .getSize() target is now required');
						target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				}

				return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		},

		expandByPoint: function expandByPoint(point) {

				this.min.min(point);
				this.max.max(point);

				return this;
		},

		expandByVector: function expandByVector(vector) {

				this.min.sub(vector);
				this.max.add(vector);

				return this;
		},

		expandByScalar: function expandByScalar(scalar) {

				this.min.addScalar(-scalar);
				this.max.addScalar(scalar);

				return this;
		},

		expandByObject: function () {

				var scope, i, l;

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				function traverse(node) {

						var geometry = node.geometry;

						if (geometry !== undefined) {

								if (geometry.isGeometry) {

										var vertices = geometry.vertices;

										for (i = 0, l = vertices.length; i < l; i++) {

												v1.copy(vertices[i]);
												v1.applyMatrix4(node.matrixWorld);

												scope.expandByPoint(v1);
										}
								} else if (geometry.isBufferGeometry) {

										var attribute = geometry.attributes.position;

										if (attribute !== undefined) {

												for (i = 0, l = attribute.count; i < l; i++) {

														v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);

														scope.expandByPoint(v1);
												}
										}
								}
						}
				}

				return function expandByObject(object) {

						scope = this;

						object.updateMatrixWorld(true);

						object.traverse(traverse);

						return this;
				};
		}(),

		containsPoint: function containsPoint(point) {

				return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		},

		containsBox: function containsBox(box) {

				return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		},

		getParameter: function getParameter(point, target) {

				if (target === undefined) {

						console.warn('THREE.Box3: .getParameter() target is now required');
						target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				}

				return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		},

		intersectsBox: function intersectsBox(box) {
				return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		},

		intersectsSphere: function () {

				var closestPoint = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function intersectsSphere(sphere) {
						this.clampPoint(sphere.center, closestPoint);

						return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
				};
		}(),

		intersectsPlane: function intersectsPlane(plane) {

				var min, max;

				if (plane.normal.x > 0) {

						min = plane.normal.x * this.min.x;
						max = plane.normal.x * this.max.x;
				} else {

						min = plane.normal.x * this.max.x;
						max = plane.normal.x * this.min.x;
				}

				if (plane.normal.y > 0) {

						min += plane.normal.y * this.min.y;
						max += plane.normal.y * this.max.y;
				} else {

						min += plane.normal.y * this.max.y;
						max += plane.normal.y * this.min.y;
				}

				if (plane.normal.z > 0) {

						min += plane.normal.z * this.min.z;
						max += plane.normal.z * this.max.z;
				} else {

						min += plane.normal.z * this.max.z;
						max += plane.normal.z * this.min.z;
				}

				return min <= -plane.constant && max >= -plane.constant;
		},

		intersectsTriangle: function () {
				var v0 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var v2 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				var f0 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var f1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var f2 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				var testAxis = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				var center = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var extents = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				var triangleNormal = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				function satForAxes(axes) {

						var i, j;

						for (i = 0, j = axes.length - 3; i <= j; i += 3) {

								testAxis.fromArray(axes, i);

								var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);

								var p0 = v0.dot(testAxis);
								var p1 = v1.dot(testAxis);
								var p2 = v2.dot(testAxis);

								if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
										return false;
								}
						}

						return true;
				}

				return function intersectsTriangle(triangle) {

						if (this.isEmpty()) {

								return false;
						}

						this.getCenter(center);
						extents.subVectors(this.max, center);

						v0.subVectors(triangle.a, center);
						v1.subVectors(triangle.b, center);
						v2.subVectors(triangle.c, center);

						f0.subVectors(v1, v0);
						f1.subVectors(v2, v1);
						f2.subVectors(v0, v2);

						var axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];
						if (!satForAxes(axes)) {

								return false;
						}

						axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
						if (!satForAxes(axes)) {

								return false;
						}

						triangleNormal.crossVectors(f0, f1);
						axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
						return satForAxes(axes);
				};
		}(),

		clampPoint: function clampPoint(point, target) {

				if (target === undefined) {

						console.warn('THREE.Box3: .clampPoint() target is now required');
						target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				}

				return target.copy(point).clamp(this.min, this.max);
		},

		distanceToPoint: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function distanceToPoint(point) {

						var clampedPoint = v1.copy(point).clamp(this.min, this.max);
						return clampedPoint.sub(point).length();
				};
		}(),

		getBoundingSphere: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function getBoundingSphere(target) {

						if (target === undefined) {

								console.error('THREE.Box3: .getBoundingSphere() target is now required');
						}

						this.getCenter(target.center);

						target.radius = this.getSize(v1).length() * 0.5;

						return target;
				};
		}(),

		intersect: function intersect(box) {

				this.min.max(box.min);
				this.max.min(box.max);

				if (this.isEmpty()) this.makeEmpty();

				return this;
		},

		union: function union(box) {

				this.min.min(box.min);
				this.max.max(box.max);

				return this;
		},

		applyMatrix4: function () {

				var points = [new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */](), new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]()];

				return function applyMatrix4(matrix) {
						if (this.isEmpty()) return this;

						points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
						points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
						points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
						points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
						points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
						points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
						points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
						points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);

						this.setFromPoints(points);

						return this;
				};
		}(),

		translate: function translate(offset) {

				this.min.add(offset);
				this.max.add(offset);

				return this;
		},

		equals: function equals(box) {

				return box.min.equals(this.min) && box.max.equals(this.max);
		}

});



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Quaternion; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Math_js__ = __webpack_require__(8);







function Quaternion(x, y, z, w) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = w !== undefined ? w : 1;
}

__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(Quaternion, {

		slerp: function slerp(qa, qb, qm, t) {

				return qm.copy(qa).slerp(qb, t);
		},

		slerpFlat: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

				var x0 = src0[srcOffset0 + 0],
				    y0 = src0[srcOffset0 + 1],
				    z0 = src0[srcOffset0 + 2],
				    w0 = src0[srcOffset0 + 3],
				    x1 = src1[srcOffset1 + 0],
				    y1 = src1[srcOffset1 + 1],
				    z1 = src1[srcOffset1 + 2],
				    w1 = src1[srcOffset1 + 3];

				if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

						var s = 1 - t,
						    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
						    dir = cos >= 0 ? 1 : -1,
						    sqrSin = 1 - cos * cos;

						if (sqrSin > __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

								var sin = Math.sqrt(sqrSin),
								    len = Math.atan2(sin, cos * dir);

								s = Math.sin(s * len) / sin;
								t = Math.sin(t * len) / sin;
						}

						var tDir = t * dir;

						x0 = x0 * s + x1 * tDir;
						y0 = y0 * s + y1 * tDir;
						z0 = z0 * s + z1 * tDir;
						w0 = w0 * s + w1 * tDir;

						if (s === 1 - t) {

								var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

								x0 *= f;
								y0 *= f;
								z0 *= f;
								w0 *= f;
						}
				}

				dst[dstOffset] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
		}

});

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default()(Quaternion.prototype, {

		x: {

				get: function get() {

						return this._x;
				},

				set: function set(value) {

						this._x = value;
						this._onChangeCallback();
				}

		},

		y: {

				get: function get() {

						return this._y;
				},

				set: function set(value) {

						this._y = value;
						this._onChangeCallback();
				}

		},

		z: {

				get: function get() {

						return this._z;
				},

				set: function set(value) {

						this._z = value;
						this._onChangeCallback();
				}

		},

		w: {

				get: function get() {

						return this._w;
				},

				set: function set(value) {

						this._w = value;
						this._onChangeCallback();
				}

		}

});

__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(Quaternion.prototype, {

		isQuaternion: true,

		set: function set(x, y, z, w) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;

				this._onChangeCallback();

				return this;
		},

		clone: function clone() {

				return new this.constructor(this._x, this._y, this._z, this._w);
		},

		copy: function copy(quaternion) {

				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;

				this._onChangeCallback();

				return this;
		},

		setFromEuler: function setFromEuler(euler, update) {

				if (!(euler && euler.isEuler)) {

						throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
				}

				var x = euler._x,
				    y = euler._y,
				    z = euler._z,
				    order = euler.order;

				var cos = Math.cos;
				var sin = Math.sin;

				var c1 = cos(x / 2);
				var c2 = cos(y / 2);
				var c3 = cos(z / 2);

				var s1 = sin(x / 2);
				var s2 = sin(y / 2);
				var s3 = sin(z / 2);

				if (order === 'XYZ') {

						this._x = s1 * c2 * c3 + c1 * s2 * s3;
						this._y = c1 * s2 * c3 - s1 * c2 * s3;
						this._z = c1 * c2 * s3 + s1 * s2 * c3;
						this._w = c1 * c2 * c3 - s1 * s2 * s3;
				} else if (order === 'YXZ') {

						this._x = s1 * c2 * c3 + c1 * s2 * s3;
						this._y = c1 * s2 * c3 - s1 * c2 * s3;
						this._z = c1 * c2 * s3 - s1 * s2 * c3;
						this._w = c1 * c2 * c3 + s1 * s2 * s3;
				} else if (order === 'ZXY') {

						this._x = s1 * c2 * c3 - c1 * s2 * s3;
						this._y = c1 * s2 * c3 + s1 * c2 * s3;
						this._z = c1 * c2 * s3 + s1 * s2 * c3;
						this._w = c1 * c2 * c3 - s1 * s2 * s3;
				} else if (order === 'ZYX') {

						this._x = s1 * c2 * c3 - c1 * s2 * s3;
						this._y = c1 * s2 * c3 + s1 * c2 * s3;
						this._z = c1 * c2 * s3 - s1 * s2 * c3;
						this._w = c1 * c2 * c3 + s1 * s2 * s3;
				} else if (order === 'YZX') {

						this._x = s1 * c2 * c3 + c1 * s2 * s3;
						this._y = c1 * s2 * c3 + s1 * c2 * s3;
						this._z = c1 * c2 * s3 - s1 * s2 * c3;
						this._w = c1 * c2 * c3 - s1 * s2 * s3;
				} else if (order === 'XZY') {

						this._x = s1 * c2 * c3 - c1 * s2 * s3;
						this._y = c1 * s2 * c3 - s1 * c2 * s3;
						this._z = c1 * c2 * s3 + s1 * s2 * c3;
						this._w = c1 * c2 * c3 + s1 * s2 * s3;
				}

				if (update !== false) this._onChangeCallback();

				return this;
		},

		setFromAxisAngle: function setFromAxisAngle(axis, angle) {

				var halfAngle = angle / 2,
				    s = Math.sin(halfAngle);

				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos(halfAngle);

				this._onChangeCallback();

				return this;
		},

		setFromRotationMatrix: function setFromRotationMatrix(m) {

				var te = m.elements,
				    m11 = te[0],
				    m12 = te[4],
				    m13 = te[8],
				    m21 = te[1],
				    m22 = te[5],
				    m23 = te[9],
				    m31 = te[2],
				    m32 = te[6],
				    m33 = te[10],
				    trace = m11 + m22 + m33,
				    s;

				if (trace > 0) {

						s = 0.5 / Math.sqrt(trace + 1.0);

						this._w = 0.25 / s;
						this._x = (m32 - m23) * s;
						this._y = (m13 - m31) * s;
						this._z = (m21 - m12) * s;
				} else if (m11 > m22 && m11 > m33) {

						s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

						this._w = (m32 - m23) / s;
						this._x = 0.25 * s;
						this._y = (m12 + m21) / s;
						this._z = (m13 + m31) / s;
				} else if (m22 > m33) {

						s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

						this._w = (m13 - m31) / s;
						this._x = (m12 + m21) / s;
						this._y = 0.25 * s;
						this._z = (m23 + m32) / s;
				} else {

						s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

						this._w = (m21 - m12) / s;
						this._x = (m13 + m31) / s;
						this._y = (m23 + m32) / s;
						this._z = 0.25 * s;
				}

				this._onChangeCallback();

				return this;
		},

		setFromUnitVectors: function setFromUnitVectors(vFrom, vTo) {

				var EPS = 0.000001;

				var r = vFrom.dot(vTo) + 1;

				if (r < EPS) {

						r = 0;

						if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

								this._x = -vFrom.y;
								this._y = vFrom.x;
								this._z = 0;
								this._w = r;
						} else {

								this._x = 0;
								this._y = -vFrom.z;
								this._z = vFrom.y;
								this._w = r;
						}
				} else {

						this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
						this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
						this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
						this._w = r;
				}

				return this.normalize();
		},

		angleTo: function angleTo(q) {

				return 2 * Math.acos(Math.abs(__WEBPACK_IMPORTED_MODULE_3__Math_js__["a" /* _Math */].clamp(this.dot(q), -1, 1)));
		},

		rotateTowards: function rotateTowards(q, step) {

				var angle = this.angleTo(q);

				if (angle === 0) return this;

				var t = Math.min(1, step / angle);

				this.slerp(q, t);

				return this;
		},

		inverse: function inverse() {

				return this.conjugate();
		},

		conjugate: function conjugate() {

				this._x *= -1;
				this._y *= -1;
				this._z *= -1;

				this._onChangeCallback();

				return this;
		},

		dot: function dot(v) {

				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		},

		lengthSq: function lengthSq() {

				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		},

		length: function length() {

				return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		},

		normalize: function normalize() {

				var l = this.length();

				if (l === 0) {

						this._x = 0;
						this._y = 0;
						this._z = 0;
						this._w = 1;
				} else {

						l = 1 / l;

						this._x = this._x * l;
						this._y = this._y * l;
						this._z = this._z * l;
						this._w = this._w * l;
				}

				this._onChangeCallback();

				return this;
		},

		multiply: function multiply(q, p) {

				if (p !== undefined) {

						console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
						return this.multiplyQuaternions(q, p);
				}

				return this.multiplyQuaternions(this, q);
		},

		premultiply: function premultiply(q) {

				return this.multiplyQuaternions(q, this);
		},

		multiplyQuaternions: function multiplyQuaternions(a, b) {

				var qax = a._x,
				    qay = a._y,
				    qaz = a._z,
				    qaw = a._w;
				var qbx = b._x,
				    qby = b._y,
				    qbz = b._z,
				    qbw = b._w;

				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

				this._onChangeCallback();

				return this;
		},

		slerp: function slerp(qb, t) {

				if (t === 0) return this;
				if (t === 1) return this.copy(qb);

				var x = this._x,
				    y = this._y,
				    z = this._z,
				    w = this._w;

				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

				if (cosHalfTheta < 0) {

						this._w = -qb._w;
						this._x = -qb._x;
						this._y = -qb._y;
						this._z = -qb._z;

						cosHalfTheta = -cosHalfTheta;
				} else {

						this.copy(qb);
				}

				if (cosHalfTheta >= 1.0) {

						this._w = w;
						this._x = x;
						this._y = y;
						this._z = z;

						return this;
				}

				var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

				if (sqrSinHalfTheta <= __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

						var s = 1 - t;
						this._w = s * w + t * this._w;
						this._x = s * x + t * this._x;
						this._y = s * y + t * this._y;
						this._z = s * z + t * this._z;

						return this.normalize();
				}

				var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
				var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
				var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
				    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

				this._w = w * ratioA + this._w * ratioB;
				this._x = x * ratioA + this._x * ratioB;
				this._y = y * ratioA + this._y * ratioB;
				this._z = z * ratioA + this._z * ratioB;

				this._onChangeCallback();

				return this;
		},

		equals: function equals(quaternion) {

				return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		},

		fromArray: function fromArray(array, offset) {

				if (offset === undefined) offset = 0;

				this._x = array[offset];
				this._y = array[offset + 1];
				this._z = array[offset + 2];
				this._w = array[offset + 3];

				this._onChangeCallback();

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				array[offset] = this._x;
				array[offset + 1] = this._y;
				array[offset + 2] = this._z;
				array[offset + 3] = this._w;

				return array;
		},

		_onChange: function _onChange(callback) {

				this._onChangeCallback = callback;

				return this;
		},

		_onChangeCallback: function _onChangeCallback() {}

});



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Ray; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(2);



function Ray(origin, direction) {

		this.origin = origin !== undefined ? origin : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
		this.direction = direction !== undefined ? direction : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Ray.prototype, {

		set: function set(origin, direction) {

				this.origin.copy(origin);
				this.direction.copy(direction);

				return this;
		},

		clone: function clone() {

				return new this.constructor().copy(this);
		},

		copy: function copy(ray) {

				this.origin.copy(ray.origin);
				this.direction.copy(ray.direction);

				return this;
		},

		at: function at(t, target) {

				if (target === undefined) {

						console.warn('THREE.Ray: .at() target is now required');
						target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				}

				return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		},

		lookAt: function lookAt(v) {

				this.direction.copy(v).sub(this.origin).normalize();

				return this;
		},

		recast: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function recast(t) {

						this.origin.copy(this.at(t, v1));

						return this;
				};
		}(),

		closestPointToPoint: function closestPointToPoint(point, target) {

				if (target === undefined) {

						console.warn('THREE.Ray: .closestPointToPoint() target is now required');
						target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				}

				target.subVectors(point, this.origin);

				var directionDistance = target.dot(this.direction);

				if (directionDistance < 0) {

						return target.copy(this.origin);
				}

				return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		},

		distanceToPoint: function distanceToPoint(point) {

				return Math.sqrt(this.distanceSqToPoint(point));
		},

		distanceSqToPoint: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function distanceSqToPoint(point) {

						var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);

						if (directionDistance < 0) {

								return this.origin.distanceToSquared(point);
						}

						v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

						return v1.distanceToSquared(point);
				};
		}(),

		distanceSqToSegment: function () {

				var segCenter = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var segDir = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var diff = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {

						segCenter.copy(v0).add(v1).multiplyScalar(0.5);
						segDir.copy(v1).sub(v0).normalize();
						diff.copy(this.origin).sub(segCenter);

						var segExtent = v0.distanceTo(v1) * 0.5;
						var a01 = -this.direction.dot(segDir);
						var b0 = diff.dot(this.direction);
						var b1 = -diff.dot(segDir);
						var c = diff.lengthSq();
						var det = Math.abs(1 - a01 * a01);
						var s0, s1, sqrDist, extDet;

						if (det > 0) {

								s0 = a01 * b1 - b0;
								s1 = a01 * b0 - b1;
								extDet = segExtent * det;

								if (s0 >= 0) {

										if (s1 >= -extDet) {

												if (s1 <= extDet) {

														var invDet = 1 / det;
														s0 *= invDet;
														s1 *= invDet;
														sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
												} else {

														s1 = segExtent;
														s0 = Math.max(0, -(a01 * s1 + b0));
														sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
												}
										} else {

												s1 = -segExtent;
												s0 = Math.max(0, -(a01 * s1 + b0));
												sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
										}
								} else {

										if (s1 <= -extDet) {

												s0 = Math.max(0, -(-a01 * segExtent + b0));
												s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
												sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
										} else if (s1 <= extDet) {

												s0 = 0;
												s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
												sqrDist = s1 * (s1 + 2 * b1) + c;
										} else {

												s0 = Math.max(0, -(a01 * segExtent + b0));
												s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
												sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
										}
								}
						} else {

								s1 = a01 > 0 ? -segExtent : segExtent;
								s0 = Math.max(0, -(a01 * s1 + b0));
								sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}

						if (optionalPointOnRay) {

								optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
						}

						if (optionalPointOnSegment) {

								optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
						}

						return sqrDist;
				};
		}(),

		intersectSphere: function () {

				var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function intersectSphere(sphere, target) {

						v1.subVectors(sphere.center, this.origin);
						var tca = v1.dot(this.direction);
						var d2 = v1.dot(v1) - tca * tca;
						var radius2 = sphere.radius * sphere.radius;

						if (d2 > radius2) return null;

						var thc = Math.sqrt(radius2 - d2);

						var t0 = tca - thc;

						var t1 = tca + thc;

						if (t0 < 0 && t1 < 0) return null;

						if (t0 < 0) return this.at(t1, target);

						return this.at(t0, target);
				};
		}(),

		intersectsSphere: function intersectsSphere(sphere) {

				return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		},

		distanceToPlane: function distanceToPlane(plane) {

				var denominator = plane.normal.dot(this.direction);

				if (denominator === 0) {
						if (plane.distanceToPoint(this.origin) === 0) {

								return 0;
						}

						return null;
				}

				var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

				return t >= 0 ? t : null;
		},

		intersectPlane: function intersectPlane(plane, target) {

				var t = this.distanceToPlane(plane);

				if (t === null) {

						return null;
				}

				return this.at(t, target);
		},

		intersectsPlane: function intersectsPlane(plane) {

				var distToPoint = plane.distanceToPoint(this.origin);

				if (distToPoint === 0) {

						return true;
				}

				var denominator = plane.normal.dot(this.direction);

				if (denominator * distToPoint < 0) {

						return true;
				}

				return false;
		},

		intersectBox: function intersectBox(box, target) {

				var tmin, tmax, tymin, tymax, tzmin, tzmax;

				var invdirx = 1 / this.direction.x,
				    invdiry = 1 / this.direction.y,
				    invdirz = 1 / this.direction.z;

				var origin = this.origin;

				if (invdirx >= 0) {

						tmin = (box.min.x - origin.x) * invdirx;
						tmax = (box.max.x - origin.x) * invdirx;
				} else {

						tmin = (box.max.x - origin.x) * invdirx;
						tmax = (box.min.x - origin.x) * invdirx;
				}

				if (invdiry >= 0) {

						tymin = (box.min.y - origin.y) * invdiry;
						tymax = (box.max.y - origin.y) * invdiry;
				} else {

						tymin = (box.max.y - origin.y) * invdiry;
						tymax = (box.min.y - origin.y) * invdiry;
				}

				if (tmin > tymax || tymin > tmax) return null;

				if (tymin > tmin || tmin !== tmin) tmin = tymin;

				if (tymax < tmax || tmax !== tmax) tmax = tymax;

				if (invdirz >= 0) {

						tzmin = (box.min.z - origin.z) * invdirz;
						tzmax = (box.max.z - origin.z) * invdirz;
				} else {

						tzmin = (box.max.z - origin.z) * invdirz;
						tzmax = (box.min.z - origin.z) * invdirz;
				}

				if (tmin > tzmax || tzmin > tmax) return null;

				if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

				if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

				if (tmax < 0) return null;

				return this.at(tmin >= 0 ? tmin : tmax, target);
		},

		intersectsBox: function () {

				var v = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function intersectsBox(box) {

						return this.intersectBox(box, v) !== null;
				};
		}(),

		intersectTriangle: function () {
				var diff = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var edge1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var edge2 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
				var normal = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function intersectTriangle(a, b, c, backfaceCulling, target) {

						edge1.subVectors(b, a);
						edge2.subVectors(c, a);
						normal.crossVectors(edge1, edge2);

						var DdN = this.direction.dot(normal);
						var sign;

						if (DdN > 0) {

								if (backfaceCulling) return null;
								sign = 1;
						} else if (DdN < 0) {

								sign = -1;
								DdN = -DdN;
						} else {

								return null;
						}

						diff.subVectors(this.origin, a);
						var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));

						if (DdQxE2 < 0) {

								return null;
						}

						var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));

						if (DdE1xQ < 0) {

								return null;
						}

						if (DdQxE2 + DdE1xQ > DdN) {

								return null;
						}

						var QdN = -sign * diff.dot(normal);

						if (QdN < 0) {

								return null;
						}

						return this.at(QdN / DdN, target);
				};
		}(),

		applyMatrix4: function applyMatrix4(matrix4) {

				this.origin.applyMatrix4(matrix4);
				this.direction.transformDirection(matrix4);

				return this;
		},

		equals: function equals(ray) {

				return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		}

});



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Pass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EffectComposer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cameras_OrthographicCamera__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometries_PlaneGeometry__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__objects_Mesh__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__renderers_WebGLRenderTarget__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__CopyShader__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ShaderPass__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_Clock__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__MaskPass__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__math_Vector2__ = __webpack_require__(4);














function EffectComposer(renderer, renderTarget) {

	this.renderer = renderer;

	if (renderTarget === undefined) {

		var parameters = {
			minFilter: __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* LinearFilter */],
			magFilter: __WEBPACK_IMPORTED_MODULE_4__constants__["a" /* LinearFilter */],
			format: __WEBPACK_IMPORTED_MODULE_4__constants__["c" /* RGBAFormat */],
			stencilBuffer: false
		};

		var size = renderer.getSize(new __WEBPACK_IMPORTED_MODULE_10__math_Vector2__["a" /* Vector2 */]());
		this._pixelRatio = renderer.getPixelRatio();
		this._width = size.width;
		this._height = size.height;

		renderTarget = new __WEBPACK_IMPORTED_MODULE_5__renderers_WebGLRenderTarget__["a" /* WebGLRenderTarget */](this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
		renderTarget.texture.name = 'EffectComposer.rt1';
	} else {

		this._pixelRatio = 1;
		this._width = renderTarget.width;
		this._height = renderTarget.height;
	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();
	this.renderTarget2.texture.name = 'EffectComposer.rt2';

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.renderToScreen = true;

	this.passes = [];

	if (__WEBPACK_IMPORTED_MODULE_6__CopyShader__["a" /* CopyShader */] === undefined) {

		console.error('THREE.EffectComposer relies on THREE.CopyShader');
	}

	if (__WEBPACK_IMPORTED_MODULE_7__ShaderPass__["a" /* ShaderPass */] === undefined) {

		console.error('THREE.EffectComposer relies on THREE.ShaderPass');
	}

	this.copyPass = new __WEBPACK_IMPORTED_MODULE_7__ShaderPass__["a" /* ShaderPass */](__WEBPACK_IMPORTED_MODULE_6__CopyShader__["a" /* CopyShader */]);

	this.clock = new __WEBPACK_IMPORTED_MODULE_8__core_Clock__["a" /* Clock */]();
};

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(EffectComposer.prototype, {

	swapBuffers: function swapBuffers() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	},

	addPass: function addPass(pass) {

		this.passes.push(pass);

		var size = this.renderer.getDrawingBufferSize(new __WEBPACK_IMPORTED_MODULE_10__math_Vector2__["a" /* Vector2 */]());
		pass.setSize(size.width, size.height);
	},

	insertPass: function insertPass(pass, index) {

		this.passes.splice(index, 0, pass);
	},

	isLastEnabledPass: function isLastEnabledPass(passIndex) {

		for (var i = passIndex + 1; i < this.passes.length; i++) {

			if (this.passes[i].enabled) {

				return false;
			}
		}

		return true;
	},

	render: function render(deltaTime) {

		if (deltaTime === undefined) {

			deltaTime = this.clock.getDelta();
		}

		var currentRenderTarget = this.renderer.getRenderTarget();

		var maskActive = false;

		var pass,
		    i,
		    il = this.passes.length;

		for (i = 0; i < il; i++) {

			pass = this.passes[i];

			if (pass.enabled === false) continue;

			pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
			pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

			if (pass.needsSwap) {

				if (maskActive) {

					var context = this.renderer.context;

					context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

					this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

					context.stencilFunc(context.EQUAL, 1, 0xffffffff);
				}

				this.swapBuffers();
			}

			if (__WEBPACK_IMPORTED_MODULE_9__MaskPass__["a" /* MaskPass */] !== undefined) {

				if (pass instanceof __WEBPACK_IMPORTED_MODULE_9__MaskPass__["a" /* MaskPass */]) {

					maskActive = true;
				} else if (pass instanceof __WEBPACK_IMPORTED_MODULE_9__MaskPass__["b" /* ClearMaskPass */]) {

					maskActive = false;
				}
			}
		}

		this.renderer.setRenderTarget(currentRenderTarget);
	},

	reset: function reset(renderTarget) {

		if (renderTarget === undefined) {

			var size = this.renderer.getSize(new __WEBPACK_IMPORTED_MODULE_10__math_Vector2__["a" /* Vector2 */]());
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
	},

	setSize: function setSize(width, height) {

		this._width = width;
		this._height = height;

		var effectiveWidth = this._width * this._pixelRatio;
		var effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
		this.renderTarget2.setSize(effectiveWidth, effectiveHeight);

		for (var i = 0; i < this.passes.length; i++) {

			this.passes[i].setSize(effectiveWidth, effectiveHeight);
		}
	},

	setPixelRatio: function setPixelRatio(pixelRatio) {

		this._pixelRatio = pixelRatio;

		this.setSize(this._width, this._height);
	}

});

function Pass() {
	this.enabled = true;

	this.needsSwap = true;

	this.clear = false;

	this.renderToScreen = false;
};

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Pass.prototype, {

	setSize: function setSize() {},

	render: function render() {

		console.error('THREE.Pass: .render() must be implemented in derived pass.');
	}

});

Pass.FullScreenQuad = function () {

	var camera = new __WEBPACK_IMPORTED_MODULE_1__cameras_OrthographicCamera__["a" /* OrthographicCamera */](-1, 1, 1, -1, 0, 1);
	var geometry = new __WEBPACK_IMPORTED_MODULE_2__geometries_PlaneGeometry__["a" /* PlaneBufferGeometry */](2, 2);

	var FullScreenQuad = function FullScreenQuad(material) {

		this._mesh = new __WEBPACK_IMPORTED_MODULE_3__objects_Mesh__["a" /* Mesh */](geometry, material);
	};

	Object.defineProperty(FullScreenQuad.prototype, 'material', {

		get: function get() {

			return this._mesh.material;
		},

		set: function set(value) {

			this._mesh.material = value;
		}

	});

	__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(FullScreenQuad.prototype, {

		render: function render(renderer) {

			renderer.render(this._mesh, camera);
		}

	});

	return FullScreenQuad;
}();



/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(541), __esModule: true };

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(31);
var call = __webpack_require__(203);
var isArrayIter = __webpack_require__(201);
var anObject = __webpack_require__(23);
var toLength = __webpack_require__(84);
var getIterFn = __webpack_require__(128);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(115);
var defined = __webpack_require__(80);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(80);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = __webpack_require__(11);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = __webpack_require__(11);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CatmullRom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return QuadraticBezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CubicBezier; });


function CatmullRom(t, p0, p1, p2, p3) {

	var v0 = (p2 - p0) * 0.5;
	var v1 = (p3 - p1) * 0.5;
	var t2 = t * t;
	var t3 = t * t2;
	return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}

function QuadraticBezierP0(t, p) {

	var k = 1 - t;
	return k * k * p;
}

function QuadraticBezierP1(t, p) {

	return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {

	return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {

	return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}

function CubicBezierP0(t, p) {

	var k = 1 - t;
	return k * k * k * p;
}

function CubicBezierP1(t, p) {

	var k = 1 - t;
	return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {

	return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {

	return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {

	return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}



/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DefaultLoadingManager; });
/* unused harmony export LoadingManager */


function LoadingManager(onLoad, onProgress, onError) {

	var scope = this;

	var isLoading = false;
	var itemsLoaded = 0;
	var itemsTotal = 0;
	var urlModifier = undefined;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function (url) {

		itemsTotal++;

		if (isLoading === false) {

			if (scope.onStart !== undefined) {

				scope.onStart(url, itemsLoaded, itemsTotal);
			}
		}

		isLoading = true;
	};

	this.itemEnd = function (url) {

		itemsLoaded++;

		if (scope.onProgress !== undefined) {

			scope.onProgress(url, itemsLoaded, itemsTotal);
		}

		if (itemsLoaded === itemsTotal) {

			isLoading = false;

			if (scope.onLoad !== undefined) {

				scope.onLoad();
			}
		}
	};

	this.itemError = function (url) {

		if (scope.onError !== undefined) {

			scope.onError(url);
		}
	};

	this.resolveURL = function (url) {

		if (urlModifier) {

			return urlModifier(url);
		}

		return url;
	};

	this.setURLModifier = function (transform) {

		urlModifier = transform;
		return this;
	};
}

var DefaultLoadingManager = new LoadingManager();



/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderTarget; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__textures_Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector4_js__ = __webpack_require__(36);







function WebGLRenderTarget(width, height, options) {

	this.width = width;
	this.height = height;

	this.scissor = new __WEBPACK_IMPORTED_MODULE_5__math_Vector4_js__["a" /* Vector4 */](0, 0, width, height);
	this.scissorTest = false;

	this.viewport = new __WEBPACK_IMPORTED_MODULE_5__math_Vector4_js__["a" /* Vector4 */](0, 0, width, height);

	options = options || {};

	this.texture = new __WEBPACK_IMPORTED_MODULE_3__textures_Texture_js__["a" /* Texture */](undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

	this.texture.image = {};
	this.texture.image.width = width;
	this.texture.image.height = height;

	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : __WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* LinearFilter */];

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}

WebGLRenderTarget.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

	constructor: WebGLRenderTarget,

	isWebGLRenderTarget: true,

	setSize: function setSize(width, height) {

		if (this.width !== width || this.height !== height) {

			this.width = width;
			this.height = height;

			this.texture.image.width = width;
			this.texture.image.height = height;

			this.dispose();
		}

		this.viewport.set(0, 0, width, height);
		this.scissor.set(0, 0, width, height);
	},

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	copy: function copy(source) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy(source.viewport);

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;
	},

	dispose: function dispose() {

		this.dispatchEvent({ type: 'dispose' });
	}

});



/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(535), __esModule: true };

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 68 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(85)('meta');
var isObject = __webpack_require__(16);
var has = __webpack_require__(41);
var setDesc = __webpack_require__(24).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(40)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(210);
var enumBugKeys = __webpack_require__(114);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(24).f;
var has = __webpack_require__(41);
var TAG = __webpack_require__(13)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 74 */
/***/ (function(module, exports) {



/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(61);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = __webpack_require__(49),
    util     = __webpack_require__(11);

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PerspectiveCamera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Camera_js__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Math_js__ = __webpack_require__(8);






function PerspectiveCamera(fov, aspect, near, far) {

		__WEBPACK_IMPORTED_MODULE_2__Camera_js__["a" /* Camera */].call(this);

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;
		this.filmOffset = 0;

		this.updateProjectionMatrix();
}

PerspectiveCamera.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Camera_js__["a" /* Camera */].prototype), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function copy(source, recursive) {

				__WEBPACK_IMPORTED_MODULE_2__Camera_js__["a" /* Camera */].prototype.copy.call(this, source, recursive);

				this.fov = source.fov;
				this.zoom = source.zoom;

				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;

				this.aspect = source.aspect;
				this.view = source.view === null ? null : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, source.view);

				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;

				return this;
		},

		setFocalLength: function setFocalLength(focalLength) {
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

				this.fov = __WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].RAD2DEG * 2 * Math.atan(vExtentSlope);
				this.updateProjectionMatrix();
		},

		getFocalLength: function getFocalLength() {

				var vExtentSlope = Math.tan(__WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].DEG2RAD * 0.5 * this.fov);

				return 0.5 * this.getFilmHeight() / vExtentSlope;
		},

		getEffectiveFOV: function getEffectiveFOV() {

				return __WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].RAD2DEG * 2 * Math.atan(Math.tan(__WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].DEG2RAD * 0.5 * this.fov) / this.zoom);
		},

		getFilmWidth: function getFilmWidth() {
				return this.filmGauge * Math.min(this.aspect, 1);
		},

		getFilmHeight: function getFilmHeight() {
				return this.filmGauge / Math.max(this.aspect, 1);
		},

		setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {

				this.aspect = fullWidth / fullHeight;

				if (this.view === null) {

						this.view = {
								enabled: true,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
						};
				}

				this.view.enabled = true;
				this.view.fullWidth = fullWidth;
				this.view.fullHeight = fullHeight;
				this.view.offsetX = x;
				this.view.offsetY = y;
				this.view.width = width;
				this.view.height = height;

				this.updateProjectionMatrix();
		},

		clearViewOffset: function clearViewOffset() {

				if (this.view !== null) {

						this.view.enabled = false;
				}

				this.updateProjectionMatrix();
		},

		updateProjectionMatrix: function updateProjectionMatrix() {

				var near = this.near,
				    top = near * Math.tan(__WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].DEG2RAD * 0.5 * this.fov) / this.zoom,
				    height = 2 * top,
				    width = this.aspect * height,
				    left = -0.5 * width,
				    view = this.view;

				if (this.view !== null && this.view.enabled) {

						var fullWidth = view.fullWidth,
						    fullHeight = view.fullHeight;

						left += view.offsetX * width / fullWidth;
						top -= view.offsetY * height / fullHeight;
						width *= view.width / fullWidth;
						height *= view.height / fullHeight;
				}

				var skew = this.filmOffset;
				if (skew !== 0) left += near * skew / this.getFilmWidth();

				this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);

				this.projectionMatrixInverse.getInverse(this.projectionMatrix);
		},

		toJSON: function toJSON(meta) {

				var data = __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);

				data.object.fov = this.fov;
				data.object.zoom = this.zoom;

				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;

				data.object.aspect = this.aspect;

				if (this.view !== null) data.object.view = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, this.view);

				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;

				return data;
		}

});



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Mesh; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Ray_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__math_Triangle_js__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__core_Face3_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__materials_MeshBasicMaterial_js__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__pms_VertexIndexRange__ = __webpack_require__(98);

















function Mesh(geometry, material) {

	__WEBPACK_IMPORTED_MODULE_8__core_Object3D_js__["a" /* Object3D */].call(this);

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new __WEBPACK_IMPORTED_MODULE_13__core_BufferGeometry_js__["a" /* BufferGeometry */]();
	this.material = material !== undefined ? material : new __WEBPACK_IMPORTED_MODULE_12__materials_MeshBasicMaterial_js__["a" /* MeshBasicMaterial */]({ color: Math.random() * 0xffffff });

	this.drawMode = __WEBPACK_IMPORTED_MODULE_11__constants_js__["y" /* TrianglesDrawMode */];

	this.updateMorphTargets();
}

Mesh.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_8__core_Object3D_js__["a" /* Object3D */].prototype), {

	constructor: Mesh,

	isMesh: true,

	setDrawMode: function setDrawMode(value) {

		this.drawMode = value;
	},

	copy: function copy(source) {

		__WEBPACK_IMPORTED_MODULE_8__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source);

		this.drawMode = source.drawMode;

		if (source.morphTargetInfluences !== undefined) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();
		}

		if (source.morphTargetDictionary !== undefined) {

			this.morphTargetDictionary = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()({}, source.morphTargetDictionary);
		}

		return this;
	},

	updateMorphTargets: function updateMorphTargets() {

		var geometry = this.geometry;
		var m, ml, name;

		if (geometry.isBufferGeometry) {

			var morphAttributes = geometry.morphAttributes;
			var keys = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(morphAttributes);

			if (keys.length > 0) {

				var morphAttribute = morphAttributes[keys[0]];

				if (morphAttribute !== undefined) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for (m = 0, ml = morphAttribute.length; m < ml; m++) {

						name = morphAttribute[m].name || String(m);

						this.morphTargetInfluences.push(0);
						this.morphTargetDictionary[name] = m;
					}
				}
			}
		} else {

			var morphTargets = geometry.morphTargets;

			if (morphTargets !== undefined && morphTargets.length > 0) {

				console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}
	},

	raycast: function () {

		var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */]();
		var ray = new __WEBPACK_IMPORTED_MODULE_6__math_Ray_js__["a" /* Ray */]();
		var sphere = new __WEBPACK_IMPORTED_MODULE_5__math_Sphere_js__["a" /* Sphere */]();

		var vA = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var vB = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var vC = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

		var tempA = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var tempB = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var tempC = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

		var morphA = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var morphB = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var morphC = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

		var uvA = new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]();
		var uvB = new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]();
		var uvC = new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]();

		var intersectionPoint = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
		var intersectionPointWorld = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

		function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {

			var intersect;

			if (material.side === __WEBPACK_IMPORTED_MODULE_11__constants_js__["g" /* BackSide */]) {

				intersect = ray.intersectTriangle(pC, pB, pA, true, point);
			} else {

				intersect = ray.intersectTriangle(pA, pB, pC, material.side !== __WEBPACK_IMPORTED_MODULE_11__constants_js__["h" /* DoubleSide */], point);
			}

			if (intersect === null) return null;

			intersectionPointWorld.copy(point);
			intersectionPointWorld.applyMatrix4(object.matrixWorld);

			var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);

			if (distance < raycaster.near || distance > raycaster.far) return null;

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};
		}

		function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, uv, a, b, c) {

			vA.fromBufferAttribute(position, a);
			vB.fromBufferAttribute(position, b);
			vC.fromBufferAttribute(position, c);

			var morphInfluences = object.morphTargetInfluences;

			if (material.morphTargets && morphPosition && morphInfluences) {

				morphA.set(0, 0, 0);
				morphB.set(0, 0, 0);
				morphC.set(0, 0, 0);

				for (var i = 0, il = morphPosition.length; i < il; i++) {

					var influence = morphInfluences[i];
					var morphAttribute = morphPosition[i];

					if (influence === 0) continue;

					tempA.fromBufferAttribute(morphAttribute, a);
					tempB.fromBufferAttribute(morphAttribute, b);
					tempC.fromBufferAttribute(morphAttribute, c);

					morphA.addScaledVector(tempA.sub(vA), influence);
					morphB.addScaledVector(tempB.sub(vB), influence);
					morphC.addScaledVector(tempC.sub(vC), influence);
				}

				vA.add(morphA);
				vB.add(morphB);
				vC.add(morphC);
			}

			var intersection = checkIntersection(object, material, raycaster, ray, vA, vB, vC, intersectionPoint);

			if (intersection) {

				if (uv) {

					uvA.fromBufferAttribute(uv, a);
					uvB.fromBufferAttribute(uv, b);
					uvC.fromBufferAttribute(uv, c);

					intersection.uv = __WEBPACK_IMPORTED_MODULE_9__math_Triangle_js__["a" /* Triangle */].getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]());
				}

				var face = new __WEBPACK_IMPORTED_MODULE_10__core_Face3_js__["a" /* Face3 */](a, b, c);
				__WEBPACK_IMPORTED_MODULE_9__math_Triangle_js__["a" /* Triangle */].getNormal(vA, vB, vC, face.normal);

				intersection.face = face;
			}

			return intersection;
		}

		return function raycast(raycaster, intersects) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if (material === undefined) return;

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			sphere.copy(geometry.boundingSphere);
			sphere.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(sphere) === false) return;

			inverseMatrix.getInverse(matrixWorld);
			ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

			if (geometry.boundingBox !== null) {

				if (ray.intersectsBox(geometry.boundingBox) === false) return;
			}

			var intersection;

			if (geometry.isBufferGeometry || geometry.isPMBufferGeometry) {

				var a, b, c;
				var index = null;
				var position = null;
				var uv = null;
				var morphPosition = null;
				var groups;
				var pickRangeArray = [];
				if (geometry.isPMBufferGeometry) {
					var vertexIndex = geometry.getVertexIndex(__WEBPACK_IMPORTED_MODULE_14__constants__["e" /* DRAWMODE */].TRIANGLES);
					index = vertexIndex.getBufferAttribute();
					position = geometry.getBufferAttribute('position');
					uv = geometry.getBufferAttribute('uv');
					groups = [];
					pickRangeArray = vertexIndex.getPickRangeArray();
					if (pickRangeArray.length === 0) {
						var fullRange = new __WEBPACK_IMPORTED_MODULE_15__pms_VertexIndexRange__["a" /* VertexIndexRange */]();
						fullRange.setRange(0, index.count);
						pickRangeArray.push(fullRange);
					}
				} else if (geometry.isBufferGeometry) {
					index = geometry.index;
					position = geometry.attributes.position;
					uv = geometry.attributes.uv;
					morphPosition = geometry.morphAttributes.position;
					groups = geometry.groups;
					var pickRange = new __WEBPACK_IMPORTED_MODULE_15__pms_VertexIndexRange__["a" /* VertexIndexRange */]();
					pickRange.setRange(geometry.drawRange.start, geometry.drawRange.count);
					pickRangeArray.push(pickRange);
				}
				var i, j, k, il, jl, kl;
				var group, groupMaterial;
				var start, end;

				if (index !== null) {

					if (Array.isArray(material)) {

						for (i = 0, il = groups.length; i < il; i++) {

							group = groups[i];
							groupMaterial = material[group.materialIndex];

							for (j = 0, jl = pickRangeArray.length; j < jl; j++) {
								var pickRange = pickRangeArray[j];
								start = Math.max(group.start, pickRange.getOffset());
								end = Math.min(group.start + pickRange.getCount(), pickRange.getOffset() + pickRange.getCount());

								for (k = start, kl = end; k < kl; k += 3) {

									a = index.getX(k);
									b = index.getX(k + 1);
									c = index.getX(k + 2);

									intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c);

									if (intersection) {

										intersection.faceIndex = Math.floor(k / 3);
										intersection.face.materialIndex = group.materialIndex;
										intersects.push(intersection);
									}
								}
							}
						}
					} else {

						for (i = 0, il = pickRangeArray.length; i < il; i++) {
							var pickRange = pickRangeArray[i];
							start = Math.max(0, pickRange.getOffset());
							end = Math.min(index.count, pickRange.getOffset() + pickRange.getCount());
							for (j = start, jl = end; j < jl; j += 3) {

								a = index.getX(j);
								b = index.getX(j + 1);
								c = index.getX(j + 2);

								intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, a, b, c);

								if (intersection) {

									intersection.faceIndex = Math.floor(j / 3);
									intersects.push(intersection);
								}
							}
						}
					}
				} else if (position !== undefined) {

					if (Array.isArray(material)) {

						for (i = 0, il = groups.length; i < il; i++) {

							group = groups[i];
							groupMaterial = material[group.materialIndex];

							for (j = 0, jl = pickRangeArray.length; j < jl; j++) {
								var pickRange = pickRangeArray[j];
								start = Math.max(group.start, pickRange.getOffset());
								end = Math.min(group.start + pickRange.getCount(), pickRange.getOffset() + pickRange.getCount());

								for (k = start, kl = end; k < kl; k += 3) {

									a = k;
									b = k + 1;
									c = k + 2;

									intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c);

									if (intersection) {

										intersection.faceIndex = Math.floor(k / 3);
										intersection.face.materialIndex = group.materialIndex;
										intersects.push(intersection);
									}
								}
							}
						}
					} else {

						for (i = 0, il = pickRangeArray.length; i < il; i++) {
							var pickRange = pickRangeArray[i];
							start = Math.max(0, pickRange.getOffset());
							end = Math.min(position.count, pickRange.getOffset() + pickRange.getCount());
							for (j = start, jl = end; j < jl; j += 3) {

								a = j;
								b = j + 1;
								c = j + 2;

								intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, a, b, c);

								if (intersection) {

									intersection.faceIndex = Math.floor(j / 3);
									intersects.push(intersection);
								}
							}
						}
					}
				}
			} else if (geometry.isGeometry) {

				var fvA, fvB, fvC;
				var isMultiMaterial = Array.isArray(material);

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var uvs;

				var faceVertexUvs = geometry.faceVertexUvs[0];
				if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

				for (var f = 0, fl = faces.length; f < fl; f++) {

					var face = faces[f];
					var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;

					if (faceMaterial === undefined) continue;

					fvA = vertices[face.a];
					fvB = vertices[face.b];
					fvC = vertices[face.c];

					intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

					if (intersection) {

						if (uvs && uvs[f]) {

							var uvs_f = uvs[f];
							uvA.copy(uvs_f[0]);
							uvB.copy(uvs_f[1]);
							uvC.copy(uvs_f[2]);

							intersection.uv = __WEBPACK_IMPORTED_MODULE_9__math_Triangle_js__["a" /* Triangle */].getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]());
						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push(intersection);
					}
				}
			}
		};
	}(),

	clone: function clone() {

		return new this.constructor(this.geometry, this.material).copy(this);
	}

});



/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(68);
var TAG = __webpack_require__(13)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 80 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(23);
var dPs = __webpack_require__(207);
var enumBugKeys = __webpack_require__(114);
var IE_PROTO = __webpack_require__(122)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(113)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(199).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 82 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(42);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(124);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(61);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = __webpack_require__(49),
    util  = __webpack_require__(11);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(17);
var normalizeHeaderName = __webpack_require__(255);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(140);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(140);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(217)))

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OrthographicCamera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Camera_js__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__ = __webpack_require__(14);





function OrthographicCamera(left, right, top, bottom, near, far) {

		__WEBPACK_IMPORTED_MODULE_2__Camera_js__["a" /* Camera */].call(this);

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left !== undefined ? left : -1;
		this.right = right !== undefined ? right : 1;
		this.top = top !== undefined ? top : 1;
		this.bottom = bottom !== undefined ? bottom : -1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();
}

OrthographicCamera.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Camera_js__["a" /* Camera */].prototype), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function copy(source, recursive) {

				__WEBPACK_IMPORTED_MODULE_2__Camera_js__["a" /* Camera */].prototype.copy.call(this, source, recursive);

				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;

				this.zoom = source.zoom;
				this.view = source.view === null ? null : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, source.view);

				return this;
		},

		setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {

				if (this.view === null) {

						this.view = {
								enabled: true,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
						};
				}

				this.view.enabled = true;
				this.view.fullWidth = fullWidth;
				this.view.fullHeight = fullHeight;
				this.view.offsetX = x;
				this.view.offsetY = y;
				this.view.width = width;
				this.view.height = height;

				this.updateProjectionMatrix();
		},

		clearViewOffset: function clearViewOffset() {

				if (this.view !== null) {

						this.view.enabled = false;
				}

				this.updateProjectionMatrix();
		},

		updateProjectionMatrix: function updateProjectionMatrix() {

				var dx = (this.right - this.left) / (2 * this.zoom);
				var dy = (this.top - this.bottom) / (2 * this.zoom);
				var cx = (this.right + this.left) / 2;
				var cy = (this.top + this.bottom) / 2;

				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;

				if (this.view !== null && this.view.enabled) {

						var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
						var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
						var scaleW = (this.right - this.left) / this.view.width;
						var scaleH = (this.top - this.bottom) / this.view.height;

						left += scaleW * (this.view.offsetX / zoomW);
						right = left + scaleW * (this.view.width / zoomW);
						top -= scaleH * (this.view.offsetY / zoomH);
						bottom = top - scaleH * (this.view.height / zoomH);
				}

				this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);

				this.projectionMatrixInverse.getInverse(this.projectionMatrix);
		},

		toJSON: function toJSON(meta) {

				var data = __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);

				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;

				if (this.view !== null) data.object.view = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, this.view);

				return data;
		}

});



/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Face3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(2);




function Face3(a, b, c, normal, color, materialIndex) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal && normal.isVector3 ? normal : new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();
	this.vertexNormals = Array.isArray(normal) ? normal : [];

	this.color = color && color.isColor ? color : new __WEBPACK_IMPORTED_MODULE_1__math_Color_js__["a" /* Color */]();
	this.vertexColors = Array.isArray(color) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Face3.prototype, {

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	copy: function copy(source) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy(source.normal);
		this.color.copy(source.color);

		this.materialIndex = source.materialIndex;

		for (var i = 0, il = source.vertexNormals.length; i < il; i++) {

			this.vertexNormals[i] = source.vertexNormals[i].clone();
		}

		for (var i = 0, il = source.vertexColors.length; i < il; i++) {

			this.vertexColors[i] = source.vertexColors[i].clone();
		}

		return this;
	}

});



/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EllipseCurve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__ = __webpack_require__(4);





function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'EllipseCurve';

	this.aX = aX || 0;
	this.aY = aY || 0;

	this.xRadius = xRadius || 1;
	this.yRadius = yRadius || 1;

	this.aStartAngle = aStartAngle || 0;
	this.aEndAngle = aEndAngle || 2 * Math.PI;

	this.aClockwise = aClockwise || false;

	this.aRotation = aRotation || 0;
}

EllipseCurve.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype);
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();

	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs(deltaAngle) < __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default.a;

	while (deltaAngle < 0) {
		deltaAngle += twoPi;
	}while (deltaAngle > twoPi) {
		deltaAngle -= twoPi;
	}if (deltaAngle < __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default.a) {

		if (samePoints) {

			deltaAngle = 0;
		} else {

			deltaAngle = twoPi;
		}
	}

	if (this.aClockwise === true && !samePoints) {

		if (deltaAngle === twoPi) {

			deltaAngle = -twoPi;
		} else {

			deltaAngle = deltaAngle - twoPi;
		}
	}

	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos(angle);
	var y = this.aY + this.yRadius * Math.sin(angle);

	if (this.aRotation !== 0) {

		var cos = Math.cos(this.aRotation);
		var sin = Math.sin(this.aRotation);

		var tx = x - this.aX;
		var ty = y - this.aY;

		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;
	}

	return point.set(x, y);
};

EllipseCurve.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.aX = source.aX;
	this.aY = source.aY;

	this.xRadius = source.xRadius;
	this.yRadius = source.yRadius;

	this.aStartAngle = source.aStartAngle;
	this.aEndAngle = source.aEndAngle;

	this.aClockwise = source.aClockwise;

	this.aRotation = source.aRotation;

	return this;
};

EllipseCurve.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.aX = this.aX;
	data.aY = this.aY;

	data.xRadius = this.xRadius;
	data.yRadius = this.yRadius;

	data.aStartAngle = this.aStartAngle;
	data.aEndAngle = this.aEndAngle;

	data.aClockwise = this.aClockwise;

	data.aRotation = this.aRotation;

	return data;
};

EllipseCurve.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.aX = json.aX;
	this.aY = json.aY;

	this.xRadius = json.xRadius;
	this.yRadius = json.yRadius;

	this.aStartAngle = json.aStartAngle;
	this.aEndAngle = json.aEndAngle;

	this.aClockwise = json.aClockwise;

	this.aRotation = json.aRotation;

	return this;
};



/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlaneBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__ = __webpack_require__(12);







function PlaneGeometry(width, height, widthSegments, heightSegments) {

	__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].call(this);

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
	this.mergeVertices();
}

PlaneGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;

function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {

	__WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	width = width || 1;
	height = height || 1;

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor(widthSegments) || 1;
	var gridY = Math.floor(heightSegments) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var ix, iy;

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	for (iy = 0; iy < gridY1; iy++) {

		var y = iy * segment_height - height_half;

		for (ix = 0; ix < gridX1; ix++) {

			var x = ix * segment_width - width_half;

			vertices.push(x, -y, 0);

			normals.push(0, 0, 1);

			uvs.push(ix / gridX);
			uvs.push(1 - iy / gridY);
		}
	}

	for (iy = 0; iy < gridY; iy++) {

		for (ix = 0; ix < gridX; ix++) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * (iy + 1);
			var c = ix + 1 + gridX1 * (iy + 1);
			var d = ix + 1 + gridX1 * iy;

			indices.push(a, b, d);
			indices.push(b, c, d);
		}
	}

	this.setIndex(indices);
	this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](vertices, 3));
	this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](normals, 3));
	this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](uvs, 2));
}

PlaneBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;



/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineBasicMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Color_js__ = __webpack_require__(9);




function LineBasicMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].call(this);

	this.type = 'LineBasicMaterial';

	this.color = new __WEBPACK_IMPORTED_MODULE_2__math_Color_js__["a" /* Color */](0xffffff);

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.lights = false;

	this.setValues(parameters);
}

LineBasicMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.color.copy(source.color);

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;
};



/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Frustum; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Plane_js__ = __webpack_require__(94);





function Frustum(p0, p1, p2, p3, p4, p5) {

		this.planes = [p0 !== undefined ? p0 : new __WEBPACK_IMPORTED_MODULE_3__Plane_js__["a" /* Plane */](), p1 !== undefined ? p1 : new __WEBPACK_IMPORTED_MODULE_3__Plane_js__["a" /* Plane */](), p2 !== undefined ? p2 : new __WEBPACK_IMPORTED_MODULE_3__Plane_js__["a" /* Plane */](), p3 !== undefined ? p3 : new __WEBPACK_IMPORTED_MODULE_3__Plane_js__["a" /* Plane */](), p4 !== undefined ? p4 : new __WEBPACK_IMPORTED_MODULE_3__Plane_js__["a" /* Plane */](), p5 !== undefined ? p5 : new __WEBPACK_IMPORTED_MODULE_3__Plane_js__["a" /* Plane */]()];
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Frustum.prototype, {

		set: function set(p0, p1, p2, p3, p4, p5) {

				var planes = this.planes;

				planes[0].copy(p0);
				planes[1].copy(p1);
				planes[2].copy(p2);
				planes[3].copy(p3);
				planes[4].copy(p4);
				planes[5].copy(p5);

				return this;
		},

		clone: function clone() {

				return new this.constructor().copy(this);
		},

		copy: function copy(frustum) {

				var planes = this.planes;

				for (var i = 0; i < 6; i++) {

						planes[i].copy(frustum.planes[i]);
				}

				return this;
		},

		setFromMatrix: function setFromMatrix(m) {

				var planes = this.planes;
				var me = m.elements;
				var me0 = me[0],
				    me1 = me[1],
				    me2 = me[2],
				    me3 = me[3];
				var me4 = me[4],
				    me5 = me[5],
				    me6 = me[6],
				    me7 = me[7];
				var me8 = me[8],
				    me9 = me[9],
				    me10 = me[10],
				    me11 = me[11];
				var me12 = me[12],
				    me13 = me[13],
				    me14 = me[14],
				    me15 = me[15];

				planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
				planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
				planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
				planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
				planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
				planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();

				return this;
		},

		intersectsObject: function () {

				var sphere = new __WEBPACK_IMPORTED_MODULE_2__Sphere_js__["a" /* Sphere */]();

				return function intersectsObject(object) {

						var geometry = object.geometry;

						if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

						sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

						return this.intersectsSphere(sphere);
				};
		}(),

		intersectsSprite: function () {

				var sphere = new __WEBPACK_IMPORTED_MODULE_2__Sphere_js__["a" /* Sphere */]();

				return function intersectsSprite(sprite) {

						sphere.center.set(0, 0, 0);
						sphere.radius = 0.7071067811865476;
						sphere.applyMatrix4(sprite.matrixWorld);

						return this.intersectsSphere(sphere);
				};
		}(),

		intersectsSphere: function intersectsSphere(sphere) {

				var planes = this.planes;
				var center = sphere.center;
				var negRadius = -sphere.radius;

				for (var i = 0; i < 6; i++) {

						var distance = planes[i].distanceToPoint(center);

						if (distance < negRadius) {

								return false;
						}
				}

				return true;
		},

		intersectsBox: function () {

				var p = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

				return function intersectsBox(box) {

						var planes = this.planes;

						for (var i = 0; i < 6; i++) {

								var plane = planes[i];

								p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
								p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
								p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

								if (plane.distanceToPoint(p) < 0) {

										return false;
								}
						}

						return true;
				};
		}(),

		containsPoint: function containsPoint(point) {

				var planes = this.planes;

				for (var i = 0; i < 6; i++) {

						if (planes[i].distanceToPoint(point) < 0) {

								return false;
						}
				}

				return true;
		}

});



/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Plane; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Vector3_js__ = __webpack_require__(2);




function Plane(normal, constant) {

	this.normal = normal !== undefined ? normal : new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */](1, 0, 0);
	this.constant = constant !== undefined ? constant : 0;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Plane.prototype, {

	isPlane: true,

	set: function set(normal, constant) {

		this.normal.copy(normal);
		this.constant = constant;

		return this;
	},

	setComponents: function setComponents(x, y, z, w) {

		this.normal.set(x, y, z);
		this.constant = w;

		return this;
	},

	setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {

		this.normal.copy(normal);
		this.constant = -point.dot(this.normal);

		return this;
	},

	setFromCoplanarPoints: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
		var v2 = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();

		return function setFromCoplanarPoints(a, b, c) {

			var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();

			this.setFromNormalAndCoplanarPoint(normal, a);

			return this;
		};
	}(),

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	copy: function copy(plane) {

		this.normal.copy(plane.normal);
		this.constant = plane.constant;

		return this;
	},

	normalize: function normalize() {

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar(inverseNormalLength);
		this.constant *= inverseNormalLength;

		return this;
	},

	negate: function negate() {

		this.constant *= -1;
		this.normal.negate();

		return this;
	},

	distanceToPoint: function distanceToPoint(point) {

		return this.normal.dot(point) + this.constant;
	},

	distanceToSphere: function distanceToSphere(sphere) {

		return this.distanceToPoint(sphere.center) - sphere.radius;
	},

	projectPoint: function projectPoint(point, target) {

		if (target === undefined) {

			console.warn('THREE.Plane: .projectPoint() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
		}

		return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
	},

	intersectLine: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();

		return function intersectLine(line, target) {

			if (target === undefined) {

				console.warn('THREE.Plane: .intersectLine() target is now required');
				target = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
			}

			var direction = line.delta(v1);

			var denominator = this.normal.dot(direction);

			if (denominator === 0) {
				if (this.distanceToPoint(line.start) === 0) {

					return target.copy(line.start);
				}

				return undefined;
			}

			var t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {

				return undefined;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		};
	}(),

	intersectsLine: function intersectsLine(line) {

		var startSign = this.distanceToPoint(line.start);
		var endSign = this.distanceToPoint(line.end);

		return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
	},

	intersectsBox: function intersectsBox(box) {

		return box.intersectsPlane(this);
	},

	intersectsSphere: function intersectsSphere(sphere) {

		return sphere.intersectsPlane(this);
	},

	coplanarPoint: function coplanarPoint(target) {

		if (target === undefined) {

			console.warn('THREE.Plane: .coplanarPoint() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
		}

		return target.copy(this.normal).multiplyScalar(-this.constant);
	},

	applyMatrix4: function () {

		var v1 = new __WEBPACK_IMPORTED_MODULE_2__Vector3_js__["a" /* Vector3 */]();
		var m1 = new __WEBPACK_IMPORTED_MODULE_1__Matrix3_js__["a" /* Matrix3 */]();

		return function applyMatrix4(matrix, optionalNormalMatrix) {

			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);

			var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);

			var normal = this.normal.applyMatrix3(normalMatrix).normalize();

			this.constant = -referencePoint.dot(normal);

			return this;
		};
	}(),

	translate: function translate(offset) {

		this.constant -= offset.dot(this.normal);

		return this;
	},

	equals: function equals(plane) {

		return plane.normal.equals(this.normal) && plane.constant === this.constant;
	}

});



/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Group; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__ = __webpack_require__(14);




function Group() {

	__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].call(this);

	this.type = 'Group';
}

Group.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype), {

	constructor: Group,

	isGroup: true

});



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Line; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Ray_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__materials_LineBasicMaterial_js__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_BufferAttribute_js__ = __webpack_require__(12);











function Line(geometry, material, mode) {

						if (mode === 1) {

												console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
						}

						__WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__["a" /* Object3D */].call(this);

						this.type = 'Line';

						this.geometry = geometry !== undefined ? geometry : new __WEBPACK_IMPORTED_MODULE_8__core_BufferGeometry_js__["a" /* BufferGeometry */]();
						this.material = material !== undefined ? material : new __WEBPACK_IMPORTED_MODULE_7__materials_LineBasicMaterial_js__["a" /* LineBasicMaterial */]({ color: Math.random() * 0xffffff });
}

Line.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_5__core_Object3D_js__["a" /* Object3D */].prototype), {

						constructor: Line,

						isLine: true,

						computeLineDistances: function () {

												var start = new __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__["a" /* Vector3 */]();
												var end = new __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__["a" /* Vector3 */]();

												return function computeLineDistances() {

																		var geometry = this.geometry;

																		if (geometry.isBufferGeometry) {

																								if (geometry.index === null) {

																														var positionAttribute = geometry.attributes.position;
																														var lineDistances = [0];

																														for (var i = 1, l = positionAttribute.count; i < l; i++) {

																																				start.fromBufferAttribute(positionAttribute, i - 1);
																																				end.fromBufferAttribute(positionAttribute, i);

																																				lineDistances[i] = lineDistances[i - 1];
																																				lineDistances[i] += start.distanceTo(end);
																														}

																														geometry.addAttribute('lineDistance', new __WEBPACK_IMPORTED_MODULE_9__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](lineDistances, 1));
																								} else {

																														console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
																								}
																		} else if (geometry.isGeometry) {

																								var vertices = geometry.vertices;
																								var lineDistances = geometry.lineDistances;

																								lineDistances[0] = 0;

																								for (var i = 1, l = vertices.length; i < l; i++) {

																														lineDistances[i] = lineDistances[i - 1];
																														lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
																								}
																		}

																		return this;
												};
						}(),

						raycast: function () {

												var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__["a" /* Matrix4 */]();
												var ray = new __WEBPACK_IMPORTED_MODULE_3__math_Ray_js__["a" /* Ray */]();
												var sphere = new __WEBPACK_IMPORTED_MODULE_2__math_Sphere_js__["a" /* Sphere */]();

												return function raycast(raycaster, intersects) {

																		var precision = raycaster.linePrecision;

																		var geometry = this.geometry;
																		var matrixWorld = this.matrixWorld;

																		if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

																		sphere.copy(geometry.boundingSphere);
																		sphere.applyMatrix4(matrixWorld);
																		sphere.radius += precision;

																		if (raycaster.ray.intersectsSphere(sphere) === false) return;

																		inverseMatrix.getInverse(matrixWorld);
																		ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

																		var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
																		var localPrecisionSq = localPrecision * localPrecision;

																		var vStart = new __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__["a" /* Vector3 */]();
																		var vEnd = new __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__["a" /* Vector3 */]();
																		var interSegment = new __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__["a" /* Vector3 */]();
																		var interRay = new __WEBPACK_IMPORTED_MODULE_6__math_Vector3_js__["a" /* Vector3 */]();
																		var step = this && this.isLineSegments ? 2 : 1;

																		if (geometry.isBufferGeometry) {

																								var index = geometry.index;
																								var attributes = geometry.attributes;
																								var positions = attributes.position.array;

																								if (index !== null) {

																														var indices = index.array;

																														for (var i = 0, l = indices.length - 1; i < l; i += step) {

																																				var a = indices[i];
																																				var b = indices[i + 1];

																																				vStart.fromArray(positions, a * 3);
																																				vEnd.fromArray(positions, b * 3);

																																				var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

																																				if (distSq > localPrecisionSq) continue;

																																				interRay.applyMatrix4(this.matrixWorld);

																																				var distance = raycaster.ray.origin.distanceTo(interRay);

																																				if (distance < raycaster.near || distance > raycaster.far) continue;

																																				intersects.push({

																																										distance: distance,

																																										point: interSegment.clone().applyMatrix4(this.matrixWorld),
																																										index: i,
																																										face: null,
																																										faceIndex: null,
																																										object: this

																																				});
																														}
																								} else {

																														for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {

																																				vStart.fromArray(positions, 3 * i);
																																				vEnd.fromArray(positions, 3 * i + 3);

																																				var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

																																				if (distSq > localPrecisionSq) continue;

																																				interRay.applyMatrix4(this.matrixWorld);

																																				var distance = raycaster.ray.origin.distanceTo(interRay);

																																				if (distance < raycaster.near || distance > raycaster.far) continue;

																																				intersects.push({

																																										distance: distance,

																																										point: interSegment.clone().applyMatrix4(this.matrixWorld),
																																										index: i,
																																										face: null,
																																										faceIndex: null,
																																										object: this

																																				});
																														}
																								}
																		} else if (geometry.isGeometry) {

																								var vertices = geometry.vertices;
																								var nbVertices = vertices.length;

																								for (var i = 0; i < nbVertices - 1; i += step) {

																														var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

																														if (distSq > localPrecisionSq) continue;

																														interRay.applyMatrix4(this.matrixWorld);

																														var distance = raycaster.ray.origin.distanceTo(interRay);

																														if (distance < raycaster.near || distance > raycaster.far) continue;

																														intersects.push({

																																				distance: distance,

																																				point: interSegment.clone().applyMatrix4(this.matrixWorld),
																																				index: i,
																																				face: null,
																																				faceIndex: null,
																																				object: this

																														});
																								}
																		}
												};
						}(),

						clone: function clone() {

												return new this.constructor(this.geometry, this.material).copy(this);
						}

});



/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VertexAttributeArray; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__VertexAttribute_js__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_EventDispatcher_js__ = __webpack_require__(19);





function VertexAttributeArray() {
  this.buffer = undefined;

  this.programID = -1;

  this.vertexAttributes = [];

  this.needUpdate = false;
}

VertexAttributeArray.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_3__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

  constructor: VertexAttributeArray,

  dirty: function dirty() {

    this.needUpdate = true;
  },

  addBufferAttribute: function addBufferAttribute(name, bufferAttribute) {

    if (!name || !bufferAttribute) {

      return;
    }

    var vertexAttribute = this.getVertexAttribute(name);

    if (vertexAttribute) {

      if (vertexAttribute.getBufferAttribute().array.length !== bufferAttribute.array.length) {
        console.warn('VBO buffer size out of range, please create a new one.');
        return;
      }

      vertexAttribute.setBufferAttribute(bufferAttribute);
    } else {

      this.vertexAttributes.push(new __WEBPACK_IMPORTED_MODULE_2__VertexAttribute_js__["a" /* VertexAttribute */](name, bufferAttribute));
    }

    this.dirty();
  },

  removeAttribute: function removeAttribute(name) {

    for (var i = 0, size = this.vertexAttributes.length; i < size; i++) {

      if (this.vertexAttributes[i].getName() === name) {

        this.vertexAttributes.splice(i, 1);

        break;
      }
    }

    this.dirty();
  },

  updateAttribute: function updateAttribute(name, offset, array) {

    var bufferAttribute = this.getBufferAttribute(name);
    if (!bufferAttribute) {
      return;
    }

    var bufferArray = bufferAttribute.array;
    for (var i = 0, il = array.length, maxL = bufferArray.length; i < il && i + offset < maxL; i++) {
      bufferArray[i + offset] = array[i];
    }

    this.dirty();
  },

  getVertexAttribute: function getVertexAttribute(name) {

    for (var i = 0, size = this.vertexAttributes.length; i < size; i++) {

      var vertexAttribute = this.vertexAttributes[i];

      if (vertexAttribute.getName() === name) {
        return vertexAttribute;
      }
    }

    return undefined;
  },

  getBufferAttribute: function getBufferAttribute(name) {

    var vertexAttribute = this.getVertexAttribute(name);

    if (!vertexAttribute) {
      return undefined;
    }

    return vertexAttribute.getBufferAttribute();
  },

  getVertexAttributeArray: function getVertexAttributeArray() {

    return this.vertexAttributes;
  },

  update: function update(gl) {

    if (!this.needUpdate) {

      return;
    }

    if (!this.buffer) {

      this.programID = undefined;

      var _attributeCount = this.vertexAttributes.length;
      var maxBufferSize = 0;
      for (var i = 0; i < _attributeCount; i++) {

        maxBufferSize += this.vertexAttributes[i].getBufferAttribute().array.length;
      }

      this.buffer = gl.createBuffer();

      if (!this.buffer) {

        return;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, maxBufferSize * 4, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    if (!this.buffer) {
      return;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    var offset = 0;
    var attributeCount = this.vertexAttributes.length;
    for (var _i = 0; _i < attributeCount; _i++) {

      var vertexAttribute = this.vertexAttributes[_i];

      vertexAttribute.setOffset(offset);

      var bufferAttribute = vertexAttribute.getBufferAttribute();

      gl.bufferSubData(gl.ARRAY_BUFFER, offset * 4, bufferAttribute.array);

      offset += bufferAttribute.array.length;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    this.needUpdate = false;
  },

  bind: function bind(gl, program, state, meshPerAttribute) {

    if (!this.buffer) {

      return;
    }

    if (this.programID !== program.id) {

      var programAttributes = program.getAttributes();

      for (var i = 0, il = this.vertexAttributes.length; i < il; i++) {

        var vertexAttribute = this.vertexAttributes[i];

        var programAttribute = programAttributes[vertexAttribute.getName()];

        if (programAttribute === undefined) {
          continue;
        }

        vertexAttribute.setLayout(programAttribute);
      }

      this.programID = program.id;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

    for (var _i2 = 0, _il = this.vertexAttributes.length; _i2 < _il; _i2++) {

      var _vertexAttribute = this.vertexAttributes[_i2];

      if (_vertexAttribute.getLayout() < 0) {

        continue;
      }

      state.enableAttributeAndDivisor(_vertexAttribute.getLayout(), meshPerAttribute);

      gl.vertexAttribPointer(_vertexAttribute.getLayout(), _vertexAttribute.getBufferAttribute().itemSize, gl.FLOAT, false, 0, _vertexAttribute.getOffset() * 4);
    }
  },

  release: function release(gl) {

    if (this.buffer) {
      gl.deleteBuffer(this.buffer);

      this.buffer = undefined;
    }

    this.programID = -1;

    this.vertexAttributes = [];

    this.needUpdate = false;
  }
});



/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VertexIndexRange; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Color__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Math__ = __webpack_require__(8);






function VertexIndexRange() {
  this.offset = 0;

  this.count = 0;

  this.visible = true;

  this.transparency = undefined;

  this.opacity = undefined;

  this.diffuse = undefined;

  this.vertexIndex = null;
}

VertexIndexRange.prototype = {

  constructor: VertexIndexRange,

  setRange: function setRange(offset, count) {

    this.offset = offset;
    this.count = count;
  },

  getOffset: function getOffset() {

    return this.offset;
  },

  getCount: function getCount() {

    return this.count;
  },

  setVertexIndex: function setVertexIndex(vertexIndex) {
    this.vertexIndex = vertexIndex;
  },

  setVisible: function setVisible(value) {
    if (this.visible === value || !this.vertexIndex) {
      return;
    }
    this.visible = value;
    this.vertexIndex.addUpdateMode(__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* INDEXUPDATEMODE */].UNIONDRAWRANGE);
  },

  getVisible: function getVisible() {
    return this.visible;
  },

  setTransparency: function setTransparency(value, opacity) {
    this.opacity = opacity !== undefined ? opacity : this.opacity;

    if (this.transparency === value) {
      return;
    }

    this.transparency = value;
    if (this.vertexIndex) {
      this.vertexIndex.addUpdateMode(__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* INDEXUPDATEMODE */].UNIONDRAWRANGE);
    }
  },

  getTransparency: function getTransparency() {
    return this.transparency;
  },

  getOpacity: function getOpacity() {
    return this.opacity;
  },

  setDiffuse: function setDiffuse(color) {
    if (this.diffuse === color) {
      return;
    }
    this.diffuse = color;
    if (this.vertexIndex) {
      this.vertexIndex.addUpdateMode(__WEBPACK_IMPORTED_MODULE_0__constants__["f" /* INDEXUPDATEMODE */].UNIONDRAWRANGE);
    }
  },

  getDiffuse: function getDiffuse() {
    return this.diffuse;
  },

  union: function union(indexRange) {

    if (this.transparency !== indexRange.getTransparency()) {
      return false;
    }

    if (this.diffuse !== indexRange.getDiffuse()) {
      return false;
    }

    if (this.transparency && !__WEBPACK_IMPORTED_MODULE_2__math_Math__["a" /* _Math */].compareFloat(this.opacity, indexRange.opacity)) {
      return false;
    }

    if (this.offset + this.count < indexRange.getOffset() || indexRange.getOffset() + indexRange.getCount() < this.offset) {
      return false;
    }

    var start = Math.min(this.offset, indexRange.getOffset());
    var end = Math.max(this.offset + this.count, indexRange.getOffset() + indexRange.getCount());

    this.offset = start;
    this.count = end - start;

    return true;
  }
};



/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLAnimation; });


function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;

		function onAnimationFrame(time, frame) {

				if (isAnimating === false) return;

				animationLoop(time, frame);

				context.requestAnimationFrame(onAnimationFrame);
		}

		return {

				start: function start() {

						if (isAnimating === true) return;
						if (animationLoop === null) return;

						context.requestAnimationFrame(onAnimationFrame);

						isAnimating = true;
				},

				stop: function stop() {

						isAnimating = false;
				},

				setAnimationLoop: function setAnimationLoop(callback) {

						animationLoop = callback;
				},

				setContext: function setContext(value) {

						context = value;
				}

		};
}



/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export arrayMin */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayMax; });


function arrayMin(array) {

	if (array.length === 0) return Infinity;

	var min = array[0];

	for (var i = 1, l = array.length; i < l; ++i) {

		if (array[i] < min) min = array[i];
	}

	return min;
}

function arrayMax(array) {

	if (array.length === 0) return -Infinity;

	var max = array[0];

	for (var i = 1, l = array.length; i < l; ++i) {

		if (array[i] > max) max = array[i];
	}

	return max;
}



/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__ = __webpack_require__(491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__);



function UseFlatBuffer() {
  this.type = 'flatBuffer';
}
UseFlatBuffer.prototype = {
  constructor: UseFlatBuffer,

  DecodeBase64: function DecodeBase64(sInfo) {
    var base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var n = 0,
        i = 0,
        j = 0,
        pad = 0;
    var p = null;
    pad = 0;
    n = sInfo.length;
    var src = [];
    src.length = n;
    var newSize = 0;
    for (i = 0; i < n; i++) {
      src[i] = sInfo[i];
    }

    while (n > 0 && src[n - 1] == '=') {
      src[n - 1] = 0;
      pad++;
      n--;
    }
    for (i = 0; i < n; i++) {
      var findPos = base64.indexOf(src[i], 0);
      if (findPos === -1) break;
      src[i] = findPos;
    }

    var idstSize = parseInt(n * 3 / 4.0 + 4);
    var dstArr = [];
    dstArr.length = idstSize;
    for (i = 0, j = 0; i < n; i += 4, j += 3) {
      dstArr[j] = (src[i] << 2) + ((src[i + 1] & 0x30) >> 4);
      dstArr[j + 1] = ((src[i + 1] & 0x0F) << 4) + ((src[i + 2] & 0x3C) >> 2);
      dstArr[j + 2] = ((src[i + 2] & 0x03) << 6) + src[i + 3];
      newSize += 3;
    }
    newSize -= pad;
    dstArr.length = newSize;
    return dstArr;
  },
  EncodeBase64: function EncodeBase64(uArr) {
    var base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var n = 0,
        buflen = 0,
        i = 0,
        j = 0;
    buflen = n = uArr.length;
    var idstSize = parseInt(buflen / 3.0 * 4 + 4);
    var dst = [];
    dst.length = idstSize;
    for (i = 0, j = 0; i <= buflen - 3; i += 3, j += 4) {
      dst[j] = (uArr[i] & 0xFC) >> 2;
      dst[j + 1] = ((uArr[i] & 0x03) << 4) + ((uArr[i + 1] & 0xF0) >> 4);
      dst[j + 2] = ((uArr[i + 1] & 0x0F) << 2) + ((uArr[i + 2] & 0xC0) >> 6);
      dst[j + 3] = uArr[i + 2] & 0x3F;
    }
    if (n % 3 == 1) {
      dst[j] = (uArr[i] & 0xFC) >> 2;
      dst[j + 1] = (uArr[i] & 0x03) << 4;
      dst[j + 2] = 64;
      dst[j + 3] = 64;
      j += 4;
    } else if (n % 3 == 2) {
      dst[j] = (uArr[i] & 0xFC) >> 2;
      dst[j + 1] = ((uArr[i] & 0x03) << 4) + ((uArr[i + 1] & 0xF0) >> 4);
      dst[j + 2] = (uArr[i + 1] & 0x0F) << 2;
      dst[j + 3] = 64;
      j += 4;
    }
    var base64string = '';
    for (i = 0; i < j; i++) {
      base64string += base64[dst[i]];
    }
    return base64string;
  },

  setFlatBuffer: function setFlatBuffer(cameraPosition, cameraTarget, cameraUp, viewWidth, viewHeight, floorInfo, cullPlaneArr, currentStageId) {
    var builder = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].Builder(1024);

    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.startCameraInfo(builder);
    var eyePosOffset = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].Vec3.createVec3(builder, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.addEyePos(builder, eyePosOffset);
    var tarPosOffset = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].Vec3.createVec3(builder, cameraTarget.x, cameraTarget.y, cameraTarget.z);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.addTarPos(builder, tarPosOffset);
    var upOffset = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].Vec3.createVec3(builder, cameraUp.x, cameraUp.y, cameraUp.z);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.addUp(builder, upOffset);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.addViewWidth(builder, viewWidth);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.addViewHeight(builder, viewHeight);
    var cameraInfoOffset = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CameraInfo.endCameraInfo(builder);

    var floorInfoArray = [];
    for (var i = 0; i < floorInfo.length; i++) {
      var state = null;
      var comTypeArrVec = null;
      if (floorInfo[i].state === 0) {
        state = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].Showtype.AllHide;
      } else if (floorInfo[i].state === 1) {
        state = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].Showtype.AllShow;
      } else if (floorInfo[i].state === 2) {
        state = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].Showtype.Custom;
        var comTypeArr = floorInfo[i].comtypeArr;
        comTypeArrVec = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].FloorInfo.createComtypeArrVector(builder, comTypeArr);
      }
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].FloorInfo.startFloorInfo(builder);
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].FloorInfo.addFloorid(builder, floorInfo[i].floorid);
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].FloorInfo.addState(builder, state);
      if (floorInfo[i].state === 2) {
        __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].FloorInfo.addComtypeArr(builder, comTypeArrVec);
      }
      var floorInfoArrOffset = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].FloorInfo.endFloorInfo(builder);
      floorInfoArray.push(floorInfoArrOffset);
    }

    var cullPlaneArray = [];
    for (var j = 0; j < cullPlaneArr.length; j++) {
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CullPlane.startCullPlane(builder);
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CullPlane.addA(builder, cullPlaneArr[j].x);
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CullPlane.addB(builder, cullPlaneArr[j].y);
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CullPlane.addC(builder, cullPlaneArr[j].z);
      __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CullPlane.addD(builder, cullPlaneArr[j].constant);
      var cullPlaneOffset = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].CullPlane.endCullPlane(builder);
      cullPlaneArray.push(cullPlaneOffset);
    }

    var floorInfoArrVec = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.createFloorInfoArrVector(builder, floorInfoArray);
    var cullPlaneArrVec = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.createCullPlaneArrVector(builder, cullPlaneArray);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.startViewInfo(builder);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.addCameraInfo(builder, cameraInfoOffset);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.addFloorInfoArr(builder, floorInfoArrVec);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.addCullPlaneArr(builder, cullPlaneArrVec);
    __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.addStageId(builder, currentStageId);
    var viewInfo = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.endViewInfo(builder);

    builder.finish(viewInfo);
    return this.EncodeBase64(builder.asUint8Array());
  },
  getFlatBuffer: function getFlatBuffer(bytes) {
    var data = new Uint8Array(bytes);
    var buf = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(data);
    var monster = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_ViewInfo_generated_js__["ViewInfoSpace"].ViewInfo.getRootAsViewInfo(buf);
    var cameraPosition = {
      x: monster.cameraInfo().eyePos().x(),
      y: monster.cameraInfo().eyePos().y(),
      z: monster.cameraInfo().eyePos().z()
    };
    var cameraTarget = {
      x: monster.cameraInfo().tarPos().x(),
      y: monster.cameraInfo().tarPos().y(),
      z: monster.cameraInfo().tarPos().z()
    };
    var cameraUp = {
      x: monster.cameraInfo().up().x(),
      y: monster.cameraInfo().up().y(),
      z: monster.cameraInfo().up().z()
    };
    var viewWidth = monster.cameraInfo().viewWidth();
    var viewHeight = monster.cameraInfo().viewHeight();
    var floorInfo = [];
    for (var i = 0; i < monster.floorInfoArrLength(); i++) {
      var obj = {};
      obj.floorid = monster.floorInfoArr(i).floorid();
      obj.state = monster.floorInfoArr(i).state();
      obj.comtypeArr = monster.floorInfoArr(i).comtypeArrArray();
      floorInfo.push(obj);
    }
    var cullPlane = [];
    for (var j = 0; j < monster.cullPlaneArrLength(); j++) {
      cullPlane.push(monster.cullPlaneArr(j).D());
    }
    var stageId = monster.stageId();
    return {
      cameraPosition: cameraPosition,
      cameraTarget: cameraTarget,
      cameraUp: cameraUp,
      viewWidth: viewWidth,
      viewHeight: viewHeight,
      floorInfo: floorInfo,
      cullPlane: cullPlane,
      stageId: stageId
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (UseFlatBuffer);

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MeshData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return InstanceMeshData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EntInfoData; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__THREE_constants__ = __webpack_require__(3);




function MeshData() {
  this.entID = 0;

  this.bndBox = null;

  this.geoID = 0;

  this.Mesh = null;

  this.positionOffset = 0;
  this.positionCount = 0;

  this.triangleRange = new window.$CCBIM.WebGL.VertexIndexRange();
}

MeshData.prototype = {
  constructor: MeshData,

  isMeshData: true,

  setEntID: function setEntID(value) {
    this.entID = value;
  },

  getEntID: function getEntID() {
    return this.entID;
  },

  setBndBox: function setBndBox(min, max) {
    if (!this.bndBox) {
      this.bndBox = new window.$CCBIM.WebGL.Box3(min, max);
    } else {
      this.bndBox.set(min, max);
    }
  },

  getBndBox: function getBndBox() {
    return this.bndBox;
  },

  setGeoID: function setGeoID(value) {
    this.geoID = value;
  },

  getGeoID: function getGeoID() {
    return this.geoID;
  },

  setObject3D: function setObject3D(value) {
    this.Mesh = value;
  },

  getObject3D: function getObject3D() {
    return this.Mesh;
  },

  setPosition: function setPosition(offset, count) {
    this.positionOffset = offset;
    this.positionCount = count;
  },

  getPositionOffset: function getPositionOffset() {
    return this.positionOffset;
  },

  getPositionCount: function getPositionCount() {
    return this.positionCount;
  },

  setTriangle: function setTriangle(offset, count) {
    this.triangleRange.setRange(offset * 3, count * 3);
  },

  getTriangleDrawRange: function getTriangleDrawRange() {
    return this.triangleRange;
  },

  getTriangleOffset: function getTriangleOffset() {
    return this.triangleRange.getOffset() / 3;
  },

  getTriangleCount: function getTriangleCount() {
    return this.triangleRange.getCount() / 3;
  },

  setVisible: function setVisible(value) {
    if (!this.Mesh) {
      return;
    }
    this.triangleRange.setVisible(value);
  },

  getVisible: function getVisible() {
    return this.triangleRange.getVisible();
  },

  setHighlight: function setHighlight(color, opacity) {
    if (!this.Mesh) {
      return;
    }

    this.triangleRange.setDiffuse(color);
    this.triangleRange.setTransparency(opacity !== undefined, opacity);
  },

  clearHighlight: function clearHighlight() {
    if (!this.Mesh) {
      return;
    }

    this.triangleRange.setDiffuse(undefined);
    this.triangleRange.setTransparency(undefined, undefined);
  },

  setPick: function setPick() {
    if (!this.Mesh || !this.Mesh.geometry || !this.Mesh.geometry.isPMBufferGeometry) {
      return;
    }

    var index = this.Mesh.geometry.getVertexIndex(__WEBPACK_IMPORTED_MODULE_0__THREE_constants__["e" /* DRAWMODE */].TRIANGLES);
    if (index) {
      index.addPickRange(this.triangleRange);
    }
  },

  clear: function clear() {
    this.Mesh = null;
    this.triangleRange.setVertexIndex(null);
    this.triangleRange = null;
  }
};

function InstanceMeshData() {
  this.entID = 0;

  this.bndBox = null;

  this.geoID = 0;
  this.instanceMesh = null;

  this.matrixIndex = 0;

  this.visible = true;
}

InstanceMeshData.prototype = {
  constructor: InstanceMeshData,

  isInstanceMeshData: true,

  setEntID: function setEntID(value) {
    this.entID = value;
  },

  getEntID: function getEntID() {
    return this.entID;
  },

  setBndBox: function setBndBox(min, max) {
    if (!this.bndBox) {
      this.bndBox = new window.$CCBIM.WebGL.Box3(min, max);
    } else {
      this.bndBox.set(min, max);
    }
  },

  getBndBox: function getBndBox() {
    return this.bndBox;
  },

  setGeoID: function setGeoID(value) {
    this.geoID = value;
  },

  getGeoID: function getGeoID() {
    return this.geoID;
  },

  setObject3D: function setObject3D(value) {
    this.instanceMesh = value;
  },

  getObject3D: function getObject3D() {
    return this.instanceMesh;
  },

  setMatrixIndex: function setMatrixIndex(value) {
    this.matrixIndex = value;
  },

  getMatrixIndex: function getMatrixIndex() {
    return this.matrixIndex;
  },

  setVisible: function setVisible(value) {
    if (!this.instanceMesh || this.visible === value) {
      return;
    }

    var instanceState = this.instanceMesh.geometry.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.State.name);
    if (!instanceState) {
      return;
    }

    this.visible = value;

    var bufferArray = instanceState.array;
    var itemSize = instanceState.itemSize;
    bufferArray[this.getMatrixIndex() * itemSize] = this.visible ? 1.0 : 0.0;

    this.instanceMesh.geometry.getInstanceAttributeArray().dirty();
  },

  getVisible: function getVisible() {
    return this.visible;
  },

  setHighlight: function setHighlight(color, opacity) {
    if (!this.instanceMesh) {
      return;
    }

    var instanceState = this.instanceMesh.geometry.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.State.name);
    if (!instanceState) {
      return;
    }

    var bufferArray = instanceState.array;
    var itemSize = instanceState.itemSize;

    var colorMode = 0.0;
    if (color && opacity !== undefined) {
      colorMode = 1.0;
    } else if (color && opacity === undefined) {
      colorMode = 2.0;
    } else if (!color && opacity !== undefined) {
      colorMode = 3.0;
    }
    bufferArray[this.getMatrixIndex() * itemSize + 1] = colorMode;

    if (color && colorMode > 0.0) {
      var instanceColor = this.instanceMesh.geometry.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.Color.name);
      if (instanceColor) {
        var r = color.r;
        var g = color.g;
        var b = color.b;
        var a = opacity !== undefined ? opacity : 1.0;
        bufferArray = instanceColor.array;
        itemSize = instanceColor.itemSize;
        bufferArray[this.getMatrixIndex() * itemSize] = r;
        bufferArray[this.getMatrixIndex() * itemSize + 1] = g;
        bufferArray[this.getMatrixIndex() * itemSize + 2] = b;
        bufferArray[this.getMatrixIndex() * itemSize + 3] = a;
      }
    }

    if (opacity !== undefined) {
      var index = this.instanceMesh.geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
      if (index) {
        var indexRangeArray = index.getIndexRangeArray();
        for (var i = 0, il = indexRangeArray.length; i < il; i++) {
          indexRangeArray[i].setTransparency(true);
        }
      }
    }

    this.instanceMesh.geometry.getInstanceAttributeArray().dirty();
  },

  clearHighlight: function clearHighlight() {
    if (!this.instanceMesh) {
      return;
    }

    var trisIndex = this.instanceMesh.geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
    var instanceState = this.instanceMesh.geometry.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.State.name);
    if (instanceState && trisIndex) {
      var bufferArray = instanceState.array;
      var itemSize = instanceState.itemSize;
      bufferArray[this.getMatrixIndex() * itemSize + 1] = 0.0;
      this.instanceMesh.geometry.getInstanceAttributeArray().dirty();

      var transparency = void 0;
      for (var i = 0, il = bufferArray.length / itemSize; i < il; i++) {
        if (bufferArray[i * itemSize + 1] > 0.0) {
          transparency = true;
          break;
        }
      }
      var indexRangeArray = trisIndex.getIndexRangeArray();
      for (var _i = 0, _il = indexRangeArray.length; _i < _il; _i++) {
        indexRangeArray[_i].setTransparency(transparency);
      }
    }
  },

  setPick: function setPick() {
    if (!this.instanceMesh) {
      return;
    }

    this.instanceMesh.geometry.addPickMatrixIndex(this.matrixIndex);
  },

  clear: function clear() {
    this.instanceMesh = null;
  }
};

function EntInfoData() {
  this.entDataArray = [];
}

EntInfoData.prototype = {
  constructor: EntInfoData,

  addEntData: function addEntData(value) {
    this.entDataArray.push(value);
  },

  clearEntData: function clearEntData() {
    this.entDataArray = [];
  },

  getEntDataArray: function getEntDataArray() {
    return this.entDataArray;
  }
};



/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


function FileIndex() {
  this.type = 'FileIndex';

  this.id = 0;

  this.url = '';

  this.fileSize = 0;

  this.type = 0;
}

FileIndex.prototype = {
  constructor: FileIndex,

  setID: function setID(fileID) {
    this.id = fileID;
  },

  getID: function getID() {
    return this.id;
  },

  setType: function setType(type) {
    this.type = type;
  },

  getType: function getType() {
    return this.type;
  },

  setURL: function setURL(url) {
    this.url = url;
  },

  getURL: function getURL() {
    return this.url;
  },

  setFileSize: function setFileSize(fileSize) {
    this.fileSize = fileSize;
  },

  getFileSize: function getFileSize() {
    return this.fileSize;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (FileIndex);

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__EntData_js__ = __webpack_require__(102);







function SceneNode() {
  this.type = 'SceneNode';

  this.bndBox = null;

  this.pageData = null;

  this.lodDataArray = [];

  this.entInfoFileList = [];

  this.curPage = null;

  this.nextPage = null;

  this.materialGroupMap = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();

  this.entInfoMap = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();

  this.entInfoDataMap = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();

  this.objectMap = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();

  this.haveLoad = false;
}

SceneNode.prototype = {
  constructor: SceneNode,

  setBndBox: function setBndBox(bndBox) {
    this.bndBox = bndBox;
  },

  getBndBox: function getBndBox() {
    return this.bndBox;
  },

  setPageData: function setPageData(pageData) {
    this.pageData = pageData;
  },

  getPageData: function getPageData() {
    return this.pageData;
  },

  addPageLOD: function addPageLOD(pageLOD) {
    if (!pageLOD) {
      return;
    }
    this.lodDataArray.push(pageLOD);
  },

  getPageLODArray: function getPageLODArray() {
    return this.lodDataArray;
  },

  addEntInfoFileList: function addEntInfoFileList(fileIndex) {
    this.entInfoFileList.push(fileIndex);
  },

  getEntInfoFileList: function getEntInfoFileList() {
    return this.entInfoFileList;
  },

  setHaveLoad: function setHaveLoad() {
    this.haveLoad = true;
  },

  removeHaveLoad: function removeHaveLoad() {
    this.haveLoad = false;
  },

  getHaveLoad: function getHaveLoad() {
    return this.haveLoad;
  },

  setCurPage: function setCurPage(pageData) {
    this.curPage = pageData;
  },

  getCurPage: function getCurPage() {
    return this.curPage;
  },

  setNextPage: function setNextPage(pageData) {
    this.nextPage = pageData;
  },

  getNextPage: function getNextPage() {
    return this.nextPage;
  },

  getObjectMap: function getObjectMap() {
    return this.objectMap;
  },

  clearData: function clearData() {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator___default()(this.materialGroupMap.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var group = _step.value;

        group.removeAll();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.materialGroupMap.clear();

    this.entInfoDataMap.forEach(function (entInfoData) {
      entInfoData.clearEntData();
    });
    this.entInfoDataMap.clear();

    this.entInfoMap.forEach(function (entInfo) {
      entInfo.clear();
    });
    this.entInfoMap.clear();

    this.objectMap.clear();
  },

  clearNextPage: function clearNextPage() {
    this.nextPage = null;
  },

  clearCurPage: function clearCurPage() {
    this.curPage = null;
  },

  getMaterialGroup: function getMaterialGroup(material) {
    if (!material) {
      return undefined;
    }
    return this.materialGroupMap.get(material.uuid);
  },

  getOrCreateMaterialGroup: function getOrCreateMaterialGroup(material) {
    if (!material) {
      return undefined;
    }
    var group = this.materialGroupMap.get(material.uuid);
    if (!group) {
      group = new window.$CCBIM.WebGL.Group();
      this.materialGroupMap.set(material.uuid, group);
    }
    return group;
  },

  addEntInfo: function addEntInfo(entInfo) {
    this.entInfoMap.set(entInfo.getID(), entInfo);
  },

  getEntInfo: function getEntInfo(entID) {
    return this.entInfoMap.get(entID);
  },

  getOrCreateEntInfoData: function getOrCreateEntInfoData(entID) {
    var entInfo = this.entInfoDataMap.get(entID);
    if (!entInfo) {
      entInfo = new __WEBPACK_IMPORTED_MODULE_3__EntData_js__["a" /* EntInfoData */]();
      this.entInfoDataMap.set(entID, entInfo);
    }
    return entInfo;
  },
  finish: function finish() {
    var _this = this;

    this.materialGroupMap.forEach(function (group) {
      for (var i = 0, il = group.children.length; i < il; i++) {
        var object = group.children[i];
        var bufferGeometry = object.geometry;
        if (bufferGeometry.isPMBufferGeometry || bufferGeometry.isPMInstanceBufferGeometry) {
          _this.objectMap.set(bufferGeometry.getUUID(), object);
        }
      }
    });

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator___default()(this.entInfoDataMap), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _ref = _step2.value;

        var _ref2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref, 2);

        var entID = _ref2[0];
        var entInfoData = _ref2[1];

        var entInfo = this.entInfoMap.get(entID);
        if (!entInfo) {
          console.warn('Can\'t find EntInfo.' + entID.toString());
          continue;
        }
        var entDataArray = entInfoData.getEntDataArray();
        for (var i = 0, il = entDataArray.length; i < il; i++) {
          var entData = entDataArray[i];
          var object = this.objectMap.get(entData.getGeoID());
          if (!object) {
            console.warn('Associate to a GeoData failed.');
            continue;
          }

          if (entData.isMeshData) {
            var triangleIndex = object.geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
            if (!triangleIndex) {
              console.warn('MeshData doesn\'t contain a TRIANGLES-INDEX.');
              continue;
            }
            triangleIndex.addIndexRange(entData.getTriangleDrawRange());
          }

          entData.setObject3D(object);
        }
        entInfo.setEntDataArray(entDataArray);
        entInfoData.clearEntData();
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    this.entInfoDataMap.clear();
  }
};

/* harmony default export */ __webpack_exports__["a"] = (SceneNode);

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


if (Date.now === undefined) {

  Date.now = function () {

    return new Date().valueOf();
  };
}

var TWEEN = TWEEN || function () {

  var _tweens = [];

  return {

    REVISION: '8',

    getAll: function getAll() {

      return _tweens;
    },

    removeAll: function removeAll() {

      _tweens = [];
    },

    add: function add(tween) {

      _tweens.push(tween);
    },

    remove: function remove(tween) {

      var i = _tweens.indexOf(tween);

      if (i !== -1) {

        _tweens.splice(i, 1);
      }
    },

    update: function update(time) {

      if (_tweens.length === 0) return false;

      var i = 0,
          numTweens = _tweens.length;

      time = time !== undefined ? time : Date.now();

      while (i < numTweens) {

        if (_tweens[i].update(time)) {

          i++;
        } else {

          _tweens.splice(i, 1);

          numTweens--;
        }
      }

      return true;
    }

  };
}();

TWEEN.Tween = function (object) {

  var _object = object;
  var _valuesStart = {};
  var _valuesEnd = {};
  var _duration = 1000;
  var _delayTime = 0;
  var _startTime = null;
  var _easingFunction = TWEEN.Easing.Linear.None;
  var _interpolationFunction = TWEEN.Interpolation.Linear;
  var _chainedTweens = [];
  var _onStartCallback = null;
  var _onStartCallbackFired = false;
  var _onUpdateCallback = null;
  var _onCompleteCallback = null;

  this.to = function (properties, duration) {

    if (duration !== undefined) {

      _duration = duration;
    }

    _valuesEnd = properties;

    return this;
  };

  this.start = function (time) {

    TWEEN.add(this);

    _onStartCallbackFired = false;

    _startTime = time !== undefined ? time : Date.now();
    _startTime += _delayTime;

    for (var property in _valuesEnd) {
      if (_object[property] === null || !(property in _object)) {

        continue;
      }

      if (_valuesEnd[property] instanceof Array) {

        if (_valuesEnd[property].length === 0) {

          continue;
        }

        _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
      }

      _valuesStart[property] = _object[property];
    }

    return this;
  };

  this.stop = function () {

    TWEEN.remove(this);
    return this;
  };

  this.delay = function (amount) {

    _delayTime = amount;
    return this;
  };

  this.easing = function (easing) {

    _easingFunction = easing;
    return this;
  };

  this.interpolation = function (interpolation) {

    _interpolationFunction = interpolation;
    return this;
  };

  this.chain = function () {

    _chainedTweens = arguments;
    return this;
  };

  this.onStart = function (callback) {

    _onStartCallback = callback;
    return this;
  };

  this.onUpdate = function (callback) {

    _onUpdateCallback = callback;
    return this;
  };

  this.onComplete = function (callback) {

    _onCompleteCallback = callback;
    return this;
  };

  this.update = function (time) {

    if (time < _startTime) {

      return true;
    }

    if (_onStartCallbackFired === false) {

      if (_onStartCallback !== null) {

        _onStartCallback.call(_object);
      }

      _onStartCallbackFired = true;
    }

    var elapsed = (time - _startTime) / _duration;
    elapsed = elapsed > 1 ? 1 : elapsed;

    var value = _easingFunction(elapsed);

    for (var property in _valuesStart) {

      var start = _valuesStart[property];
      var end = _valuesEnd[property];

      if (end instanceof Array) {

        _object[property] = _interpolationFunction(end, value);
      } else {

        _object[property] = start + (end - start) * value;
      }
    }

    if (_onUpdateCallback !== null) {

      _onUpdateCallback(_object, value);
    }

    if (elapsed == 1) {

      if (_onCompleteCallback !== null) {

        _onCompleteCallback.call(_object);
      }

      for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {

        _chainedTweens[i].start(time);
      }

      return false;
    }

    return true;
  };
};

TWEEN.Easing = {

  Linear: {

    None: function None(k) {

      return k;
    }

  },

  Quadratic: {

    In: function In(k) {

      return k * k;
    },

    Out: function Out(k) {

      return k * (2 - k);
    },

    InOut: function InOut(k) {

      if ((k *= 2) < 1) return 0.5 * k * k;
      return -0.5 * (--k * (k - 2) - 1);
    }

  },

  Cubic: {

    In: function In(k) {

      return k * k * k;
    },

    Out: function Out(k) {

      return --k * k * k + 1;
    },

    InOut: function InOut(k) {

      if ((k *= 2) < 1) return 0.5 * k * k * k;
      return 0.5 * ((k -= 2) * k * k + 2);
    }

  },

  Quartic: {

    In: function In(k) {

      return k * k * k * k;
    },

    Out: function Out(k) {

      return 1 - --k * k * k * k;
    },

    InOut: function InOut(k) {

      if ((k *= 2) < 1) return 0.5 * k * k * k * k;
      return -0.5 * ((k -= 2) * k * k * k - 2);
    }

  },

  Quintic: {

    In: function In(k) {

      return k * k * k * k * k;
    },

    Out: function Out(k) {

      return --k * k * k * k * k + 1;
    },

    InOut: function InOut(k) {

      if ((k *= 2) < 1) return 0.5 * k * k * k * k * k;
      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    }

  },

  Sinusoidal: {

    In: function In(k) {

      return 1 - Math.cos(k * Math.PI / 2);
    },

    Out: function Out(k) {

      return Math.sin(k * Math.PI / 2);
    },

    InOut: function InOut(k) {

      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

  },

  Exponential: {

    In: function In(k) {

      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },

    Out: function Out(k) {

      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },

    InOut: function InOut(k) {

      if (k === 0) return 0;
      if (k === 1) return 1;
      if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1);
      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    }

  },

  Circular: {

    In: function In(k) {

      return 1 - Math.sqrt(1 - k * k);
    },

    Out: function Out(k) {

      return Math.sqrt(1 - --k * k);
    },

    InOut: function InOut(k) {

      if ((k *= 2) < 1) return -0.5 * (Math.sqrt(1 - k * k) - 1);
      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    }

  },

  Elastic: {

    In: function In(k) {

      var s,
          a = 0.1,
          p = 0.4;
      if (k === 0) return 0;
      if (k === 1) return 1;
      if (!a || a < 1) {
        a = 1;s = p / 4;
      } else s = p * Math.asin(1 / a) / (2 * Math.PI);
      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },

    Out: function Out(k) {

      var s,
          a = 0.1,
          p = 0.4;
      if (k === 0) return 0;
      if (k === 1) return 1;
      if (!a || a < 1) {
        a = 1;s = p / 4;
      } else s = p * Math.asin(1 / a) / (2 * Math.PI);
      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
    },

    InOut: function InOut(k) {

      var s,
          a = 0.1,
          p = 0.4;
      if (k === 0) return 0;
      if (k === 1) return 1;
      if (!a || a < 1) {
        a = 1;s = p / 4;
      } else s = p * Math.asin(1 / a) / (2 * Math.PI);
      if ((k *= 2) < 1) return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    }

  },

  Back: {

    In: function In(k) {

      var s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },

    Out: function Out(k) {

      var s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },

    InOut: function InOut(k) {

      var s = 1.70158 * 1.525;
      if ((k *= 2) < 1) return 0.5 * (k * k * ((s + 1) * k - s));
      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    }

  },

  Bounce: {

    In: function In(k) {

      return 1 - TWEEN.Easing.Bounce.Out(1 - k);
    },

    Out: function Out(k) {

      if (k < 1 / 2.75) {

        return 7.5625 * k * k;
      } else if (k < 2 / 2.75) {

        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
      } else if (k < 2.5 / 2.75) {

        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
      } else {

        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
      }
    },

    InOut: function InOut(k) {

      if (k < 0.5) return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
      return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
    }

  }

};

TWEEN.Interpolation = {

  Linear: function Linear(v, k) {

    var m = v.length - 1,
        f = m * k,
        i = Math.floor(f),
        fn = TWEEN.Interpolation.Utils.Linear;

    if (k < 0) return fn(v[0], v[1], f);
    if (k > 1) return fn(v[m], v[m - 1], m - f);

    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
  },

  Bezier: function Bezier(v, k) {

    var b = 0,
        n = v.length - 1,
        pw = Math.pow,
        bn = TWEEN.Interpolation.Utils.Bernstein,
        i;

    for (i = 0; i <= n; i++) {
      b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
    }

    return b;
  },

  CatmullRom: function CatmullRom(v, k) {

    var m = v.length - 1,
        f = m * k,
        i = Math.floor(f),
        fn = TWEEN.Interpolation.Utils.CatmullRom;

    if (v[0] === v[m]) {

      if (k < 0) i = Math.floor(f = m * (1 + k));

      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    } else {

      if (k < 0) return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
      if (k > 1) return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);

      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
  },

  Utils: {

    Linear: function Linear(p0, p1, t) {

      return (p1 - p0) * t + p0;
    },

    Bernstein: function Bernstein(n, i) {

      var fc = TWEEN.Interpolation.Utils.Factorial;
      return fc(n) / fc(i) / fc(n - i);
    },

    Factorial: function () {

      var a = [1];

      return function (n) {

        var s = 1,
            i;
        if (a[n]) return a[n];
        for (i = n; i > 1; i--) {
          s *= i;
        }return a[n] = s;
      };
    }(),

    CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {

      var v0 = (p2 - p0) * 0.5,
          v1 = (p3 - p1) * 0.5,
          t2 = t * t,
          t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

  }

};

/* harmony default export */ __webpack_exports__["a"] = (TWEEN);

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(540), __esModule: true };

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(26);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(106);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(623);


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(31);
var IObject = __webpack_require__(115);
var toObject = __webpack_require__(59);
var toLength = __webpack_require__(84);
var asc = __webpack_require__(552);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(10);
var $export = __webpack_require__(6);
var meta = __webpack_require__(70);
var fails = __webpack_require__(40);
var hide = __webpack_require__(42);
var redefineAll = __webpack_require__(83);
var forOf = __webpack_require__(56);
var anInstance = __webpack_require__(78);
var isObject = __webpack_require__(16);
var setToStringTag = __webpack_require__(73);
var dP = __webpack_require__(24).f;
var each = __webpack_require__(111)(0);
var DESCRIPTORS = __webpack_require__(20);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16);
var document = __webpack_require__(10).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 114 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(68);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(69);
var $export = __webpack_require__(6);
var redefine = __webpack_require__(119);
var hide = __webpack_require__(42);
var Iterators = __webpack_require__(57);
var $iterCreate = __webpack_require__(557);
var setToStringTag = __webpack_require__(73);
var getPrototypeOf = __webpack_require__(561);
var ITERATOR = __webpack_require__(13)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(67);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 118 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(42);


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(6);
var aFunction = __webpack_require__(67);
var ctx = __webpack_require__(31);
var forOf = __webpack_require__(56);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(6);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(123)('keys');
var uid = __webpack_require__(85);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(5);
var global = __webpack_require__(10);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(69) ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 124 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(16);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var core = __webpack_require__(5);
var LIBRARY = __webpack_require__(69);
var wksExt = __webpack_require__(127);
var defineProperty = __webpack_require__(24).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(13);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(79);
var ITERATOR = __webpack_require__(13)('iterator');
var Iterators = __webpack_require__(57);
module.exports = __webpack_require__(5).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = MapField;

// extends Field
var Field = __webpack_require__(49);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = __webpack_require__(62),
    util    = __webpack_require__(11);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Message;

var util = __webpack_require__(33);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Method;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(61);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = __webpack_require__(11);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(33);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Root;

// extends Namespace
var Namespace = __webpack_require__(75);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = __webpack_require__(49),
    Enum    = __webpack_require__(27),
    OneOf   = __webpack_require__(86),
    util    = __webpack_require__(11);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Strip path if this file references a bundled definition
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common)
                filename = altname;
        }

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            util.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

// extends Namespace
var Namespace = __webpack_require__(75);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = __webpack_require__(131),
    util   = __webpack_require__(11),
    rpc    = __webpack_require__(222);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Type;

// extends Namespace
var Namespace = __webpack_require__(75);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = __webpack_require__(27),
    OneOf     = __webpack_require__(86),
    Field     = __webpack_require__(49),
    MapField  = __webpack_require__(129),
    Service   = __webpack_require__(134),
    Message   = __webpack_require__(130),
    Reader    = __webpack_require__(132),
    Writer    = __webpack_require__(136),
    util      = __webpack_require__(11),
    encoder   = __webpack_require__(220),
    decoder   = __webpack_require__(219),
    verifier  = __webpack_require__(224),
    converter = __webpack_require__(218),
    wrappers  = __webpack_require__(225);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(33);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(606);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/_css-loader@0.28.11@css-loader/index.js!./normalize.css", function() {
			var newContent = require("!!../../node_modules/_css-loader@0.28.11@css-loader/index.js!./normalize.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(17);
var settle = __webpack_require__(247);
var buildURL = __webpack_require__(250);
var parseHeaders = __webpack_require__(256);
var isURLSameOrigin = __webpack_require__(254);
var createError = __webpack_require__(143);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(249);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(252);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(217)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(246);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArrayCamera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PerspectiveCamera_js__ = __webpack_require__(76);






function ArrayCamera(array) {

	__WEBPACK_IMPORTED_MODULE_2__PerspectiveCamera_js__["a" /* PerspectiveCamera */].call(this);

	this.cameras = array || [];
}

ArrayCamera.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__PerspectiveCamera_js__["a" /* PerspectiveCamera */].prototype), {

	constructor: ArrayCamera,

	isArrayCamera: true

});



/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Camera; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__ = __webpack_require__(2);








function Camera() {

	__WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].call(this);

	this.type = 'Camera';

	this.matrixWorldInverse = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();

	this.projectionMatrix = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
	this.projectionMatrixInverse = new __WEBPACK_IMPORTED_MODULE_2__math_Matrix4_js__["a" /* Matrix4 */]();
}

Camera.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype), {

	constructor: Camera,

	isCamera: true,

	copy: function copy(source, recursive) {

		__WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source, recursive);

		this.matrixWorldInverse.copy(source.matrixWorldInverse);

		this.projectionMatrix.copy(source.projectionMatrix);
		this.projectionMatrixInverse.copy(source.projectionMatrixInverse);

		return this;
	},

	getWorldDirection: function getWorldDirection(target) {

		if (target === undefined) {

			console.warn('THREE.Camera: .getWorldDirection() target is now required');
			target = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();
		}

		this.updateMatrixWorld(true);

		var e = this.matrixWorld.elements;

		return target.set(-e[8], -e[9], -e[10]).normalize();
	},

	updateMatrixWorld: function updateMatrixWorld(force) {

		__WEBPACK_IMPORTED_MODULE_3__core_Object3D_js__["a" /* Object3D */].prototype.updateMatrixWorld.call(this, force);

		this.matrixWorldInverse.getInverse(this.matrixWorld);
	},

	clone: function clone() {

		return new this.constructor().copy(this);
	}

});



/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Clock; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);



function Clock(autoStart) {

	this.autoStart = autoStart !== undefined ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Clock.prototype, {

	start: function start() {

		this.startTime = (typeof performance === 'undefined' ? Date : performance).now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;
	},

	stop: function stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;
	},

	getElapsedTime: function getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;
	},

	getDelta: function getDelta() {

		var diff = 0;

		if (this.autoStart && !this.running) {

			this.start();
			return 0;
		}

		if (this.running) {

			var newTime = (typeof performance === 'undefined' ? Date : performance).now();

			diff = (newTime - this.oldTime) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;
		}

		return diff;
	}

});



/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeUtils; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Earcut_js__ = __webpack_require__(263);




var ShapeUtils = {

		area: function area(contour) {

				var n = contour.length;
				var a = 0.0;

				for (var p = n - 1, q = 0; q < n; p = q++) {

						a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
				}

				return a * 0.5;
		},

		isClockWise: function isClockWise(pts) {

				return ShapeUtils.area(pts) < 0;
		},

		triangulateShape: function triangulateShape(contour, holes) {

				var vertices = [];
				var holeIndices = [];
				var faces = [];

				removeDupEndPts(contour);
				addContour(vertices, contour);

				var holeIndex = contour.length;

				holes.forEach(removeDupEndPts);

				for (var i = 0; i < holes.length; i++) {

						holeIndices.push(holeIndex);
						holeIndex += holes[i].length;
						addContour(vertices, holes[i]);
				}

				var triangles = __WEBPACK_IMPORTED_MODULE_0__Earcut_js__["a" /* Earcut */].triangulate(vertices, holeIndices);

				for (var i = 0; i < triangles.length; i += 3) {

						faces.push(triangles.slice(i, i + 3));
				}

				return faces;
		}

};

function removeDupEndPts(points) {

		var l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {

				points.pop();
		}
}

function addContour(vertices, contour) {

		for (var i = 0; i < contour.length; i++) {

				vertices.push(contour[i].x);
				vertices.push(contour[i].y);
		}
}



/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Path; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CurvePath_js__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__curves_EllipseCurve_js__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__curves_SplineCurve_js__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__curves_CubicBezierCurve_js__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__curves_QuadraticBezierCurve_js__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__curves_LineCurve_js__ = __webpack_require__(152);










function Path(points) {

	__WEBPACK_IMPORTED_MODULE_3__CurvePath_js__["a" /* CurvePath */].call(this);

	this.type = 'Path';

	this.currentPoint = new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */]();

	if (points) {

		this.setFromPoints(points);
	}
}

Path.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_3__CurvePath_js__["a" /* CurvePath */].prototype), {

	constructor: Path,

	setFromPoints: function setFromPoints(points) {

		this.moveTo(points[0].x, points[0].y);

		for (var i = 1, l = points.length; i < l; i++) {

			this.lineTo(points[i].x, points[i].y);
		}
	},

	moveTo: function moveTo(x, y) {

		this.currentPoint.set(x, y);
	},

	lineTo: function lineTo(x, y) {

		var curve = new __WEBPACK_IMPORTED_MODULE_8__curves_LineCurve_js__["a" /* LineCurve */](this.currentPoint.clone(), new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](x, y));
		this.curves.push(curve);

		this.currentPoint.set(x, y);
	},

	quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {

		var curve = new __WEBPACK_IMPORTED_MODULE_7__curves_QuadraticBezierCurve_js__["a" /* QuadraticBezierCurve */](this.currentPoint.clone(), new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](aCPx, aCPy), new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](aX, aY));

		this.curves.push(curve);

		this.currentPoint.set(aX, aY);
	},

	bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

		var curve = new __WEBPACK_IMPORTED_MODULE_6__curves_CubicBezierCurve_js__["a" /* CubicBezierCurve */](this.currentPoint.clone(), new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](aCP1x, aCP1y), new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](aCP2x, aCP2y), new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](aX, aY));

		this.curves.push(curve);

		this.currentPoint.set(aX, aY);
	},

	splineThru: function splineThru(pts) {

		var npts = [this.currentPoint.clone()].concat(pts);

		var curve = new __WEBPACK_IMPORTED_MODULE_5__curves_SplineCurve_js__["a" /* SplineCurve */](npts);
		this.curves.push(curve);

		this.currentPoint.copy(pts[pts.length - 1]);
	},

	arc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
	},

	absarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	},

	ellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	},

	absellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

		var curve = new __WEBPACK_IMPORTED_MODULE_4__curves_EllipseCurve_js__["a" /* EllipseCurve */](aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

		if (this.curves.length > 0) {
			var firstPoint = curve.getPoint(0);

			if (!firstPoint.equals(this.currentPoint)) {

				this.lineTo(firstPoint.x, firstPoint.y);
			}
		}

		this.curves.push(curve);

		var lastPoint = curve.getPoint(1);
		this.currentPoint.copy(lastPoint);
	},

	copy: function copy(source) {

		__WEBPACK_IMPORTED_MODULE_3__CurvePath_js__["a" /* CurvePath */].prototype.copy.call(this, source);

		this.currentPoint.copy(source.currentPoint);

		return this;
	},

	toJSON: function toJSON() {

		var data = __WEBPACK_IMPORTED_MODULE_3__CurvePath_js__["a" /* CurvePath */].prototype.toJSON.call(this);

		data.currentPoint = this.currentPoint.toArray();

		return data;
	},

	fromJSON: function fromJSON(json) {

		__WEBPACK_IMPORTED_MODULE_3__CurvePath_js__["a" /* CurvePath */].prototype.fromJSON.call(this, json);

		this.currentPoint.fromArray(json.currentPoint);

		return this;
	}

});



/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CatmullRomCurve3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__ = __webpack_require__(25);




function CubicPoly() {

	var c0 = 0,
	    c1 = 0,
	    c2 = 0,
	    c3 = 0;

	function init(x0, x1, t0, t1) {

		c0 = x0;
		c1 = t0;
		c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;
	}

	return {

		initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {

			init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
		},

		initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
			var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
			var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

			t1 *= dt1;
			t2 *= dt1;

			init(x1, x2, t1, t2);
		},

		calc: function calc(t) {

			var t2 = t * t;
			var t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;
		}

	};
}

var tmp = new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
var px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

function CatmullRomCurve3(points, closed, curveType, tension) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'CatmullRomCurve3';

	this.points = points || [];
	this.closed = closed || false;
	this.curveType = curveType || 'centripetal';
	this.tension = tension || 0.5;
}

CatmullRomCurve3.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();

	var points = this.points;
	var l = points.length;

	var p = (l - (this.closed ? 0 : 1)) * t;
	var intPoint = Math.floor(p);
	var weight = p - intPoint;

	if (this.closed) {

		intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
	} else if (weight === 0 && intPoint === l - 1) {

		intPoint = l - 2;
		weight = 1;
	}

	var p0, p1, p2, p3;

	if (this.closed || intPoint > 0) {

		p0 = points[(intPoint - 1) % l];
	} else {
		tmp.subVectors(points[0], points[1]).add(points[0]);
		p0 = tmp;
	}

	p1 = points[intPoint % l];
	p2 = points[(intPoint + 1) % l];

	if (this.closed || intPoint + 2 < l) {

		p3 = points[(intPoint + 2) % l];
	} else {
		tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
		p3 = tmp;
	}

	if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
		var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
		var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
		var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
		var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

		if (dt1 < 1e-4) dt1 = 1.0;
		if (dt0 < 1e-4) dt0 = dt1;
		if (dt2 < 1e-4) dt2 = dt1;

		px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
		py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
		pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
	} else if (this.curveType === 'catmullrom') {

		px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
		py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
		pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
	}

	point.set(px.calc(weight), py.calc(weight), pz.calc(weight));

	return point;
};

CatmullRomCurve3.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.points = [];

	for (var i = 0, l = source.points.length; i < l; i++) {

		var point = source.points[i];

		this.points.push(point.clone());
	}

	this.closed = source.closed;
	this.curveType = source.curveType;
	this.tension = source.tension;

	return this;
};

CatmullRomCurve3.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.points = [];

	for (var i = 0, l = this.points.length; i < l; i++) {

		var point = this.points[i];
		data.points.push(point.toArray());
	}

	data.closed = this.closed;
	data.curveType = this.curveType;
	data.tension = this.tension;

	return data;
};

CatmullRomCurve3.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.points = [];

	for (var i = 0, l = json.points.length; i < l; i++) {

		var point = json.points[i];
		this.points.push(new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]().fromArray(point));
	}

	this.closed = json.closed;
	this.curveType = json.curveType;
	this.tension = json.tension;

	return this;
};



/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CubicBezierCurve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__ = __webpack_require__(4);





function CubicBezierCurve(v0, v1, v2, v3) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'CubicBezierCurve';

	this.v0 = v0 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
	this.v1 = v1 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
	this.v2 = v2 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
	this.v3 = v3 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
}

CubicBezierCurve.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();

	var v0 = this.v0,
	    v1 = this.v1,
	    v2 = this.v2,
	    v3 = this.v3;

	point.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["b" /* CubicBezier */])(t, v0.x, v1.x, v2.x, v3.x), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["b" /* CubicBezier */])(t, v0.y, v1.y, v2.y, v3.y));

	return point;
};

CubicBezierCurve.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.v0.copy(source.v0);
	this.v1.copy(source.v1);
	this.v2.copy(source.v2);
	this.v3.copy(source.v3);

	return this;
};

CubicBezierCurve.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;
};

CubicBezierCurve.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.v0.fromArray(json.v0);
	this.v1.fromArray(json.v1);
	this.v2.fromArray(json.v2);
	this.v3.fromArray(json.v3);

	return this;
};



/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineCurve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__ = __webpack_require__(25);




function LineCurve(v1, v2) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'LineCurve';

	this.v1 = v1 || new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]();
	this.v2 = v2 || new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]();
}

LineCurve.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype);
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]();

	if (t === 1) {

		point.copy(this.v2);
	} else {

		point.copy(this.v2).sub(this.v1);
		point.multiplyScalar(t).add(this.v1);
	}

	return point;
};

LineCurve.prototype.getPointAt = function (u, optionalTarget) {

	return this.getPoint(u, optionalTarget);
};

LineCurve.prototype.getTangent = function () {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();
};

LineCurve.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.v1.copy(source.v1);
	this.v2.copy(source.v2);

	return this;
};

LineCurve.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;
};

LineCurve.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.v1.fromArray(json.v1);
	this.v2.fromArray(json.v2);

	return this;
};



/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QuadraticBezierCurve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__ = __webpack_require__(4);





function QuadraticBezierCurve(v0, v1, v2) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'QuadraticBezierCurve';

	this.v0 = v0 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
	this.v1 = v1 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
	this.v2 = v2 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();
}

QuadraticBezierCurve.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();

	var v0 = this.v0,
	    v1 = this.v1,
	    v2 = this.v2;

	point.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["c" /* QuadraticBezier */])(t, v0.x, v1.x, v2.x), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["c" /* QuadraticBezier */])(t, v0.y, v1.y, v2.y));

	return point;
};

QuadraticBezierCurve.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.v0.copy(source.v0);
	this.v1.copy(source.v1);
	this.v2.copy(source.v2);

	return this;
};

QuadraticBezierCurve.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;
};

QuadraticBezierCurve.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.v0.fromArray(json.v0);
	this.v1.fromArray(json.v1);
	this.v2.fromArray(json.v2);

	return this;
};



/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SplineCurve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__ = __webpack_require__(4);





function SplineCurve(points) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'SplineCurve';

	this.points = points || [];
}

SplineCurve.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype);
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]();

	var points = this.points;
	var p = (points.length - 1) * t;

	var intPoint = Math.floor(p);
	var weight = p - intPoint;

	var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
	var p1 = points[intPoint];
	var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
	var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

	point.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["a" /* CatmullRom */])(weight, p0.x, p1.x, p2.x, p3.x), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["a" /* CatmullRom */])(weight, p0.y, p1.y, p2.y, p3.y));

	return point;
};

SplineCurve.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.points = [];

	for (var i = 0, l = source.points.length; i < l; i++) {

		var point = source.points[i];

		this.points.push(point.clone());
	}

	return this;
};

SplineCurve.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.points = [];

	for (var i = 0, l = this.points.length; i < l; i++) {

		var point = this.points[i];
		data.points.push(point.toArray());
	}

	return data;
};

SplineCurve.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.points = [];

	for (var i = 0, l = json.points.length; i < l; i++) {

		var point = json.points[i];
		this.points.push(new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */]().fromArray(point));
	}

	return this;
};



/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BoxBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__ = __webpack_require__(2);








function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {

	__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].call(this);

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
	this.mergeVertices();
}

BoxGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].prototype);
BoxGeometry.prototype.constructor = BoxGeometry;

function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {

	__WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	width = width || 1;
	height = height || 1;
	depth = depth || 1;

	widthSegments = Math.floor(widthSegments) || 1;
	heightSegments = Math.floor(heightSegments) || 1;
	depthSegments = Math.floor(depthSegments) || 1;

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	var numberOfVertices = 0;
	var groupStart = 0;

	buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
	buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
	buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
	buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
	buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
	buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);

	this.setIndex(indices);
	this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](vertices, 3));
	this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](normals, 3));
	this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](uvs, 2));

	function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {

		var segmentWidth = width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var ix, iy;

		var vector = new __WEBPACK_IMPORTED_MODULE_4__math_Vector3_js__["a" /* Vector3 */]();

		for (iy = 0; iy < gridY1; iy++) {

			var y = iy * segmentHeight - heightHalf;

			for (ix = 0; ix < gridX1; ix++) {

				var x = ix * segmentWidth - widthHalf;

				vector[u] = x * udir;
				vector[v] = y * vdir;
				vector[w] = depthHalf;

				vertices.push(vector.x, vector.y, vector.z);

				vector[u] = 0;
				vector[v] = 0;
				vector[w] = depth > 0 ? 1 : -1;

				normals.push(vector.x, vector.y, vector.z);

				uvs.push(ix / gridX);
				uvs.push(1 - iy / gridY);

				vertexCounter += 1;
			}
		}

		for (iy = 0; iy < gridY; iy++) {

			for (ix = 0; ix < gridX; ix++) {

				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * (iy + 1);
				var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
				var d = numberOfVertices + (ix + 1) + gridX1 * iy;

				indices.push(a, b, d);
				indices.push(b, c, d);

				groupCount += 6;
			}
		}

		scope.addGroup(groupStart, groupCount, materialIndex);

		groupStart += groupCount;

		numberOfVertices += vertexCounter;
	}
}

BoxBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;



/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Light; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Color_js__ = __webpack_require__(9);





function Light(color, intensity) {

	__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].call(this);

	this.type = 'Light';

	this.color = new __WEBPACK_IMPORTED_MODULE_3__math_Color_js__["a" /* Color */](color);
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;
}

Light.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype), {

	constructor: Light,

	isLight: true,

	copy: function copy(source) {

		__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source);

		this.color.copy(source.color);
		this.intensity = source.intensity;

		return this;
	},

	toJSON: function toJSON(meta) {

		var data = __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();

		if (this.distance !== undefined) data.object.distance = this.distance;
		if (this.angle !== undefined) data.object.angle = this.angle;
		if (this.decay !== undefined) data.object.decay = this.decay;
		if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

		if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();

		return data;
	}

});



/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Cache; });


var Cache = {

	enabled: false,

	files: {},

	add: function add(key, file) {

		if (this.enabled === false) return;

		this.files[key] = file;
	},

	get: function get(key) {

		if (this.enabled === false) return;

		return this.files[key];
	},

	remove: function remove(key) {

		delete this.files[key];
	},

	clear: function clear() {

		this.files = {};
	}

};



/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cache_js__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LoadingManager_js__ = __webpack_require__(64);






var loading = {};

function FileLoader(manager) {

				this.manager = manager !== undefined ? manager : __WEBPACK_IMPORTED_MODULE_2__LoadingManager_js__["a" /* DefaultLoadingManager */];
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(FileLoader.prototype, {

				load: function load(url, onLoad, onProgress, onError) {

								if (url === undefined) url = '';

								if (this.path !== undefined) url = this.path + url;

								url = this.manager.resolveURL(url);

								var scope = this;

								var cached = __WEBPACK_IMPORTED_MODULE_1__Cache_js__["a" /* Cache */].get(url);

								if (cached !== undefined) {

												scope.manager.itemStart(url);

												setTimeout(function () {

																if (onLoad) onLoad(cached);

																scope.manager.itemEnd(url);
												}, 0);

												return cached;
								}

								if (loading[url] !== undefined) {

												loading[url].push({

																onLoad: onLoad,
																onProgress: onProgress,
																onError: onError

												});

												return;
								}

								var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
								var dataUriRegexResult = url.match(dataUriRegex);

								if (dataUriRegexResult) {

												var mimeType = dataUriRegexResult[1];
												var isBase64 = !!dataUriRegexResult[2];
												var data = dataUriRegexResult[3];

												data = decodeURIComponent(data);

												if (isBase64) data = atob(data);

												try {

																var response;
																var responseType = (this.responseType || '').toLowerCase();

																switch (responseType) {

																				case 'arraybuffer':
																				case 'blob':

																								var view = new Uint8Array(data.length);

																								for (var i = 0; i < data.length; i++) {

																												view[i] = data.charCodeAt(i);
																								}

																								if (responseType === 'blob') {

																												response = new Blob([view.buffer], { type: mimeType });
																								} else {

																												response = view.buffer;
																								}

																								break;

																				case 'document':

																								var parser = new DOMParser();
																								response = parser.parseFromString(data, mimeType);

																								break;

																				case 'json':

																								response = JSON.parse(data);

																								break;

																				default:

																								response = data;

																								break;

																}

																setTimeout(function () {

																				if (onLoad) onLoad(response);

																				scope.manager.itemEnd(url);
																}, 0);
												} catch (error) {
																setTimeout(function () {

																				if (onError) onError(error);

																				scope.manager.itemError(url);
																				scope.manager.itemEnd(url);
																}, 0);
												}
								} else {

												loading[url] = [];

												loading[url].push({

																onLoad: onLoad,
																onProgress: onProgress,
																onError: onError

												});

												var request = new XMLHttpRequest();

												request.open('GET', url, true);

												request.addEventListener('load', function (event) {

																var response = this.response;

																__WEBPACK_IMPORTED_MODULE_1__Cache_js__["a" /* Cache */].add(url, response);

																var callbacks = loading[url];

																delete loading[url];

																if (this.status === 200 || this.status === 0) {

																				if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

																				for (var i = 0, il = callbacks.length; i < il; i++) {

																								var callback = callbacks[i];
																								if (callback.onLoad) callback.onLoad(response);
																				}

																				scope.manager.itemEnd(url);
																} else {

																				for (var i = 0, il = callbacks.length; i < il; i++) {

																								var callback = callbacks[i];
																								if (callback.onError) callback.onError(event);
																				}

																				scope.manager.itemError(url);
																				scope.manager.itemEnd(url);
																}
												}, false);

												request.addEventListener('progress', function (event) {

																var callbacks = loading[url];

																for (var i = 0, il = callbacks.length; i < il; i++) {

																				var callback = callbacks[i];
																				if (callback.onProgress) callback.onProgress(event);
																}
												}, false);

												request.addEventListener('error', function (event) {

																var callbacks = loading[url];

																delete loading[url];

																for (var i = 0, il = callbacks.length; i < il; i++) {

																				var callback = callbacks[i];
																				if (callback.onError) callback.onError(event);
																}

																scope.manager.itemError(url);
																scope.manager.itemEnd(url);
												}, false);

												request.addEventListener('abort', function (event) {

																var callbacks = loading[url];

																delete loading[url];

																for (var i = 0, il = callbacks.length; i < il; i++) {

																				var callback = callbacks[i];
																				if (callback.onError) callback.onError(event);
																}

																scope.manager.itemError(url);
																scope.manager.itemEnd(url);
												}, false);

												if (this.responseType !== undefined) request.responseType = this.responseType;
												if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

												if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

												for (var header in this.requestHeader) {

																request.setRequestHeader(header, this.requestHeader[header]);
												}

												request.send(null);
								}

								scope.manager.itemStart(url);

								return request;
				},

				setPath: function setPath(value) {

								this.path = value;
								return this;
				},

				setResponseType: function setResponseType(value) {

								this.responseType = value;
								return this;
				},

				setWithCredentials: function setWithCredentials(value) {

								this.withCredentials = value;
								return this;
				},

				setMimeType: function setMimeType(value) {

								this.mimeType = value;
								return this;
				},

				setRequestHeader: function setRequestHeader(value) {

								this.requestHeader = value;
								return this;
				}

});



/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshBasicMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Color_js__ = __webpack_require__(9);





function MeshBasicMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].call(this);

	this.type = 'MeshBasicMaterial';

	this.color = new __WEBPACK_IMPORTED_MODULE_3__math_Color_js__["a" /* Color */](0xffffff);

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = __WEBPACK_IMPORTED_MODULE_2__constants_js__["z" /* MultiplyOperation */];
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.lights = false;

	this.setValues(parameters);
}

MeshBasicMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.color.copy(source.color);

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;
};



/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PointsMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Color_js__ = __webpack_require__(9);




function PointsMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].call(this);

	this.type = 'PointsMaterial';

	this.color = new __WEBPACK_IMPORTED_MODULE_2__math_Color_js__["a" /* Color */](0xffffff);

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.morphTargets = false;

	this.lights = false;

	this.setValues(parameters);
}

PointsMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype);
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.color.copy(source.color);

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.morphTargets = source.morphTargets;

	return this;
};



/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Euler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Math_js__ = __webpack_require__(8);







function Euler(x, y, z, order) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;
}

Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

Euler.DefaultOrder = 'XYZ';

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default()(Euler.prototype, {

		x: {

				get: function get() {

						return this._x;
				},

				set: function set(value) {

						this._x = value;
						this._onChangeCallback();
				}

		},

		y: {

				get: function get() {

						return this._y;
				},

				set: function set(value) {

						this._y = value;
						this._onChangeCallback();
				}

		},

		z: {

				get: function get() {

						return this._z;
				},

				set: function set(value) {

						this._z = value;
						this._onChangeCallback();
				}

		},

		order: {

				get: function get() {

						return this._order;
				},

				set: function set(value) {

						this._order = value;
						this._onChangeCallback();
				}

		}

});

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Euler.prototype, {

		isEuler: true,

		set: function set(x, y, z, order) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;

				this._onChangeCallback();

				return this;
		},

		clone: function clone() {

				return new this.constructor(this._x, this._y, this._z, this._order);
		},

		copy: function copy(euler) {

				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;

				this._onChangeCallback();

				return this;
		},

		setFromRotationMatrix: function setFromRotationMatrix(m, order, update) {

				var clamp = __WEBPACK_IMPORTED_MODULE_5__Math_js__["a" /* _Math */].clamp;

				var te = m.elements;
				var m11 = te[0],
				    m12 = te[4],
				    m13 = te[8];
				var m21 = te[1],
				    m22 = te[5],
				    m23 = te[9];
				var m31 = te[2],
				    m32 = te[6],
				    m33 = te[10];

				order = order || this._order;

				if (order === 'XYZ') {

						this._y = Math.asin(clamp(m13, -1, 1));

						if (Math.abs(m13) < 0.99999) {

								this._x = Math.atan2(-m23, m33);
								this._z = Math.atan2(-m12, m11);
						} else {

								this._x = Math.atan2(m32, m22);
								this._z = 0;
						}
				} else if (order === 'YXZ') {

						this._x = Math.asin(-clamp(m23, -1, 1));

						if (Math.abs(m23) < 0.99999) {

								this._y = Math.atan2(m13, m33);
								this._z = Math.atan2(m21, m22);
						} else {

								this._y = Math.atan2(-m31, m11);
								this._z = 0;
						}
				} else if (order === 'ZXY') {

						this._x = Math.asin(clamp(m32, -1, 1));

						if (Math.abs(m32) < 0.99999) {

								this._y = Math.atan2(-m31, m33);
								this._z = Math.atan2(-m12, m22);
						} else {

								this._y = 0;
								this._z = Math.atan2(m21, m11);
						}
				} else if (order === 'ZYX') {

						this._y = Math.asin(-clamp(m31, -1, 1));

						if (Math.abs(m31) < 0.99999) {

								this._x = Math.atan2(m32, m33);
								this._z = Math.atan2(m21, m11);
						} else {

								this._x = 0;
								this._z = Math.atan2(-m12, m22);
						}
				} else if (order === 'YZX') {

						this._z = Math.asin(clamp(m21, -1, 1));

						if (Math.abs(m21) < 0.99999) {

								this._x = Math.atan2(-m23, m22);
								this._y = Math.atan2(-m31, m11);
						} else {

								this._x = 0;
								this._y = Math.atan2(m13, m33);
						}
				} else if (order === 'XZY') {

						this._z = Math.asin(-clamp(m12, -1, 1));

						if (Math.abs(m12) < 0.99999) {

								this._x = Math.atan2(m32, m22);
								this._y = Math.atan2(m13, m11);
						} else {

								this._x = Math.atan2(-m23, m33);
								this._y = 0;
						}
				} else {

						console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
				}

				this._order = order;

				if (update !== false) this._onChangeCallback();

				return this;
		},

		setFromQuaternion: function () {

				var matrix = new __WEBPACK_IMPORTED_MODULE_4__Matrix4_js__["a" /* Matrix4 */]();

				return function setFromQuaternion(q, order, update) {

						matrix.makeRotationFromQuaternion(q);

						return this.setFromRotationMatrix(matrix, order, update);
				};
		}(),

		setFromVector3: function setFromVector3(v, order) {

				return this.set(v.x, v.y, v.z, order || this._order);
		},

		reorder: function () {

				var q = new __WEBPACK_IMPORTED_MODULE_2__Quaternion_js__["a" /* Quaternion */]();

				return function reorder(newOrder) {

						q.setFromEuler(this);

						return this.setFromQuaternion(q, newOrder);
				};
		}(),

		equals: function equals(euler) {

				return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		},

		fromArray: function fromArray(array) {

				this._x = array[0];
				this._y = array[1];
				this._z = array[2];
				if (array[3] !== undefined) this._order = array[3];

				this._onChangeCallback();

				return this;
		},

		toArray: function toArray(array, offset) {

				if (array === undefined) array = [];
				if (offset === undefined) offset = 0;

				array[offset] = this._x;
				array[offset + 1] = this._y;
				array[offset + 2] = this._z;
				array[offset + 3] = this._order;

				return array;
		},

		toVector3: function toVector3(optionalResult) {

				if (optionalResult) {

						return optionalResult.set(this._x, this._y, this._z);
				} else {

						return new __WEBPACK_IMPORTED_MODULE_3__Vector3_js__["a" /* Vector3 */](this._x, this._y, this._z);
				}
		},

		_onChange: function _onChange(callback) {

				this._onChangeCallback = callback;

				return this;
		},

		_onChangeCallback: function _onChangeCallback() {}

});



/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Triangle; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Vector3_js__ = __webpack_require__(2);



function Triangle(a, b, c) {

			this.a = a !== undefined ? a : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
			this.b = b !== undefined ? b : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
			this.c = c !== undefined ? c : new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Triangle, {

			getNormal: function () {

						var v0 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function getNormal(a, b, c, target) {

									if (target === undefined) {

												console.warn('THREE.Triangle: .getNormal() target is now required');
												target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
									}

									target.subVectors(c, b);
									v0.subVectors(a, b);
									target.cross(v0);

									var targetLengthSq = target.lengthSq();
									if (targetLengthSq > 0) {

												return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
									}

									return target.set(0, 0, 0);
						};
			}(),

			getBarycoord: function () {

						var v0 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var v2 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function getBarycoord(point, a, b, c, target) {

									v0.subVectors(c, a);
									v1.subVectors(b, a);
									v2.subVectors(point, a);

									var dot00 = v0.dot(v0);
									var dot01 = v0.dot(v1);
									var dot02 = v0.dot(v2);
									var dot11 = v1.dot(v1);
									var dot12 = v1.dot(v2);

									var denom = dot00 * dot11 - dot01 * dot01;

									if (target === undefined) {

												console.warn('THREE.Triangle: .getBarycoord() target is now required');
												target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
									}

									if (denom === 0) {
												return target.set(-2, -1, -1);
									}

									var invDenom = 1 / denom;
									var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
									var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

									return target.set(1 - u - v, v, u);
						};
			}(),

			containsPoint: function () {

						var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function containsPoint(point, a, b, c) {

									Triangle.getBarycoord(point, a, b, c, v1);

									return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
						};
			}(),

			getUV: function () {

						var barycoord = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {

									this.getBarycoord(point, p1, p2, p3, barycoord);

									target.set(0, 0);
									target.addScaledVector(uv1, barycoord.x);
									target.addScaledVector(uv2, barycoord.y);
									target.addScaledVector(uv3, barycoord.z);

									return target;
						};
			}(),

			isFrontFacing: function () {

						var v0 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function isFrontFacing(a, b, c, direction) {

									v0.subVectors(c, b);
									v1.subVectors(a, b);

									return v0.cross(v1).dot(direction) < 0 ? true : false;
						};
			}()

});

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Triangle.prototype, {

			set: function set(a, b, c) {

						this.a.copy(a);
						this.b.copy(b);
						this.c.copy(c);

						return this;
			},

			setFromPointsAndIndices: function setFromPointsAndIndices(points, i0, i1, i2) {

						this.a.copy(points[i0]);
						this.b.copy(points[i1]);
						this.c.copy(points[i2]);

						return this;
			},

			clone: function clone() {

						return new this.constructor().copy(this);
			},

			copy: function copy(triangle) {

						this.a.copy(triangle.a);
						this.b.copy(triangle.b);
						this.c.copy(triangle.c);

						return this;
			},

			getArea: function () {

						var v0 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var v1 = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function getArea() {

									v0.subVectors(this.c, this.b);
									v1.subVectors(this.a, this.b);

									return v0.cross(v1).length() * 0.5;
						};
			}(),

			getMidpoint: function getMidpoint(target) {

						if (target === undefined) {

									console.warn('THREE.Triangle: .getMidpoint() target is now required');
									target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						}

						return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
			},

			getNormal: function getNormal(target) {

						return Triangle.getNormal(this.a, this.b, this.c, target);
			},

			getPlane: function getPlane(target) {

						if (target === undefined) {

									console.warn('THREE.Triangle: .getPlane() target is now required');
									target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						}

						return target.setFromCoplanarPoints(this.a, this.b, this.c);
			},

			getBarycoord: function getBarycoord(point, target) {

						return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
			},

			getUV: function getUV(point, uv1, uv2, uv3, target) {

						return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
			},

			containsPoint: function containsPoint(point) {

						return Triangle.containsPoint(point, this.a, this.b, this.c);
			},

			isFrontFacing: function isFrontFacing(direction) {

						return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
			},

			intersectsBox: function intersectsBox(box) {

						return box.intersectsTriangle(this);
			},

			closestPointToPoint: function () {

						var vab = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var vac = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var vbc = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var vap = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var vbp = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
						var vcp = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();

						return function closestPointToPoint(p, target) {

									if (target === undefined) {

												console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
												target = new __WEBPACK_IMPORTED_MODULE_1__Vector3_js__["a" /* Vector3 */]();
									}

									var a = this.a,
									    b = this.b,
									    c = this.c;
									var v, w;

									vab.subVectors(b, a);
									vac.subVectors(c, a);
									vap.subVectors(p, a);
									var d1 = vab.dot(vap);
									var d2 = vac.dot(vap);
									if (d1 <= 0 && d2 <= 0) {
												return target.copy(a);
									}

									vbp.subVectors(p, b);
									var d3 = vab.dot(vbp);
									var d4 = vac.dot(vbp);
									if (d3 >= 0 && d4 <= d3) {
												return target.copy(b);
									}

									var vc = d1 * d4 - d3 * d2;
									if (vc <= 0 && d1 >= 0 && d3 <= 0) {

												v = d1 / (d1 - d3);

												return target.copy(a).addScaledVector(vab, v);
									}

									vcp.subVectors(p, c);
									var d5 = vab.dot(vcp);
									var d6 = vac.dot(vcp);
									if (d6 >= 0 && d5 <= d6) {
												return target.copy(c);
									}

									var vb = d5 * d2 - d1 * d6;
									if (vb <= 0 && d2 >= 0 && d6 <= 0) {

												w = d2 / (d2 - d6);

												return target.copy(a).addScaledVector(vac, w);
									}

									var va = d3 * d6 - d5 * d4;
									if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {

												vbc.subVectors(c, b);
												w = (d4 - d3) / (d4 - d3 + (d5 - d6));

												return target.copy(b).addScaledVector(vbc, w);
									}

									var denom = 1 / (va + vb + vc);

									v = vb * denom;
									w = vc * denom;
									return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
						};
			}(),

			equals: function equals(triangle) {

						return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
			}

});



/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineSegments; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Line_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute_js__ = __webpack_require__(12);






function LineSegments(geometry, material) {

					__WEBPACK_IMPORTED_MODULE_2__Line_js__["a" /* Line */].call(this, geometry, material);

					this.type = 'LineSegments';
}

LineSegments.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Line_js__["a" /* Line */].prototype), {

					constructor: LineSegments,

					isLineSegments: true,

					computeLineDistances: function () {

										var start = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
										var end = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

										return function computeLineDistances() {

															var geometry = this.geometry;

															if (geometry.isBufferGeometry) {

																				if (geometry.index === null) {

																									var positionAttribute = geometry.attributes.position;
																									var lineDistances = [];

																									for (var i = 0, l = positionAttribute.count; i < l; i += 2) {

																														start.fromBufferAttribute(positionAttribute, i);
																														end.fromBufferAttribute(positionAttribute, i + 1);

																														lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
																														lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
																									}

																									geometry.addAttribute('lineDistance', new __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](lineDistances, 1));
																				} else {

																									console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
																				}
															} else if (geometry.isGeometry) {

																				var vertices = geometry.vertices;
																				var lineDistances = geometry.lineDistances;

																				for (var i = 0, l = vertices.length; i < l; i += 2) {

																									start.copy(vertices[i]);
																									end.copy(vertices[i + 1]);

																									lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
																									lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
																				}
															}

															return this;
										};
					}()

});



/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PMBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Box3_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__math_Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__math_Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__VertexAttributeArray_js__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__constants_js__ = __webpack_require__(3);
















var PMBufferGeometryId = -1;

function PMBufferGeometry() {

  Object.defineProperty(this, 'id', { value: PMBufferGeometryId -= 1 });

  this.uuid = __WEBPACK_IMPORTED_MODULE_10__math_Math_js__["a" /* _Math */].generateUUID();

  this.name = '';
  this.type = 'PMBufferGeometry';

  this.attributeArray = new __WEBPACK_IMPORTED_MODULE_11__VertexAttributeArray_js__["a" /* VertexAttributeArray */]();

  this.indexArray = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  this.userData = {};
}

PMBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_4__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype), {

  constructor: PMBufferGeometry,

  isPMBufferGeometry: true,

  setUUID: function setUUID(value) {
    this.uuid = value;
  },

  getUUID: function getUUID() {
    return this.uuid;
  },

  setIndexArray: function setIndexArray(indexArray) {

    this.indexArray = indexArray;
  },

  getIndexArray: function getIndexArray() {

    return this.indexArray;
  },

  setAttributeArray: function setAttributeArray(attributeArray) {

    this.attributeArray = attributeArray;
  },

  getAttributeArray: function getAttributeArray() {

    return this.attributeArray;
  },

  addVertexIndex: function addVertexIndex(vertexIndex) {

    this.indexArray.push(vertexIndex);
  },

  getVertexIndex: function getVertexIndex(drawMode) {
    for (var i = 0, size = this.indexArray.length; i < size; i++) {

      var vertexIndex = this.indexArray[i];

      if (vertexIndex.getDrawMode() === drawMode) {

        return vertexIndex;
      }
    }

    return undefined;
  },

  getIndex: function getIndex(drawMode) {

    var vertexIndex = this.getVertexIndex(drawMode);
    if (vertexIndex) {
      return vertexIndex.getBufferAttribute();
    }

    return undefined;
  },

  addBufferAttribute: function addBufferAttribute(name, bufferAttribute) {

    if (!bufferAttribute) {

      return this;
    }

    if (name === 'index') {

      console.warn('PMBufferGeometry can\'t insert a index-buffer-attribute directly, please create \'VertexIndex\' object then use \'addVertexIndex\'. ');

      return this;
    }

    this.attributeArray.addBufferAttribute(name, bufferAttribute);

    return this;
  },

  getBufferAttribute: function getBufferAttribute(name) {

    return this.attributeArray.getBufferAttribute(name);
  },

  removeAttribute: function removeAttribute(name) {

    this.attributeArray.removeAttribute(name);

    return this;
  },

  updateAttribute: function updateAttribute(name, offset, array) {
    this.attributeArray.updateAttribute(name, offset, array);
  },

  applyMatrix: function applyMatrix(matrix) {

    var position = this.getBufferAttribute('position');

    if (position !== undefined) {

      matrix.applyToBufferAttribute(position);

      this.attributeArray.dirty();
    }

    var normal = this.getBufferAttribute('normal');

    if (normal !== undefined) {

      var normalMatrix = new __WEBPACK_IMPORTED_MODULE_9__math_Matrix3_js__["a" /* Matrix3 */]().getNormalMatrix(matrix);

      normalMatrix.applyToBufferAttribute(normal);

      this.attributeArray.dirty();
    }

    if (this.boundingBox !== null) {

      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {

      this.computeBoundingSphere();
    }

    return this;
  },

  rotateX: function () {

    var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

    return function rotateX(angle) {

      m1.makeRotationX(angle);

      this.applyMatrix(m1);

      return this;
    };
  }(),

  rotateY: function () {

    var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

    return function rotateY(angle) {

      m1.makeRotationY(angle);

      this.applyMatrix(m1);

      return this;
    };
  }(),

  rotateZ: function () {

    var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

    return function rotateZ(angle) {

      m1.makeRotationZ(angle);

      this.applyMatrix(m1);

      return this;
    };
  }(),

  translate: function () {

    var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

    return function translate(x, y, z) {

      m1.makeTranslation(x, y, z);

      this.applyMatrix(m1);

      return this;
    };
  }(),

  scale: function () {

    var m1 = new __WEBPACK_IMPORTED_MODULE_8__math_Matrix4_js__["a" /* Matrix4 */]();

    return function scale(x, y, z) {

      m1.makeScale(x, y, z);

      this.applyMatrix(m1);

      return this;
    };
  }(),

  lookAt: function () {

    var obj = new __WEBPACK_IMPORTED_MODULE_7__core_Object3D_js__["a" /* Object3D */]();

    return function lookAt(vector) {

      obj.lookAt(vector);

      obj.updateMatrix();

      this.applyMatrix(obj.matrix);
    };
  }(),

  center: function () {

    var offset = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();

    return function center() {

      this.computeBoundingBox();

      this.boundingBox.getCenter(offset).negate();

      this.translate(offset.x, offset.y, offset.z);

      return this;
    };
  }(),

  computeBoundingBox: function () {

    var box = new __WEBPACK_IMPORTED_MODULE_3__math_Box3_js__["a" /* Box3 */]();

    return function computeBoundingBox() {

      if (this.boundingBox === null) {

        this.boundingBox = new __WEBPACK_IMPORTED_MODULE_3__math_Box3_js__["a" /* Box3 */]();
      }

      var position = this.getBufferAttribute('position');

      if (position !== undefined) {

        this.boundingBox.setFromBufferAttribute(position);
      } else {

        this.boundingBox.makeEmpty();
      }

      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

        console.error('PMBufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(),

  computeBoundingSphere: function () {

    var box = new __WEBPACK_IMPORTED_MODULE_3__math_Box3_js__["a" /* Box3 */]();
    var boxMorphTargets = new __WEBPACK_IMPORTED_MODULE_3__math_Box3_js__["a" /* Box3 */]();
    var vector = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();

    return function computeBoundingSphere() {

      if (this.boundingSphere === null) {

        this.boundingSphere = new __WEBPACK_IMPORTED_MODULE_6__math_Sphere_js__["a" /* Sphere */]();
      }

      var position = this.getBufferAttribute('position');

      if (position) {

        var center = this.boundingSphere.center;

        box.setFromBufferAttribute(position);

        box.getCenter(center);

        var maxRadiusSq = 0;

        for (var i = 0, il = position.count; i < il; i++) {

          vector.fromBufferAttribute(position, i);

          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {

          console.error('PMBufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),

  computeFaceNormals: function computeFaceNormals() {},

  computeVertexNormals: function computeVertexNormals() {

    var indexAttribute = this.getIndex(__WEBPACK_IMPORTED_MODULE_12__constants_js__["e" /* DRAWMODE */].TRIANGLES);

    var positionsAttribute = this.getBufferAttribute('position');

    if (!positionsAttribute || !indexAttribute) {

      return;
    }

    var normalAttribute = this.getBufferAttribute('normal');

    if (!normalAttribute) {

      normalAttribute = new __WEBPACK_IMPORTED_MODULE_5__core_BufferAttribute_js__["k" /* BufferAttribute */](new Float32Array(positionsAttribute.array.length), 3);
      this.addBufferAttribute('normal', normalAttribute);
    }

    var vA = void 0,
        vB = void 0,
        vC = void 0;
    var pA = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */](),
        pB = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */](),
        pC = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();
    var cb = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */](),
        ab = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();

    var indices = indexAttribute.array;
    var positions = positionsAttribute.array;
    var normals = normalAttribute.array;

    for (var i = 0, il = indexAttribute.count; i < il; i += 3) {

      vA = indices[i + 0] * 3;
      vB = indices[i + 1] * 3;
      vC = indices[i + 2] * 3;

      pA.fromArray(positions, vA);
      pB.fromArray(positions, vB);
      pC.fromArray(positions, vC);

      cb.subVectors(pC, pB);
      ab.subVectors(pA, pB);
      cb.cross(ab);

      normals[vA] += cb.x;
      normals[vA + 1] += cb.y;
      normals[vA + 2] += cb.z;

      normals[vB] += cb.x;
      normals[vB + 1] += cb.y;
      normals[vB + 2] += cb.z;

      normals[vC] += cb.x;
      normals[vC + 1] += cb.y;
      normals[vC + 2] += cb.z;
    }

    this.normalizeNormals();

    this.attributeArray.dirty();
  },

  normalizeNormals: function () {

    var vector = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();

    return function normalizeNormals() {

      var normals = this.getBufferAttribute('normal');

      for (var i = 0, il = normals.count; i < il; i++) {

        vector.x = normals.getX(i);
        vector.y = normals.getY(i);
        vector.z = normals.getZ(i);

        vector.normalize();

        normals.setXYZ(i, vector.x, vector.y, vector.z);
      }
    };
  }(),

  clone: function clone() {

    return new PMBufferGeometry().copy(this);
  },

  dispose: function dispose() {

    this.dispatchEvent({ type: 'dispose' });
  }

});



/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PMInstanceBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PMInstanceAttribute; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PMBufferGeometry_js__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__VertexAttributeArray_js__ = __webpack_require__(97);







var PMInstanceAttribute = {
  MatrixR1: { name: 'instanceMatrixR1', itemSize: 4 },
  MatrixR2: { name: 'instanceMatrixR2', itemSize: 4 },
  MatrixR3: { name: 'instanceMatrixR3', itemSize: 4 },
  MatrixR4: { name: 'instanceMatrixR4', itemSize: 4 },
  Color: { name: 'instanceColor', itemSize: 4 },
  State: { name: 'instanceState', itemSize: 2 }
};

function PMInstanceBufferGeometry() {

  __WEBPACK_IMPORTED_MODULE_2__PMBufferGeometry_js__["a" /* PMBufferGeometry */].call(this);

  this.type = 'PMInstancedBufferGeometry';

  this.instanceAttributeArray = new __WEBPACK_IMPORTED_MODULE_3__VertexAttributeArray_js__["a" /* VertexAttributeArray */]();

  this.instancedCount = 0;

  this.pickMatrixIndex = [];
}

PMInstanceBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__PMBufferGeometry_js__["a" /* PMBufferGeometry */].prototype), {

  constructor: PMInstanceBufferGeometry,

  isPMInstanceBufferGeometry: true,

  getInstanceAttributeArray: function getInstanceAttributeArray() {

    return this.instanceAttributeArray;
  },

  addInstanceBufferAttribute: function addInstanceBufferAttribute(name, bufferAttribute) {

    this.instanceAttributeArray.addBufferAttribute(name, bufferAttribute);
  },

  getInstanceBufferAttribute: function getInstanceBufferAttribute(name) {

    return this.instanceAttributeArray.getBufferAttribute(name);
  },

  removeInstanceAttribute: function removeInstanceAttribute(name) {

    this.instanceAttributeArray.removeAttribute(name);
  },

  setInstancedCount: function setInstancedCount(value) {

    this.instancedCount = value;
  },

  getInstancedCount: function getInstancedCount() {

    return this.instancedCount;
  },

  addPickMatrixIndex: function addPickMatrixIndex(matrixIndex) {
    this.pickMatrixIndex.push(matrixIndex);
  },

  removePickMatrixIndex: function removePickMatrixIndex(matrixIndex) {
    for (var i = 0, il = this.pickMatrixIndex.length; i < il; i++) {
      if (matrixIndex === this.pickMatrixIndex[i]) {
        this.pickMatrixIndex.splice(i, 1);
        break;
      }
    }
  },

  getPickMatrixIndexArray: function getPickMatrixIndexArray() {
    return this.pickMatrixIndex;
  },

  clearPickMatrixIndex: function clearPickMatrixIndex() {
    this.pickMatrixIndex = [];
  },

  getTransparency: function getTransparency() {
    var indexArray = this.getIndexArray();
    for (var i = 0, il = indexArray.length; i < il; i++) {
      var indexRangeArray = indexArray[i].getIndexRangeArray();
      for (var j = 0, jl = indexRangeArray.length; j < jl; j++) {
        if (indexRangeArray[j].getTransparency()) {
          return true;
        }
      }
    }
    return undefined;
  }
});



/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VertexAttribute; });


function VertexAttribute(name, bufferAttribute) {

  this.type = 'VertexAttribute';

  this.name = name;

  this.bufferAttribute = bufferAttribute;

  this.layout = -1;

  this.offset = 0;
}

VertexAttribute.prototype = {

  constructor: VertexAttribute,

  getName: function getName() {

    return this.name;
  },

  setBufferAttribute: function setBufferAttribute(bufferAttribute) {

    this.bufferAttribute = bufferAttribute;
  },

  getBufferAttribute: function getBufferAttribute() {

    return this.bufferAttribute;
  },

  setLayout: function setLayout(layout) {

    this.layout = layout;
  },

  getLayout: function getLayout() {

    return this.layout;
  },

  setOffset: function setOffset(offset) {

    this.offset = offset;
  },

  getOffset: function getOffset() {

    return this.offset;
  }
};



/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopyShader; });


var CopyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")

};



/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MaskPass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ClearMaskPass; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EffectComposer__ = __webpack_require__(54);






function MaskPass(scene, camera) {

	__WEBPACK_IMPORTED_MODULE_2__EffectComposer__["b" /* Pass */].call(this);

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;
};

MaskPass.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__EffectComposer__["b" /* Pass */].prototype), {

	constructor: MaskPass,

	render: function render(renderer, writeBuffer, readBuffer) {

		var context = renderer.context;
		var state = renderer.state;

		state.buffers.color.setMask(false);
		state.buffers.depth.setMask(false);

		state.buffers.color.setLocked(true);
		state.buffers.depth.setLocked(true);

		var writeValue, clearValue;

		if (this.inverse) {

			writeValue = 0;
			clearValue = 1;
		} else {

			writeValue = 1;
			clearValue = 0;
		}

		state.buffers.stencil.setTest(true);
		state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
		state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
		state.buffers.stencil.setClear(clearValue);

		renderer.setRenderTarget(readBuffer);
		if (this.clear) renderer.clear();
		renderer.render(this.scene, this.camera);

		renderer.setRenderTarget(writeBuffer);
		if (this.clear) renderer.clear();
		renderer.render(this.scene, this.camera);

		state.buffers.color.setLocked(false);
		state.buffers.depth.setLocked(false);

		state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff);
		state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
	}

});

function ClearMaskPass() {

	__WEBPACK_IMPORTED_MODULE_2__EffectComposer__["b" /* Pass */].call(this);

	this.needsSwap = false;
};

ClearMaskPass.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__EffectComposer__["b" /* Pass */].prototype);

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(ClearMaskPass.prototype, {

	render: function render(renderer) {

		renderer.state.buffers.stencil.setTest(false);
	}

});



/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SMAAEdgesShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SMAAWeightsShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SMAABlendShader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Vector2__ = __webpack_require__(4);




var SMAAEdgesShader = {

	defines: {

		"SMAA_THRESHOLD": "0.1"

	},

	uniforms: {

		"tDiffuse": { value: null },
		"resolution": { value: new __WEBPACK_IMPORTED_MODULE_0__math_Vector2__["a" /* Vector2 */](1 / 1024, 1 / 512) }

	},

	vertexShader: ["uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 3 ];", "void SMAAEdgeDetectionVS( vec2 texcoord ) {", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );", "vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );", "vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );", "}", "void main() {", "vUv = uv;", "SMAAEdgeDetectionVS( vUv );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "varying vec4 vOffset[ 3 ];", "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {", "vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );", "vec4 delta;", "vec3 C = texture2D( colorTex, texcoord ).rgb;", "vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;", "vec3 t = abs( C - Cleft );", "delta.x = max( max( t.r, t.g ), t.b );", "vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;", "t = abs( C - Ctop );", "delta.y = max( max( t.r, t.g ), t.b );", "vec2 edges = step( threshold, delta.xy );", "if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )", "discard;", "vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;", "t = abs( C - Cright );", "delta.z = max( max( t.r, t.g ), t.b );", "vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;", "t = abs( C - Cbottom );", "delta.w = max( max( t.r, t.g ), t.b );", "float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );", "vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;", "t = abs( C - Cleftleft );", "delta.z = max( max( t.r, t.g ), t.b );", "vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;", "t = abs( C - Ctoptop );", "delta.w = max( max( t.r, t.g ), t.b );", "maxDelta = max( max( maxDelta, delta.z ), delta.w );", "edges.xy *= step( 0.5 * maxDelta, delta.xy );", "return vec4( edges, 0.0, 0.0 );", "}", "void main() {", "gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );", "}"].join("\n")

};

var SMAAWeightsShader = {

	defines: {

		"SMAA_MAX_SEARCH_STEPS": "8",
		"SMAA_AREATEX_MAX_DISTANCE": "16",
		"SMAA_AREATEX_PIXEL_SIZE": "( 1.0 / vec2( 160.0, 560.0 ) )",
		"SMAA_AREATEX_SUBTEX_SIZE": "( 1.0 / 7.0 )"

	},

	uniforms: {

		"tDiffuse": { value: null },
		"tArea": { value: null },
		"tSearch": { value: null },
		"resolution": { value: new __WEBPACK_IMPORTED_MODULE_0__math_Vector2__["a" /* Vector2 */](1 / 1024, 1 / 512) }

	},

	vertexShader: ["uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 3 ];", "varying vec2 vPixcoord;", "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {", "vPixcoord = texcoord / resolution;", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );", "vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );", "vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );", "}", "void main() {", "vUv = uv;", "SMAABlendingWeightCalculationVS( vUv );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )", "uniform sampler2D tDiffuse;", "uniform sampler2D tArea;", "uniform sampler2D tSearch;", "uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[3];", "varying vec2 vPixcoord;", "#if __VERSION__ == 100", "vec2 round( vec2 x ) {", "return sign( x ) * floor( abs( x ) + 0.5 );", "}", "#endif", "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {", "e.r = bias + e.r * scale;", "return 255.0 * texture2D( searchTex, e, 0.0 ).r;", "}", "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 0.0, 1.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", "e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord -= vec2( 2.0, 0.0 ) * resolution;", "if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;", "}", "texcoord.x += 0.25 * resolution.x;", "texcoord.x += resolution.x;", "texcoord.x += 2.0 * resolution.x;", "texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);", "return texcoord.x;", "}", "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 0.0, 1.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", "e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord += vec2( 2.0, 0.0 ) * resolution;", "if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;", "}", "texcoord.x -= 0.25 * resolution.x;", "texcoord.x -= resolution.x;", "texcoord.x -= 2.0 * resolution.x;", "texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );", "return texcoord.x;", "}", "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 1.0, 0.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", "e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord += vec2( 0.0, 2.0 ) * resolution;", "if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;", "}", "texcoord.y -= 0.25 * resolution.y;", "texcoord.y -= resolution.y;", "texcoord.y -= 2.0 * resolution.y;", "texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );", "return texcoord.y;", "}", "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 1.0, 0.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", "e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord -= vec2( 0.0, 2.0 ) * resolution;", "if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;", "}", "texcoord.y += 0.25 * resolution.y;", "texcoord.y += resolution.y;", "texcoord.y += 2.0 * resolution.y;", "texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );", "return texcoord.y;", "}", "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {", "vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;", "texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );", "texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;", "return texture2D( areaTex, texcoord, 0.0 ).rg;", "}", "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {", "vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );", "vec2 e = texture2D( edgesTex, texcoord ).rg;", "if ( e.g > 0.0 ) {", "vec2 d;", "vec2 coords;", "coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );", "coords.y = offset[ 1 ].y;", "d.x = coords.x;", "float e1 = texture2D( edgesTex, coords, 0.0 ).r;", "coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );", "d.y = coords.x;", "d = d / resolution.x - pixcoord.x;", "vec2 sqrt_d = sqrt( abs( d ) );", "coords.y -= 1.0 * resolution.y;", "float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;", "weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );", "}", "if ( e.r > 0.0 ) {", "vec2 d;", "vec2 coords;", "coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );", "coords.x = offset[ 0 ].x;", "d.x = coords.y;", "float e1 = texture2D( edgesTex, coords, 0.0 ).g;", "coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );", "d.y = coords.y;", "d = d / resolution.y - pixcoord.y;", "vec2 sqrt_d = sqrt( abs( d ) );", "coords.y -= 1.0 * resolution.y;", "float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;", "weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );", "}", "return weights;", "}", "void main() {", "gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );", "}"].join("\n")

};

var SMAABlendShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"tColor": { value: null },
		"resolution": { value: new __WEBPACK_IMPORTED_MODULE_0__math_Vector2__["a" /* Vector2 */](1 / 1024, 1 / 512) }

	},

	vertexShader: ["uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 2 ];", "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );", "vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );", "}", "void main() {", "vUv = uv;", "SMAANeighborhoodBlendingVS( vUv );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform sampler2D tColor;", "uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 2 ];", "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {", "vec4 a;", "a.xz = texture2D( blendTex, texcoord ).xz;", "a.y = texture2D( blendTex, offset[ 1 ].zw ).g;", "a.w = texture2D( blendTex, offset[ 1 ].xy ).a;", "if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {", "return texture2D( colorTex, texcoord, 0.0 );", "} else {", "vec2 offset;", "offset.x = a.a > a.b ? a.a : -a.b;", "offset.y = a.g > a.r ? -a.g : a.r;", "if ( abs( offset.x ) > abs( offset.y )) {", "offset.y = 0.0;", "} else {", "offset.x = 0.0;", "}", "vec4 C = texture2D( colorTex, texcoord, 0.0 );", "texcoord += sign( offset ) * resolution;", "vec4 Cop = texture2D( colorTex, texcoord, 0.0 );", "float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );", "C.xyz = pow(C.xyz, vec3(2.2));", "Cop.xyz = pow(Cop.xyz, vec3(2.2));", "vec4 mixed = mix(C, Cop, s);", "mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));", "return mixed;", "}", "}", "void main() {", "gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );", "}"].join("\n")

};



/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderPass; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__renderers_shaders_UniformsUtils__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__materials_ShaderMaterial__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EffectComposer__ = __webpack_require__(54);








function ShaderPass(shader, textureID) {

	__WEBPACK_IMPORTED_MODULE_4__EffectComposer__["b" /* Pass */].call(this);

	this.textureID = textureID !== undefined ? textureID : "tDiffuse";

	if (shader instanceof __WEBPACK_IMPORTED_MODULE_3__materials_ShaderMaterial__["a" /* ShaderMaterial */]) {

		this.uniforms = shader.uniforms;

		this.material = shader;
	} else if (shader) {

		this.uniforms = __WEBPACK_IMPORTED_MODULE_2__renderers_shaders_UniformsUtils__["c" /* clone */](shader.uniforms);

		this.material = new __WEBPACK_IMPORTED_MODULE_3__materials_ShaderMaterial__["a" /* ShaderMaterial */]({

			defines: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, shader.defines),
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		});
	}

	this.fsQuad = new __WEBPACK_IMPORTED_MODULE_4__EffectComposer__["b" /* Pass */].FullScreenQuad(this.material);
};

ShaderPass.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_4__EffectComposer__["b" /* Pass */].prototype), {

	constructor: ShaderPass,

	render: function render(renderer, writeBuffer, readBuffer) {

		if (this.uniforms[this.textureID]) {

			this.uniforms[this.textureID].value = readBuffer.texture;
		}

		this.fsQuad.material = this.material;

		if (this.renderToScreen) {

			renderer.setRenderTarget(null);
			this.fsQuad.render(renderer);
		} else {

			renderer.setRenderTarget(writeBuffer);

			if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			this.fsQuad.render(renderer);
		}
	}

});



/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderChunk; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_alphamap_fragment_glsl_js__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ShaderChunk_alphamap_pars_fragment_glsl_js__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ShaderChunk_alphatest_fragment_glsl_js__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ShaderChunk_aomap_fragment_glsl_js__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ShaderChunk_aomap_pars_fragment_glsl_js__ = __webpack_require__(303);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ShaderChunk_begin_vertex_glsl_js__ = __webpack_require__(304);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ShaderChunk_beginnormal_vertex_glsl_js__ = __webpack_require__(305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ShaderChunk_bsdfs_glsl_js__ = __webpack_require__(306);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ShaderChunk_bumpmap_pars_fragment_glsl_js__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ShaderChunk_clipping_planes_fragment_glsl_js__ = __webpack_require__(308);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ShaderChunk_clipping_planes_pars_fragment_glsl_js__ = __webpack_require__(309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ShaderChunk_clipping_planes_pars_vertex_glsl_js__ = __webpack_require__(310);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ShaderChunk_clipping_planes_vertex_glsl_js__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__ShaderChunk_color_fragment_glsl_js__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__ShaderChunk_color_pars_fragment_glsl_js__ = __webpack_require__(313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__ShaderChunk_color_pars_vertex_glsl_js__ = __webpack_require__(314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__ShaderChunk_color_vertex_glsl_js__ = __webpack_require__(315);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__ShaderChunk_common_glsl_js__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__ShaderChunk_cube_uv_reflection_fragment_glsl_js__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__ShaderChunk_defaultnormal_vertex_glsl_js__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__ShaderChunk_displacementmap_pars_vertex_glsl_js__ = __webpack_require__(321);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__ShaderChunk_displacementmap_vertex_glsl_js__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__ShaderChunk_emissivemap_fragment_glsl_js__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__ShaderChunk_emissivemap_pars_fragment_glsl_js__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__ShaderChunk_encodings_fragment_glsl_js__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__ShaderChunk_encodings_pars_fragment_glsl_js__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__ShaderChunk_envmap_fragment_glsl_js__ = __webpack_require__(329);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__ShaderChunk_envmap_pars_fragment_glsl_js__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__ShaderChunk_envmap_pars_vertex_glsl_js__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__ShaderChunk_envmap_vertex_glsl_js__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__ShaderChunk_fog_vertex_glsl_js__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__ShaderChunk_fog_pars_vertex_glsl_js__ = __webpack_require__(336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__ShaderChunk_fog_fragment_glsl_js__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__ShaderChunk_fog_pars_fragment_glsl_js__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__ShaderChunk_gradientmap_pars_fragment_glsl_js__ = __webpack_require__(338);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__ShaderChunk_lightmap_fragment_glsl_js__ = __webpack_require__(343);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__ShaderChunk_lightmap_pars_fragment_glsl_js__ = __webpack_require__(344);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__ShaderChunk_lights_lambert_vertex_glsl_js__ = __webpack_require__(348);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__ShaderChunk_lights_pars_begin_glsl_js__ = __webpack_require__(349);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__ShaderChunk_envmap_physical_pars_fragment_glsl_js__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__ShaderChunk_lights_phong_fragment_glsl_js__ = __webpack_require__(350);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__ShaderChunk_lights_phong_pars_fragment_glsl_js__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__ShaderChunk_lights_physical_fragment_glsl_js__ = __webpack_require__(352);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__ShaderChunk_lights_physical_pars_fragment_glsl_js__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__ShaderChunk_lights_fragment_begin_glsl_js__ = __webpack_require__(345);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__ShaderChunk_lights_fragment_maps_glsl_js__ = __webpack_require__(347);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__ShaderChunk_lights_fragment_end_glsl_js__ = __webpack_require__(346);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__ShaderChunk_logdepthbuf_fragment_glsl_js__ = __webpack_require__(354);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__ShaderChunk_logdepthbuf_pars_fragment_glsl_js__ = __webpack_require__(355);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__ShaderChunk_logdepthbuf_pars_vertex_glsl_js__ = __webpack_require__(356);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__ShaderChunk_logdepthbuf_vertex_glsl_js__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__ShaderChunk_map_fragment_glsl_js__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__ShaderChunk_map_pars_fragment_glsl_js__ = __webpack_require__(359);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__ShaderChunk_map_particle_fragment_glsl_js__ = __webpack_require__(360);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__ShaderChunk_map_particle_pars_fragment_glsl_js__ = __webpack_require__(361);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__ShaderChunk_metalnessmap_fragment_glsl_js__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__ShaderChunk_metalnessmap_pars_fragment_glsl_js__ = __webpack_require__(363);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__ShaderChunk_morphnormal_vertex_glsl_js__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__ShaderChunk_morphtarget_pars_vertex_glsl_js__ = __webpack_require__(365);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__ShaderChunk_morphtarget_vertex_glsl_js__ = __webpack_require__(366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__ShaderChunk_normal_fragment_begin_glsl_js__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__ShaderChunk_normal_fragment_maps_glsl_js__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__ShaderChunk_normalmap_pars_fragment_glsl_js__ = __webpack_require__(369);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__ShaderChunk_packing_glsl_js__ = __webpack_require__(372);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__ShaderChunk_premultiplied_alpha_fragment_glsl_js__ = __webpack_require__(373);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__ShaderChunk_project_vertex_glsl_js__ = __webpack_require__(374);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__ShaderChunk_dithering_fragment_glsl_js__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__ShaderChunk_dithering_pars_fragment_glsl_js__ = __webpack_require__(324);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__ShaderChunk_roughnessmap_fragment_glsl_js__ = __webpack_require__(375);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__ShaderChunk_roughnessmap_pars_fragment_glsl_js__ = __webpack_require__(376);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__ShaderChunk_shadowmap_pars_fragment_glsl_js__ = __webpack_require__(377);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71__ShaderChunk_shadowmap_pars_vertex_glsl_js__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72__ShaderChunk_shadowmap_vertex_glsl_js__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_73__ShaderChunk_shadowmask_pars_fragment_glsl_js__ = __webpack_require__(380);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_74__ShaderChunk_skinbase_vertex_glsl_js__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_75__ShaderChunk_skinning_pars_vertex_glsl_js__ = __webpack_require__(382);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_76__ShaderChunk_skinning_vertex_glsl_js__ = __webpack_require__(383);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_77__ShaderChunk_skinnormal_vertex_glsl_js__ = __webpack_require__(384);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_78__ShaderChunk_specularmap_fragment_glsl_js__ = __webpack_require__(385);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_79__ShaderChunk_specularmap_pars_fragment_glsl_js__ = __webpack_require__(386);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_80__ShaderChunk_tonemapping_fragment_glsl_js__ = __webpack_require__(387);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_81__ShaderChunk_tonemapping_pars_fragment_glsl_js__ = __webpack_require__(388);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_82__ShaderChunk_uv_pars_fragment_glsl_js__ = __webpack_require__(392);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_83__ShaderChunk_uv_pars_vertex_glsl_js__ = __webpack_require__(393);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_84__ShaderChunk_uv_vertex_glsl_js__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_85__ShaderChunk_uv2_pars_fragment_glsl_js__ = __webpack_require__(389);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_86__ShaderChunk_uv2_pars_vertex_glsl_js__ = __webpack_require__(390);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_87__ShaderChunk_uv2_vertex_glsl_js__ = __webpack_require__(391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_88__ShaderChunk_worldpos_vertex_glsl_js__ = __webpack_require__(395);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_89__ShaderChunk_instance_attribute_pars_vertex_glsl__ = __webpack_require__(341);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_90__ShaderChunk_instance_attribute_vertex_glsl__ = __webpack_require__(342);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_91__ShaderChunk_instance_attribute_pars_fragment_glsl__ = __webpack_require__(340);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_92__ShaderChunk_instance_attribute_fragment_glsl__ = __webpack_require__(339);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_93__ShaderChunk_offset_position_pars_vertex_glsl__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_94__ShaderChunk_offset_position_vertex_glsl__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_95__ShaderLib_background_frag_glsl_js__ = __webpack_require__(396);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_96__ShaderLib_background_vert_glsl_js__ = __webpack_require__(397);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_97__ShaderLib_cube_frag_glsl_js__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_98__ShaderLib_cube_vert_glsl_js__ = __webpack_require__(399);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_99__ShaderLib_depth_frag_glsl_js__ = __webpack_require__(400);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_100__ShaderLib_depth_vert_glsl_js__ = __webpack_require__(401);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_101__ShaderLib_distanceRGBA_frag_glsl_js__ = __webpack_require__(402);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_102__ShaderLib_distanceRGBA_vert_glsl_js__ = __webpack_require__(403);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_103__ShaderLib_equirect_frag_glsl_js__ = __webpack_require__(404);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_104__ShaderLib_equirect_vert_glsl_js__ = __webpack_require__(405);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_105__ShaderLib_linedashed_frag_glsl_js__ = __webpack_require__(406);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_106__ShaderLib_linedashed_vert_glsl_js__ = __webpack_require__(407);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_107__ShaderLib_meshbasic_frag_glsl_js__ = __webpack_require__(408);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_108__ShaderLib_meshbasic_vert_glsl_js__ = __webpack_require__(409);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_109__ShaderLib_meshlambert_frag_glsl_js__ = __webpack_require__(410);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_110__ShaderLib_meshlambert_vert_glsl_js__ = __webpack_require__(411);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_111__ShaderLib_meshmatcap_frag_glsl_js__ = __webpack_require__(412);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_112__ShaderLib_meshmatcap_vert_glsl_js__ = __webpack_require__(413);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_113__ShaderLib_meshphong_frag_glsl_js__ = __webpack_require__(414);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_114__ShaderLib_meshphong_vert_glsl_js__ = __webpack_require__(415);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_115__ShaderLib_meshphysical_frag_glsl_js__ = __webpack_require__(416);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_116__ShaderLib_meshphysical_vert_glsl_js__ = __webpack_require__(417);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_117__ShaderLib_normal_frag_glsl_js__ = __webpack_require__(418);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_118__ShaderLib_normal_vert_glsl_js__ = __webpack_require__(419);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_119__ShaderLib_points_frag_glsl_js__ = __webpack_require__(420);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_120__ShaderLib_points_vert_glsl_js__ = __webpack_require__(421);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_121__ShaderLib_shadow_frag_glsl_js__ = __webpack_require__(422);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_122__ShaderLib_shadow_vert_glsl_js__ = __webpack_require__(423);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_123__ShaderLib_sprite_frag_glsl_js__ = __webpack_require__(424);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_124__ShaderLib_sprite_vert_glsl_js__ = __webpack_require__(425);































































































































var ShaderChunk = {
	alphamap_fragment: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_alphamap_fragment_glsl_js__["a" /* default */],
	alphamap_pars_fragment: __WEBPACK_IMPORTED_MODULE_1__ShaderChunk_alphamap_pars_fragment_glsl_js__["a" /* default */],
	alphatest_fragment: __WEBPACK_IMPORTED_MODULE_2__ShaderChunk_alphatest_fragment_glsl_js__["a" /* default */],
	aomap_fragment: __WEBPACK_IMPORTED_MODULE_3__ShaderChunk_aomap_fragment_glsl_js__["a" /* default */],
	aomap_pars_fragment: __WEBPACK_IMPORTED_MODULE_4__ShaderChunk_aomap_pars_fragment_glsl_js__["a" /* default */],
	begin_vertex: __WEBPACK_IMPORTED_MODULE_5__ShaderChunk_begin_vertex_glsl_js__["a" /* default */],
	beginnormal_vertex: __WEBPACK_IMPORTED_MODULE_6__ShaderChunk_beginnormal_vertex_glsl_js__["a" /* default */],
	bsdfs: __WEBPACK_IMPORTED_MODULE_7__ShaderChunk_bsdfs_glsl_js__["a" /* default */],
	bumpmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_8__ShaderChunk_bumpmap_pars_fragment_glsl_js__["a" /* default */],
	clipping_planes_fragment: __WEBPACK_IMPORTED_MODULE_9__ShaderChunk_clipping_planes_fragment_glsl_js__["a" /* default */],
	clipping_planes_pars_fragment: __WEBPACK_IMPORTED_MODULE_10__ShaderChunk_clipping_planes_pars_fragment_glsl_js__["a" /* default */],
	clipping_planes_pars_vertex: __WEBPACK_IMPORTED_MODULE_11__ShaderChunk_clipping_planes_pars_vertex_glsl_js__["a" /* default */],
	clipping_planes_vertex: __WEBPACK_IMPORTED_MODULE_12__ShaderChunk_clipping_planes_vertex_glsl_js__["a" /* default */],
	color_fragment: __WEBPACK_IMPORTED_MODULE_13__ShaderChunk_color_fragment_glsl_js__["a" /* default */],
	color_pars_fragment: __WEBPACK_IMPORTED_MODULE_14__ShaderChunk_color_pars_fragment_glsl_js__["a" /* default */],
	color_pars_vertex: __WEBPACK_IMPORTED_MODULE_15__ShaderChunk_color_pars_vertex_glsl_js__["a" /* default */],
	color_vertex: __WEBPACK_IMPORTED_MODULE_16__ShaderChunk_color_vertex_glsl_js__["a" /* default */],
	common: __WEBPACK_IMPORTED_MODULE_17__ShaderChunk_common_glsl_js__["a" /* default */],
	cube_uv_reflection_fragment: __WEBPACK_IMPORTED_MODULE_18__ShaderChunk_cube_uv_reflection_fragment_glsl_js__["a" /* default */],
	defaultnormal_vertex: __WEBPACK_IMPORTED_MODULE_19__ShaderChunk_defaultnormal_vertex_glsl_js__["a" /* default */],
	displacementmap_pars_vertex: __WEBPACK_IMPORTED_MODULE_20__ShaderChunk_displacementmap_pars_vertex_glsl_js__["a" /* default */],
	displacementmap_vertex: __WEBPACK_IMPORTED_MODULE_21__ShaderChunk_displacementmap_vertex_glsl_js__["a" /* default */],
	emissivemap_fragment: __WEBPACK_IMPORTED_MODULE_22__ShaderChunk_emissivemap_fragment_glsl_js__["a" /* default */],
	emissivemap_pars_fragment: __WEBPACK_IMPORTED_MODULE_23__ShaderChunk_emissivemap_pars_fragment_glsl_js__["a" /* default */],
	encodings_fragment: __WEBPACK_IMPORTED_MODULE_24__ShaderChunk_encodings_fragment_glsl_js__["a" /* default */],
	encodings_pars_fragment: __WEBPACK_IMPORTED_MODULE_25__ShaderChunk_encodings_pars_fragment_glsl_js__["a" /* default */],
	envmap_fragment: __WEBPACK_IMPORTED_MODULE_26__ShaderChunk_envmap_fragment_glsl_js__["a" /* default */],
	envmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_27__ShaderChunk_envmap_pars_fragment_glsl_js__["a" /* default */],
	envmap_pars_vertex: __WEBPACK_IMPORTED_MODULE_28__ShaderChunk_envmap_pars_vertex_glsl_js__["a" /* default */],
	envmap_physical_pars_fragment: __WEBPACK_IMPORTED_MODULE_39__ShaderChunk_envmap_physical_pars_fragment_glsl_js__["a" /* default */],
	envmap_vertex: __WEBPACK_IMPORTED_MODULE_29__ShaderChunk_envmap_vertex_glsl_js__["a" /* default */],
	fog_vertex: __WEBPACK_IMPORTED_MODULE_30__ShaderChunk_fog_vertex_glsl_js__["a" /* default */],
	fog_pars_vertex: __WEBPACK_IMPORTED_MODULE_31__ShaderChunk_fog_pars_vertex_glsl_js__["a" /* default */],
	fog_fragment: __WEBPACK_IMPORTED_MODULE_32__ShaderChunk_fog_fragment_glsl_js__["a" /* default */],
	fog_pars_fragment: __WEBPACK_IMPORTED_MODULE_33__ShaderChunk_fog_pars_fragment_glsl_js__["a" /* default */],
	gradientmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_34__ShaderChunk_gradientmap_pars_fragment_glsl_js__["a" /* default */],
	lightmap_fragment: __WEBPACK_IMPORTED_MODULE_35__ShaderChunk_lightmap_fragment_glsl_js__["a" /* default */],
	lightmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_36__ShaderChunk_lightmap_pars_fragment_glsl_js__["a" /* default */],
	lights_lambert_vertex: __WEBPACK_IMPORTED_MODULE_37__ShaderChunk_lights_lambert_vertex_glsl_js__["a" /* default */],
	lights_pars_begin: __WEBPACK_IMPORTED_MODULE_38__ShaderChunk_lights_pars_begin_glsl_js__["a" /* default */],
	lights_phong_fragment: __WEBPACK_IMPORTED_MODULE_40__ShaderChunk_lights_phong_fragment_glsl_js__["a" /* default */],
	lights_phong_pars_fragment: __WEBPACK_IMPORTED_MODULE_41__ShaderChunk_lights_phong_pars_fragment_glsl_js__["a" /* default */],
	lights_physical_fragment: __WEBPACK_IMPORTED_MODULE_42__ShaderChunk_lights_physical_fragment_glsl_js__["a" /* default */],
	lights_physical_pars_fragment: __WEBPACK_IMPORTED_MODULE_43__ShaderChunk_lights_physical_pars_fragment_glsl_js__["a" /* default */],
	lights_fragment_begin: __WEBPACK_IMPORTED_MODULE_44__ShaderChunk_lights_fragment_begin_glsl_js__["a" /* default */],
	lights_fragment_maps: __WEBPACK_IMPORTED_MODULE_45__ShaderChunk_lights_fragment_maps_glsl_js__["a" /* default */],
	lights_fragment_end: __WEBPACK_IMPORTED_MODULE_46__ShaderChunk_lights_fragment_end_glsl_js__["a" /* default */],
	logdepthbuf_fragment: __WEBPACK_IMPORTED_MODULE_47__ShaderChunk_logdepthbuf_fragment_glsl_js__["a" /* default */],
	logdepthbuf_pars_fragment: __WEBPACK_IMPORTED_MODULE_48__ShaderChunk_logdepthbuf_pars_fragment_glsl_js__["a" /* default */],
	logdepthbuf_pars_vertex: __WEBPACK_IMPORTED_MODULE_49__ShaderChunk_logdepthbuf_pars_vertex_glsl_js__["a" /* default */],
	logdepthbuf_vertex: __WEBPACK_IMPORTED_MODULE_50__ShaderChunk_logdepthbuf_vertex_glsl_js__["a" /* default */],
	map_fragment: __WEBPACK_IMPORTED_MODULE_51__ShaderChunk_map_fragment_glsl_js__["a" /* default */],
	map_pars_fragment: __WEBPACK_IMPORTED_MODULE_52__ShaderChunk_map_pars_fragment_glsl_js__["a" /* default */],
	map_particle_fragment: __WEBPACK_IMPORTED_MODULE_53__ShaderChunk_map_particle_fragment_glsl_js__["a" /* default */],
	map_particle_pars_fragment: __WEBPACK_IMPORTED_MODULE_54__ShaderChunk_map_particle_pars_fragment_glsl_js__["a" /* default */],
	metalnessmap_fragment: __WEBPACK_IMPORTED_MODULE_55__ShaderChunk_metalnessmap_fragment_glsl_js__["a" /* default */],
	metalnessmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_56__ShaderChunk_metalnessmap_pars_fragment_glsl_js__["a" /* default */],
	morphnormal_vertex: __WEBPACK_IMPORTED_MODULE_57__ShaderChunk_morphnormal_vertex_glsl_js__["a" /* default */],
	morphtarget_pars_vertex: __WEBPACK_IMPORTED_MODULE_58__ShaderChunk_morphtarget_pars_vertex_glsl_js__["a" /* default */],
	morphtarget_vertex: __WEBPACK_IMPORTED_MODULE_59__ShaderChunk_morphtarget_vertex_glsl_js__["a" /* default */],
	normal_fragment_begin: __WEBPACK_IMPORTED_MODULE_60__ShaderChunk_normal_fragment_begin_glsl_js__["a" /* default */],
	normal_fragment_maps: __WEBPACK_IMPORTED_MODULE_61__ShaderChunk_normal_fragment_maps_glsl_js__["a" /* default */],
	normalmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_62__ShaderChunk_normalmap_pars_fragment_glsl_js__["a" /* default */],
	packing: __WEBPACK_IMPORTED_MODULE_63__ShaderChunk_packing_glsl_js__["a" /* default */],
	premultiplied_alpha_fragment: __WEBPACK_IMPORTED_MODULE_64__ShaderChunk_premultiplied_alpha_fragment_glsl_js__["a" /* default */],
	project_vertex: __WEBPACK_IMPORTED_MODULE_65__ShaderChunk_project_vertex_glsl_js__["a" /* default */],
	dithering_fragment: __WEBPACK_IMPORTED_MODULE_66__ShaderChunk_dithering_fragment_glsl_js__["a" /* default */],
	dithering_pars_fragment: __WEBPACK_IMPORTED_MODULE_67__ShaderChunk_dithering_pars_fragment_glsl_js__["a" /* default */],
	roughnessmap_fragment: __WEBPACK_IMPORTED_MODULE_68__ShaderChunk_roughnessmap_fragment_glsl_js__["a" /* default */],
	roughnessmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_69__ShaderChunk_roughnessmap_pars_fragment_glsl_js__["a" /* default */],
	shadowmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_70__ShaderChunk_shadowmap_pars_fragment_glsl_js__["a" /* default */],
	shadowmap_pars_vertex: __WEBPACK_IMPORTED_MODULE_71__ShaderChunk_shadowmap_pars_vertex_glsl_js__["a" /* default */],
	shadowmap_vertex: __WEBPACK_IMPORTED_MODULE_72__ShaderChunk_shadowmap_vertex_glsl_js__["a" /* default */],
	shadowmask_pars_fragment: __WEBPACK_IMPORTED_MODULE_73__ShaderChunk_shadowmask_pars_fragment_glsl_js__["a" /* default */],
	skinbase_vertex: __WEBPACK_IMPORTED_MODULE_74__ShaderChunk_skinbase_vertex_glsl_js__["a" /* default */],
	skinning_pars_vertex: __WEBPACK_IMPORTED_MODULE_75__ShaderChunk_skinning_pars_vertex_glsl_js__["a" /* default */],
	skinning_vertex: __WEBPACK_IMPORTED_MODULE_76__ShaderChunk_skinning_vertex_glsl_js__["a" /* default */],
	skinnormal_vertex: __WEBPACK_IMPORTED_MODULE_77__ShaderChunk_skinnormal_vertex_glsl_js__["a" /* default */],
	specularmap_fragment: __WEBPACK_IMPORTED_MODULE_78__ShaderChunk_specularmap_fragment_glsl_js__["a" /* default */],
	specularmap_pars_fragment: __WEBPACK_IMPORTED_MODULE_79__ShaderChunk_specularmap_pars_fragment_glsl_js__["a" /* default */],
	tonemapping_fragment: __WEBPACK_IMPORTED_MODULE_80__ShaderChunk_tonemapping_fragment_glsl_js__["a" /* default */],
	tonemapping_pars_fragment: __WEBPACK_IMPORTED_MODULE_81__ShaderChunk_tonemapping_pars_fragment_glsl_js__["a" /* default */],
	uv_pars_fragment: __WEBPACK_IMPORTED_MODULE_82__ShaderChunk_uv_pars_fragment_glsl_js__["a" /* default */],
	uv_pars_vertex: __WEBPACK_IMPORTED_MODULE_83__ShaderChunk_uv_pars_vertex_glsl_js__["a" /* default */],
	uv_vertex: __WEBPACK_IMPORTED_MODULE_84__ShaderChunk_uv_vertex_glsl_js__["a" /* default */],
	uv2_pars_fragment: __WEBPACK_IMPORTED_MODULE_85__ShaderChunk_uv2_pars_fragment_glsl_js__["a" /* default */],
	uv2_pars_vertex: __WEBPACK_IMPORTED_MODULE_86__ShaderChunk_uv2_pars_vertex_glsl_js__["a" /* default */],
	uv2_vertex: __WEBPACK_IMPORTED_MODULE_87__ShaderChunk_uv2_vertex_glsl_js__["a" /* default */],
	worldpos_vertex: __WEBPACK_IMPORTED_MODULE_88__ShaderChunk_worldpos_vertex_glsl_js__["a" /* default */],
	instance_attribute_pars_vertex: __WEBPACK_IMPORTED_MODULE_89__ShaderChunk_instance_attribute_pars_vertex_glsl__["a" /* default */],
	instance_attribute_vertex: __WEBPACK_IMPORTED_MODULE_90__ShaderChunk_instance_attribute_vertex_glsl__["a" /* default */],
	instance_attribute_pars_fragment: __WEBPACK_IMPORTED_MODULE_91__ShaderChunk_instance_attribute_pars_fragment_glsl__["a" /* default */],
	instance_attribute_fragment: __WEBPACK_IMPORTED_MODULE_92__ShaderChunk_instance_attribute_fragment_glsl__["a" /* default */],
	offset_vertex_position_pars_vertex: __WEBPACK_IMPORTED_MODULE_93__ShaderChunk_offset_position_pars_vertex_glsl__["a" /* default */],
	offset_vertex_position_vertex: __WEBPACK_IMPORTED_MODULE_94__ShaderChunk_offset_position_vertex_glsl__["a" /* default */],

	background_frag: __WEBPACK_IMPORTED_MODULE_95__ShaderLib_background_frag_glsl_js__["a" /* default */],
	background_vert: __WEBPACK_IMPORTED_MODULE_96__ShaderLib_background_vert_glsl_js__["a" /* default */],
	cube_frag: __WEBPACK_IMPORTED_MODULE_97__ShaderLib_cube_frag_glsl_js__["a" /* default */],
	cube_vert: __WEBPACK_IMPORTED_MODULE_98__ShaderLib_cube_vert_glsl_js__["a" /* default */],
	depth_frag: __WEBPACK_IMPORTED_MODULE_99__ShaderLib_depth_frag_glsl_js__["a" /* default */],
	depth_vert: __WEBPACK_IMPORTED_MODULE_100__ShaderLib_depth_vert_glsl_js__["a" /* default */],
	distanceRGBA_frag: __WEBPACK_IMPORTED_MODULE_101__ShaderLib_distanceRGBA_frag_glsl_js__["a" /* default */],
	distanceRGBA_vert: __WEBPACK_IMPORTED_MODULE_102__ShaderLib_distanceRGBA_vert_glsl_js__["a" /* default */],
	equirect_frag: __WEBPACK_IMPORTED_MODULE_103__ShaderLib_equirect_frag_glsl_js__["a" /* default */],
	equirect_vert: __WEBPACK_IMPORTED_MODULE_104__ShaderLib_equirect_vert_glsl_js__["a" /* default */],
	linedashed_frag: __WEBPACK_IMPORTED_MODULE_105__ShaderLib_linedashed_frag_glsl_js__["a" /* default */],
	linedashed_vert: __WEBPACK_IMPORTED_MODULE_106__ShaderLib_linedashed_vert_glsl_js__["a" /* default */],
	meshbasic_frag: __WEBPACK_IMPORTED_MODULE_107__ShaderLib_meshbasic_frag_glsl_js__["a" /* default */],
	meshbasic_vert: __WEBPACK_IMPORTED_MODULE_108__ShaderLib_meshbasic_vert_glsl_js__["a" /* default */],
	meshlambert_frag: __WEBPACK_IMPORTED_MODULE_109__ShaderLib_meshlambert_frag_glsl_js__["a" /* default */],
	meshlambert_vert: __WEBPACK_IMPORTED_MODULE_110__ShaderLib_meshlambert_vert_glsl_js__["a" /* default */],
	meshmatcap_frag: __WEBPACK_IMPORTED_MODULE_111__ShaderLib_meshmatcap_frag_glsl_js__["a" /* default */],
	meshmatcap_vert: __WEBPACK_IMPORTED_MODULE_112__ShaderLib_meshmatcap_vert_glsl_js__["a" /* default */],
	meshphong_frag: __WEBPACK_IMPORTED_MODULE_113__ShaderLib_meshphong_frag_glsl_js__["a" /* default */],
	meshphong_vert: __WEBPACK_IMPORTED_MODULE_114__ShaderLib_meshphong_vert_glsl_js__["a" /* default */],
	meshphysical_frag: __WEBPACK_IMPORTED_MODULE_115__ShaderLib_meshphysical_frag_glsl_js__["a" /* default */],
	meshphysical_vert: __WEBPACK_IMPORTED_MODULE_116__ShaderLib_meshphysical_vert_glsl_js__["a" /* default */],
	normal_frag: __WEBPACK_IMPORTED_MODULE_117__ShaderLib_normal_frag_glsl_js__["a" /* default */],
	normal_vert: __WEBPACK_IMPORTED_MODULE_118__ShaderLib_normal_vert_glsl_js__["a" /* default */],
	points_frag: __WEBPACK_IMPORTED_MODULE_119__ShaderLib_points_frag_glsl_js__["a" /* default */],
	points_vert: __WEBPACK_IMPORTED_MODULE_120__ShaderLib_points_vert_glsl_js__["a" /* default */],
	shadow_frag: __WEBPACK_IMPORTED_MODULE_121__ShaderLib_shadow_frag_glsl_js__["a" /* default */],
	shadow_vert: __WEBPACK_IMPORTED_MODULE_122__ShaderLib_shadow_vert_glsl_js__["a" /* default */],
	sprite_frag: __WEBPACK_IMPORTED_MODULE_123__ShaderLib_sprite_frag_glsl_js__["a" /* default */],
	sprite_vert: __WEBPACK_IMPORTED_MODULE_124__ShaderLib_sprite_vert_glsl_js__["a" /* default */]
};

/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShaderLib; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Matrix3_js__ = __webpack_require__(28);







var ShaderLib = {

	basic: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].specularmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshbasic_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshbasic_frag

	},

	lambert: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].specularmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].emissivemap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, {
			emissive: { value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000) }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshlambert_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshlambert_frag

	},

	phong: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].specularmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].emissivemap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].gradientmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, {
			emissive: { value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000) },
			specular: { value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x111111) },
			shininess: { value: 30 }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphong_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphong_frag

	},

	standard: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].envmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].aomap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lightmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].emissivemap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].roughnessmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].metalnessmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, {
			emissive: { value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000) },
			roughness: { value: 0.5 },
			metalness: { value: 0.5 },
			envMapIntensity: { value: 1 } }]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_frag

	},

	matcap: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, {
			matcap: { value: null }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshmatcap_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshmatcap_frag

	},

	points: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].points, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].points_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].points_frag

	},

	dashed: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, {
			scale: { value: 1 },
			dashSize: { value: 1 },
			totalSize: { value: 2 }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].linedashed_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].linedashed_frag

	},

	depth: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].depth_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].depth_frag

	},

	normal: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].bumpmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].normalmap, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, {
			opacity: { value: 1.0 }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].normal_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].normal_frag

	},

	sprite: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].sprite, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].sprite_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new __WEBPACK_IMPORTED_MODULE_5__math_Matrix3_js__["a" /* Matrix3 */]() },
			t2D: { value: null }
		},

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].background_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].background_frag

	},


	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: -1 },
			opacity: { value: 1.0 }
		},

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].cube_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null }
		},

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].equirect_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].equirect_frag

	},

	distanceRGBA: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].common, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].displacementmap, {
			referencePosition: { value: new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]() },
			nearDistance: { value: 1 },
			farDistance: { value: 1000 }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].distanceRGBA_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].distanceRGBA_frag

	},

	shadow: {

		uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([__WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].lights, __WEBPACK_IMPORTED_MODULE_3__UniformsLib_js__["a" /* UniformsLib */].fog, {
			color: { value: new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x00000) },
			opacity: { value: 1.0 }
		}]),

		vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].shadow_vert,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__UniformsUtils_js__["d" /* mergeUniforms */])([ShaderLib.standard.uniforms, {
		clearCoat: { value: 0 },
		clearCoatRoughness: { value: 0 }
	}]),

	vertexShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_vert,
	fragmentShader: __WEBPACK_IMPORTED_MODULE_0__ShaderChunk_js__["a" /* ShaderChunk */].meshphysical_frag

};



/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniformsLib; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__ = __webpack_require__(28);




var UniformsLib = {

	common: {

		diffuse: { value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xeeeeee) },
		opacity: { value: 1.0 },
		disableMap: { value: false },

		map: { value: null },
		uvTransform: { value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]() },

		alphaMap: { value: null }
	},

	specularmap: {

		specularMap: { value: null }

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: -1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](1, 1) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xffffff) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

		rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

	},

	points: {

		diffuse: { value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xeeeeee) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		uvTransform: { value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]() }

	},

	sprite: {

		diffuse: { value: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](0xeeeeee) },
		opacity: { value: 1.0 },
		center: { value: new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](0.5, 0.5) },
		rotation: { value: 0.0 },
		map: { value: null },
		uvTransform: { value: new __WEBPACK_IMPORTED_MODULE_2__math_Matrix3_js__["a" /* Matrix3 */]() }

	}

};



/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLUniforms; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__textures_CubeTexture_js__ = __webpack_require__(451);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textures_Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textures_DataTexture2DArray_js__ = __webpack_require__(453);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__textures_DataTexture3D_js__ = __webpack_require__(454);







var emptyTexture = new __WEBPACK_IMPORTED_MODULE_1__textures_Texture_js__["a" /* Texture */]();
var emptyTexture2dArray = new __WEBPACK_IMPORTED_MODULE_2__textures_DataTexture2DArray_js__["a" /* DataTexture2DArray */]();
var emptyTexture3d = new __WEBPACK_IMPORTED_MODULE_3__textures_DataTexture3D_js__["a" /* DataTexture3D */]();
var emptyCubeTexture = new __WEBPACK_IMPORTED_MODULE_0__textures_CubeTexture_js__["a" /* CubeTexture */]();

var arrayCacheF32 = [];
var arrayCacheI32 = [];

var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);

function flatten(array, nBlocks, blockSize) {

	var firstElem = array[0];

	if (firstElem <= 0 || firstElem > 0) return array;


	var n = nBlocks * blockSize,
	    r = arrayCacheF32[n];

	if (r === undefined) {

		r = new Float32Array(n);
		arrayCacheF32[n] = r;
	}

	if (nBlocks !== 0) {

		firstElem.toArray(r, 0);

		for (var i = 1, offset = 0; i !== nBlocks; ++i) {

			offset += blockSize;
			array[i].toArray(r, offset);
		}
	}

	return r;
}

function arraysEqual(a, b) {

	if (a.length !== b.length) return false;

	for (var i = 0, l = a.length; i < l; i++) {

		if (a[i] !== b[i]) return false;
	}

	return true;
}

function copyArray(a, b) {

	for (var i = 0, l = b.length; i < l; i++) {

		a[i] = b[i];
	}
}

function allocTexUnits(textures, n) {

	var r = arrayCacheI32[n];

	if (r === undefined) {

		r = new Int32Array(n);
		arrayCacheI32[n] = r;
	}

	for (var i = 0; i !== n; ++i) {
		r[i] = textures.allocateTextureUnit();
	}return r;
}

function setValueV1f(gl, v) {

	var cache = this.cache;

	if (cache[0] === v) return;

	gl.uniform1f(this.addr, v);

	cache[0] = v;
}

function setValueV2f(gl, v) {

	var cache = this.cache;

	if (v.x !== undefined) {

		if (cache[0] !== v.x || cache[1] !== v.y) {

			gl.uniform2f(this.addr, v.x, v.y);

			cache[0] = v.x;
			cache[1] = v.y;
		}
	} else {

		if (arraysEqual(cache, v)) return;

		gl.uniform2fv(this.addr, v);

		copyArray(cache, v);
	}
}

function setValueV3f(gl, v) {

	var cache = this.cache;

	if (v.x !== undefined) {

		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {

			gl.uniform3f(this.addr, v.x, v.y, v.z);

			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
		}
	} else if (v.r !== undefined) {

		if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {

			gl.uniform3f(this.addr, v.r, v.g, v.b);

			cache[0] = v.r;
			cache[1] = v.g;
			cache[2] = v.b;
		}
	} else {

		if (arraysEqual(cache, v)) return;

		gl.uniform3fv(this.addr, v);

		copyArray(cache, v);
	}
}

function setValueV4f(gl, v) {

	var cache = this.cache;

	if (v.x !== undefined) {

		if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {

			gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);

			cache[0] = v.x;
			cache[1] = v.y;
			cache[2] = v.z;
			cache[3] = v.w;
		}
	} else {

		if (arraysEqual(cache, v)) return;

		gl.uniform4fv(this.addr, v);

		copyArray(cache, v);
	}
}

function setValueM2(gl, v) {

	var cache = this.cache;
	var elements = v.elements;

	if (elements === undefined) {

		if (arraysEqual(cache, v)) return;

		gl.uniformMatrix2fv(this.addr, false, v);

		copyArray(cache, v);
	} else {

		if (arraysEqual(cache, elements)) return;

		mat2array.set(elements);

		gl.uniformMatrix2fv(this.addr, false, mat2array);

		copyArray(cache, elements);
	}
}

function setValueM3(gl, v) {

	var cache = this.cache;
	var elements = v.elements;

	if (elements === undefined) {

		if (arraysEqual(cache, v)) return;

		gl.uniformMatrix3fv(this.addr, false, v);

		copyArray(cache, v);
	} else {

		if (arraysEqual(cache, elements)) return;

		mat3array.set(elements);

		gl.uniformMatrix3fv(this.addr, false, mat3array);

		copyArray(cache, elements);
	}
}

function setValueM4(gl, v) {

	var cache = this.cache;
	var elements = v.elements;

	if (elements === undefined) {

		if (arraysEqual(cache, v)) return;

		gl.uniformMatrix4fv(this.addr, false, v);

		copyArray(cache, v);
	} else {

		if (arraysEqual(cache, elements)) return;

		mat4array.set(elements);

		gl.uniformMatrix4fv(this.addr, false, mat4array);

		copyArray(cache, elements);
	}
}

function setValueT1(gl, v, textures) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if (cache[0] !== unit) {

		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}

	textures.safeSetTexture2D(v || emptyTexture, unit);
}

function setValueT2DArray1(gl, v, textures) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if (cache[0] !== unit) {

		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}

	textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}

function setValueT3D1(gl, v, textures) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if (cache[0] !== unit) {

		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}

	textures.setTexture3D(v || emptyTexture3d, unit);
}

function setValueT6(gl, v, textures) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if (cache[0] !== unit) {

		gl.uniform1i(this.addr, unit);
		cache[0] = unit;
	}

	textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}

function setValueV1i(gl, v) {

	var cache = this.cache;

	if (cache[0] === v) return;

	gl.uniform1i(this.addr, v);

	cache[0] = v;
}

function setValueV2i(gl, v) {

	var cache = this.cache;

	if (arraysEqual(cache, v)) return;

	gl.uniform2iv(this.addr, v);

	copyArray(cache, v);
}

function setValueV3i(gl, v) {

	var cache = this.cache;

	if (arraysEqual(cache, v)) return;

	gl.uniform3iv(this.addr, v);

	copyArray(cache, v);
}

function setValueV4i(gl, v) {

	var cache = this.cache;

	if (arraysEqual(cache, v)) return;

	gl.uniform4iv(this.addr, v);

	copyArray(cache, v);
}

function getSingularSetter(type) {

	switch (type) {

		case 0x1406:
			return setValueV1f;
		case 0x8b50:
			return setValueV2f;
		case 0x8b51:
			return setValueV3f;
		case 0x8b52:
			return setValueV4f;

		case 0x8b5a:
			return setValueM2;
		case 0x8b5b:
			return setValueM3;
		case 0x8b5c:
			return setValueM4;

		case 0x8b5e:case 0x8d66:
			return setValueT1;
		case 0x8b5f:
			return setValueT3D1;
		case 0x8b60:
			return setValueT6;
		case 0x8DC1:
			return setValueT2DArray1;

		case 0x1404:case 0x8b56:
			return setValueV1i;
		case 0x8b53:case 0x8b57:
			return setValueV2i;
		case 0x8b54:case 0x8b58:
			return setValueV3i;
		case 0x8b55:case 0x8b59:
			return setValueV4i;}
}

function setValueV1fArray(gl, v) {

	gl.uniform1fv(this.addr, v);
}

function setValueV1iArray(gl, v) {

	gl.uniform1iv(this.addr, v);
}

function setValueV2iArray(gl, v) {

	gl.uniform2iv(this.addr, v);
}

function setValueV3iArray(gl, v) {

	gl.uniform3iv(this.addr, v);
}

function setValueV4iArray(gl, v) {

	gl.uniform4iv(this.addr, v);
}

function setValueV2fArray(gl, v) {

	var data = flatten(v, this.size, 2);

	gl.uniform2fv(this.addr, data);
}

function setValueV3fArray(gl, v) {

	var data = flatten(v, this.size, 3);

	gl.uniform3fv(this.addr, data);
}

function setValueV4fArray(gl, v) {

	var data = flatten(v, this.size, 4);

	gl.uniform4fv(this.addr, data);
}

function setValueM2Array(gl, v) {

	var data = flatten(v, this.size, 4);

	gl.uniformMatrix2fv(this.addr, false, data);
}

function setValueM3Array(gl, v) {

	var data = flatten(v, this.size, 9);

	gl.uniformMatrix3fv(this.addr, false, data);
}

function setValueM4Array(gl, v) {

	var data = flatten(v, this.size, 16);

	gl.uniformMatrix4fv(this.addr, false, data);
}

function setValueT1Array(gl, v, textures) {

	var n = v.length;

	var units = allocTexUnits(textures, n);

	gl.uniform1iv(this.addr, units);

	for (var i = 0; i !== n; ++i) {

		textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
	}
}

function setValueT6Array(gl, v, textures) {

	var n = v.length;

	var units = allocTexUnits(textures, n);

	gl.uniform1iv(this.addr, units);

	for (var i = 0; i !== n; ++i) {

		textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
	}
}

function getPureArraySetter(type) {

	switch (type) {

		case 0x1406:
			return setValueV1fArray;
		case 0x8b50:
			return setValueV2fArray;
		case 0x8b51:
			return setValueV3fArray;
		case 0x8b52:
			return setValueV4fArray;

		case 0x8b5a:
			return setValueM2Array;
		case 0x8b5b:
			return setValueM3Array;
		case 0x8b5c:
			return setValueM4Array;

		case 0x8b5e:
			return setValueT1Array;
		case 0x8b60:
			return setValueT6Array;

		case 0x1404:case 0x8b56:
			return setValueV1iArray;
		case 0x8b53:case 0x8b57:
			return setValueV2iArray;
		case 0x8b54:case 0x8b58:
			return setValueV3iArray;
		case 0x8b55:case 0x8b59:
			return setValueV4iArray;}
}

function SingleUniform(id, activeInfo, addr) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter(activeInfo.type);
}

function PureArrayUniform(id, activeInfo, addr) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter(activeInfo.type);
}

PureArrayUniform.prototype.updateCache = function (data) {

	var cache = this.cache;

	if (data instanceof Float32Array && cache.length !== data.length) {

		this.cache = new Float32Array(data.length);
	}

	copyArray(cache, data);
};

function StructuredUniform(id) {

	this.id = id;

	this.seq = [];
	this.map = {};
}

StructuredUniform.prototype.setValue = function (gl, value, textures) {

	var seq = this.seq;

	for (var i = 0, n = seq.length; i !== n; ++i) {

		var u = seq[i];
		u.setValue(gl, value[u.id], textures);
	}
};

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

function addUniform(container, uniformObject) {

	container.seq.push(uniformObject);
	container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {

	var path = activeInfo.name,
	    pathLength = path.length;

	RePathPart.lastIndex = 0;

	while (true) {

		var match = RePathPart.exec(path),
		    matchEnd = RePathPart.lastIndex,
		    id = match[1],
		    idIsIndex = match[2] === ']',
		    subscript = match[3];

		if (idIsIndex) id = id | 0;

		if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {

			addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));

			break;
		} else {

			var map = container.map,
			    next = map[id];

			if (next === undefined) {

				next = new StructuredUniform(id);
				addUniform(container, next);
			}

			container = next;
		}
	}
}

function WebGLUniforms(gl, program) {

	this.seq = [];
	this.map = {};

	var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

	for (var i = 0; i < n; ++i) {

		var info = gl.getActiveUniform(program, i),
		    addr = gl.getUniformLocation(program, info.name);

		parseUniform(info, addr, this);
	}
}

WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {

	var u = this.map[name];

	if (u !== undefined) u.setValue(gl, value, textures);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {

	var v = object[name];

	if (v !== undefined) this.setValue(gl, name, v);
};

WebGLUniforms.upload = function (gl, seq, values, textures) {

	for (var i = 0, n = seq.length; i !== n; ++i) {

		var u = seq[i],
		    v = values[u.id];

		if (v.needsUpdate !== false) {
			u.setValue(gl, v.value, textures);
		}
	}
};

WebGLUniforms.seqWithValue = function (seq, values) {

	var r = [];

	for (var i = 0, n = seq.length; i !== n; ++i) {

		var u = seq[i];
		if (u.id in values) r.push(u);
	}

	return r;
};



/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return setProjectionFromUnion; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__ = __webpack_require__(2);




var cameraLPos = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();
var cameraRPos = new __WEBPACK_IMPORTED_MODULE_0__math_Vector3_js__["a" /* Vector3 */]();

function setProjectionFromUnion(camera, cameraL, cameraR) {

	cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
	cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);

	var ipd = cameraLPos.distanceTo(cameraRPos);

	var projL = cameraL.projectionMatrix.elements;
	var projR = cameraR.projectionMatrix.elements;

	var near = projL[14] / (projL[10] - 1);
	var far = projL[14] / (projL[10] + 1);
	var topFov = (projL[9] + 1) / projL[5];
	var bottomFov = (projL[9] - 1) / projL[5];

	var leftFov = (projL[8] - 1) / projL[0];
	var rightFov = (projR[8] + 1) / projR[0];
	var left = near * leftFov;
	var right = near * rightFov;

	var zOffset = ipd / (-leftFov + rightFov);
	var xOffset = zOffset * -leftFov;

	cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
	camera.translateX(xOffset);
	camera.translateZ(zOffset);
	camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
	camera.matrixWorldInverse.getInverse(camera.matrixWorld);

	var near2 = near + zOffset;
	var far2 = far + zOffset;
	var left2 = left - xOffset;
	var right2 = right + (ipd - xOffset);
	var top2 = topFov * far / far2 * near2;
	var bottom2 = bottomFov * far / far2 * near2;

	camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}



/***/ }),
/* 176 */
/***/ (function(module, exports) {


!function (v) {
  var c,
      i = '<svg><symbol id="icon-huiche" viewBox="0 0 1024 1024"><path d="M639.199519 894.900713 253.016039 894.900713l0 0-96.577592 0c-5.27412 0-9.983375-1.539053-14.378475-3.768837-9.168824 1.098008-18.714224-1.381463-25.746384-8.413624l-44.143383-44.175105c-12.18246-12.183484-12.18246-31.933293 0-44.145429l208.851679-273.122471c12.18246-12.17939 31.962969-12.17939 44.145429 0l44.145429 44.146453c12.17939 12.211113 12.17939 31.994692 0 44.173059L249.498936 766.299777l335.880817 0c98.149391-5.276167 176.393429-83.266425 181.228551-181.035146L766.608304 348.34264c0-17.772782 14.377452-32.149211 32.151257-32.149211l64.98813 0c17.772782 0 32.150234 14.376429 32.150234 32.149211l0 33.593096 0 225.27472 0 32.496112C895.897925 780.64653 780.985756 894.900713 639.199519 894.900713z"  ></path></symbol><symbol id="icon-tick" viewBox="0 0 1024 1024"><path d="M150.49024423 528.23747134c-12.92002158-12.58190689-13.21260425-33.26591409-0.63154028-46.196897 12.57010263-12.9208645 33.25410983-13.21344717 46.18509275-0.63238403l217.98689199 212.06187846 411.49631799-405.39339351c12.86437198-12.64936157 33.53657492-12.46892102 46.18593568 0.38364586 12.64936157 12.86437198 12.47988235 33.54753623-0.38364588 46.18593567L437.07306613 762.46060586c-12.61563382 12.42507568-32.91515222 12.53721862-45.66653833 0.12479013L150.49024423 528.23747134z"  ></path></symbol><symbol id="icon-full" viewBox="0 0 1024 1024"><path d="M617.058243 512c0-58.021461-47.049572-105.072057-105.08229-105.072057-58.009182 0-105.059777 47.050596-105.059777 105.072057 0 58.033741 47.050596 105.071034 105.059777 105.071034C570.00867 617.071034 617.058243 570.033741 617.058243 512z"  ></path><path d="M536.694937 64.303538 487.254921 64.303538 487.254921 193.188954 384.416741 193.188954 511.974929 347.012342 639.533117 193.188954 536.694937 193.188954Z"  ></path><path d="M511.974929 676.988682 384.416741 830.811046 487.254921 830.811046 487.254921 959.696462 536.694937 959.696462 536.694937 830.811046 639.533117 830.811046Z"  ></path><path d="M959.68367 487.279992 830.821791 487.279992 830.821791 384.441812 676.999426 512 830.821791 639.557164 830.821791 536.718985 959.68367 536.718985Z"  ></path><path d="M193.176163 487.279992 64.315306 487.279992 64.315306 536.718985 193.176163 536.718985 193.176163 639.557164 346.99955 512 193.176163 384.441812Z"  ></path></symbol><symbol id="icon-xiala" viewBox="0 0 1902 1024"><path d="M155.204535 74.710455C126.615552 46.121472 80.483035 45.902117 51.719826 74.665326L51.719826 74.665326C23.155712 103.22944 23.012571 149.397723 51.378322 177.763474L827.770953 954.156105C884.758821 1011.143973 977.122889 1011.175424 1034.142208 954.156105L1810.534839 177.763474C1838.910318 149.387995 1838.956544 103.428535 1810.193335 74.665326L1810.193335 74.665326C1781.629294 46.101285 1735.477321 45.94176 1706.708626 74.710455L982.721463 798.697618C954.132553 827.286601 907.960393 827.466313 879.191698 798.697618L155.204535 74.710455 155.204535 74.710455Z"  ></path></symbol><symbol id="icon-sousuo" viewBox="0 0 1024 1024"><path d="M970.961455 924.672 828.648727 782.359273C906.263273 699.182545 954.181818 587.938909 954.181818 465.454545 954.181818 208.779636 745.402182 0 488.727273 0 232.075636 0 23.272727 208.779636 23.272727 465.454545 23.272727 557.730909 50.338909 647.051636 101.585455 723.688727 112.290909 739.770182 133.957818 743.982545 149.992727 733.323636 166.027636 722.618182 170.333091 700.951273 159.627636 684.916364 116.107636 619.776 93.090909 543.906909 93.090909 465.454545 93.090909 247.296 270.568727 69.818182 488.727273 69.818182 706.885818 69.818182 884.363636 247.296 884.363636 465.454545 884.363636 683.613091 706.885818 861.090909 488.727273 861.090909 409.995636 861.090909 333.940364 837.957818 268.730182 794.228364 252.741818 783.546182 231.051636 787.758545 220.276364 803.770182 209.547636 819.781818 213.829818 841.472 229.818182 852.224 306.571636 903.703273 396.101818 930.909091 488.727273 930.909091 580.887273 930.909091 666.647273 903.633455 739.002182 857.250909L888.692364 1006.941091C900.049455 1018.298182 914.944 1024 929.815273 1024 944.709818 1024 959.604364 1018.298182 970.961455 1006.941091 993.698909 984.226909 993.698909 947.409455 970.961455 924.672ZM247.552 396.695273C273.501091 296.064 356.910545 222.685091 460.055273 209.768727 479.185455 207.371636 492.753455 189.917091 490.356364 170.786909 487.959273 151.656727 470.365091 138.065455 451.374545 140.485818 319.627636 156.986182 213.108364 250.728727 179.968 379.287273 175.150545 397.952 186.368 416.989091 205.056 421.783273 207.965091 422.551273 210.897455 422.900364 213.783273 422.900364 229.329455 422.900364 243.502545 412.450909 247.552 396.695273Z"  ></path></symbol><symbol id="icon-suo1" viewBox="0 0 1024 1024"><path d="M870.4 396.8l-192 0L531.2 396.8 345.6 396.8 345.6 249.6c0-76.8 76.8-140.8 166.4-140.8 70.4 0 128 38.4 153.6 89.6l108.8 0C742.4 83.2 640 12.8 512 12.8c-147.2 0-268.8 102.4-268.8 249.6l0 134.4L166.4 396.8c-38.4 0-64 32-64 64l0 486.4c0 38.4 32 64 64 64l691.2 0c38.4 0 64-32 64-64L921.6 460.8C921.6 428.8 902.4 403.2 870.4 396.8zM550.4 716.8l0 108.8c0 6.4-6.4 6.4-6.4 6.4L486.4 832c-6.4 0-6.4-6.4-6.4-6.4l0-108.8C448 704 428.8 678.4 428.8 646.4c0-44.8 38.4-83.2 83.2-83.2 44.8 0 83.2 38.4 83.2 83.2C595.2 678.4 576 704 550.4 716.8z"  ></path></symbol><symbol id="icon-chongz" viewBox="0 0 1024 1024"><path d="M815.29625 697.4721875l144.7040625-211.775625h-102.335625c-13.6321875-207.2315625-185.728125-371.3915625-396.41625-371.3915625-219.6478125 0-397.2478125 178.048125-397.2478125 397.7596875 0 219.5203125 178.048125 397.6321875 397.6959375 397.6321875 98.495625 0 188.4159375-36.031875 257.9203125-95.424375l-53.184375-68.4796875c-54.72 47.8715625-126.271875 77.248125-204.7359375 77.248125-171.84 0-311.10375-139.3284375-311.10375-310.97625 0-171.90375 139.3284375-311.1684375 311.10375-311.1684375 162.8803125 0 295.9359375 125.375625 309.3121875 284.8003125h-100.415625l144.7040625 211.775625z"  ></path></symbol><symbol id="icon-floor" viewBox="0 0 1024 1024"><path d="M804.58789063 598.66015625l119.44335937 64.16015625c16.25976563 8.26171875 22.1484375 28.828125 13.88671875 44.91210938-3.25195313 6.15234375-8.52539063 10.37109375-13.88671875 13.44726562l-399.0234375 214.18945313c-10.37109375 5.44921875-21.70898438 4.921875-31.37695313-1e-8L94.08007812 721.09179688c-15.90820313-8.26171875-21.62109375-28.828125-13.44726562-44.82421876 3.60351563-6.15234375 8.34960938-10.8984375 13.44726563-13.53515625l119.44335937-64.16015624-119.44335938-63.89648438c-15.90820313-8.26171875-21.62109375-28.828125-13.44726562-44.82421875 3.60351563-5.88867188 8.34960938-10.63476563 13.44726563-13.53515625L213.5234375 412.68359375 94.08007812 348.34765625c-15.90820313-8.26171875-21.62109375-28.56445313-13.44726562-44.82421875 3.60351563-5.88867188 8.34960938-10.63476563 13.44726563-13.7109375l399.55078124-213.75c10.01953125-5.625 21.88476563-5.18554688 31.37695313 0l399.0234375 213.75c16.25976563 8.7890625 22.1484375 28.828125 13.88671875 45.08789063-3.25195313 5.88867188-8.52539063 10.81054688-13.88671875 13.44726562L804.58789063 412.68359375l119.44335937 63.72070313c16.25976563 8.52539063 22.1484375 28.65234375 13.88671875 44.91210937-3.25195313 6.06445313-8.52539063 10.81054688-13.88671875 13.44726563L804.58789063 598.66015625 804.58789063 598.66015625 804.58789063 598.66015625zM838.42578125 691.82421875L838.42578125 691.82421875l-103.88671875-55.72265625L525.0078125 748.953125c-3.8671875 1.66992188-7.29492188 2.63671875-10.8984375 3.60351563l-0.87890625 0.43945312-2.63671875 0-0.703125 0L508.484375 752.99609375l-0.52734375 0-3.07617188 0-0.61523437-0.43945313c-3.8671875-0.96679688-7.11914063-1.84570313-10.63476563-3.60351562L283.66015625 636.1015625l-103.62304688 55.72265625L509.36328125 868.30859375 838.42578125 691.82421875 838.42578125 691.82421875 838.42578125 691.82421875zM509.45117187 681.89257813L509.45117187 681.89257813c109.24804688-58.27148438 219.55078125-117.68554688 328.97460938-176.48437501l-103.88671875-55.45898437-209.44335938 112.5c-3.8671875 1.66992188-7.29492188 3.07617188-10.89843749 3.515625l-0.87890625 0.43945313-2.63671875-1e-8-0.703125 0L508.484375 566.40429688l-0.52734375 0-3.07617188 0-0.61523437-0.43945313c-3.8671875-0.43945313-7.11914063-1.84570313-10.63476563-3.515625l-209.97070312-112.5-103.62304688 55.45898438C289.8125 564.20703125 399.5 623.18164063 509.45117187 681.89257813L509.45117187 681.89257813 509.45117187 681.89257813zM509.45117187 495.4765625L509.45117187 495.4765625c109.24804688-58.44726563 219.55078125-117.68554688 328.97460938-176.22070313L509.45117187 142.5078125 180.125 319.25585937C289.8125 377.79101562 399.5 437.02929687 509.45117187 495.4765625L509.45117187 495.4765625 509.45117187 495.4765625z"  ></path></symbol><symbol id="icon-bianji" viewBox="0 0 1025 1024"><path d="M352.376267 760.009763C350.834511 761.551537 344.542685 764.999821 342.477506 765.457002L180.527334 801.308566 222.635043 843.416258 258.486607 681.466086C258.968311 679.290121 262.315961 673.185192 263.933828 671.567325L802.537066 132.964087C816.326621 119.17455 816.326621 96.817276 802.537066 83.027721 788.747511 69.238184 766.390237 69.238184 752.6007 83.027721L213.997462 621.630958C202.867871 632.76055 192.923842 650.894883 189.535232 666.202041L153.683668 828.152232C148.102938 853.36177 170.581839 875.840671 195.791378 870.259924L357.74155 834.40836C372.932502 831.045473 391.255217 821.003546 402.312651 809.94613L940.915871 271.34291C954.705426 257.553355 954.705426 235.196081 940.915871 221.406543 927.126334 207.616989 904.769059 207.616989 890.979505 221.406543L352.376267 760.009763ZM414.64915 72.685568 51.729426 72.685568C23.157654 72.685568 0 95.845588 0 124.414994L0 972.214166C0 1000.785938 23.16002 1023.943592 51.729426 1023.943592L899.528598 1023.943592C928.10037 1023.943592 951.258041 1000.783572 951.258041 972.214166L951.258041 609.294442 951.258041 427.83458C951.258041 408.333224 935.449053 392.524235 915.947697 392.524235 896.446323 392.524235 880.637352 408.333224 880.637352 427.83458L880.637352 609.294442 880.637352 972.214166C880.637352 961.782466 889.096033 953.322902 899.528598 953.322902L51.729426 953.322902C62.161143 953.322902 70.62069 961.781601 70.62069 972.214166L70.62069 124.414994C70.62069 134.846711 62.162008 143.306258 51.729426 143.306258L414.64915 143.306258 596.109012 143.306258C615.610386 143.306258 631.419357 127.497269 631.419357 107.995913 631.419357 88.494539 615.610386 72.685568 596.109012 72.685568L414.64915 72.685568ZM1008.873949 203.384814C1029.040658 183.218105 1029.030682 150.678581 1008.912031 130.559929L951.147855 72.795754 893.383662 15.031561C873.350038-5.002063 840.660092-5.031671 820.558777 15.069643L752.6007 83.027721C738.811145 96.817276 738.811145 119.17455 752.6007 132.964087 766.390237 146.753642 788.747511 146.753642 802.537066 132.964087L870.495144 65.006009C862.997098 72.504055 850.972531 72.49318 843.447296 64.967927L901.211489 122.73212 958.975665 180.496296C951.522074 173.042706 951.518349 160.867699 958.937582 153.448448L890.979505 221.406543C877.18995 235.196081 877.18995 257.553355 890.979505 271.34291 904.769059 285.132447 927.126334 285.132447 940.915871 271.34291L1008.873949 203.384814Z"  ></path></symbol><symbol id="icon-fangda" viewBox="0 0 1024 1024"><path d="M118.24066865 154.674067l0 235.89566279c0 16.64231661 13.5070418 30.15025839 30.1502584 30.15025839 16.64321572 0 30.15025839-13.5079418 30.1502584-30.15025839L178.54118545 220.34034511l191.69602997 191.75628956c11.27565527 11.2765544 29.54766709 11.2765544 40.88268195 0 11.2765544-11.33591396 11.2765544-29.60702666 0-40.88358105l-191.75628956-191.69602999 170.22938467 0c16.64231661 0 30.15025839-13.5079418 30.1502584-30.1502584 0-16.64231661-13.5079418-30.15025839-30.1502584-30.1502584L153.69732881 119.21650684C131.68745176 119.21650684 118.24066865 130.55421992 118.24066865 154.674067L118.24066865 154.674067z"  ></path><path d="M868.56235068 119.21650684L632.66578877 119.21650684c-16.64231661 0-30.15025839 13.5079418-30.1502584 30.15025839 0 16.64321572 13.5079418 30.15025839 30.1502584 30.15025841l170.22938467 0-191.75628956 191.69602998c-11.2765544 11.27565527-11.2765544 29.54766709 0 40.88358105 11.33591396 11.2765544 29.60702666 11.2765544 40.88268194 0L843.7175958 220.34034511l0 170.22938468c0 16.64231661 13.5079418 30.15025839 30.1502584 30.15025839 16.64321572 0 30.15025839-13.5079418 30.1502584-30.15025839L904.01811172 154.674067C904.01811172 130.55421992 890.63248731 119.21650684 868.56235068 119.21650684L868.56235068 119.21650684z"  ></path><path d="M153.69732881 903.12501729l235.89656192 0c16.64231661 0 30.15025839-13.5070418 30.15025839-30.15025841 0-16.64321572-13.5079418-30.15025839-30.15025839-30.15025839L219.36450693 842.82450137l191.75628955-191.69602999c11.2765544-11.27565527 11.2765544-29.54766709 0-40.88268193-11.33591396-11.2765544-29.60702666-11.2765544-40.88268193 0l-191.69602998 191.75628956L178.54208457 631.77269434c0-16.64231661-13.5070418-30.15025839-30.1502584-30.1502584-16.64321572 0-30.15025839 13.5079418-30.15025839 30.1502584l0 235.89656191C118.24066865 891.78910332 131.68745176 903.12501729 153.69732881 903.12501729L153.69732881 903.12501729z"  ></path><path d="M904.01811172 867.66835713L904.01811172 631.77269434c0-16.64231661-13.5070418-30.15025839-30.15025839-30.1502584-16.64231661 0-30.15025839 13.5079418-30.15025841 30.1502584l0 170.22938467L652.02156494 610.24578945c-11.27565527-11.2765544-29.54766709-11.2765544-40.88268194 0-11.2765544 11.33591396-11.2765544 29.60702666 0 40.88268193l191.75628956 191.69602999L632.66578877 842.82450137c-16.64231661 0-30.15025839 13.5070418-30.1502584 30.1502584 0 16.64321572 13.5079418 30.15025839 30.1502584 30.15025839l235.89656191 0C890.63248731 903.12501729 904.01811172 891.78910332 904.01811172 867.66835713L904.01811172 867.66835713z"  ></path></symbol><symbol id="icon-t-down" viewBox="0 0 1024 1024"><path d="M882.78857421 364.10205078l-370.80878905 370.72529297-370.76835939-370.72529297 741.57714844 0z"  ></path></symbol><symbol id="icon-suo" viewBox="0 0 1024 1024"><path d="M853.333287 403.394199h-62.060911v-124.121823C791.272376 124.121823 667.150552 0 512 0 356.848296 0 232.726473 124.121823 232.726473 279.272376v124.121823H170.666713C136.533499 403.394199 108.605801 431.320746 108.605801 465.453959v496.48384c0 34.134365 27.927698 62.060912 62.060912 62.060911h682.666574c34.133214 0 62.060912-27.926547 62.060912-62.060911V465.455111c0-34.134365-27.927698-62.060912-62.060912-62.060912zM574.05976 760.241851v62.05976c0 24.824365-21.722183 46.545396-46.546547 46.545396-24.823213 0-46.544244-21.721031-46.544245-46.544245V760.241851c-18.618849-15.515516-31.031032-37.236547-31.031031-62.060912 0-43.443214 34.133214-77.576428 77.575276-77.576428 43.443214 0 77.576428 34.133214 77.576427 77.576428 0 24.824365-12.413334 46.544244-31.02988 62.060912zM698.181584 403.394199H325.818416v-124.121823c0-102.399641 83.780791-186.181584 186.181584-186.181584C614.399641 93.090792 698.181584 176.872735 698.181584 279.272376v124.121823z"  ></path></symbol><symbol id="icon-caidan-copy" viewBox="0 0 1024 1024"><path d="M139.478 870.539c0 7.14 5.825 12.966 12.966 12.966h266.122c7.193 0 12.967-5.824 12.967-12.966v-266.069c0-7.194-5.774-12.969-12.968-12.969h-266.122c-7.14 0-12.966 5.774-12.966 12.969v266.069zM139.478 416.405c0 7.14 5.825 12.966 12.966 12.965h266.122c7.193 0 12.967-5.824 12.967-12.966v-266.172c0-7.092-5.773-12.966-12.967-12.966h-266.122c-7.14 0-12.966 5.873-12.966 12.966v266.172zM107.872 416.405v-266.172c0-24.565 20.109-44.572 44.571-44.572h266.122c24.566 0 44.674 20.005 44.674 44.572v266.172c0 24.511-20.058 44.571-44.674 44.571h-266.122c-24.462-0.001-44.572-20.005-44.572-44.571v0 0zM593.614 870.539c0 7.14 5.822 12.966 12.912 12.966h266.125c7.193 0 12.965-5.824 12.965-12.966v-266.069c0-7.194-5.774-12.969-12.965-12.969h-266.125c-7.091 0-12.912 5.774-12.912 12.969v266.069zM561.906 870.538v-266.069c0-24.566 20.056-44.677 44.619-44.677h266.125c24.616-0.049 44.67 20.057 44.67 44.622v266.122c0 24.517-20.055 44.572-44.67 44.572h-266.125c-24.513 0-44.619-20.056-44.619-44.572v0 0zM561.906 416.405v-266.172c0-24.565 20.056-44.572 44.619-44.572h266.125c24.563 0 44.67 20.005 44.67 44.572v266.172c0 24.511-20.055 44.57-44.67 44.571h-266.125c-24.512-0.001-44.619-20.005-44.619-44.571v0 0zM107.872 870.539v-266.069c0-24.566 20.109-44.677 44.571-44.677h266.122c24.566 0 44.674 20.11 44.674 44.677v266.069c0 24.517-20.107 44.572-44.674 44.572h-266.122c-24.462 0-44.572-20.056-44.572-44.572v0 0zM107.872 870.539z"  ></path></symbol><symbol id="icon-bianji1" viewBox="0 0 1024 1024"><path d="M121.018182 912.290909h786.618182V977.454545H121.018182zM176.872727 781.963636H186.181818l204.8-65.163636c4.654545 0 9.309091-4.654545 13.963637-9.309091l465.454545-465.454545c4.654545-4.654545 9.309091-13.963636 9.309091-23.272728s-4.654545-18.618182-9.309091-23.272727l-144.290909-144.290909c-13.963636-13.963636-32.581818-13.963636-46.545455 0l-465.454545 465.454545c-4.654545 4.654545-4.654545 9.309091-9.309091 13.963637L139.636364 735.418182c-4.654545 13.963636 0 23.272727 9.309091 32.581818 9.309091 9.309091 18.618182 13.963636 27.927272 13.963636z m93.090909-223.418181l432.872728-432.872728 97.745454 97.745455-432.872727 432.872727-139.636364 41.890909 41.890909-139.636363z"  ></path></symbol><symbol id="icon-zhankai" viewBox="0 0 1024 1024"><path d="M63.35 819.35h897.3v99.9H63.35v-99.9z m0.45-249.3h598.05v100.35H63.8v-100.35z m0-199.35h598.05v100.35H63.8V370.7zM63.35 121.4h897.3v100.35H63.35V121.4zM760.4 345.5l200.25 175.5-200.25 174.6V345.5z"  ></path></symbol><symbol id="icon-shouqi" viewBox="0 0 1024 1024"><path d="M972.8 204.8h-921.601v-102.4h921.601v102.4z"  ></path><path d="M665.6 460.801h-614.399v-103.253h614.399v103.253z"  ></path><path d="M665.6 665.6h-614.399v-103.253h614.399v103.253z"  ></path><path d="M972.8 921.6h-921.601v-103.253h921.601c0 0 0 103.253 0 103.253z"  ></path><path d="M972.8 691.2l-205.653-205.653 205.653-153.6v359.253z"  ></path></symbol><symbol id="icon-upload" viewBox="0 0 1024 1024"><path d="M840.5 900.3h-657c-16.5 0-29.9 13.4-29.9 29.9s13.4 29.9 29.9 29.9h657.1c16.5 0 29.9-13.4 29.9-29.9-0.1-16.6-13.5-29.9-30-29.9zM512 134.2l251.2 228H631.5v418.2h-239V362.3H260.9L512 134.2m0-70.2c-7.6 0-15.3 2.9-21.1 8.7L162.4 371c-18.8 18.8-5.5 51 21.1 51h149.3v358.4c0 33 26.7 59.7 59.7 59.7h238.9c33 0 59.7-26.7 59.7-59.7V422h149.3c26.6 0 39.9-32.2 21.1-51L533.1 72.7c-5.8-5.8-13.5-8.7-21.1-8.7z"  ></path></symbol><symbol id="icon-t-right" viewBox="0 0 1024 1024"><path d="M364.10205078 141.21142579l370.72529297 370.80878905-370.72529297 370.76835939 0-741.57714844z"  ></path></symbol><symbol id="icon-suoxiao" viewBox="0 0 1024 1024"><path d="M413.51451475 400.62212351c0-0.08955286 0.00542752-0.1804628 0.00542751-0.27001567V159.29773768c0-18.40309634-14.92003537-33.32313172-33.32313171-33.32313172-18.40173926 0-33.32720215 14.92003537-33.32720216 33.32313171v155.43920023L153.48445261 102.00702534C141.10310278 88.39093225 120.02970578 87.3841424 106.40818518 99.76549222 92.7920921 112.14684204 91.78530142 133.22566657 104.16665207 146.84175964l201.31871704 221.45452405H138.31611166c-18.40852386 0-33.32855923 14.92003537-33.32855924 33.32177546 0 18.40852386 14.92003537 33.32855923 33.32855924 33.32855923h241.04894349a33.21458294 33.21458294 0 0 0 21.62563879-7.97698225c0.54545801-0.43962259 1.09091602-0.89552774 1.62144854-1.37856966 7.3189042-6.64590152 10.98785467-15.80470889 10.90237226-24.96894296M610.35423599 400.62212351c0-0.08955286-0.00542752-0.1804628-0.00542752-0.27001567V159.29773768c0-18.40309634 14.92003537-33.32313172 33.32855923-33.32313172 18.40309634 0 33.32177463 14.92003537 33.32177546 33.32313171v155.43920023L870.38429813 102.00702534c12.38134983-13.61609308 33.46017434-14.62288294 47.07626742-2.24153312 13.62152061 12.38134983 14.62288294 33.46017434 2.24153311 47.07626742L718.38338162 368.29628369H885.55942368c18.40309634 0 33.32313172 14.92003537 33.32313171 33.32177546 0 18.40852386-14.92003537 33.32855923-33.32313171 33.32855923H644.50369558a33.19965747 33.19965747 0 0 1-21.62021126-7.97698225c-0.55088553-0.43962259-1.0976998-0.89552774-1.62687525-1.37856966-7.31347669-6.64590152-10.98107007-15.80470889-10.90237308-24.96894296M413.51451475 623.0522302c0 0.08955286 0.00542752 0.1804628 0.00542751 0.27001482V864.37661602c0 18.40309634-14.92003537 33.32313172-33.32313171 33.32313172-18.40173926 0-33.32720215-14.92003537-33.32720216-33.32313171V708.9374158L153.48445261 921.66190085c-12.38134983 13.62152061-33.45474683 14.62288294-47.07626743 2.24153311-13.61609308-12.38134983-14.62288294-33.45474683-2.24153311-47.07084072l201.31871704-221.45452406H138.31611166c-18.40852386 0-33.32855923-14.92003537-33.32855924-33.32855924 0-18.40173926 14.92003537-33.32177463 33.32855924-33.32177461h241.04894349a33.18608908 33.18608908 0 0 1 21.62563879 7.9769814c0.54545801 0.43962259 1.09091602 0.89010022 1.62144854 1.37178589 7.3189042 6.65268613 10.98785467 15.81149268 10.90237226 24.97572758M610.35423599 623.0522302c0 0.08955286-0.00542752 0.1804628-0.00542752 0.27001482V864.37661602c0 18.40309634 14.92003537 33.32313172 33.32855923 33.32313172 18.40309634 0 33.32177463-14.92003537 33.32177546-33.32313171V708.9374158l193.38515497 212.72448505c12.38134983 13.62152061 33.46017434 14.62288294 47.07626742 2.24153311 13.62152061-12.38134983 14.62288294-33.45474683 2.24153311-47.07084072L718.38338162 655.37806918H885.55942368c18.40309634 0 33.32313172-14.92003537 33.32313171-33.32855923 0-18.40173926-14.92003537-33.32177463-33.32313171-33.32177463H644.50369558a33.1711636 33.1711636 0 0 0-21.62021126 7.97698142c-0.55088553 0.43962259-1.0976998 0.89010022-1.62687525 1.37178589-7.31347669 6.65268613-10.98107007 15.81149268-10.90237308 24.97572757"  ></path></symbol><symbol id="icon-guanbi" viewBox="0 0 1024 1024"><path d="M598.92622222 516.66488889l226.19022223-226.19022222c24.00711111-24.00711111 24.00711111-62.91911111 0-86.92622222-24.00711111-24.00711111-62.91911111-24.00711111-86.92622223 0L512 429.73866667 285.80977778 203.66222222c-24.00711111-24.00711111-62.91911111-24.00711111-86.92622223 0-24.00711111 24.00711111-24.00711111 62.91911111 0 86.92622223l226.19022223 226.19022222-225.28 225.16622222c-24.00711111 24.00711111-24.00711111 62.91911111 0 86.92622222 24.00711111 24.00711111 62.91911111 24.00711111 86.92622222 0l225.28-225.16622222 225.16622222 225.16622222c24.00711111 24.00711111 62.91911111 24.00711111 86.92622223 0 24.00711111-24.00711111 24.00711111-62.91911111 0-86.92622222l-225.16622223-225.28z"  ></path></symbol><symbol id="icon-poumian" viewBox="0 0 1219 1024"><path d="M623.13650753 900.57142812h-274.28571375v-91.42857093h274.28571375v91.42857093z m-365.71428562 0H170.5650791c-77.71428563 0-137.14285687-59.42857125-137.14285688-137.14285687v-41.14285688h91.42857188v41.14285688c0 27.42857156 18.28571437 45.71428594 45.714285 45.71428594h86.85714281v91.42857093zM124.8507941 630.8571425H33.42222222v-274.28571375h91.42857188v274.28571375z m-91.42857188-365.71428563C33.42222222 182.85714313 92.85079348 123.42857188 170.5650791 123.42857188h128.00000063v91.42857093H170.5650791c-27.42857156 0-45.71428594 18.28571437-45.71428501 45.71428594l-91.42857187 4.57142812zM627.70793659 214.85714281H389.99365066V123.42857188H627.70793659v91.42857093zM1039.13650816 900.57142812h-228.57142874v-91.42857093h228.57142874c27.42857156 0 45.71428594-18.28571437 45.71428594-45.71428594V260.57142875c0-27.42857156-18.28571437-45.71428594-45.71428594-45.71428594h-228.57142874V123.42857188h228.57142874c77.71428563 0 137.14285687 59.42857125 137.14285687 137.14285687v502.8571425c0 77.71428563-59.42857125 137.14285687-137.14285687 137.14285688z"  ></path><path d="M719.13650753 32c27.42857156 0 45.71428594 18.28571437 45.71428595 45.71428594v868.57142812c0 27.42857156-18.28571437 45.71428594-45.71428595 45.71428594s-45.71428594-18.28571437-45.714285-45.71428594V77.71428594c0-27.42857156 18.28571437-45.71428594 45.714285-45.71428594z"  ></path></symbol><symbol id="icon-choose" viewBox="0 0 1177 1024"><path d="M422 827H197c-76.50000001 0-135-58.50000001-135-135V197c0-76.50000001 58.50000001-135 135-135h765c76.50000001 0 135 58.50000001 134.99999998 135v225h-89.99999998V197c0-27-18-45-45-45.00000001H197c-27 0-45 18-45.00000001 45.00000001v495c0 27 18 45 45.00000001 45h225v90z"  ></path><path d="M854 962c-49.50000001 0-94.50000001-22.50000003-121.49999999-67.50000002l-72-116.99999997-148.50000001 81 13.50000001-571.50000001L1052 561.50000001 899 647l72 117c36 58.50000001 18 139.50000001-40.50000001 180-4.50000001 0-4.50000001 4.50000001-9 4.50000001-22.50000003 9-45 13.50000001-67.49999999 13.49999999zM692 656l117 193.50000001c13.50000001 22.50000003 45 31.50000001 67.50000001 17.99999998 18-13.50000001 27-36 13.49999999-54.00000001l-121.50000001-197.99999995 85.50000001-45.00000005-247.50000001-130.49999997-4.49999999 269.99999999 90-54z"  ></path></symbol><symbol id="icon-shikou" viewBox="0 0 1251 1024"><path d="M85.33333345 138.66666688h959.99999999c31.99999969 0 53.33333344 21.33333375 53.33333345 53.33333343s-21.33333375 53.33333344-53.33333345 53.33333344H85.33333345c-31.99999969 0-53.33333344-21.33333375-53.33333345-53.33333344s21.33333375-53.33333344 53.33333341-53.33333343z m959.99999999 0c31.99999969 0 53.33333344 21.33333375 53.33333345 53.33333343v746.66666624c0 31.99999969-21.33333375 53.33333344-53.33333345 53.33333345s-53.33333344-21.33333375-53.33333344-53.33333345V192.00000031c0-31.99999969 21.33333375-53.33333344 53.33333344-53.33333344zM192.00000031 778.66666625h960c31.99999969 0 53.33333344 21.33333375 53.33333344 53.33333344s-21.33333375 53.33333344-53.33333344 53.33333344H192.00000031c-31.99999969 0-53.33333344-21.33333375-53.33333344-53.33333344s21.33333375-53.33333344 53.33333344-53.33333344zM192.00000031 32c31.99999969 0 53.33333344 21.33333375 53.33333344 53.33333341v746.66666628c0 31.99999969-21.33333375 53.33333344-53.33333344 53.33333343s-53.33333344-21.33333375-53.33333344-53.33333343V85.33333345c0-31.99999969 21.33333375-53.33333344 53.33333344-53.33333345zM405.33333312 512H298.66666625V298.66666625h213.33333375v106.66666688H405.33333312zM938.66666655 725.33333375h-213.3333328v-106.66666688h106.66666594V512h106.66666686z"  ></path></symbol><symbol id="icon-mark" viewBox="0 0 1170 1024"><path d="M640.43480761 962c-201.38100732 0-377.05380029-132.8257705-432.75493037-325.63737334-8.5694045-8.5694045-34.27761797-21.42351123-47.13172471-29.99291572-51.41642695-21.42351123-98.54815254-47.13172471-98.54815253-94.26345029s47.13172471-72.83993906 98.54815253-98.54815255c17.13880898-8.5694045 42.84702247-21.42351123 51.41642696-29.99291571C276.23511406 152.19126933 524.74784609 10.79609346 760.40647138 79.35133028 957.50277646 135.05246035 1090.32854697 310.72525332 1090.32854697 512.10626065 1090.32854697 760.61899268 888.94753965 962 640.43480761 962zM160.54815253 512.10626065c12.85410674 8.5694045 25.70821348 17.13880898 38.56232023 21.42351122 42.84702247 21.42351123 81.40934356 42.84702247 89.97874804 77.12464131 42.84702247 158.53398398 188.52690059 265.65154102 351.34558682 265.65154102 201.38100732 0 364.19969355-162.81868623 364.19969355-364.19969355 0-162.81868623-107.11755703-308.49856435-265.65154101-351.34558682-192.81160283-51.41642695-394.19261016 59.98583232-449.89373936 252.79743427-8.5694045 34.27761797-47.13172471 55.7011292-89.97874804 77.12464131-12.85410674 4.28470224-25.70821348 12.85410674-38.56232022 21.42351124z"  ></path><path d="M640.43480761 512.10626065m-64.27053368 0a64.27053457 64.27053457 0 1 0 128.54106826 0 64.27053457 64.27053457 0 1 0-128.54106826 0Z"  ></path></symbol><symbol id="icon-coordinate" viewBox="0 0 1024 1024"><path d="M313.67558328 890.89348215c-91.92606976 0-164.15369659-72.22762683-164.15369577-164.15369577s72.22762683-164.15369659 164.15369577-164.1536966 164.15369659 72.22762683 164.1536966 164.1536966-72.22762683 164.15369659-164.1536966 164.15369577z m0-262.64591373c-55.81225717 0-98.49221797 42.67996079-98.49221714 98.49221796s42.67996079 98.49221797 98.49221714 98.49221713 98.49221797-42.67996079 98.49221796-98.49221713-42.67996079-98.49221797-98.49221796-98.49221796zM730.62597296 913.875L684.66293808 867.91196512l141.17217874-141.17217874-141.17217874-141.17217956 45.96303488-45.96303489 187.13521363 187.13521445z"  ></path><path d="M444.99854055 693.90904706h397.25194591c16.41536965 0 29.54766522 13.13229556 29.54766524 32.83073932s-13.13229556 32.83073932-29.54766524 32.83073932H444.99854055c-16.41536965 0-29.54766522-13.13229556-29.54766522-32.83073932s13.13229556-32.83073932 29.54766522-32.83073931z"  ></path><path d="M454.84776284 322.92169227L313.67558328 181.74951352 172.50340453 322.92169227 126.54036965 276.95865738 313.67558328 89.82344376l187.13521445 187.13521362z"  ></path><path d="M313.67558328 135.78647864c19.69844376 0 32.83073932 13.13229556 32.83073932 32.83073932v426.79961115c0 19.69844376-13.13229556 32.83073932-32.83073932 32.83073932s-32.83073932-13.13229556-32.83073931-32.83073933V168.61721797c0-19.69844376 16.41536965-32.83073932 32.83073931-32.83073933z"  ></path></symbol><symbol id="icon-yuan" viewBox="0 0 1024 1024"><path d="M195.59375 90.125c21.09375 0 35.15625027 14.06250027 35.15625027 35.15625027v703.12499973c0 21.09375-14.06250027 35.15625027-35.15625027 35.15625027s-35.15625027-14.06250027-35.15625027-35.15625027V125.28125027c0-21.09375 14.06250027-35.15625027 35.15625027-35.15625027z"  ></path><path d="M195.59375 793.24999973h703.12499973c21.09375 0 35.15625027 14.06250027 35.15625027 35.15625027s-14.06250027 35.15625027-35.15625027 35.15625027H195.59375c-21.09375 0-35.15625027-14.06250027-35.15625027-35.15625027s14.06250027-35.15625027 35.15625027-35.15625027zM125.28125027 160.43749973h35.15624946c21.09375 0 35.15625027 14.06250027 35.15625027 35.15625027s-14.06250027 35.15625027-35.15625027 35.15625027H125.28125027c-21.09375 0-35.15625027-14.06250027-35.15625027-35.15625027s14.06250027-35.15625027 35.15625027-35.15625027z"  ></path><path d="M793.24999973 828.40625c21.09375 0 35.15625027 14.06250027 35.15625027 35.15625027v35.15624946c0 21.09375-14.06250027 35.15625027-35.15625027 35.15625027s-35.15625027-14.06250027-35.15624946-35.15625027v-35.15624946c0-21.09375 14.06250027-35.15625027 35.15624946-35.15625027zM758.09375027 160.43749973H371.37499973c-38.67187473 0-70.31249973 31.640625-70.31249973 70.31250054v421.875c0 38.67187473 31.640625 70.31249973 70.31249973 70.31249973h386.71875054c38.67187473 0 70.31249973-31.640625 70.31249973-70.31249973V230.75000027c0-38.67187473-31.640625-70.31249973-70.31249973-70.31250054z m0 492.18750054H371.37499973V230.75000027h386.71875054v421.875z"  ></path></symbol><symbol id="icon-ceju" viewBox="0 0 1024 1024"><path d="M446.0820315 907.5078125H215.36914062c-56.03027318 0-98.87695313-42.84667994-98.87695312-98.87695313V215.36914062c0-56.03027318 42.84667994-98.87695313 98.87695313-98.87695312h230.71289087c56.03027318 0 98.87695313 42.84667994 98.87695313 98.87695313v593.26171875c0 56.03027318-42.84667994 98.87695313-98.87695313 98.87695312zM215.36914062 182.410156c-19.77539063 0-32.95898463 13.183594-32.95898462 32.95898463v593.26171875c0 19.77539063 13.183594 32.95898463 32.95898463 32.95898462h230.71289087c19.77539063 0 32.95898463-13.183594 32.95898387-32.95898462V215.36914062c0-19.77539063-13.183594-32.95898463-32.95898387-32.95898462H215.36914062z"  ></path><path d="M347.20507838 281.28710912h131.83593699c19.77539063 0 32.95898463 13.183594 32.95898463 32.95898463s-13.183594 32.95898463-32.95898463 32.95898463H347.20507838c-19.77539063 0-32.95898463-13.183594-32.95898463-32.95898463s13.183594-32.95898463 32.95898463-32.95898463z m65.91796849 98.87695313h32.95898463c19.77539063 0 32.95898463 13.183594 32.95898387 32.95898463s-13.183594 32.95898463-32.95898387 32.95898462H413.12304687c-19.77539063 0-32.95898463-13.183594-32.95898462-32.95898462s13.183594-32.95898463 32.95898463-32.95898463z m0 98.87695312h32.95898463c19.77539063 0 32.95898463 13.183594 32.95898387 32.95898463s-13.183594 32.95898463-32.95898387 32.95898463H413.12304687c-19.77539063 0-32.95898463-13.183594-32.95898462-32.95898463s13.183594-32.95898463 32.95898463-32.95898463z m-65.91796849 98.87695313h131.83593699c19.77539063 0 32.95898463 13.183594 32.95898463 32.95898463s-13.183594 32.95898463-32.95898463 32.95898462H347.20507838c-19.77539063 0-32.95898463-13.183594-32.95898463-32.95898462s13.183594-32.95898463 32.95898463-32.95898463z m65.91796849 98.87695312h32.95898463c19.77539063 0 32.95898463 13.183594 32.95898387 32.95898463s-13.183594 32.95898463-32.95898387 32.95898463H413.12304687c-19.77539063 0-32.95898463-13.183594-32.95898462-32.95898463s13.183594-32.95898463 32.95898463-32.95898463z"  ></path><path d="M610.87695313 116.4921875h263.67187474c19.77539063 0 32.95898463 13.183594 32.95898463 32.95898463s-13.183594 32.95898463-32.95898463 32.95898387h-263.67187475c-19.77539063 0-32.95898463-13.183594-32.95898462-32.95898387s13.183594-32.95898463 32.95898462-32.95898463zM610.87695313 841.589844h263.67187474c19.77539063 0 32.95898463 13.183594 32.95898463 32.95898387s-13.183594 32.95898463-32.95898463 32.95898463h-263.67187475c-19.77539063 0-32.95898463-13.183594-32.95898462-32.95898463s13.183594-32.95898463 32.95898462-32.95898387z"  ></path><path d="M709.75390625 314.24609375h65.9179685v395.5078125h-65.9179685z"  ></path><path d="M742.71289088 182.410156l131.83593699 131.83593775h-263.67187474l131.83593775-131.83593775z"  ></path><path d="M742.71289088 841.589844l-131.83593776-131.83593775h263.67187475l-131.83593699 131.83593775z"  ></path></symbol><symbol id="icon-open" viewBox="0 0 1371 1024"><path d="M674.8959275 992c-273.66515812 0-521.26696875-182.44343906-634.208145-464.79637969L32 509.82805437l8.6877825-17.37556593C149.2850675 214.44343906 401.23076937 32 674.8959275 32c273.66515812 0 521.26696875 182.44343906 634.208145 464.79637969l8.6877825 17.37556594-8.6877825 17.37556593c-112.94117625 278.00904937-360.54298687 460.45248844-634.208145 460.45248844zM131.9095025 509.82805437c99.9095025 238.91402719 312.76018125 390.95022656 542.986425 390.95022657s443.07692345-152.03619937 542.986425-390.95022656C1117.97285093 270.91402719 905.12217219 118.87782781 674.8959275 118.87782781c-230.22624468 4.34389125-443.07692345 156.38009063-542.986425 390.95022657z"  ></path><path d="M674.8959275 687.92760219c-95.56561125 0-173.75565657-78.19004531-173.75565564-173.75565657s78.19004531-173.75565657 173.75565564-173.75565563 173.75565657 78.19004531 173.75565656 173.75565564-78.19004531 173.75565657-173.75565656 173.75565656z m0-264.97737563c-47.78280562 0-86.87782781 39.09502219-86.87782781 86.87782781s39.09502219 86.87782781 86.87782781 86.87782782 86.87782781-39.09502219 86.8778278-86.87782782-39.09502219-86.87782781-86.8778278-86.87782781z"  ></path></symbol><symbol id="icon-close" viewBox="0 0 1312 1024"><path d="M671.33752758 992c-261.81818156 0-498.70129875-174.54545437-606.75324655-444.67532437L56.27259259 530.70129875l8.31168844-16.62337688C168.48038509 248.10389657 409.51934603 73.55844125 671.33752758 73.55844125c261.81818156 0 498.70129875 174.54545437 606.75324656 444.67532531l8.31168844 16.62337594-8.31168844 16.62337688c-108.05194781 265.97402625-344.93506501 440.51948063-606.75324656 440.51948062zM151.8570082 530.70129875c95.58441563 228.57142875 299.22077906 374.02597406 519.48051938 374.02597406s423.89610375-145.45454531 519.48051939-374.02597406C1095.23363135 302.12986999 891.5972679 156.67532469 671.33752758 156.67532469c-220.25974031 4.15584375-423.89610375 149.61039001-519.48051938 374.02597406z"  ></path><path d="M1132.63622883 32l58.18181812 58.18181812L251.59726758 992l-58.18181811-58.18181812L1132.63622883 32z"  ></path></symbol><symbol id="icon-jia" viewBox="0 0 1024 1024"><path d="M997.65534176 975.53439452h-953.21172669v-955.22272189h953.21172669v955.22272189z m-902.93684658-50.2748801h852.66196649v-854.67296171h-852.66196649v854.67296171z"  ></path><path d="M809.62729018 522.05497602h-578.16112115c-14.07696642 0-25.13744005-11.06047362-25.13744005-25.13744005s11.06047362-25.13744005 25.13744005-25.13744004h578.16112115c14.07696642 0 25.13744005 11.06047362 25.13744006 25.13744004S823.70425663 522.05497602 809.62729018 522.05497602z"  ></path><path d="M521.04947843 800.57781178c-14.07696642 0-25.13744005-11.06047362-25.13744006-25.13744005v-556.04017391c0-14.07696642 11.06047362-25.13744005 25.13744006-25.13744005s25.13744005 11.06047362 25.13744004 25.13744005v556.04017391c0 13.07146883-11.06047362 25.13744005-25.13744004 25.13744005z"  ></path></symbol><symbol id="icon-zanting" viewBox="0 0 1024 1024"><path d="M512 960A448 448 0 1 0 512 64a448 448 0 0 0 0 896z m0 64A512 512 0 1 1 512 0a512 512 0 0 1 0 1024z"  ></path><path d="M672 640a32 32 0 0 1-64 0V384a32 32 0 0 1 64 0v256zM416 640a32 32 0 0 1-64 0V384a32 32 0 1 1 64 0v256z"  ></path></symbol><symbol id="icon-bofang" viewBox="0 0 1024 1024"><path d="M512 960A448 448 0 1 0 512 64a448 448 0 0 0 0 896z m0 64A512 512 0 1 1 512 0a512 512 0 0 1 0 1024z"  ></path><path d="M448 422.656v217.088L621.632 531.2 448 422.656z m14.336 283.584A51.2 51.2 0 0 1 384 662.848V399.552a51.2 51.2 0 0 1 78.336-43.392l210.56 131.648a51.2 51.2 0 0 1 0 86.784l-210.56 131.648z"  ></path></symbol><symbol id="icon-zu" viewBox="0 0 1024 1024"><path d="M932.25841867 537.60172745a280.61742453 280.61742453 0 0 0-69.72385391-40.55510413 351.18471203 351.18471203 0 0 0-312.35161762-334.42146689v80.829064L435.15967432 90.125h115.02327282v1.93286892A421.7168562 421.7168562 0 0 1 933.5587124 511.8418562c0 8.6803385-0.77314774 17.18496194-1.30029373 25.75987125zM722.7002843 406.76407309v210.8584281l-204.21638772 105.42921405L300.9834281 617.72793039v-210.8584281l217.39503928-105.42921405z m-175.71535647 230.08168817l105.42921405-54.40147503v-140.57228486l-1.15972202-0.59743268a26.67359152 26.67359152 0 0 1-9.2074845 27.69274018L546.98492783 527.48052268v109.36523858z m-175.7153573-54.40147503l105.42921404 51.16831238v-85.15166199l-105.42921404-60.90294288v94.88629248z m33.28048855-156.80838401l92.4614209 53.38232556 103.60177432-63.92524713-84.3433709-43.61255172z m30.60961524 428.53461163v-73.80044934l61.74637646 82.30507279c0 0.2108584 0.2108584 0.38657346 0.28114426 0.56228934L550.18294714 933.5587124H435.15967432v-7.30975891A421.7168562 421.7168562 0 0 1 90.125 511.8418562c0-12.40550381 0.80829025-24.60015006 1.86258307-36.79479547a279.07112989 279.07112989 0 0 0 68.88041949 27.69274018C160.7977167 505.79724768 160.41114243 508.7844086 160.41114243 511.8418562a350.90356777 350.90356777 0 0 0 274.74853189 342.32865765z"  ></path></symbol><symbol id="icon-celiang" viewBox="0 0 1072 1024"><path d="M933.875 170.48214326h-241.07142893a40.17857163 40.17857163 0 1 1 0-80.35714326h241.07142893a40.17857163 40.17857163 0 1 1 0 80.35714326z m-80.35714326 161.15625v360.68303567h120.53571489L813.33928595 853.51785674l-160.71428568-161.15625h120.53571406V331.63839326h-120.53571406L813.33928595 170.48214326l160.71428568 161.15625h-120.53571489zM974.05357163 893.69642837a40.17857163 40.17857163 0 0 1-40.17857163 40.17857163h-241.07142893a40.17857163 40.17857163 0 0 1 0-80.35714325h241.07142893a40.17857163 40.17857163 0 0 1 40.17857163 40.17857162z m-482.14285703 40.17857163H170.48214326a80.35714326 80.35714326 0 0 1-80.35714326-80.35714325V170.48214326a80.35714326 80.35714326 0 0 1 80.35714326-80.35714326h321.42857134a80.35714326 80.35714326 0 0 1 80.35714243 80.35714326v683.03571348a80.35714326 80.35714326 0 0 1-80.35714243 80.35714326z m-61.15178568-160.71428567H491.9107146v-40.17857163H371.37499973a40.17857163 40.17857163 0 0 1 0-80.35714243h120.53571487v-40.17857162H430.75892892A19.20535674 19.20535674 0 0 1 411.55357136 593.24107108v-1.76785648A19.20535674 19.20535674 0 0 1 430.75892892 572.26785702H491.9107146v-40.17857162H430.75892892A19.20535674 19.20535674 0 0 1 411.55357136 512.88392864v-1.76785728A19.20535674 19.20535674 0 0 1 430.75892892 491.9107146H491.9107146V451.73214298H331.19642893a40.17857163 40.17857163 0 0 1 0-80.35714325h160.71428567V331.19642893H430.75892892A19.20535674 19.20535674 0 0 1 411.55357136 311.99107136v-1.76785731A19.20535674 19.20535674 0 0 1 430.75892892 291.0178573H491.9107146V250.83928567H430.75892892A19.20535674 19.20535674 0 0 1 411.55357136 231.63392893v-1.7678573A19.20535674 19.20535674 0 0 1 430.75892892 210.66071405H491.9107146a40.17857163 40.17857163 0 0 0-40.17857162-40.1785708H210.66071405a40.17857163 40.17857163 0 0 0-40.1785708 40.1785708v602.67857189a40.17857163 40.17857163 0 0 0 40.1785708 40.1785708h241.07142893a40.17857163 40.17857163 0 0 0 40.17857162-40.1785708H430.75892892A19.20535674 19.20535674 0 0 1 411.55357136 794.13392837v-1.76785729A19.20535674 19.20535674 0 0 1 430.75892892 773.16071433z"  ></path></symbol><symbol id="icon-xiaoditu" viewBox="0 0 1024 1024"><path d="M860.73704932 933.12959219H179.35343869A80.56182101 80.56182101 0 0 1 90.44241067 849.07555502l43.87347813-232.81442962a80.7625231 80.7625231 0 0 1 82.84982464-44.7164264h37.12988699a31.71093064 31.71093064 0 0 1 36.64820298 21.83638761 35.60455178 35.60455178 0 0 1-39.65873429 22.88003879h-39.01648727l-32.91514316 237.43057763H860.73704932l-97.94262195-237.31015622h-39.01648728a44.15446087 44.15446087 0 0 1-44.15446087-22.88003878c-2.60912713-12.04212607 12.04212607-21.8363876 32.5137398-21.8363876h37.21016849a99.78908149 99.78908149 0 0 1 91.72085724 44.71642639l87.74695542 232.81442962A62.49863232 62.49863232 0 0 1 860.73704932 933.12959219z m-346.61251731-170.59678006a32.91514316 32.91514316 0 0 1-24.32509332 10.59707071 32.79472256 32.79472256 0 0 1-24.36523407-10.75763287c-9.31257752-10.39636863-19.4681033-21.51526493-30.18559543-33.23626666-95.57433765-104.36508957-224.58564404-240.84251313-224.58564404-369.09115192A276.00552082 276.00552082 0 0 1 491.84659948 90.18079543a275.96538007 275.96538007 0 0 1 280.98293309 269.82389604c0 130.81762519-135.79503744 268.94080701-233.53695732 375.03193386-8.79075192 9.4329981-17.26038035 18.82585629-25.16804324 27.4961868zM491.84659948 170.46163287a196.08594681 196.08594681 0 0 0-200.70209399 190.46628754C291.14450549 451.44456512 383.46746899 547.66114978 451.70618118 621.43923974c7.66682007 8.26892632 14.93223596 16.05616782 21.55540485 23.48214506a23.56242573 23.56242573 0 0 0 17.38080093 7.58653857 23.64270639 23.64270639 0 0 0 17.38080176-7.46611716l18.02304794-19.38782263C595.60958279 550.87238318 692.54869431 453.29102466 692.54869431 360.92792041A196.08594681 196.08594681 0 0 0 491.84659948 170.46163287zM371.42534292 371.16372769a120.42125656 120.42125656 0 1 1 120.42125656 120.42125656 120.42125656 120.42125656 0 0 1-120.42125655-120.42125656z m160.56167569 0a40.14041913 40.14041913 0 1 0-40.14041913 40.14041913 40.14041913 40.14041913 0 0 0 40.14041913-40.14041913z"  ></path></symbol><symbol id="icon-jian" viewBox="0 0 1024 1024"><path d="M1024 1024H0V0h1024v1024zM971 53H51v920h920V53z"  ></path><path d="M172 482h680v60H172z"  ></path></symbol><symbol id="icon-yanjing" viewBox="0 0 1024 1024"><path d="M511.032 915.619C230.79 915.619 3.66 609.924 3.66 514.57c0-125.923 227.13-401.035 507.372-401.035 280.272 0 507.402 304.967 507.402 401.035 0 100.34-227.13 401.048-507.402 401.048z m0-738.657c-245.216 0-444.007 232.7-444.007 337.61 0 79.469 198.793 337.622 444.007 337.622 245.217 0 443.978-262.182 443.978-337.622 0-77.457-198.761-337.61-443.978-337.61z m0 527.916c-105.11 0-190.306-85.195-190.306-190.306 0-105.05 85.196-190.278 190.306-190.278 105.047 0 190.275 85.227 190.275 190.278 0 105.11-85.228 190.306-190.275 190.306z m0-317.159c-70.083 0-126.85 56.783-126.85 126.853 0 70.083 56.767 126.85 126.85 126.85 70.052 0 126.851-56.766 126.851-126.85-0.001-70.07-56.799-126.853-126.851-126.853z"  ></path></symbol><symbol id="icon-shang" viewBox="0 0 1024 1024"><path d="M512.00988746 141.21142578c10.45623779 0 19.24145531 3.50024414 26.37542748 10.71331811l259.5421145 259.55200196C805.03668189 418.58105492 808.63085938 427.33660865 808.63085938 437.84228516c0 10.60949731-3.53485132 19.46887183-10.56994606 26.46936011-7.02026391 7.00543237-15.88952661 10.60949731-26.50891137 10.60949731-10.44140625 0-19.22167969-3.60900903-26.35565185-10.71331811L549.09863305 267.79370094V845.7097168c0 10.19915748-3.62384057 18.94976782-10.89624071 26.16284179-7.23284888 7.31195068-15.97357177 10.91601563-26.2122798 10.91601563-10.23376465 0-18.959656-3.60900903-26.22216796-10.91601563-7.24273705-7.21307397-10.87646508-15.96862769-10.87646508-26.16284179V267.79370094l-196.10760522 196.41906761C271.65484619 471.31213355 262.87951684 474.92114258 252.41833496 474.92114258c-10.61938477 0-19.45898438-3.60900903-26.4990232-10.60949731C218.86444068 457.31115699 215.36914062 448.45178247 215.36914062 437.84228516c0-10.50567651 3.55462623-19.26123023 10.69354248-26.36553931l259.53717042-259.55200196C492.7288816 144.71166992 501.52398658 141.21142578 511.97033691 141.21142578h0.03955055z"  ></path></symbol><symbol id="icon-shuzhuangtu" viewBox="0 0 1024 1024"><path d="M537.6 716.8H640v251.733333H384v-251.733333h102.4v-196.266667H174.933333v196.266667h102.4v251.733333H17.066667v-251.733333h102.4v-264.533333h362.666666V290.133333H384V55.466667h256v234.666666h-102.4v162.133334h362.666667v264.533333h102.4v251.733333h-260.266667v-251.733333h102.4v-196.266667h-311.466667v196.266667z m51.2-593.066667h-157.866667v102.4h157.866667V123.733333zM226.133333 780.8H68.266667v119.466667h157.866666v-119.466667z m729.6 0h-157.866666v119.466667h157.866666v-119.466667z m-366.933333 0h-157.866667v119.466667h157.866667v-119.466667z m0 0" fill="#444444" ></path></symbol></svg>',
      h = (c = document.getElementsByTagName("script"))[c.length - 1].getAttribute("data-injectcss");if (h && !v.__iconfont__svg__cssinject__) {
    v.__iconfont__svg__cssinject__ = !0;try {
      document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>");
    } catch (c) {
      console && console.log(c);
    }
  }!function (c) {
    if (document.addEventListener) {
      if (~["complete", "loaded", "interactive"].indexOf(document.readyState)) setTimeout(c, 0);else {
        var h = function h() {
          document.removeEventListener("DOMContentLoaded", h, !1), c();
        };document.addEventListener("DOMContentLoaded", h, !1);
      }
    } else document.attachEvent && (a = c, t = v.document, o = !1, l = function l() {
      o || (o = !0, a());
    }, (_i = function i() {
      try {
        t.documentElement.doScroll("left");
      } catch (c) {
        return void setTimeout(_i, 50);
      }l();
    })(), t.onreadystatechange = function () {
      "complete" == t.readyState && (t.onreadystatechange = null, l());
    });var a, t, o, l, _i;
  }(function () {
    var c, h, a, t, o, l;(c = document.createElement("div")).innerHTML = i, i = null, (h = c.getElementsByTagName("svg")[0]) && (h.setAttribute("aria-hidden", "true"), h.style.position = "absolute", h.style.width = 0, h.style.height = 0, h.style.overflow = "hidden", a = h, (t = document.body).firstChild ? (o = a, (l = t.firstChild).parentNode.insertBefore(o, l)) : t.appendChild(a));
  });
}(window);

/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_tree_vue__ = __webpack_require__(639);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_tree_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_tree_vue__);


__WEBPACK_IMPORTED_MODULE_0__src_tree_vue___default.a.install = function (Vue) {
  Vue.component(__WEBPACK_IMPORTED_MODULE_0__src_tree_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_0__src_tree_vue___default.a);
};

/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__src_tree_vue___default.a);

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      isModelDis: false,

      isModelDisHeightControl: false,

      labelControl_ModelNode: null
    };
  },

  methods: {
    setModelHeightColor: function setModelHeightColor(mode, element) {
      if (mode) {
        this.isModelDis = true;
        this.isModelDisHeightControl = true;

        window.$CCBIM.labelControl_ModelNode = new window.$CCBIM.WebGL.Group();
        window.$CCBIM.labelControl_ModelNode.name = 'DisControl';
        window.$CCBIM.webglContext.scene.add(window.$CCBIM.labelControl_ModelNode);

        element.addEventListener('mouseup', this.OnMouseUp_ModelDis, false);
      } else {
        this.isModelDis = false;
        this.isModelDisHeightControl = false;
        window.$CCBIM.labelControl_ModelNode.removeAll();
        element.removeEventListener('mouseup', this.OnMouseUp_ModelDis, false);
      }
    },
    addLabel: function addLabel(name, centerPt) {
      var textGeo = new window.$CCBIM.WebGL.TextGeometry(name, {
        font: window.$CCBIM.render.webGlFont,
        size: 0.1,
        height: 0.001,
        curveSegments: 1
      });
      var textMaterial = new window.$CCBIM.WebGL.MeshBasicMaterial({ color: 0x000000, depthFunc: 1 });
      var curLableText = new window.$CCBIM.WebGL.Mesh(textGeo, textMaterial);
      curLableText.position.copy(centerPt);
      curLableText.rotateX(Math.PI / 2);
      window.$CCBIM.labelControl_ModelNode.add(curLableText);
    },
    computeLabelPosition: function computeLabelPosition() {},
    OnMouseDown_ModelDis: function OnMouseDown_ModelDis(e) {},
    OnMouseUp_ModelDis: function OnMouseUp_ModelDis(e) {
      if (e.which !== 1) {
        return;
      }
      if (window.$CCBIM.controller.IsInRotControl && window.$CCBIM.controller.IsInRotControl()) {
        return;
      }
      var temRenderList = window.$CCBIM.webglContext.getRenderList();

      var startInterObj = void 0;
      var intersectObjectsArray = window.$CCBIM.actionManager.getIntersectsObjectsArray(e, true);
      for (var i = 0, il = intersectObjectsArray.length; i < il; i++) {
        var tem = intersectObjectsArray[i];
        if (tem.face && tem.face.normal) {
          startInterObj = tem;
          break;
        }
      }
      if (!startInterObj) {
        return;
      }

      var startPoint = startInterObj.point;

      var otherRaycaster = new window.$CCBIM.WebGL.Raycaster(startInterObj.point, startInterObj.face.normal, window.$CCBIM.webglContext.camera.near, window.$CCBIM.webglContext.camera.far);
      var otherIntersects = otherRaycaster.intersectRenderObjects(temRenderList, true, false);
      if (otherIntersects.length <= 0) {
        return;
      }
      var endInterObj = null;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(otherIntersects), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          if (item.face) {
            endInterObj = item;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (!endInterObj) {
        return;
      }

      if (!this.lineMaterial) {
        this.lineMaterial = new window.$CCBIM.WebGL.LineBasicMaterial({ color: 0xff0000 });
      }

      var endPoint = endInterObj.point;

      var geometry = new window.$CCBIM.WebGL.Geometry();

      geometry.vertices.push(startPoint);
      geometry.vertices.push(endPoint);

      var midLine = new window.$CCBIM.WebGL.Line(geometry, this.lineMaterial);
      midLine.name = 'midLine';
      window.$CCBIM.labelControl_ModelNode.add(midLine);
      var aniStart = new window.$CCBIM.WebGL.Vector3((startPoint.x + endPoint.x) / 2 + 0.1, (startPoint.y + endPoint.y) / 2, (startPoint.z + endPoint.z) / 2 + 0.1);
      var length = startPoint.distanceTo(endPoint).toFixed(2) + ' m';
      this.addLabel(length, aniStart);
    },
    OnTouchEnd_ModelDis: function OnTouchEnd_ModelDis(e) {
      if (window.$CCBIM.controller.IsInRotControl && window.$CCBIM.controller.IsInRotControl()) {
        return;
      }
      var temRenderList = window.$CCBIM.webglContext.getRenderList();

      var startInterObj = window.$CCBIM.actionManager.getIntersectsFirstEnt(e, true);
      if (!startInterObj) {
        return;
      }
      var startPoint = startInterObj.point;

      var otherRaycaster = new window.$CCBIM.WebGL.Raycaster(startPoint, startInterObj.face.normal, window.$CCBIM.webglContext.camera.near, window.$CCBIM.webglContext.camera.far);
      var otherIntersects = otherRaycaster.intersectRenderObjects(temRenderList, true, false);
      if (otherIntersects.length <= 0) {
        return;
      }
      var endInterObj = null;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(otherIntersects), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          if (item.face) {
            endInterObj = item;
            break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (!endInterObj) {
        return;
      }

      if (!this.lineMaterial) {
        this.lineMaterial = new window.$CCBIM.WebGL.LineBasicMaterial({ color: 0xff0000 });
      }

      var endPoint = endInterObj.point;

      var tubeGeometry = new window.$CCBIM.WebGL.TubeBufferGeometry(new window.$CCBIM.WebGL.CatmullRomCurve3([startPoint, endPoint]), 3, 0.03);
      var midLine = new window.$CCBIM.WebGL.Mesh(tubeGeometry, this.lineMaterial);
      midLine.name = 'midLine';
      window.$CCBIM.labelControl_ModelNode.add(midLine);
      var aniStart = new window.$CCBIM.WebGL.Vector3((startPoint.x + endPoint.x) / 2 + 0.1, (startPoint.y + endPoint.y) / 2, (startPoint.z + endPoint.z) / 2 + 0.1);
      var length = startPoint.distanceTo(endPoint).toFixed(2) + ' m';
      this.addLabel(length, aniStart);
    },
    OnMouseMove_ModelDis: function OnMouseMove_ModelDis() {
      if (this.isModelDis === false) return;
    }
  }
});

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = TrackballControls;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__THREE_constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_classlib_Devices_js__ = __webpack_require__(181);






function TrackballControls(object, domElement, isModelBall) {

  var _this = this;
  var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

  this.devices = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_Devices_js__["a" /* default */]();

  this.object = object;
  this.domElement = domElement !== undefined ? domElement : document;

  this.enabled = true;
  this.isModelBall = isModelBall;

  this.screen = { left: 0, top: 0, width: 0, height: 0 };

  this.rotateSpeed = 5;
  this.zoomSpeed = 2;
  this.panSpeed = 1;

  this.noRotate = false;
  this.noZoom = false;
  this.noZoomPan = false;
  this.noPan = false;

  this.staticMoving = true;
  this.dynamicDampingFactor = 0.4;

  this.minDistance = 0;
  this.maxDistance = Infinity;

  this.keys = [65, 83, 68];

  this.target = new window.$CCBIM.WebGL.Vector3();

  this.pointMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

  this.autoRotationAngle = null;

  var EPS = 0.000001;

  var lastPosition = new window.$CCBIM.WebGL.Vector3();

  var _state = STATE.NONE,
      _prevState = STATE.NONE,
      _eye = new window.$CCBIM.WebGL.Vector3(),
      _movePrev = new window.$CCBIM.WebGL.Vector2(),
      _moveCurr = new window.$CCBIM.WebGL.Vector2(),
      _lastAxis = new window.$CCBIM.WebGL.Vector3(),
      _lastAngle = 0,
      _zoomStart = new window.$CCBIM.WebGL.Vector2(),
      _zoomEnd = new window.$CCBIM.WebGL.Vector2(),
      _touchZoomDistanceStart = 0,
      _touchZoomDistanceEnd = 0,
      _panStart = new window.$CCBIM.WebGL.Vector2(),
      _panEnd = new window.$CCBIM.WebGL.Vector2();

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.up0 = this.object.up.clone();

  var changeEvent = { type: 'change' };
  var startEvent = { type: 'start' };
  var endEvent = { type: 'end' };

  this.rotMat = null;
  this.scene = null;
  this.modelCenter = new window.$CCBIM.WebGL.Vector3();
  this.modelCenter0 = null;
  this.testObj = null;
  this.isInRot = false;

  this.mouseDownX = 0;
  this.mouseDownY = 0;
  this.mouseMoveX = 0;
  this.mouseMoveY = 0;
  this.isMouseDown = false;

  this.handleResize = function () {

    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect();

      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  this.handleEvent = function (event) {

    if (typeof this[event.type] == 'function') {

      this[event.type](event);
    }
  };

  this.SetModelCenterPt = function (centerPt, bCancel) {
    if (_this.modelCenter0 == null) {
      _this.modelCenter0 = new window.$CCBIM.WebGL.Vector3();
      _this.modelCenter0.copy(_this.modelCenter);
    }
    if (bCancel) {
      _this.modelCenter.copy(_this.modelCenter0);
    } else {
      _this.modelCenter.copy(centerPt);

      var temEye = new window.$CCBIM.WebGL.Vector3();
      temEye.subVectors(_this.target, _this.object.position);
      var temlen = _this.modelCenter.distanceTo(_this.object.position);

      _this.target.copy(_this.object.position);
      _this.target.add(temEye.setLength(temlen));
    }
  };

  this.IsInRotControl = function () {
    return _this.isInRot;
  };

  var getMouseOnScreen = function () {

    var vector = new window.$CCBIM.WebGL.Vector2();

    return function getMouseOnScreen(pageX, pageY) {
      vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);
      return vector;
    };
  }();

  var getMouseOnCircle = function () {

    var vector = new window.$CCBIM.WebGL.Vector2();

    return function getMouseOnCircle(pageX, pageY) {

      vector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width);
      _this.vector = vector;
      return vector;
    };
  }();

  this.rotateCamera = function () {

    var axis = new window.$CCBIM.WebGL.Vector3(),
        quaternion = new window.$CCBIM.WebGL.Quaternion(),
        eyeDirection = new window.$CCBIM.WebGL.Vector3(),
        objectUpDirection = new window.$CCBIM.WebGL.Vector3(),
        objectSidewaysDirection = new window.$CCBIM.WebGL.Vector3(),
        moveDirection = new window.$CCBIM.WebGL.Vector3(),
        angle;

    return function rotateCamera() {

      moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
      angle = moveDirection.length() || _this.autoRotationAngle;

      if (angle) {
        window.$CCBIM.render.onBeforeUpdate();
        _eye.copy(_this.object.position).sub(_this.target);

        eyeDirection.copy(_eye).normalize();
        objectUpDirection.copy(_this.object.up).normalize();
        objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

        objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
        objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);
        moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));
        axis.crossVectors(moveDirection, _eye).normalize();

        if (null == _this.scene) {
          angle *= _this.rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);

          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);

          _lastAxis.copy(axis);
          _lastAngle = angle;
        } else {
          _this.isInRot = true;
          if (null == _this.rotMat) {
            _this.rotMat = new window.$CCBIM.WebGL.Matrix4();
          }
          angle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
          angle *= _this.rotateSpeed;

          var rotMat = new window.$CCBIM.WebGL.Matrix4();
          var yzRotMat = new window.$CCBIM.WebGL.Matrix4();
          var yzRotVer = new window.$CCBIM.WebGL.Vector3();
          if (Math.abs(_moveCurr.y - _movePrev.y) > Math.abs(_moveCurr.x - _movePrev.x)) {
            if (_moveCurr.y - _movePrev.y < 0) angle *= -1;

            yzRotVer.crossVectors(_this.object.up, _eye).normalize();
            rotMat.makeRotationAxis(yzRotVer, angle);
          } else {
            if (_moveCurr.x - _movePrev.x > 0) angle *= -1;

            rotMat.makeRotationAxis(new window.$CCBIM.WebGL.Vector3(0, 0, 1), angle);
          }

          var temRotMat = new window.$CCBIM.WebGL.Matrix4();
          {
            var moveBack = new window.$CCBIM.WebGL.Matrix4();
            moveBack.setPosition(_this.modelCenter);
            temRotMat.multiply(moveBack);

            temRotMat.multiply(rotMat);

            var temMove = new window.$CCBIM.WebGL.Matrix4();
            temMove.setPosition(new window.$CCBIM.WebGL.Vector3(-_this.modelCenter.x, -_this.modelCenter.y, -_this.modelCenter.z));
            temRotMat.multiply(temMove);
          }

          var temVer = new window.$CCBIM.WebGL.Vector3();
          temVer.copy(_this.object.up);
          var eyeLen = _eye.length();
          _eye.transformDirection(temRotMat);
          _eye.setLength(eyeLen);
          _this.object.up.transformDirection(temRotMat);
          _this.target.applyMatrix4(temRotMat);

          _lastAxis.copy(axis);
          _lastAngle = angle;
          _this.rotMat.copy(temRotMat);
        }
      } else if (!_this.staticMoving && _lastAngle) {
        _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
        _eye.copy(_this.object.position).sub(_this.target);
        quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
        _eye.applyQuaternion(quaternion);
        _this.object.up.applyQuaternion(quaternion);
      }
      _movePrev.copy(_moveCurr);
    };
  }();

  this.zoomCamera = function () {

    var factor;

    if (_state === STATE.TOUCH_ZOOM_PAN) {
      factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
      _touchZoomDistanceStart = _touchZoomDistanceEnd;
      _eye.multiplyScalar(factor);
    } else {
      factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

      if (factor !== 1.0 && factor > 0.0) {

        _eye.multiplyScalar(factor);

        window.$CCBIM.render.onAfterUpdate();
      }

      if (_this.staticMoving) {

        _zoomStart.copy(_zoomEnd);
      } else {

        _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
      }
    }
  };

  this.panCamera = function () {

    var mouseChange = new window.$CCBIM.WebGL.Vector2(),
        objectUp = new window.$CCBIM.WebGL.Vector3(),
        pan = new window.$CCBIM.WebGL.Vector3();

    return function panCamera() {

      mouseChange.copy(_panEnd).sub(_panStart);

      if (mouseChange.lengthSq()) {

        mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

        pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
        pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

        _this.object.position.add(pan);
        _this.target.add(pan);

        if (_this.staticMoving) {

          window.$CCBIM.render.onBeforeUpdate();

          _panStart.copy(_panEnd);
        } else {

          _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
        }
      }
    };
  }();

  this.checkDistances = function () {

    if (!_this.noZoom || !_this.noPan) {

      if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {

        _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
        _zoomStart.copy(_zoomEnd);
        _this.computePoinPosition();
      }

      if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {
        _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
        _zoomStart.copy(_zoomEnd);
        _this.computePoinPosition();
      }
    }
  };

  this.update = function () {

    _eye.subVectors(_this.object.position, _this.target);

    if (_this.isAutoRotation) {
      _this.autoRotationAngle = 0.002;
    } else {
      _this.autoRotationAngle = 0;
    }

    if (!_this.noRotate) {

      _this.rotateCamera();
    }

    if (!_this.noZoom) {

      _this.zoomCamera();
    }

    if (!_this.noPan) {

      _this.panCamera();
    }

    _this.object.position.addVectors(_this.target, _eye);

    _this.checkDistances();

    _this.object.lookAt(_this.target);

    if (lastPosition.distanceToSquared(_this.object.position) > EPS) {

      lastPosition.copy(_this.object.position);
    }
  };

  this.reset = function () {

    _state = STATE.NONE;
    _prevState = STATE.NONE;

    _this.isInRot = false;

    _this.target.copy(_this.target0);
    _this.object.position.copy(_this.position0);
    _this.object.up.copy(_this.up0);

    _eye.subVectors(_this.object.position, _this.target);

    _this.object.lookAt(_this.target);

    lastPosition.copy(_this.object.position);
  };

  function mousedown(event) {
    if (_this.enabled === false) return;
    if (_state === STATE.NONE) {
      _state = event.button;
    }

    _this.mouseDownX = event.pageX;
    _this.mouseDownY = event.pageY;
    _this.isMouseDown = true;

    _this.isInRot = false;

    if (_state === STATE.ROTATE && !_this.noRotate) {
      if (_this.isModelBall) {
        var selectEntPt = window.$CCBIM.actionManager.getIntersectsFirstEnt(event);
        var modelCenterPt = window.$CCBIM.actionManager.getSelectGeometryBoxCenterPt();
        var clippingBox = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');
        if (modelCenterPt.x !== 0 && modelCenterPt.y !== 0 && modelCenterPt.z !== 0) {
          _this.SetModelCenterPt(modelCenterPt, false);
        } else if (clippingBox) {
          clippingBox.geometry.computeBoundingSphere();
          _this.SetModelCenterPt(clippingBox.geometry.boundingSphere.center, false);
        } else if (selectEntPt) {
          _this.SetModelCenterPt(selectEntPt.point, false);
        } else {
          _this.SetModelCenterPt(new window.$CCBIM.WebGL.Vector3(), true);
        }
      }

      _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
      _movePrev.copy(_moveCurr);
    } else if (_state === STATE.ZOOM) {
      _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
      _panEnd.copy(_panStart);
    } else if (_state === STATE.PAN && !_this.noPan) {
      _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
      _panEnd.copy(_panStart);
    }

    this.addEventListener('mousemove', mousemove, false);
    this.addEventListener('mouseup', mouseup, false);
  }

  function mousemove(event) {
    if (_this.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();

    if (_this.isMouseDown) {
      _this.mouseMoveX = event.pageX;
      _this.mouseMoveY = event.pageY;
      if (Math.abs(_this.mouseMoveX - _this.mouseDownX) > 5 || Math.abs(_this.mouseMoveY - _this.mouseDownY) > 5) {
        window.$CCBIM.render.onBeforeUpdate();
      }
    }

    if (_state === STATE.ROTATE && !_this.noRotate) {

      _movePrev.copy(_moveCurr);
      _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
    } else if (_state === STATE.ZOOM && !_this.noZoomPan) {
      _this.domElement.style.cursor = 'move';
      _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
    } else if (_state === STATE.PAN && !_this.noPan) {

      _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
    }
  }

  function mouseup(event) {
    if (_this.enabled === false) return;
    window.$CCBIM.render.onAfterUpdate();
    _this.domElement.style.cursor = 'auto';
    event.preventDefault();
    event.stopPropagation();

    _this.isMouseDown = false;

    _state = STATE.NONE;

    _this.domElement.removeEventListener('mousemove', mousemove);
    _this.domElement.removeEventListener('mouseup', mouseup);
  }

  function mousewheel(event) {

    if (_this.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();
    switch (event.deltaMode) {

      case 2:
        _zoomStart.y -= event.deltaY * 0.025;
        break;

      case 1:
        _zoomStart.y -= event.deltaY * 0.01;
        break;

      default:
        _zoomStart.y -= event.deltaY * 0.00025;
        break;

    }

    window.$CCBIM.render.onBeforeUpdate();
  }

  function touchstart(event) {

    if (_this.enabled === false) return;

    window.$CCBIM.render.onBeforeUpdate();
    switch (event.touches.length) {

      case 1:
        _state = STATE.TOUCH_ROTATE;

        if (_this.isModelBall) {
          var selectEntPt = window.$CCBIM.actionManager.getIntersectsFirstEnt(event);
          var modelCenterPt = window.$CCBIM.actionManager.getSelectGeometryBoxCenterPt();
          var clippingBox = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');
          if (modelCenterPt.x !== 0 && modelCenterPt.y !== 0 && modelCenterPt.z !== 0) {
            _this.SetModelCenterPt(modelCenterPt, false);
          } else if (clippingBox) {
            clippingBox.geometry.computeBoundingSphere();
            _this.SetModelCenterPt(clippingBox.geometry.boundingSphere.center, false);
          } else if (selectEntPt) {
            _this.SetModelCenterPt(selectEntPt.point, false);
          } else {
            _this.SetModelCenterPt(new window.$CCBIM.WebGL.Vector3(), true);
          }
        }

        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
        _movePrev.copy(_moveCurr);
        break;

      default:
        _state = STATE.TOUCH_ZOOM_PAN;
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
        _panStart.copy(getMouseOnScreen(x, y));
        _panEnd.copy(_panStart);
        break;

    }
  }

  function touchmove(event) {

    if (_this.enabled === false) return;

    window.$CCBIM.render.onBeforeUpdate();
    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {

      case 1:
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
        break;

      default:
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
        _panEnd.copy(getMouseOnScreen(x, y));
        break;

    }
  }

  function touchend(event) {

    if (_this.enabled === false) return;

    _this.isInRot = false;

    switch (event.touches.length) {

      case 0:
        _state = STATE.NONE;
        break;

      case 1:
        _state = STATE.TOUCH_ROTATE;
        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
        _movePrev.copy(_moveCurr);
        break;

    }

    window.$CCBIM.render.onAfterUpdate();
  }

  this.dispose = function () {
    this.domElement.removeEventListener('mousedown', mousedown, true);
    this.domElement.removeEventListener('wheel', mousewheel, false);

    this.domElement.removeEventListener('touchstart', touchstart, false);
    this.domElement.removeEventListener('touchend', touchend, false);
    this.domElement.removeEventListener('touchmove', touchmove, false);

    this.domElement.removeEventListener('mousemove', mousemove, false);
    this.domElement.removeEventListener('mouseup', mouseup, false);
  };
  this.bindEvent = function () {
    this.domElement.addEventListener('mousedown', mousedown, true);
    this.domElement.addEventListener('wheel', mousewheel, false);

    this.domElement.addEventListener('touchstart', touchstart, false);
    this.domElement.addEventListener('touchend', touchend, false);
    this.domElement.addEventListener('touchmove', touchmove, false);
  };

  this.handleResize();

  this.getCameraData = function () {
    return {
      cameraPosition: _this.object.position,
      target: _this.target,
      cameraUp: _this.object.up
    };
  };

  this.IsInUpdataRef = false;

  this.update();

  this.setControlPosition = function (height, cameraX, cameraY) {
    window.$CCBIM.webglContext.camera.position.z = height;
    if (cameraX) {
      window.$CCBIM.webglContext.camera.position.x = cameraX;
    }
    if (cameraY) {
      window.$CCBIM.webglContext.camera.position.y = cameraY;
    }
  };
};

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


function TGALoader(manager) {

  this.manager = manager !== undefined ? manager : window.$CCBIM.WebGL.DefaultLoadingManager;
};

TGALoader.prototype = {

  constructor: TGALoader,

  load: function load(url, onLoad, onProgress, onError) {

    var scope = this;

    var texture = new window.$CCBIM.WebGL.Texture();

    var loader = new window.$CCBIM.WebGL.FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);

    loader.load(url, function (buffer) {

      texture.image = scope.parse(buffer);
      texture.needsUpdate = true;

      if (onLoad !== undefined) {

        onLoad(texture);
      }
    }, onProgress, onError);

    return texture;
  },

  parse: function parse(buffer) {

    function tgaCheckHeader(header) {

      switch (header.image_type) {

        case TGA_TYPE_INDEXED:
        case TGA_TYPE_RLE_INDEXED:
          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {

            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');
          }
          break;

        case TGA_TYPE_RGB:
        case TGA_TYPE_GREY:
        case TGA_TYPE_RLE_RGB:
        case TGA_TYPE_RLE_GREY:
          if (header.colormap_type) {

            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');
          }
          break;

        case TGA_TYPE_NO_DATA:
          console.error('THREE.TGALoader: No data.');

        default:
          console.error('THREE.TGALoader: Invalid type "%s".', header.image_type);

      }

      if (header.width <= 0 || header.height <= 0) {

        console.error('THREE.TGALoader: Invalid image size.');
      }

      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {

        console.error('THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size);
      }
    }

    function tgaParse(use_rle, use_pal, header, offset, data) {

      var pixel_data, pixel_size, pixel_total, palettes;

      pixel_size = header.pixel_size >> 3;
      pixel_total = header.width * header.height * pixel_size;

      if (use_pal) {

        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
      }

      if (use_rle) {

        pixel_data = new Uint8Array(pixel_total);

        var c, count, i;
        var shift = 0;
        var pixels = new Uint8Array(pixel_size);

        while (shift < pixel_total) {

          c = data[offset++];
          count = (c & 0x7f) + 1;

          if (c & 0x80) {

            for (i = 0; i < pixel_size; ++i) {

              pixels[i] = data[offset++];
            }

            for (i = 0; i < count; ++i) {

              pixel_data.set(pixels, shift + i * pixel_size);
            }

            shift += pixel_size * count;
          } else {

            count *= pixel_size;
            for (i = 0; i < count; ++i) {

              pixel_data[shift + i] = data[offset++];
            }
            shift += count;
          }
        }
      } else {

        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
      }

      return {
        pixel_data: pixel_data,
        palettes: palettes
      };
    }

    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {

      var colormap = palettes;
      var color,
          i = 0,
          x,
          y;
      var width = header.width;

      for (y = y_start; y !== y_end; y += y_step) {

        for (x = x_start; x !== x_end; x += x_step, i++) {

          color = image[i];
          imageData[(x + width * y) * 4 + 3] = 255;
          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
        }
      }

      return imageData;
    }

    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

      var color,
          i = 0,
          x,
          y;
      var width = header.width;

      for (y = y_start; y !== y_end; y += y_step) {

        for (x = x_start; x !== x_end; x += x_step, i += 2) {

          color = image[i + 0] + (image[i + 1] << 8);
          imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
          imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
          imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;
        }
      }

      return imageData;
    }

    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

      var i = 0,
          x,
          y;
      var width = header.width;

      for (y = y_start; y !== y_end; y += y_step) {

        for (x = x_start; x !== x_end; x += x_step, i += 3) {

          imageData[(x + width * y) * 4 + 3] = 255;
          imageData[(x + width * y) * 4 + 2] = image[i + 0];
          imageData[(x + width * y) * 4 + 1] = image[i + 1];
          imageData[(x + width * y) * 4 + 0] = image[i + 2];
        }
      }

      return imageData;
    }

    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

      var i = 0,
          x,
          y;
      var width = header.width;

      for (y = y_start; y !== y_end; y += y_step) {

        for (x = x_start; x !== x_end; x += x_step, i += 4) {

          imageData[(x + width * y) * 4 + 2] = image[i + 0];
          imageData[(x + width * y) * 4 + 1] = image[i + 1];
          imageData[(x + width * y) * 4 + 0] = image[i + 2];
          imageData[(x + width * y) * 4 + 3] = image[i + 3];
        }
      }

      return imageData;
    }

    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

      var color,
          i = 0,
          x,
          y;
      var width = header.width;

      for (y = y_start; y !== y_end; y += y_step) {

        for (x = x_start; x !== x_end; x += x_step, i++) {

          color = image[i];
          imageData[(x + width * y) * 4 + 0] = color;
          imageData[(x + width * y) * 4 + 1] = color;
          imageData[(x + width * y) * 4 + 2] = color;
          imageData[(x + width * y) * 4 + 3] = 255;
        }
      }

      return imageData;
    }

    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

      var i = 0,
          x,
          y;
      var width = header.width;

      for (y = y_start; y !== y_end; y += y_step) {

        for (x = x_start; x !== x_end; x += x_step, i += 2) {

          imageData[(x + width * y) * 4 + 0] = image[i + 0];
          imageData[(x + width * y) * 4 + 1] = image[i + 0];
          imageData[(x + width * y) * 4 + 2] = image[i + 0];
          imageData[(x + width * y) * 4 + 3] = image[i + 1];
        }
      }

      return imageData;
    }

    function getTgaRGBA(data, width, height, image, palette) {

      var x_start, y_start, x_step, y_step, x_end, y_end;

      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {

        default:
        case TGA_ORIGIN_UL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;

        case TGA_ORIGIN_BL:
          x_start = 0;
          x_step = 1;
          x_end = width;
          y_start = height - 1;
          y_step = -1;
          y_end = -1;
          break;

        case TGA_ORIGIN_UR:
          x_start = width - 1;
          x_step = -1;
          x_end = -1;
          y_start = 0;
          y_step = 1;
          y_end = height;
          break;

        case TGA_ORIGIN_BR:
          x_start = width - 1;
          x_step = -1;
          x_end = -1;
          y_start = height - 1;
          y_step = -1;
          y_end = -1;
          break;

      }

      if (use_grey) {

        switch (header.pixel_size) {

          case 8:
            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;

          case 16:
            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;

          default:
            console.error('THREE.TGALoader: Format not supported.');
            break;

        }
      } else {

        switch (header.pixel_size) {

          case 8:
            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
            break;

          case 16:
            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;

          case 24:
            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;

          case 32:
            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
            break;

          default:
            console.error('THREE.TGALoader: Format not supported.');
            break;

        }
      }

      return data;
    }

    var TGA_TYPE_NO_DATA = 0,
        TGA_TYPE_INDEXED = 1,
        TGA_TYPE_RGB = 2,
        TGA_TYPE_GREY = 3,
        TGA_TYPE_RLE_INDEXED = 9,
        TGA_TYPE_RLE_RGB = 10,
        TGA_TYPE_RLE_GREY = 11,
        TGA_ORIGIN_MASK = 0x30,
        TGA_ORIGIN_SHIFT = 0x04,
        TGA_ORIGIN_BL = 0x00,
        TGA_ORIGIN_BR = 0x01,
        TGA_ORIGIN_UL = 0x02,
        TGA_ORIGIN_UR = 0x03;

    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');

    var content = new Uint8Array(buffer),
        offset = 0,
        header = {
      id_length: content[offset++],
      colormap_type: content[offset++],
      image_type: content[offset++],
      colormap_index: content[offset++] | content[offset++] << 8,
      colormap_length: content[offset++] | content[offset++] << 8,
      colormap_size: content[offset++],
      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],
      width: content[offset++] | content[offset++] << 8,
      height: content[offset++] | content[offset++] << 8,
      pixel_size: content[offset++],
      flags: content[offset++]
    };

    tgaCheckHeader(header);

    if (header.id_length + offset > buffer.length) {

      console.error('THREE.TGALoader: No data.');
    }

    offset += header.id_length;

    var use_rle = false,
        use_pal = false,
        use_grey = false;

    switch (header.image_type) {

      case TGA_TYPE_RLE_INDEXED:
        use_rle = true;
        use_pal = true;
        break;

      case TGA_TYPE_INDEXED:
        use_pal = true;
        break;

      case TGA_TYPE_RLE_RGB:
        use_rle = true;
        break;

      case TGA_TYPE_RGB:
        break;

      case TGA_TYPE_RLE_GREY:
        use_rle = true;
        use_grey = true;
        break;

      case TGA_TYPE_GREY:
        use_grey = true;
        break;

    }

    var useOffscreen = typeof OffscreenCanvas !== 'undefined';

    var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');
    canvas.width = header.width;
    canvas.height = header.height;

    var context = canvas.getContext('2d');
    var imageData = context.createImageData(header.width, header.height);

    var result = tgaParse(use_rle, use_pal, header, offset, content);
    var rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);

    context.putImageData(imageData, 0, 0);

    return useOffscreen ? canvas.transferToImageBitmap() : canvas;
  },

  setPath: function setPath(value) {

    this.path = value;
    return this;
  }

};

/* harmony default export */ __webpack_exports__["a"] = (TGALoader);

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


function Devices() {
  this.rect = null;
}

Devices.prototype = {
  constructor: Devices,

  setDevicesWidthHeight: function setDevicesWidthHeight(dom) {
    if (dom) {
      this.rect = dom.getBoundingClientRect();
      this.rect.w = this.rect.right - this.rect.left;
      this.rect.h = window.innerHeight - this.rect.top;
      this.rect.wHalf = this.rect.w / 2;
      this.rect.hHalf = this.rect.h / 2;
    }
  },
  getDevicesWidthHeight: function getDevicesWidthHeight() {
    return this.rect;
  },
  setRenderWidth: function setRenderWidth(value) {
    if (value) {
      this.rect.w = value;
      this.rect.wHalf = this.rect.w / 2;
    }
  },
  resize: function resize() {
    var _rect = this.rect,
        w = _rect.w,
        h = _rect.h;

    window.$CCBIM.webglContext.resize(w, h);
  },
  getIsPhone: function getIsPhone() {
    var ua = navigator.userAgent.toLowerCase();
    if (ua.match('ipad|iphone|android')) {
      return true;
    } else {
      return false;
    }
  },
  is360ByUserActivationProperty: function is360ByUserActivationProperty() {
    var navigator = window.navigator;
    if (navigator.userActivation) {
      return false;
    } else {
        return true;
      }
  },
  launchFullscreen: function launchFullscreen() {
    var element = document.body;
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullScreen();
    }
  },
  exitFullscreen: function exitFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Devices);

/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EntInfo; });

function EntInfo() {
  this.type = 'EntInfo';

  this.id = 0;

  this.floorID = 0;

  this.comtype = 0;

  this.comid = 0;

  this.handle = '';

  this.selectAbility = true;

  this.stageArray = [];

  this.visible = true;
  this.entDataArray = [];
}

EntInfo.prototype = {
  constructor: EntInfo,

  setEntInfo: function setEntInfo(id, floorID, comtype, comid, handle) {
    this.id = id;
    this.floorID = floorID;
    this.comtype = comtype;
    this.comid = comid;
    this.handle = handle;
  },

  getID: function getID() {
    return this.id;
  },

  getFloorID: function getFloorID() {
    return this.floorID;
  },

  getComtype: function getComtype() {
    return this.comtype;
  },

  getComid: function getComid() {
    return this.comid;
  },

  getHandle: function getHandle() {
    return this.handle;
  },

  setSelectAbility: function setSelectAbility(value) {
    this.selectAbility = value;
  },

  getSelectAbility: function getSelectAbility() {
    return this.selectAbility;
  },

  addStage: function addStage(value) {
    this.stageArray.push(value);
  },

  hasStage: function hasStage(value) {
    return this.stageArray.indexOf(value) >= 0;
  },

  getStageArray: function getStageArray() {
    return this.stageArray;
  },

  setEntDataArray: function setEntDataArray(entDataArray) {
    this.entDataArray = entDataArray;
  },

  getEntDataArray: function getEntDataArray() {
    return this.entDataArray;
  },

  setVisible: function setVisible(value) {
    this.visible = value;
    for (var i = 0, il = this.entDataArray.length; i < il; i++) {
      this.entDataArray[i].setVisible(this.visible);
    }
  },

  getVisible: function getVisible() {
    return this.visible;
  },

  clear: function clear() {
    for (var i = 0, il = this.entDataArray.length; i < il; i++) {
      this.entDataArray[i].clear();
    }
    this.entDataArray = [];
  }
};



/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);



function FileLoader(axios) {
  this.type = 'FileLoader';

  this.axios = axios;

  this.cloudURL = undefined;

  this.fileIndexArray = [];

  this.calcelTokenArray = [];

  this.basicFileTotal = 0;

  this.basicFileLoaded = 0;

  this.basicProgress = 0;

  this.entInfoFileTotal = 0;

  this.entInfoFileLoaded = 0;

  this.entInfoProgress = 0;
}

FileLoader.prototype = {
  constructor: FileLoader,

  setCloudURL: function setCloudURL(url) {
    this.cloudURL = url;
  },

  getCloudURL: function getCloudURL() {
    return this.cloudURL;
  },

  addFileIndex: function addFileIndex(fileIndex) {
    if (!fileIndex) {
      return;
    }
    this.fileIndexArray.push(fileIndex);
  },

  getFileIndex: function getFileIndex(fileName) {
    for (var i = 0, length = this.fileIndexArray.length; i < length; i++) {
      var index = this.fileIndexArray[i];
      if (index.getURL().includes(fileName)) {
        return index;
      }
    }
    return null;
  },

  getFileIndexArray: function getFileIndexArray() {
    return this.fileIndexArray;
  },

  getAxios: function getAxios() {
    return this.axios;
  },

  addCancelToken: function addCancelToken(token) {
    this.calcelTokenArray.push(token);
  },

  clearData: function clearData() {
    this.fileIndexArray = [];
    this.calcelTokenArray = [];
  },

  loadFile: function loadFile(fileIndex) {
    var _this = this;

    if (!fileIndex) {
      return null;
    }
    return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      var cancelToken = _this.axios.CancelToken;
      var source = cancelToken.source();

      _this.axios({
        method: 'get',
        responseType: 'arraybuffer',
        cancelToken: source.token,
        url: fileIndex.getURL()
      }).then(function (res) {
        resolve(res);
      }).catch(function (thrown) {
        if (_this.axios.isCancel(thrown)) {
          console.log('Request canceled', thrown.message);
        } else {}
        reject();
      });
    });
  },

  setBasicFileTotal: function setBasicFileTotal(basicFileTotal) {
    this.basicFileTotal = basicFileTotal;
  },
  setBasicProgress: function setBasicProgress(loaded) {
    if (loaded) {
      this.basicFileLoaded += loaded;
      var progressNumber = this.basicFileLoaded / this.basicFileTotal * 100;
      this.basicProgress = parseInt(progressNumber);
    }
  },
  getBasicProgress: function getBasicProgress() {
    return this.basicProgress;
  },
  setEntInfoFileTotal: function setEntInfoFileTotal(entInfoFileTotal) {
    this.entInfoFileTotal = entInfoFileTotal;
  },
  setEntInfoProgress: function setEntInfoProgress(loaded) {
    if (loaded) {
      this.entInfoFileLoaded += loaded;
      var progressNumber = this.entInfoFileLoaded / this.entInfoFileTotal * 100;
      this.entInfoProgress = parseInt(progressNumber);
    }
  },
  getEntInfoProgress: function getEntInfoProgress() {
    return this.entInfoProgress;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (FileLoader);

/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


function PageData() {
  this.type = 'PageData';

  this.contentSize = 0;

  this.bufferGeometryFileList = [];

  this.entDataFileList = [];

  this.usage = 0;
}

PageData.prototype = {
  constructor: PageData,

  setContentSize: function setContentSize(value) {
    this.contentSize = value;
  },

  getContentSize: function getContentSize() {
    return this.contentSize;
  },

  addBufferGeometryFile: function addBufferGeometryFile(fileIndex) {
    this.bufferGeometryFileList.push(fileIndex);
  },

  getBufferGeometryFileList: function getBufferGeometryFileList() {
    return this.bufferGeometryFileList;
  },

  addEntDataFileList: function addEntDataFileList(fileIndex) {
    this.entDataFileList.push(fileIndex);
  },

  getEntDataFileList: function getEntDataFileList() {
    return this.entDataFileList;
  },

  setUsage: function setUsage(lodLevel) {
    this.usage = lodLevel;
  },

  getUsage: function getUsage() {
    return this.usage;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (PageData);

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ParamInfo */
/* unused harmony export HandleInfo */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ComidInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ComtypeInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BaseComtypeInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FloorInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuildingInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return StageInfo; });

function ParamInfo(type, nameID, valueID) {
  this.type = type;

  this.nameID = nameID;

  this.valueID = valueID;
}
ParamInfo.prototype = {
  constructor: ParamInfo,

  getType: function getType() {
    return this.type;
  },

  getNameID: function getNameID() {
    return this.nameID;
  },

  getValueID: function getValueID() {
    return this.valueID;
  }
};

function HandleInfo(floorID, handle) {
  this.floorID = floorID;

  this.handle = handle;

  this.paramInfoArray = [];
}
HandleInfo.prototype = {
  constructor: HandleInfo,

  getFloorID: function getFloorID() {
    return this.floorID;
  },

  getHandle: function getHandle() {
    return this.handle;
  },

  addParamInfo: function addParamInfo(value) {
    this.paramInfoArray.push(value);
  },

  getParamInfoArray: function getParamInfoArray() {
    return this.paramInfoArray;
  }
};

function ComidInfo(id, name) {
  this.id = id;

  this.name = name;

  this.handleArray = [];
}
ComidInfo.prototype = {
  constructor: ComidInfo,

  getID: function getID() {
    return this.id;
  },

  getName: function getName() {
    return this.name;
  },

  addHandle: function addHandle(value) {
    this.handleArray.push(value);
  },

  getHandleArray: function getHandleArray() {
    return this.handleArray;
  }
};

function ComtypeInfo(id, name) {
  this.id = id;

  this.name = name;

  this.comidInfoArray = [];

  this.childComtypeArray = [];
}
ComtypeInfo.prototype = {
  constructor: ComtypeInfo,

  getID: function getID() {
    return this.id;
  },

  getName: function getName() {
    return this.name;
  },

  addComidInfo: function addComidInfo(value) {
    this.comidInfoArray.push(value);
  },

  getComidInfoArray: function getComidInfoArray() {
    return this.comidInfoArray;
  },

  addComtypeInfo: function addComtypeInfo(value) {
    this.childComtypeArray.push(value);
  },

  getComtypeInfoArray: function getComtypeInfoArray() {
    return this.childComtypeArray;
  }
};

function BaseComtypeInfo(id, name) {
  this.id = id;

  this.name = name;

  this.comtypeInfoArray = [];

  this.childArray = [];
}
BaseComtypeInfo.prototype = {
  constructor: BaseComtypeInfo,

  getID: function getID() {
    return this.id;
  },

  getName: function getName() {
    return this.name;
  },

  addComtypeInfo: function addComtypeInfo(value) {
    this.comtypeInfoArray.push(value);
  },

  getComtypeInfoArray: function getComtypeInfoArray() {
    return this.comtypeInfoArray;
  },

  addChild: function addChild(value) {
    this.childArray.push(value);
  },

  getChildArray: function getChildArray() {
    return this.childArray;
  }
};

function FloorInfo(id, name, showID) {
  this.id = id;

  this.name = name;

  this.showID = showID;

  this.baseComtypeInfoArray = [];
}
FloorInfo.prototype = {
  constructor: FloorInfo,

  getID: function getID() {
    return this.id;
  },

  getName: function getName() {
    return this.name;
  },

  getShowID: function getShowID() {
    return this.showID;
  },

  addBaseComtypeInfo: function addBaseComtypeInfo(value) {
    this.baseComtypeInfoArray.push(value);
  },

  getBaseComtypeInfoArray: function getBaseComtypeInfoArray() {
    return this.baseComtypeInfoArray;
  }
};

function StageInfo(id, name) {
  this.id = id;

  this.name = name;
}
StageInfo.prototype = {
  constructor: StageInfo,

  getID: function getID() {
    return this.id;
  },

  getName: function getName() {
    return this.name;
  }
};

function BuildingInfo(id, name) {
  this.id = id;

  this.name = name;

  this.floorInfoArray = [];
}
BuildingInfo.prototype = {
  constructor: BuildingInfo,

  getID: function getID() {
    return this.id;
  },

  getName: function getName() {
    return this.name;
  },

  addFloorInfo: function addFloorInfo(value) {
    this.floorInfoArray.push(value);
  },

  getFloorInfoArray: function getFloorInfoArray() {
    return this.floorInfoArray;
  }
};



/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RefDefinition; });


function RefDefinition() {
  this.type = 'RefDefinition';

  this.uuid = 0;

  this.refObjectArray = [];

  this.bndBox = null;
}

RefDefinition.prototype = {
  constructor: RefDefinition,

  isRefDefinitoin: true,

  setUUID: function setUUID(value) {
    this.uuid = value;
  },

  getUUID: function getUUID() {
    return this.uuid;
  },

  addRefObject: function addRefObject(object3D) {
    this.refObjectArray.push(object3D);

    if (!object3D.geometry.boundingBox) {
      object3D.geometry.computeBoundingBox();
    }

    if (!this.bndBox) {
      this.bndBox = new window.$CCBIM.WebGL.Box3();
    }

    this.bndBox.expandByPoint(object3D.geometry.boundingBox.min);
    this.bndBox.expandByPoint(object3D.geometry.boundingBox.max);
  },

  getRefObjectArray: function getRefObjectArray() {
    return this.refObjectArray;
  },

  getBndBox: function getBndBox() {
    return this.bndBox;
  }
};



/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


function WebGLContext() {
  this.type = 'WebGLContext';

  this.viewPort = {
    width: 0,
    height: 0
  };

  this.scene = null;

  this.camera = null;

  this.renderer = null;

  this.postProcessing = {
    composer: null,
    renderPass: null,
    smaaPass: null };
}

WebGLContext.prototype = {
  constructor: WebGLContext,

  initialize: function initialize() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.initDefault(params);

    this.viewPort.width = params.width !== undefined ? params.width : window.innerWidth;
    this.viewPort.height = params.height !== undefined ? params.height : window.innerHeight;

    this.scene = params.scene !== undefined ? params.scene : new window.$CCBIM.WebGL.Scene();
    this.initClearColor(params.clearColor);

    this.camera = params.camera !== undefined ? params.camera : this.setPerspectiveCamera();

    this.initRender(params);

    this.addLight();
  },

  initDefault: function initDefault(params) {
    params.antialias = params.antialias !== undefined ? params.antialias : true;
    params.perceision = params.perceision !== undefined ? params.perceision : 'highp';
    params.logarithmicDepthBuffer = params.logarithmicDepthBuffer !== undefined ? params.logarithmicDepthBuffer : true;
    params.preserveDrawingBuffer = params.preserveDrawingBuffer !== undefined ? params.preserveDrawingBuffer : true;
    params.textureType = params.textureType !== undefined ? params.textureType : 2;
  },
  addLight: function addLight() {
    var al = new window.$CCBIM.WebGL.AmbientLight(0xffffff, 0.2);
    al.name = 'AmbientLight';
    this.scene.add(al);
    var dl = new window.$CCBIM.WebGL.DirectionalLight(0xffffff, 0.65);
    dl.name = 'DirectionalLight1';
    dl.position.set(1, 1.3, 1.3);
    this.scene.add(dl);
    var dRight = new window.$CCBIM.WebGL.DirectionalLight(0xffffff, 0.65);
    dRight.name = 'DirectionalLight2';
    dRight.position.set(1, -1.3, 1.3);
    this.scene.add(dRight);
  },
  initClearColor: function initClearColor() {
    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#fff';

    this.scene.background = new window.$CCBIM.WebGL.Color(color);
  },
  setPerspectiveCamera: function setPerspectiveCamera() {
    return new window.$CCBIM.WebGL.PerspectiveCamera(50, this.viewPort.width / this.viewPort.height, 0.0001, 1000000);
  },
  initRender: function initRender(params) {
    this.renderer = params.renderer !== undefined ? params.renderer : new window.$CCBIM.WebGL.WebGLRenderer({
      antialias: params.antialias,
      precision: params.perceision,
      logarithmicDepthBuffer: params.logarithmicDepthBuffer,
      preserveDrawingBuffer: params.preserveDrawingBuffer,
      useOffScreenCanvas: params.useOffScreenCanvas });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.viewPort.width, this.viewPort.height);
    if (params.dom) {
      params.dom.appendChild(this.renderer.domElement);
    }

    var postProcessing = this.postProcessing;
    postProcessing.composer = new window.$CCBIM.WebGL.EffectComposer(this.renderer);

    postProcessing.renderPass = new window.$CCBIM.WebGL.RenderPass(this.scene, this.camera);
    postProcessing.renderPass.enabled = true;
    postProcessing.composer.addPass(postProcessing.renderPass);

    postProcessing.smaaPass = new window.$CCBIM.WebGL.SMAAPass(this.viewPort.width * window.devicePixelRatio, this.viewPort.height * window.devicePixelRatio);
    postProcessing.composer.addPass(postProcessing.smaaPass);

    this.updateRenderer({
      smaa: !params.antialias
    });
  },

  resize: function resize(width, height) {
    this.viewPort.width = width;
    this.viewPort.height = height;

    this.renderer.setSize(width, height);

    this.postProcessing.composer.setSize(width, height);

    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
  },

  updateRenderer: function updateRenderer(params) {
    params = params || {};

    var postProcessing = this.postProcessing;

    postProcessing.smaaPass.enabled = params.smaa !== undefined ? params.smaa : false;

    var passCount = postProcessing.composer.passes.length;
    var renderToScreen = false;
    for (var i = passCount - 1; i >= 0 && i < passCount; i--) {
      var pass = postProcessing.composer.passes[i];
      if (pass.enabled === false) {
        continue;
      }
      if (renderToScreen === false) {
        pass.renderToScreen = true;
        renderToScreen = true;
      } else {
        pass.renderToScreen = false;
      }
    }
  },

  render: function render() {
    this.postProcessing.composer.render();
  },

  getViewPortWidth: function getViewPortWidth() {
    return this.viewPort.width;
  },

  getViewPortHeight: function getViewPortHeight() {
    return this.viewPort.height;
  },

  getScene: function getScene() {
    return this.scene;
  },

  getCamera: function getCamera() {
    return this.camera;
  },

  getRenderer: function getRenderer() {
    return this.renderer;
  },

  getRenderList: function getRenderList() {
    return this.renderer.getRenderList(this.scene, this.camera, true);
  }
};

/* harmony default export */ __webpack_exports__["a"] = (WebGLContext);

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_symbol_iterator__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_symbol_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_symbol_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of__ = __webpack_require__(527);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_keys__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_core_js_object_define_property__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_core_js_object_define_property___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_core_js_object_define_property__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof__);










!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(exports)) && "object" == ( false ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(module)) ? module.exports = t() : "function" == typeof define && __webpack_require__(228) ? define([], t) : "object" == (typeof exports === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(exports)) ? exports.dat = t() : e.dat = t();
}(this, function () {
  return function (e) {
    function t(o) {
      if (n[o]) return n[o].exports;var i = n[o] = { exports: {}, id: o, loaded: !1 };return e[o].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports;
    }var n = {};return t.m = e, t.c = n, t.p = "", t(0);
  }([function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }var i = n(1),
        r = o(i);e.exports = r["default"];
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }t.__esModule = !0;var i = n(2),
        r = o(i),
        a = n(6),
        l = o(a),
        s = n(3),
        u = o(s),
        d = n(7),
        c = o(d),
        f = n(8),
        _ = o(f),
        p = n(10),
        h = o(p),
        m = n(11),
        b = o(m),
        g = n(12),
        v = o(g),
        y = n(13),
        w = o(y),
        x = n(14),
        E = o(x),
        C = n(15),
        A = o(C),
        S = n(16),
        k = o(S),
        O = n(9),
        T = o(O),
        R = n(17),
        L = o(R);t["default"] = { color: { Color: r["default"], math: l["default"], interpret: u["default"] }, controllers: { Controller: c["default"], BooleanController: _["default"], OptionController: h["default"], StringController: b["default"], NumberController: v["default"], NumberControllerBox: w["default"], NumberControllerSlider: E["default"], FunctionController: A["default"], ColorController: k["default"] }, dom: { dom: T["default"] }, gui: { GUI: L["default"] }, GUI: L["default"] };
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t, n) {
      __WEBPACK_IMPORTED_MODULE_7_babel_runtime_core_js_object_define_property___default()(e, t, { get: function get() {
          return "RGB" === this.__state.space ? this.__state[t] : (h.recalculateRGB(this, t, n), this.__state[t]);
        }, set: function set(e) {
          "RGB" !== this.__state.space && (h.recalculateRGB(this, t, n), this.__state.space = "RGB"), this.__state[t] = e;
        } });
    }function a(e, t) {
      __WEBPACK_IMPORTED_MODULE_7_babel_runtime_core_js_object_define_property___default()(e, t, { get: function get() {
          return "HSV" === this.__state.space ? this.__state[t] : (h.recalculateHSV(this), this.__state[t]);
        }, set: function set(e) {
          "HSV" !== this.__state.space && (h.recalculateHSV(this), this.__state.space = "HSV"), this.__state[t] = e;
        } });
    }t.__esModule = !0;var l = n(3),
        s = o(l),
        u = n(6),
        d = o(u),
        c = n(4),
        f = o(c),
        _ = n(5),
        p = o(_),
        h = function () {
      function e() {
        if (i(this, e), this.__state = s["default"].apply(this, arguments), this.__state === !1) throw new Error("Failed to interpret color arguments");this.__state.a = this.__state.a || 1;
      }return e.prototype.toString = function () {
        return (0, f["default"])(this);
      }, e.prototype.toHexString = function () {
        return (0, f["default"])(this, !0);
      }, e.prototype.toOriginal = function () {
        return this.__state.conversion.write(this);
      }, e;
    }();h.recalculateRGB = function (e, t, n) {
      if ("HEX" === e.__state.space) e.__state[t] = d["default"].component_from_hex(e.__state.hex, n);else {
        if ("HSV" !== e.__state.space) throw new Error("Corrupted color state");p["default"].extend(e.__state, d["default"].hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v));
      }
    }, h.recalculateHSV = function (e) {
      var t = d["default"].rgb_to_hsv(e.r, e.g, e.b);p["default"].extend(e.__state, { s: t.s, v: t.v }), p["default"].isNaN(t.h) ? p["default"].isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h;
    }, h.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], r(h.prototype, "r", 2), r(h.prototype, "g", 1), r(h.prototype, "b", 0), a(h.prototype, "h"), a(h.prototype, "s"), a(h.prototype, "v"), Object.defineProperty(h.prototype, "a", { get: function get() {
        return this.__state.a;
      }, set: function set(e) {
        this.__state.a = e;
      } }), Object.defineProperty(h.prototype, "hex", { get: function get() {
        return "HEX" !== !this.__state.space && (this.__state.hex = d["default"].rgb_to_hex(this.r, this.g, this.b)), this.__state.hex;
      }, set: function set(e) {
        this.__state.space = "HEX", this.__state.hex = e;
      } }), t["default"] = h;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }t.__esModule = !0;var i = n(4),
        r = o(i),
        a = n(5),
        l = o(a),
        s = [{ litmus: l["default"].isString, conversions: { THREE_CHAR_HEX: { read: function read(e) {
            var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) };
          }, write: r["default"] }, SIX_CHAR_HEX: { read: function read(e) {
            var t = e.match(/^#([A-F0-9]{6})$/i);return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) };
          }, write: r["default"] }, CSS_RGB: { read: function read(e) {
            var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) };
          }, write: r["default"] }, CSS_RGBA: { read: function read(e) {
            var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) };
          }, write: r["default"] } } }, { litmus: l["default"].isNumber, conversions: { HEX: { read: function read(e) {
            return { space: "HEX", hex: e, conversionName: "HEX" };
          }, write: function write(e) {
            return e.hex;
          } } } }, { litmus: l["default"].isArray, conversions: { RGB_ARRAY: { read: function read(e) {
            return 3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] };
          }, write: function write(e) {
            return [e.r, e.g, e.b];
          } }, RGBA_ARRAY: { read: function read(e) {
            return 4 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] };
          }, write: function write(e) {
            return [e.r, e.g, e.b, e.a];
          } } } }, { litmus: l["default"].isObject, conversions: { RGBA_OBJ: { read: function read(e) {
            return !!(l["default"].isNumber(e.r) && l["default"].isNumber(e.g) && l["default"].isNumber(e.b) && l["default"].isNumber(e.a)) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a };
          }, write: function write(e) {
            return { r: e.r, g: e.g, b: e.b, a: e.a };
          } }, RGB_OBJ: { read: function read(e) {
            return !!(l["default"].isNumber(e.r) && l["default"].isNumber(e.g) && l["default"].isNumber(e.b)) && { space: "RGB", r: e.r, g: e.g, b: e.b };
          }, write: function write(e) {
            return { r: e.r, g: e.g, b: e.b };
          } }, HSVA_OBJ: { read: function read(e) {
            return !!(l["default"].isNumber(e.h) && l["default"].isNumber(e.s) && l["default"].isNumber(e.v) && l["default"].isNumber(e.a)) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a };
          }, write: function write(e) {
            return { h: e.h, s: e.s, v: e.v, a: e.a };
          } }, HSV_OBJ: { read: function read(e) {
            return !!(l["default"].isNumber(e.h) && l["default"].isNumber(e.s) && l["default"].isNumber(e.v)) && { space: "HSV", h: e.h, s: e.s, v: e.v };
          }, write: function write(e) {
            return { h: e.h, s: e.s, v: e.v };
          } } } }],
        u = void 0,
        d = void 0,
        c = function c() {
      d = !1;var e = arguments.length > 1 ? l["default"].toArray(arguments) : arguments[0];return l["default"].each(s, function (t) {
        if (t.litmus(e)) return l["default"].each(t.conversions, function (t, n) {
          if (u = t.read(e), d === !1 && u !== !1) return d = u, u.conversionName = n, u.conversion = t, l["default"].BREAK;
        }), l["default"].BREAK;
      }), d;
    };t["default"] = c;
  }, function (e, t) {
    "use strict";
    t.__esModule = !0, t["default"] = function (e, t) {
      var n = e.__state.conversionName.toString(),
          o = Math.round(e.r),
          i = Math.round(e.g),
          r = Math.round(e.b),
          a = e.a,
          l = Math.round(e.h),
          s = e.s.toFixed(1),
          u = e.v.toFixed(1);if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
        for (var d = e.hex.toString(16); d.length < 6;) {
          d = "0" + d;
        }return "#" + d;
      }return "CSS_RGB" === n ? "rgb(" + o + "," + i + "," + r + ")" : "CSS_RGBA" === n ? "rgba(" + o + "," + i + "," + r + "," + a + ")" : "HEX" === n ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === n ? "[" + o + "," + i + "," + r + "]" : "RGBA_ARRAY" === n ? "[" + o + "," + i + "," + r + "," + a + "]" : "RGB_OBJ" === n ? "{r:" + o + ",g:" + i + ",b:" + r + "}" : "RGBA_OBJ" === n ? "{r:" + o + ",g:" + i + ",b:" + r + ",a:" + a + "}" : "HSV_OBJ" === n ? "{h:" + l + ",s:" + s + ",v:" + u + "}" : "HSVA_OBJ" === n ? "{h:" + l + ",s:" + s + ",v:" + u + ",a:" + a + "}" : "unknown format";
    };
  }, function (e, t) {
    "use strict";
    t.__esModule = !0;var n = Array.prototype.forEach,
        o = Array.prototype.slice,
        i = { BREAK: {}, extend: function extend(e) {
        return this.each(o.call(arguments, 1), function (t) {
          var n = this.isObject(t) ? __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_keys___default()(t) : [];n.forEach(function (n) {
            this.isUndefined(t[n]) || (e[n] = t[n]);
          }.bind(this));
        }, this), e;
      }, defaults: function defaults(e) {
        return this.each(o.call(arguments, 1), function (t) {
          var n = this.isObject(t) ? __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_keys___default()(t) : [];n.forEach(function (n) {
            this.isUndefined(e[n]) && (e[n] = t[n]);
          }.bind(this));
        }, this), e;
      }, compose: function compose() {
        var e = o.call(arguments);return function () {
          for (var t = o.call(arguments), n = e.length - 1; n >= 0; n--) {
            t = [e[n].apply(this, t)];
          }return t[0];
        };
      }, each: function each(e, t, o) {
        if (e) if (n && e.forEach && e.forEach === n) e.forEach(t, o);else if (e.length === e.length + 0) {
          var i = void 0,
              r = void 0;for (i = 0, r = e.length; i < r; i++) {
            if (i in e && t.call(o, e[i], i) === this.BREAK) return;
          }
        } else for (var a in e) {
          if (t.call(o, e[a], a) === this.BREAK) return;
        }
      }, defer: function defer(e) {
        setTimeout(e, 0);
      }, debounce: function debounce(e, t) {
        var n = void 0;return function () {
          function o() {
            n = null;
          }var i = this,
              r = arguments,
              a = !n;clearTimeout(n), n = setTimeout(o, t), a && e.apply(i, r);
        };
      }, toArray: function toArray(e) {
        return e.toArray ? e.toArray() : o.call(e);
      }, isUndefined: function isUndefined(e) {
        return void 0 === e;
      }, isNull: function isNull(e) {
        return null === e;
      }, isNaN: function (e) {
        function t(t) {
          return e.apply(this, arguments);
        }return t.toString = function () {
          return e.toString();
        }, t;
      }(function (e) {
        return isNaN(e);
      }), isArray: Array.isArray || function (e) {
        return e.constructor === Array;
      }, isObject: function isObject(e) {
        return e === Object(e);
      }, isNumber: function isNumber(e) {
        return e === e + 0;
      }, isString: function isString(e) {
        return e === e + "";
      }, isBoolean: function isBoolean(e) {
        return e === !1 || e === !0;
      }, isFunction: function isFunction(e) {
        return "[object Function]" === Object.prototype.toString.call(e);
      } };t["default"] = i;
  }, function (e, t) {
    "use strict";
    t.__esModule = !0;var n = void 0,
        o = { hsv_to_rgb: function hsv_to_rgb(e, t, n) {
        var o = Math.floor(e / 60) % 6,
            i = e / 60 - Math.floor(e / 60),
            r = n * (1 - t),
            a = n * (1 - i * t),
            l = n * (1 - (1 - i) * t),
            s = [[n, l, r], [a, n, r], [r, n, l], [r, a, n], [l, r, n], [n, r, a]][o];return { r: 255 * s[0], g: 255 * s[1], b: 255 * s[2] };
      }, rgb_to_hsv: function rgb_to_hsv(e, t, n) {
        var o = Math.min(e, t, n),
            i = Math.max(e, t, n),
            r = i - o,
            a = void 0,
            l = void 0;return 0 === i ? { h: NaN, s: 0, v: 0 } : (l = r / i, a = e === i ? (t - n) / r : t === i ? 2 + (n - e) / r : 4 + (e - t) / r, a /= 6, a < 0 && (a += 1), { h: 360 * a, s: l, v: i / 255 });
      }, rgb_to_hex: function rgb_to_hex(e, t, n) {
        var o = this.hex_with_component(0, 2, e);return o = this.hex_with_component(o, 1, t), o = this.hex_with_component(o, 0, n);
      }, component_from_hex: function component_from_hex(e, t) {
        return e >> 8 * t & 255;
      }, hex_with_component: function hex_with_component(e, t, o) {
        return o << (n = 8 * t) | e & ~(255 << n);
      } };t["default"] = o;
  }, function (e, t) {
    "use strict";
    function n(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }t.__esModule = !0;var o = function () {
      function e(t, o) {
        n(this, e), this.initialValue = t[o], this.domElement = document.createElement("div"), this.object = t, this.property = o, this.__onChange = void 0, this.__onFinishChange = void 0;
      }return e.prototype.onChange = function (e) {
        return this.__onChange = e, this;
      }, e.prototype.onFinishChange = function (e) {
        return this.__onFinishChange = e, this;
      }, e.prototype.setValue = function (e) {
        return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this;
      }, e.prototype.getValue = function () {
        return this.object[this.property];
      }, e.prototype.updateDisplay = function () {
        return this;
      }, e.prototype.isModified = function () {
        return this.initialValue !== this.getValue();
      }, e;
    }();t["default"] = o;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }t.__esModule = !0;var l = n(7),
        s = o(l),
        u = n(9),
        d = o(u),
        c = function (e) {
      function t(n, o) {
        function a() {
          s.setValue(!s.__prev);
        }i(this, t);var l = r(this, e.call(this, n, o)),
            s = l;return l.__prev = l.getValue(), l.__checkbox = document.createElement("input"), l.__checkbox.setAttribute("type", "checkbox"), d["default"].bind(l.__checkbox, "change", a, !1), l.domElement.appendChild(l.__checkbox), l.updateDisplay(), l;
      }return a(t, e), t.prototype.setValue = function (t) {
        var n = e.prototype.setValue.call(this, t);return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n;
      }, t.prototype.updateDisplay = function () {
        return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0) : this.__checkbox.checked = !1, e.prototype.updateDisplay.call(this);
      }, t;
    }(s["default"]);t["default"] = c;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e) {
      if ("0" === e || a["default"].isUndefined(e)) return 0;var t = e.match(u);return a["default"].isNull(t) ? 0 : parseFloat(t[1]);
    }t.__esModule = !0;var r = n(5),
        a = o(r),
        l = { HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] },
        s = {};a["default"].each(l, function (e, t) {
      a["default"].each(e, function (e) {
        s[e] = t;
      });
    });var u = /(\d+(\.\d+)?)px/,
        d = { makeSelectable: function makeSelectable(e, t) {
        void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function () {
          return !1;
        } : function () {}, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off");
      }, makeFullscreen: function makeFullscreen(e, t, n) {
        var o = n,
            i = t;a["default"].isUndefined(i) && (i = !0), a["default"].isUndefined(o) && (o = !0), e.style.position = "absolute", i && (e.style.left = 0, e.style.right = 0), o && (e.style.top = 0, e.style.bottom = 0);
      }, fakeEvent: function fakeEvent(e, t, n, o) {
        var i = n || {},
            r = s[t];if (!r) throw new Error("Event type " + t + " not supported.");var l = document.createEvent(r);switch (r) {case "MouseEvents":
            var u = i.x || i.clientX || 0,
                d = i.y || i.clientY || 0;l.initMouseEvent(t, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, u, d, !1, !1, !1, !1, 0, null);break;case "KeyboardEvents":
            var c = l.initKeyboardEvent || l.initKeyEvent;a["default"].defaults(i, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), c(t, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);break;default:
            l.initEvent(t, i.bubbles || !1, i.cancelable || !0);}a["default"].defaults(l, o), e.dispatchEvent(l);
      }, bind: function bind(e, t, n, o) {
        var i = o || !1;return e.addEventListener ? e.addEventListener(t, n, i) : e.attachEvent && e.attachEvent("on" + t, n), d;
      }, unbind: function unbind(e, t, n, o) {
        var i = o || !1;return e.removeEventListener ? e.removeEventListener(t, n, i) : e.detachEvent && e.detachEvent("on" + t, n), d;
      }, addClass: function addClass(e, t) {
        if (void 0 === e.className) e.className = t;else if (e.className !== t) {
          var n = e.className.split(/ +/);n.indexOf(t) === -1 && (n.push(t), e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
        }return d;
      }, removeClass: function removeClass(e, t) {
        if (t) {
          if (e.className === t) e.removeAttribute("class");else {
            var n = e.className.split(/ +/),
                o = n.indexOf(t);o !== -1 && (n.splice(o, 1), e.className = n.join(" "));
          }
        } else e.className = void 0;return d;
      }, hasClass: function hasClass(e, t) {
        return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1;
      }, getWidth: function getWidth(e) {
        var t = getComputedStyle(e);return i(t["border-left-width"]) + i(t["border-right-width"]) + i(t["padding-left"]) + i(t["padding-right"]) + i(t.width);
      }, getHeight: function getHeight(e) {
        var t = getComputedStyle(e);return i(t["border-top-width"]) + i(t["border-bottom-width"]) + i(t["padding-top"]) + i(t["padding-bottom"]) + i(t.height);
      }, getOffset: function getOffset(e) {
        var t = e,
            n = { left: 0, top: 0 };if (t.offsetParent) do {
          n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent;
        } while (t);return n;
      }, isActive: function isActive(e) {
        return e === document.activeElement && (e.type || e.href);
      } };t["default"] = d;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }t.__esModule = !0;var l = n(7),
        s = o(l),
        u = n(9),
        d = o(u),
        c = n(5),
        f = o(c),
        _ = function (e) {
      function t(n, o, a) {
        i(this, t);var l = r(this, e.call(this, n, o)),
            s = a,
            u = l;return l.__select = document.createElement("select"), f["default"].isArray(s) && !function () {
          var e = {};f["default"].each(s, function (t) {
            e[t] = t;
          }), s = e;
        }(), f["default"].each(s, function (e, t) {
          var n = document.createElement("option");n.innerHTML = t, n.setAttribute("value", e), u.__select.appendChild(n);
        }), l.updateDisplay(), d["default"].bind(l.__select, "change", function () {
          var e = this.options[this.selectedIndex].value;u.setValue(e);
        }), l.domElement.appendChild(l.__select), l;
      }return a(t, e), t.prototype.setValue = function (t) {
        var n = e.prototype.setValue.call(this, t);return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n;
      }, t.prototype.updateDisplay = function () {
        return d["default"].isActive(this.__select) ? this : (this.__select.value = this.getValue(), e.prototype.updateDisplay.call(this));
      }, t;
    }(s["default"]);t["default"] = _;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }t.__esModule = !0;var l = n(7),
        s = o(l),
        u = n(9),
        d = o(u),
        c = function (e) {
      function t(n, o) {
        function a() {
          u.setValue(u.__input.value);
        }function l() {
          u.__onFinishChange && u.__onFinishChange.call(u, u.getValue());
        }i(this, t);var s = r(this, e.call(this, n, o)),
            u = s;return s.__input = document.createElement("input"), s.__input.setAttribute("type", "text"), d["default"].bind(s.__input, "keyup", a), d["default"].bind(s.__input, "change", a), d["default"].bind(s.__input, "blur", l), d["default"].bind(s.__input, "keydown", function (e) {
          13 === e.keyCode && this.blur();
        }), s.updateDisplay(), s.domElement.appendChild(s.__input), s;
      }return a(t, e), t.prototype.updateDisplay = function () {
        return d["default"].isActive(this.__input) || (this.__input.value = this.getValue()), e.prototype.updateDisplay.call(this);
      }, t;
    }(s["default"]);t["default"] = c;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }function l(e) {
      var t = e.toString();return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0;
    }t.__esModule = !0;var s = n(7),
        u = o(s),
        d = n(5),
        c = o(d),
        f = function (e) {
      function t(n, o, a) {
        i(this, t);var s = r(this, e.call(this, n, o)),
            u = a || {};return s.__min = u.min, s.__max = u.max, s.__step = u.step, c["default"].isUndefined(s.__step) ? 0 === s.initialValue ? s.__impliedStep = 1 : s.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(s.initialValue)) / Math.LN10)) / 10 : s.__impliedStep = s.__step, s.__precision = l(s.__impliedStep), s;
      }return a(t, e), t.prototype.setValue = function (t) {
        var n = t;return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step !== 0 && (n = Math.round(n / this.__step) * this.__step), e.prototype.setValue.call(this, n);
      }, t.prototype.min = function (e) {
        return this.__min = e, this;
      }, t.prototype.max = function (e) {
        return this.__max = e, this;
      }, t.prototype.step = function (e) {
        return this.__step = e, this.__impliedStep = e, this.__precision = l(e), this;
      }, t;
    }(u["default"]);t["default"] = f;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }function l(e, t) {
      var n = Math.pow(10, t);return Math.round(e * n) / n;
    }t.__esModule = !0;var s = n(12),
        u = o(s),
        d = n(9),
        c = o(d),
        f = n(5),
        _ = o(f),
        p = function (e) {
      function t(n, o, a) {
        function l() {
          var e = parseFloat(m.__input.value);_["default"].isNaN(e) || m.setValue(e);
        }function s() {
          m.__onFinishChange && m.__onFinishChange.call(m, m.getValue());
        }function u() {
          s();
        }function d(e) {
          var t = b - e.clientY;m.setValue(m.getValue() + t * m.__impliedStep), b = e.clientY;
        }function f() {
          c["default"].unbind(window, "mousemove", d), c["default"].unbind(window, "mouseup", f), s();
        }function p(e) {
          c["default"].bind(window, "mousemove", d), c["default"].bind(window, "mouseup", f), b = e.clientY;
        }i(this, t);var h = r(this, e.call(this, n, o, a));h.__truncationSuspended = !1;var m = h,
            b = void 0;return h.__input = document.createElement("input"), h.__input.setAttribute("type", "text"), c["default"].bind(h.__input, "change", l), c["default"].bind(h.__input, "blur", u), c["default"].bind(h.__input, "mousedown", p), c["default"].bind(h.__input, "keydown", function (e) {
          13 === e.keyCode && (m.__truncationSuspended = !0, this.blur(), m.__truncationSuspended = !1, s());
        }), h.updateDisplay(), h.domElement.appendChild(h.__input), h;
      }return a(t, e), t.prototype.updateDisplay = function () {
        return this.__input.value = this.__truncationSuspended ? this.getValue() : l(this.getValue(), this.__precision), e.prototype.updateDisplay.call(this);
      }, t;
    }(u["default"]);t["default"] = p;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }function l(e, t, n, o, i) {
      return o + (i - o) * ((e - t) / (n - t));
    }t.__esModule = !0;var s = n(12),
        u = o(s),
        d = n(9),
        c = o(d),
        f = function (e) {
      function t(n, o, a, s, u) {
        function d(e) {
          document.activeElement.blur(), c["default"].bind(window, "mousemove", f), c["default"].bind(window, "mouseup", _), f(e);
        }function f(e) {
          e.preventDefault();var t = h.__background.getBoundingClientRect();return h.setValue(l(e.clientX, t.left, t.right, h.__min, h.__max)), !1;
        }function _() {
          c["default"].unbind(window, "mousemove", f), c["default"].unbind(window, "mouseup", _), h.__onFinishChange && h.__onFinishChange.call(h, h.getValue());
        }i(this, t);var p = r(this, e.call(this, n, o, { min: a, max: s, step: u })),
            h = p;return p.__background = document.createElement("div"), p.__foreground = document.createElement("div"), c["default"].bind(p.__background, "mousedown", d), c["default"].addClass(p.__background, "slider"), c["default"].addClass(p.__foreground, "slider-fg"), p.updateDisplay(), p.__background.appendChild(p.__foreground), p.domElement.appendChild(p.__background), p;
      }return a(t, e), t.prototype.updateDisplay = function () {
        var t = (this.getValue() - this.__min) / (this.__max - this.__min);return this.__foreground.style.width = 100 * t + "%", e.prototype.updateDisplay.call(this);
      }, t;
    }(u["default"]);t["default"] = f;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }t.__esModule = !0;var l = n(7),
        s = o(l),
        u = n(9),
        d = o(u),
        c = function (e) {
      function t(n, o, a) {
        i(this, t);var l = r(this, e.call(this, n, o)),
            s = l;return l.__button = document.createElement("div"), l.__button.innerHTML = void 0 === a ? "Fire" : a, d["default"].bind(l.__button, "click", function (e) {
          return e.preventDefault(), s.fire(), !1;
        }), d["default"].addClass(l.__button, "button"), l.domElement.appendChild(l.__button), l;
      }return a(t, e), t.prototype.fire = function () {
        this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
      }, t;
    }(s["default"]);t["default"] = c;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }function r(e, t) {
      if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)) && "function" != typeof t ? e : t;
    }function a(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (typeof t === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(t)));e.prototype = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_create___default()(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default.a ? __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_set_prototype_of___default()(e, t) : e.__proto__ = t);
    }function l(e, t, n, o) {
      e.style.background = "", g["default"].each(y, function (i) {
        e.style.cssText += "background: " + i + "linear-gradient(" + t + ", " + n + " 0%, " + o + " 100%); ";
      });
    }function s(e) {
      e.style.background = "", e.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", e.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
    }t.__esModule = !0;var u = n(7),
        d = o(u),
        c = n(9),
        f = o(c),
        _ = n(2),
        p = o(_),
        h = n(3),
        m = o(h),
        b = n(5),
        g = o(b),
        v = function (e) {
      function t(n, o) {
        function a(e) {
          h(e), f["default"].bind(window, "mousemove", h), f["default"].bind(window, "mouseup", u);
        }function u() {
          f["default"].unbind(window, "mousemove", h), f["default"].unbind(window, "mouseup", u), _();
        }function d() {
          var e = (0, m["default"])(this.value);e !== !1 ? (y.__color.__state = e, y.setValue(y.__color.toOriginal())) : this.value = y.__color.toString();
        }function c() {
          f["default"].unbind(window, "mousemove", b), f["default"].unbind(window, "mouseup", c), _();
        }function _() {
          y.__onFinishChange && y.__onFinishChange.call(y, y.__color.toOriginal());
        }function h(e) {
          e.preventDefault();var t = y.__saturation_field.getBoundingClientRect(),
              n = (e.clientX - t.left) / (t.right - t.left),
              o = 1 - (e.clientY - t.top) / (t.bottom - t.top);return o > 1 ? o = 1 : o < 0 && (o = 0), n > 1 ? n = 1 : n < 0 && (n = 0), y.__color.v = o, y.__color.s = n, y.setValue(y.__color.toOriginal()), !1;
        }function b(e) {
          e.preventDefault();var t = y.__hue_field.getBoundingClientRect(),
              n = 1 - (e.clientY - t.top) / (t.bottom - t.top);return n > 1 ? n = 1 : n < 0 && (n = 0), y.__color.h = 360 * n, y.setValue(y.__color.toOriginal()), !1;
        }i(this, t);var v = r(this, e.call(this, n, o));v.__color = new p["default"](v.getValue()), v.__temp = new p["default"](0);var y = v;v.domElement = document.createElement("div"), f["default"].makeSelectable(v.domElement, !1), v.__selector = document.createElement("div"), v.__selector.className = "selector", v.__saturation_field = document.createElement("div"), v.__saturation_field.className = "saturation-field", v.__field_knob = document.createElement("div"), v.__field_knob.className = "field-knob", v.__field_knob_border = "2px solid ", v.__hue_knob = document.createElement("div"), v.__hue_knob.className = "hue-knob", v.__hue_field = document.createElement("div"), v.__hue_field.className = "hue-field", v.__input = document.createElement("input"), v.__input.type = "text", v.__input_textShadow = "0 1px 1px ", f["default"].bind(v.__input, "keydown", function (e) {
          13 === e.keyCode && d.call(this);
        }), f["default"].bind(v.__input, "blur", d), f["default"].bind(v.__selector, "mousedown", function () {
          f["default"].addClass(this, "drag").bind(window, "mouseup", function () {
            f["default"].removeClass(y.__selector, "drag");
          });
        });var w = document.createElement("div");return g["default"].extend(v.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), g["default"].extend(v.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: v.__field_knob_border + (v.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), g["default"].extend(v.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), g["default"].extend(v.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), g["default"].extend(w.style, { width: "100%", height: "100%", background: "none" }), l(w, "top", "rgba(0,0,0,0)", "#000"), g["default"].extend(v.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), s(v.__hue_field), g["default"].extend(v.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: v.__input_textShadow + "rgba(0,0,0,0.7)" }), f["default"].bind(v.__saturation_field, "mousedown", a), f["default"].bind(v.__field_knob, "mousedown", a), f["default"].bind(v.__hue_field, "mousedown", function (e) {
          b(e), f["default"].bind(window, "mousemove", b), f["default"].bind(window, "mouseup", c);
        }), v.__saturation_field.appendChild(w), v.__selector.appendChild(v.__field_knob), v.__selector.appendChild(v.__saturation_field), v.__selector.appendChild(v.__hue_field), v.__hue_field.appendChild(v.__hue_knob), v.domElement.appendChild(v.__input), v.domElement.appendChild(v.__selector), v.updateDisplay(), v;
      }return a(t, e), t.prototype.updateDisplay = function () {
        var e = (0, m["default"])(this.getValue());if (e !== !1) {
          var t = !1;g["default"].each(p["default"].COMPONENTS, function (n) {
            if (!g["default"].isUndefined(e[n]) && !g["default"].isUndefined(this.__color.__state[n]) && e[n] !== this.__color.__state[n]) return t = !0, {};
          }, this), t && g["default"].extend(this.__color.__state, e);
        }g["default"].extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
            o = 255 - n;g["default"].extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, l(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), g["default"].extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + n + "," + n + "," + n + ")", textShadow: this.__input_textShadow + "rgba(" + o + "," + o + "," + o + ",.7)" });
      }, t;
    }(d["default"]),
        y = ["-moz-", "-o-", "-webkit-", "-ms-", ""];t["default"] = v;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t, n) {
      var o = document.createElement("li");return t && o.appendChild(t), n ? e.__ul.insertBefore(o, n) : e.__ul.appendChild(o), e.onResize(), o;
    }function r(e, t) {
      var n = e.__preset_select[e.__preset_select.selectedIndex];t ? n.innerHTML = n.value + "*" : n.innerHTML = n.value;
    }function a(e, t, n) {
      if (n.__li = t, n.__gui = e, U["default"].extend(n, { options: function options(t) {
          if (arguments.length > 1) {
            var o = n.__li.nextElementSibling;return n.remove(), s(e, n.object, n.property, { before: o, factoryArgs: [U["default"].toArray(arguments)] });
          }if (U["default"].isArray(t) || U["default"].isObject(t)) {
            var i = n.__li.nextElementSibling;return n.remove(), s(e, n.object, n.property, { before: i, factoryArgs: [t] });
          }
        }, name: function name(e) {
          return n.__li.firstElementChild.firstElementChild.innerHTML = e, n;
        }, listen: function listen() {
          return n.__gui.listen(n), n;
        }, remove: function remove() {
          return n.__gui.remove(n), n;
        } }), n instanceof B["default"]) !function () {
        var e = new N["default"](n.object, n.property, { min: n.__min, max: n.__max, step: n.__step });U["default"].each(["updateDisplay", "onChange", "onFinishChange", "step"], function (t) {
          var o = n[t],
              i = e[t];n[t] = e[t] = function () {
            var t = Array.prototype.slice.call(arguments);return i.apply(e, t), o.apply(n, t);
          };
        }), z["default"].addClass(t, "has-slider"), n.domElement.insertBefore(e.domElement, n.domElement.firstElementChild);
      }();else if (n instanceof N["default"]) {
        var o = function o(t) {
          if (U["default"].isNumber(n.__min) && U["default"].isNumber(n.__max)) {
            var o = n.__li.firstElementChild.firstElementChild.innerHTML,
                i = n.__gui.__listening.indexOf(n) > -1;n.remove();var r = s(e, n.object, n.property, { before: n.__li.nextElementSibling, factoryArgs: [n.__min, n.__max, n.__step] });return r.name(o), i && r.listen(), r;
          }return t;
        };n.min = U["default"].compose(o, n.min), n.max = U["default"].compose(o, n.max);
      } else n instanceof O["default"] ? (z["default"].bind(t, "click", function () {
        z["default"].fakeEvent(n.__checkbox, "click");
      }), z["default"].bind(n.__checkbox, "click", function (e) {
        e.stopPropagation();
      })) : n instanceof R["default"] ? (z["default"].bind(t, "click", function () {
        z["default"].fakeEvent(n.__button, "click");
      }), z["default"].bind(t, "mouseover", function () {
        z["default"].addClass(n.__button, "hover");
      }), z["default"].bind(t, "mouseout", function () {
        z["default"].removeClass(n.__button, "hover");
      })) : n instanceof j["default"] && (z["default"].addClass(t, "color"), n.updateDisplay = U["default"].compose(function (e) {
        return t.style.borderLeftColor = n.__color.toString(), e;
      }, n.updateDisplay), n.updateDisplay());n.setValue = U["default"].compose(function (t) {
        return e.getRoot().__preset_select && n.isModified() && r(e.getRoot(), !0), t;
      }, n.setValue);
    }function l(e, t) {
      var n = e.getRoot(),
          o = n.__rememberedObjects.indexOf(t.object);if (o !== -1) {
        var i = n.__rememberedObjectIndecesToControllers[o];if (void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[o] = i), i[t.property] = t, n.load && n.load.remembered) {
          var r = n.load.remembered,
              a = void 0;if (r[e.preset]) a = r[e.preset];else {
            if (!r[Q]) return;a = r[Q];
          }if (a[o] && void 0 !== a[o][t.property]) {
            var l = a[o][t.property];t.initialValue = l, t.setValue(l);
          }
        }
      }
    }function s(e, t, n, o) {
      if (void 0 === t[n]) throw new Error('Object "' + t + '" has no property "' + n + '"');var r = void 0;if (o.color) r = new j["default"](t, n);else {
        var s = [t, n].concat(o.factoryArgs);r = C["default"].apply(e, s);
      }o.before instanceof S["default"] && (o.before = o.before.__li), l(e, r), z["default"].addClass(r.domElement, "c");var u = document.createElement("span");z["default"].addClass(u, "property-name"), u.innerHTML = r.property;var d = document.createElement("div");d.appendChild(u), d.appendChild(r.domElement);var c = i(e, d, o.before);return z["default"].addClass(c, oe.CLASS_CONTROLLER_ROW), r instanceof j["default"] ? z["default"].addClass(c, "color") : z["default"].addClass(c, g(r.getValue())), a(e, c, r), e.__controllers.push(r), r;
    }function u(e, t) {
      return document.location.href + "." + t;
    }function d(e, t, n) {
      var o = document.createElement("option");o.innerHTML = t, o.value = t, e.__preset_select.appendChild(o), n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1);
    }function c(e, t) {
      t.style.display = e.useLocalStorage ? "block" : "none";
    }function f(e) {
      var t = e.__save_row = document.createElement("li");z["default"].addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), z["default"].addClass(t, "save-row");var n = document.createElement("span");n.innerHTML = "&nbsp;", z["default"].addClass(n, "button gears");var o = document.createElement("span");o.innerHTML = "Save", z["default"].addClass(o, "button"), z["default"].addClass(o, "save");var i = document.createElement("span");i.innerHTML = "New", z["default"].addClass(i, "button"), z["default"].addClass(i, "save-as");var r = document.createElement("span");r.innerHTML = "Revert", z["default"].addClass(r, "button"), z["default"].addClass(r, "revert");var a = e.__preset_select = document.createElement("select");e.load && e.load.remembered ? U["default"].each(e.load.remembered, function (t, n) {
        d(e, n, n === e.preset);
      }) : d(e, Q, !1), z["default"].bind(a, "change", function () {
        for (var t = 0; t < e.__preset_select.length; t++) {
          e.__preset_select[t].innerHTML = e.__preset_select[t].value;
        }e.preset = this.value;
      }), t.appendChild(a), t.appendChild(n), t.appendChild(o), t.appendChild(i), t.appendChild(r), q && !function () {
        var t = document.getElementById("dg-local-explain"),
            n = document.getElementById("dg-local-storage"),
            o = document.getElementById("dg-save-locally");o.style.display = "block", "true" === localStorage.getItem(u(e, "isLocal")) && n.setAttribute("checked", "checked"), c(e, t), z["default"].bind(n, "change", function () {
          e.useLocalStorage = !e.useLocalStorage, c(e, t);
        });
      }();var l = document.getElementById("dg-new-constructor");z["default"].bind(l, "keydown", function (e) {
        !e.metaKey || 67 !== e.which && 67 !== e.keyCode || Z.hide();
      }), z["default"].bind(n, "click", function () {
        l.innerHTML = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default()(e.getSaveObject(), void 0, 2), Z.show(), l.focus(), l.select();
      }), z["default"].bind(o, "click", function () {
        e.save();
      }), z["default"].bind(i, "click", function () {
        var t = prompt("Enter a new preset name.");t && e.saveAs(t);
      }), z["default"].bind(r, "click", function () {
        e.revert();
      });
    }function _(e) {
      function t(t) {
        return t.preventDefault(), e.width += i - t.clientX, e.onResize(), i = t.clientX, !1;
      }function n() {
        z["default"].removeClass(e.__closeButton, oe.CLASS_DRAG), z["default"].unbind(window, "mousemove", t), z["default"].unbind(window, "mouseup", n);
      }function o(o) {
        return o.preventDefault(), i = o.clientX, z["default"].addClass(e.__closeButton, oe.CLASS_DRAG), z["default"].bind(window, "mousemove", t), z["default"].bind(window, "mouseup", n), !1;
      }var i = void 0;e.__resize_handle = document.createElement("div"), U["default"].extend(e.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), z["default"].bind(e.__resize_handle, "mousedown", o), z["default"].bind(e.__closeButton, "mousedown", o), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild);
    }function p(e, t) {
      e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px");
    }function h(e, t) {
      var n = {};return U["default"].each(e.__rememberedObjects, function (o, i) {
        var r = {},
            a = e.__rememberedObjectIndecesToControllers[i];U["default"].each(a, function (e, n) {
          r[n] = t ? e.initialValue : e.getValue();
        }), n[i] = r;
      }), n;
    }function m(e) {
      for (var t = 0; t < e.__preset_select.length; t++) {
        e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t);
      }
    }function b(e) {
      0 !== e.length && D["default"].call(window, function () {
        b(e);
      }), U["default"].each(e, function (e) {
        e.updateDisplay();
      });
    }var g = "function" == typeof __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol___default.a && "symbol" == __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_symbol_iterator___default.a) ? function (e) {
      return typeof e === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(e);
    } : function (e) {
      return e && "function" == typeof __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol___default.a && e.constructor === __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol___default.a ? "symbol" : typeof e === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_typeof___default()(e);
    },
        v = n(18),
        y = o(v),
        w = n(19),
        x = o(w),
        E = n(20),
        C = o(E),
        A = n(7),
        S = o(A),
        k = n(8),
        O = o(k),
        T = n(15),
        R = o(T),
        L = n(13),
        N = o(L),
        M = n(14),
        B = o(M),
        H = n(16),
        j = o(H),
        P = n(21),
        D = o(P),
        V = n(22),
        F = o(V),
        I = n(9),
        z = o(I),
        G = n(5),
        U = o(G),
        X = n(23),
        K = o(X);y["default"].inject(K["default"]);var Y = "dg",
        J = 72,
        W = 20,
        Q = "Default",
        q = function () {
      try {
        return "localStorage" in window && null !== window.localStorage;
      } catch (e) {
        return !1;
      }
    }(),
        Z = void 0,
        $ = !0,
        ee = void 0,
        te = !1,
        ne = [],
        oe = function ie(e) {
      function t() {
        var e = n.getRoot();e.width += 1, U["default"].defer(function () {
          e.width -= 1;
        });
      }var n = this,
          o = e || {};this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), z["default"].addClass(this.domElement, Y), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], o = U["default"].defaults(o, { autoPlace: !0, width: ie.DEFAULT_WIDTH }), o = U["default"].defaults(o, { resizable: o.autoPlace, hideable: o.autoPlace }), U["default"].isUndefined(o.load) ? o.load = { preset: Q } : o.preset && (o.load.preset = o.preset), U["default"].isUndefined(o.parent) && o.hideable && ne.push(this), o.resizable = U["default"].isUndefined(o.parent) && o.resizable, o.autoPlace && U["default"].isUndefined(o.scrollable) && (o.scrollable = !0);var r = q && "true" === localStorage.getItem(u(this, "isLocal")),
          a = void 0;if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default()(this, { parent: { get: function get() {
            return o.parent;
          } }, scrollable: { get: function get() {
            return o.scrollable;
          } }, autoPlace: { get: function get() {
            return o.autoPlace;
          } }, preset: { get: function get() {
            return n.parent ? n.getRoot().preset : o.load.preset;
          }, set: function set(e) {
            n.parent ? n.getRoot().preset = e : o.load.preset = e, m(this), n.revert();
          } }, width: { get: function get() {
            return o.width;
          }, set: function set(e) {
            o.width = e, p(n, e);
          } }, name: { get: function get() {
            return o.name;
          }, set: function set(e) {
            o.name = e, titleRowName && (titleRowName.innerHTML = o.name);
          } }, closed: { get: function get() {
            return o.closed;
          }, set: function set(e) {
            o.closed = e, o.closed ? z["default"].addClass(n.__ul, ie.CLASS_CLOSED) : z["default"].removeClass(n.__ul, ie.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? ie.TEXT_OPEN : ie.TEXT_CLOSED);
          } }, load: { get: function get() {
            return o.load;
          } }, useLocalStorage: { get: function get() {
            return r;
          }, set: function set(e) {
            q && (r = e, e ? z["default"].bind(window, "unload", a) : z["default"].unbind(window, "unload", a), localStorage.setItem(u(n, "isLocal"), e));
          } } }), U["default"].isUndefined(o.parent)) {
        if (o.closed = !1, z["default"].addClass(this.domElement, ie.CLASS_MAIN), z["default"].makeSelectable(this.domElement, !1), q && r) {
          n.useLocalStorage = !0;var l = localStorage.getItem(u(this, "gui"));l && (o.load = JSON.parse(l));
        }this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = ie.TEXT_CLOSED, z["default"].addClass(this.__closeButton, ie.CLASS_CLOSE_BUTTON), this.domElement.appendChild(this.__closeButton), z["default"].bind(this.__closeButton, "click", function () {
          n.closed = !n.closed;
        });
      } else {
        void 0 === o.closed && (o.closed = !0);var s = document.createTextNode(o.name);z["default"].addClass(s, "controller-name");var d = i(n, s),
            c = function c(e) {
          return e.preventDefault(), n.closed = !n.closed, !1;
        };z["default"].addClass(this.__ul, ie.CLASS_CLOSED), z["default"].addClass(d, "title"), z["default"].bind(d, "click", c), o.closed || (this.closed = !1);
      }o.autoPlace && (U["default"].isUndefined(o.parent) && ($ && (ee = document.createElement("div"), z["default"].addClass(ee, Y), z["default"].addClass(ee, ie.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(ee), $ = !1), ee.appendChild(this.domElement), z["default"].addClass(this.domElement, ie.CLASS_AUTO_PLACE)), this.parent || p(n, o.width)), this.__resizeHandler = function () {
        n.onResizeDebounced();
      }, z["default"].bind(window, "resize", this.__resizeHandler), z["default"].bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), z["default"].bind(this.__ul, "transitionend", this.__resizeHandler), z["default"].bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), o.resizable && _(this), a = function a() {
        q && "true" === localStorage.getItem(u(n, "isLocal")) && localStorage.setItem(u(n, "gui"), __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default()(n.getSaveObject()));
      }, this.saveToLocalStorageIfPossible = a, o.parent || t();
    };oe.toggleHide = function () {
      te = !te, U["default"].each(ne, function (e) {
        e.domElement.style.display = te ? "none" : "";
      });
    }, oe.CLASS_AUTO_PLACE = "a", oe.CLASS_AUTO_PLACE_CONTAINER = "ac", oe.CLASS_MAIN = "main", oe.CLASS_CONTROLLER_ROW = "cr", oe.CLASS_TOO_TALL = "taller-than-window", oe.CLASS_CLOSED = "closed", oe.CLASS_CLOSE_BUTTON = "close-button", oe.CLASS_DRAG = "drag", oe.DEFAULT_WIDTH = 245, oe.TEXT_CLOSED = "Close Controls", oe.TEXT_OPEN = "Open Controls", oe._keydownHandler = function (e) {
      "text" === document.activeElement.type || e.which !== J && e.keyCode !== J || oe.toggleHide();
    }, z["default"].bind(window, "keydown", oe._keydownHandler, !1), U["default"].extend(oe.prototype, { add: function add(e, t) {
        return s(this, e, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
      }, addColor: function addColor(e, t) {
        return s(this, e, t, { color: !0 });
      }, remove: function remove(e) {
        this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1);var t = this;U["default"].defer(function () {
          t.onResize();
        });
      }, destroy: function destroy() {
        this.autoPlace && ee.removeChild(this.domElement), z["default"].unbind(window, "keydown", oe._keydownHandler, !1), z["default"].unbind(window, "resize", this.__resizeHandler), this.saveToLocalStorageIfPossible && z["default"].unbind(window, "unload", this.saveToLocalStorageIfPossible);
      }, addFolder: function addFolder(e) {
        if (void 0 !== this.__folders[e]) throw new Error('You already have a folder in this GUI by the name "' + e + '"');var t = { name: e, parent: this };t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]);var n = new oe(t);this.__folders[e] = n;var o = i(this, n.domElement);return z["default"].addClass(o, "folder"), n;
      }, open: function open() {
        this.closed = !1;
      }, close: function close() {
        this.closed = !0;
      }, onResize: function onResize() {
        var e = this.getRoot();if (e.scrollable) {
          var t = z["default"].getOffset(e.__ul).top,
              n = 0;U["default"].each(e.__ul.childNodes, function (t) {
            e.autoPlace && t === e.__save_row || (n += z["default"].getHeight(t));
          }), window.innerHeight - t - W < n ? (z["default"].addClass(e.domElement, oe.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - W + "px") : (z["default"].removeClass(e.domElement, oe.CLASS_TOO_TALL), e.__ul.style.height = "auto");
        }e.__resize_handle && U["default"].defer(function () {
          e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
        }), e.__closeButton && (e.__closeButton.style.width = e.width + "px");
      }, onResizeDebounced: U["default"].debounce(function () {
        this.onResize();
      }, 200), remember: function remember() {
        if (U["default"].isUndefined(Z) && (Z = new F["default"](), Z.domElement.innerHTML = x["default"]), this.parent) throw new Error("You can only call remember on a top level GUI.");var e = this;U["default"].each(Array.prototype.slice.call(arguments), function (t) {
          0 === e.__rememberedObjects.length && f(e), e.__rememberedObjects.indexOf(t) === -1 && e.__rememberedObjects.push(t);
        }), this.autoPlace && p(this, this.width);
      }, getRoot: function getRoot() {
        for (var e = this; e.parent;) {
          e = e.parent;
        }return e;
      }, getSaveObject: function getSaveObject() {
        var e = this.load;return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = h(this)), e.folders = {}, U["default"].each(this.__folders, function (t, n) {
          e.folders[n] = t.getSaveObject();
        }), e;
      }, save: function save() {
        this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = h(this), r(this, !1), this.saveToLocalStorageIfPossible();
      }, saveAs: function saveAs(e) {
        this.load.remembered || (this.load.remembered = {}, this.load.remembered[Q] = h(this, !0)), this.load.remembered[e] = h(this), this.preset = e, d(this, e, !0), this.saveToLocalStorageIfPossible();
      }, revert: function revert(e) {
        U["default"].each(this.__controllers, function (t) {
          this.getRoot().load.remembered ? l(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue());
        }, this), U["default"].each(this.__folders, function (e) {
          e.revert(e);
        }), e || r(this.getRoot(), !1);
      }, listen: function listen(e) {
        var t = 0 === this.__listening.length;this.__listening.push(e), t && b(this.__listening);
      }, updateDisplay: function updateDisplay() {
        U["default"].each(this.__controllers, function (e) {
          e.updateDisplay();
        }), U["default"].each(this.__folders, function (e) {
          e.updateDisplay();
        });
      } }), e.exports = oe;
  }, function (e, t) {
    "use strict";
    e.exports = { load: function load(e, t) {
        var n = t || document,
            o = n.createElement("link");o.type = "text/css", o.rel = "stylesheet", o.href = e, n.getElementsByTagName("head")[0].appendChild(o);
      }, inject: function inject(e, t) {
        var n = t || document,
            o = document.createElement("style");o.type = "text/css", o.innerHTML = e;var i = n.getElementsByTagName("head")[0];try {
          i.appendChild(o);
        } catch (r) {}
      } };
  }, function (e, t) {
    e.exports = "<div id=dg-save class=\"dg dialogue\"> Here's the new load parameter for your <code>GUI</code>'s constructor: <textarea id=dg-new-constructor></textarea> <div id=dg-save-locally> <input id=dg-local-storage type=checkbox /> Automatically save values to <code>localStorage</code> on exit. <div id=dg-local-explain>The values saved to <code>localStorage</code> will override those passed to <code>dat.GUI</code>'s constructor. This makes it easier to work incrementally, but <code>localStorage</code> is fragile, and your friends may not see the same values you do. </div> </div> </div>";
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }t.__esModule = !0;var i = n(10),
        r = o(i),
        a = n(13),
        l = o(a),
        s = n(14),
        u = o(s),
        d = n(11),
        c = o(d),
        f = n(15),
        _ = o(f),
        p = n(8),
        h = o(p),
        m = n(5),
        b = o(m),
        g = function g(e, t) {
      var n = e[t];return b["default"].isArray(arguments[2]) || b["default"].isObject(arguments[2]) ? new r["default"](e, t, arguments[2]) : b["default"].isNumber(n) ? b["default"].isNumber(arguments[2]) && b["default"].isNumber(arguments[3]) ? b["default"].isNumber(arguments[4]) ? new u["default"](e, t, arguments[2], arguments[3], arguments[4]) : new u["default"](e, t, arguments[2], arguments[3]) : b["default"].isNumber(arguments[4]) ? new l["default"](e, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new l["default"](e, t, { min: arguments[2], max: arguments[3] }) : b["default"].isString(n) ? new c["default"](e, t) : b["default"].isFunction(n) ? new _["default"](e, t, "") : b["default"].isBoolean(n) ? new h["default"](e, t) : null;
    };t["default"] = g;
  }, function (e, t) {
    "use strict";
    function n(e) {
      setTimeout(e, 1e3 / 60);
    }t.__esModule = !0, t["default"] = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || n;
  }, function (e, t, n) {
    "use strict";
    function o(e) {
      return e && e.__esModule ? e : { "default": e };
    }function i(e, t) {
      if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }t.__esModule = !0;var r = n(9),
        a = o(r),
        l = n(5),
        s = o(l),
        u = function () {
      function e() {
        i(this, e), this.backgroundElement = document.createElement("div"), s["default"].extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), a["default"].makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), s["default"].extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);var t = this;a["default"].bind(this.backgroundElement, "click", function () {
          t.hide();
        });
      }return e.prototype.show = function () {
        var e = this;this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), s["default"].defer(function () {
          e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)";
        });
      }, e.prototype.hide = function t() {
        var e = this,
            t = function n() {
          e.domElement.style.display = "none", e.backgroundElement.style.display = "none", a["default"].unbind(e.domElement, "webkitTransitionEnd", n), a["default"].unbind(e.domElement, "transitionend", n), a["default"].unbind(e.domElement, "oTransitionEnd", n);
        };a["default"].bind(this.domElement, "webkitTransitionEnd", t), a["default"].bind(this.domElement, "transitionend", t), a["default"].bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
      }, e.prototype.layout = function () {
        this.domElement.style.left = window.innerWidth / 2 - a["default"].getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - a["default"].getHeight(this.domElement) / 2 + "px";
      }, e;
    }();t["default"] = u;
  }, function (e, t, n) {
    t = e.exports = n(24)(), t.push([e.id, ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1!important}.dg.main .close-button.drag,.dg.main:hover .close-button{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;transition:opacity .1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save>ul{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height .1s ease-out;transition:height .1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid transparent}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.boolean,.dg .cr.boolean *,.dg .cr.function,.dg .cr.function *,.dg .cr.function .property-name{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco,monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px Lucida Grande,sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid hsla(0,0%,100%,.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.boolean:hover,.dg .cr.function:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}", ""]);
  }, function (e, t) {
    e.exports = function () {
      var e = [];return e.toString = function () {
        for (var e = [], t = 0; t < this.length; t++) {
          var n = this[t];n[2] ? e.push("@media " + n[2] + "{" + n[1] + "}") : e.push(n[1]);
        }return e.join("");
      }, e.i = function (t, n) {
        "string" == typeof t && (t = [[null, t, ""]]);for (var o = {}, i = 0; i < this.length; i++) {
          var r = this[i][0];"number" == typeof r && (o[r] = !0);
        }for (i = 0; i < t.length; i++) {
          var a = t[i];"number" == typeof a[0] && o[a[0]] || (n && !a[2] ? a[2] = n : n && (a[2] = "(" + a[2] + ") and (" + n + ")"), e.push(a));
        }
      }, e;
    };
  }]);
});
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(652)(module)))

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var Stats = function Stats() {
  function h(a) {
    c.appendChild(a.dom);return a;
  }function k(a) {
    for (var d = 0; d < c.children.length; d++) {
      c.children[d].style.display = d === a ? "block" : "none";
    }l = a;
  }var l = 0,
      c = document.createElement("div");c.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click", function (a) {
    a.preventDefault();k(++l % c.children.length);
  }, !1);var g = (performance || Date).now(),
      e = g,
      a = 0,
      r = h(new Stats.Panel("FPS", "#0ff", "#002")),
      f = h(new Stats.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) var t = h(new Stats.Panel("MB", "#f08", "#201"));k(0);return { REVISION: 16, dom: c, addPanel: h, showPanel: k, begin: function begin() {
      g = (performance || Date).now();
    }, end: function end() {
      a++;var c = (performance || Date).now();f.update(c - g, 200);if (c > e + 1E3 && (r.update(1E3 * a / (c - e), 100), e = c, a = 0, t)) {
        var d = performance.memory;t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);
      }return c;
    }, update: function update() {
      g = this.end();
    }, domElement: c, setMode: k };
};
Stats.Panel = function (h, k, l) {
  var c = Infinity,
      g = 0,
      e = Math.round,
      a = e(window.devicePixelRatio || 1),
      r = 80 * a,
      f = 48 * a,
      t = 3 * a,
      u = 2 * a,
      d = 3 * a,
      m = 15 * a,
      n = 74 * a,
      p = 30 * a,
      q = document.createElement("canvas");q.width = r;q.height = f;q.style.cssText = "width:80px;height:48px";var b = q.getContext("2d");b.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif";b.textBaseline = "top";b.fillStyle = l;b.fillRect(0, 0, r, f);b.fillStyle = k;b.fillText(h, t, u);b.fillRect(d, m, n, p);b.fillStyle = l;b.globalAlpha = .9;b.fillRect(d, m, n, p);return { dom: q, update: function update(f, v) {
      c = Math.min(c, f);g = Math.max(g, f);b.fillStyle = l;b.globalAlpha = 1;b.fillRect(0, 0, r, m);b.fillStyle = k;b.fillText(e(f) + " " + h + " (" + e(c) + "-" + e(g) + ")", t, u);b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);b.fillRect(d + n - a, m, a, p);b.fillStyle = l;b.globalAlpha = .9;b.fillRect(d + n - a, m, a, e((1 - f / v) * p));
    } };
};
/* harmony default export */ __webpack_exports__["a"] = (Stats);

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(529), __esModule: true };

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(536), __esModule: true };

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(545), __esModule: true };

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(546), __esModule: true };

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(547), __esModule: true };

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(106);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(193);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(192);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(24).f;
var create = __webpack_require__(81);
var redefineAll = __webpack_require__(83);
var ctx = __webpack_require__(31);
var anInstance = __webpack_require__(78);
var forOf = __webpack_require__(56);
var $iterDefine = __webpack_require__(116);
var step = __webpack_require__(205);
var setSpecies = __webpack_require__(213);
var DESCRIPTORS = __webpack_require__(20);
var fastKey = __webpack_require__(70).fastKey;
var validate = __webpack_require__(60);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(79);
var from = __webpack_require__(549);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(10).document;
module.exports = document && document.documentElement;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(20) && !__webpack_require__(40)(function () {
  return Object.defineProperty(__webpack_require__(113)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(57);
var ITERATOR = __webpack_require__(13)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(68);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(23);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(13)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(20);
var getKeys = __webpack_require__(71);
var gOPS = __webpack_require__(118);
var pIE = __webpack_require__(82);
var toObject = __webpack_require__(59);
var IObject = __webpack_require__(115);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(40)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(24);
var anObject = __webpack_require__(23);
var getKeys = __webpack_require__(71);

module.exports = __webpack_require__(20) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(82);
var createDesc = __webpack_require__(72);
var toIObject = __webpack_require__(58);
var toPrimitive = __webpack_require__(125);
var has = __webpack_require__(41);
var IE8_DOM_DEFINE = __webpack_require__(200);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(20) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(210);
var hiddenKeys = __webpack_require__(114).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(41);
var toIObject = __webpack_require__(58);
var arrayIndexOf = __webpack_require__(550)(false);
var IE_PROTO = __webpack_require__(122)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 211 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(23);
var isObject = __webpack_require__(16);
var newPromiseCapability = __webpack_require__(117);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(10);
var core = __webpack_require__(5);
var dP = __webpack_require__(24);
var DESCRIPTORS = __webpack_require__(20);
var SPECIES = __webpack_require__(13)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(23);
var aFunction = __webpack_require__(67);
var SPECIES = __webpack_require__(13)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(31);
var invoke = __webpack_require__(556);
var html = __webpack_require__(199);
var cel = __webpack_require__(113);
var global = __webpack_require__(10);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(68)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 217 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = __webpack_require__(27),
    util = __webpack_require__(11);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = decoder;

var Enum    = __webpack_require__(27),
    types   = __webpack_require__(62),
    util    = __webpack_require__(11);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("r.skip().pos++") // assumes id 1 + key wireType
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("k=r.%s()", field.keyType)
                ("r.pos++"); // assumes id 2 + value wireType
            if (types.long[field.keyType] !== undefined) {
                if (types.basic[type] === undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
            } else {
                if (types.basic[type] === undefined) gen
                ("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[k]=r.%s()", ref, type);
            }

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = encoder;

var Enum     = __webpack_require__(27),
    types    = __webpack_require__(62),
    util     = __webpack_require__(11);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(617);


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentText;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = verifier;

var Enum      = __webpack_require__(27),
    util      = __webpack_require__(11);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = __webpack_require__(130);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
            var type = this.lookup(object["@type"]);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                return this.create({
                    type_url: "/" + type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            object["@type"] = message.$type.fullName;
            return object;
        }

        return this.toObject(message, options);
    }
};


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),
/* 228 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* SockJS client, version 0.3.4, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// JSON2 by Douglas Crockford (minified).
var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()

SockJS=function(){var a=document,b=window,c={},d=function(){};d.prototype.addEventListener=function(a,b){this._listeners||(this._listeners={}),a in this._listeners||(this._listeners[a]=[]);var d=this._listeners[a];c.arrIndexOf(d,b)===-1&&d.push(b);return},d.prototype.removeEventListener=function(a,b){if(!(this._listeners&&a in this._listeners))return;var d=this._listeners[a],e=c.arrIndexOf(d,b);if(e!==-1){d.length>1?this._listeners[a]=d.slice(0,e).concat(d.slice(e+1)):delete this._listeners[a];return}return},d.prototype.dispatchEvent=function(a){var b=a.type,c=Array.prototype.slice.call(arguments,0);this["on"+b]&&this["on"+b].apply(this,c);if(this._listeners&&b in this._listeners)for(var d=0;d<this._listeners[b].length;d++)this._listeners[b][d].apply(this,c)};var e=function(a,b){this.type=a;if(typeof b!="undefined")for(var c in b){if(!b.hasOwnProperty(c))continue;this[c]=b[c]}};e.prototype.toString=function(){var a=[];for(var b in this){if(!this.hasOwnProperty(b))continue;var c=this[b];typeof c=="function"&&(c="[function]"),a.push(b+"="+c)}return"SimpleEvent("+a.join(", ")+")"};var f=function(a){var b=this;b._events=a||[],b._listeners={}};f.prototype.emit=function(a){var b=this;b._verifyType(a);if(b._nuked)return;var c=Array.prototype.slice.call(arguments,1);b["on"+a]&&b["on"+a].apply(b,c);if(a in b._listeners)for(var d=0;d<b._listeners[a].length;d++)b._listeners[a][d].apply(b,c)},f.prototype.on=function(a,b){var c=this;c._verifyType(a);if(c._nuked)return;a in c._listeners||(c._listeners[a]=[]),c._listeners[a].push(b)},f.prototype._verifyType=function(a){var b=this;c.arrIndexOf(b._events,a)===-1&&c.log("Event "+JSON.stringify(a)+" not listed "+JSON.stringify(b._events)+" in "+b)},f.prototype.nuke=function(){var a=this;a._nuked=!0;for(var b=0;b<a._events.length;b++)delete a[a._events[b]];a._listeners={}};var g="abcdefghijklmnopqrstuvwxyz0123456789_";c.random_string=function(a,b){b=b||g.length;var c,d=[];for(c=0;c<a;c++)d.push(g.substr(Math.floor(Math.random()*b),1));return d.join("")},c.random_number=function(a){return Math.floor(Math.random()*a)},c.random_number_string=function(a){var b=(""+(a-1)).length,d=Array(b+1).join("0");return(d+c.random_number(a)).slice(-b)},c.getOrigin=function(a){a+="/";var b=a.split("/").slice(0,3);return b.join("/")},c.isSameOriginUrl=function(a,c){return c||(c=b.location.href),a.split("/").slice(0,3).join("/")===c.split("/").slice(0,3).join("/")},c.getParentDomain=function(a){if(/^[0-9.]*$/.test(a))return a;if(/^\[/.test(a))return a;if(!/[.]/.test(a))return a;var b=a.split(".").slice(1);return b.join(".")},c.objectExtend=function(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a};var h="_jp";c.polluteGlobalNamespace=function(){h in b||(b[h]={})},c.closeFrame=function(a,b){return"c"+JSON.stringify([a,b])},c.userSetCode=function(a){return a===1e3||a>=3e3&&a<=4999},c.countRTO=function(a){var b;return a>100?b=3*a:b=a+200,b},c.log=function(){b.console&&console.log&&console.log.apply&&console.log.apply(console,arguments)},c.bind=function(a,b){return a.bind?a.bind(b):function(){return a.apply(b,arguments)}},c.flatUrl=function(a){return a.indexOf("?")===-1&&a.indexOf("#")===-1},c.amendUrl=function(b){var d=a.location;if(!b)throw new Error("Wrong url for SockJS");if(!c.flatUrl(b))throw new Error("Only basic urls are supported in SockJS");return b.indexOf("//")===0&&(b=d.protocol+b),b.indexOf("/")===0&&(b=d.protocol+"//"+d.host+b),b=b.replace(/[/]+$/,""),b},c.arrIndexOf=function(a,b){for(var c=0;c<a.length;c++)if(a[c]===b)return c;return-1},c.arrSkip=function(a,b){var d=c.arrIndexOf(a,b);if(d===-1)return a.slice();var e=a.slice(0,d);return e.concat(a.slice(d+1))},c.isArray=Array.isArray||function(a){return{}.toString.call(a).indexOf("Array")>=0},c.delay=function(a,b){return typeof a=="function"&&(b=a,a=0),setTimeout(b,a)};var i=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,j={"\0":"\\u0000","\x01":"\\u0001","\x02":"\\u0002","\x03":"\\u0003","\x04":"\\u0004","\x05":"\\u0005","\x06":"\\u0006","\x07":"\\u0007","\b":"\\b","\t":"\\t","\n":"\\n","\x0b":"\\u000b","\f":"\\f","\r":"\\r","\x0e":"\\u000e","\x0f":"\\u000f","\x10":"\\u0010","\x11":"\\u0011","\x12":"\\u0012","\x13":"\\u0013","\x14":"\\u0014","\x15":"\\u0015","\x16":"\\u0016","\x17":"\\u0017","\x18":"\\u0018","\x19":"\\u0019","\x1a":"\\u001a","\x1b":"\\u001b","\x1c":"\\u001c","\x1d":"\\u001d","\x1e":"\\u001e","\x1f":"\\u001f",'"':'\\"',"\\":"\\\\","\x7f":"\\u007f","\x80":"\\u0080","\x81":"\\u0081","\x82":"\\u0082","\x83":"\\u0083","\x84":"\\u0084","\x85":"\\u0085","\x86":"\\u0086","\x87":"\\u0087","\x88":"\\u0088","\x89":"\\u0089","\x8a":"\\u008a","\x8b":"\\u008b","\x8c":"\\u008c","\x8d":"\\u008d","\x8e":"\\u008e","\x8f":"\\u008f","\x90":"\\u0090","\x91":"\\u0091","\x92":"\\u0092","\x93":"\\u0093","\x94":"\\u0094","\x95":"\\u0095","\x96":"\\u0096","\x97":"\\u0097","\x98":"\\u0098","\x99":"\\u0099","\x9a":"\\u009a","\x9b":"\\u009b","\x9c":"\\u009c","\x9d":"\\u009d","\x9e":"\\u009e","\x9f":"\\u009f","\xad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601","\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f","\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d","\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029","\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d","\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061","\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065","\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069","\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d","\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0","\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4","\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8","\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc","\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"},k=/[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,l,m=JSON&&JSON.stringify||function(a){return i.lastIndex=0,i.test(a)&&(a=a.replace(i,function(a){return j[a]})),'"'+a+'"'},n=function(a){var b,c={},d=[];for(b=0;b<65536;b++)d.push(String.fromCharCode(b));return a.lastIndex=0,d.join("").replace(a,function(a){return c[a]="\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4),""}),a.lastIndex=0,c};c.quote=function(a){var b=m(a);return k.lastIndex=0,k.test(b)?(l||(l=n(k)),b.replace(k,function(a){return l[a]})):b};var o=["websocket","xdr-streaming","xhr-streaming","iframe-eventsource","iframe-htmlfile","xdr-polling","xhr-polling","iframe-xhr-polling","jsonp-polling"];c.probeProtocols=function(){var a={};for(var b=0;b<o.length;b++){var c=o[b];a[c]=y[c]&&y[c].enabled()}return a},c.detectProtocols=function(a,b,c){var d={},e=[];b||(b=o);for(var f=0;f<b.length;f++){var g=b[f];d[g]=a[g]}var h=function(a){var b=a.shift();d[b]?e.push(b):a.length>0&&h(a)};return c.websocket!==!1&&h(["websocket"]),d["xhr-streaming"]&&!c.null_origin?e.push("xhr-streaming"):d["xdr-streaming"]&&!c.cookie_needed&&!c.null_origin?e.push("xdr-streaming"):h(["iframe-eventsource","iframe-htmlfile"]),d["xhr-polling"]&&!c.null_origin?e.push("xhr-polling"):d["xdr-polling"]&&!c.cookie_needed&&!c.null_origin?e.push("xdr-polling"):h(["iframe-xhr-polling","jsonp-polling"]),e};var p="_sockjs_global";c.createHook=function(){var a="a"+c.random_string(8);if(!(p in b)){var d={};b[p]=function(a){return a in d||(d[a]={id:a,del:function(){delete d[a]}}),d[a]}}return b[p](a)},c.attachMessage=function(a){c.attachEvent("message",a)},c.attachEvent=function(c,d){typeof b.addEventListener!="undefined"?b.addEventListener(c,d,!1):(a.attachEvent("on"+c,d),b.attachEvent("on"+c,d))},c.detachMessage=function(a){c.detachEvent("message",a)},c.detachEvent=function(c,d){typeof b.addEventListener!="undefined"?b.removeEventListener(c,d,!1):(a.detachEvent("on"+c,d),b.detachEvent("on"+c,d))};var q={},r=!1,s=function(){for(var a in q)q[a](),delete q[a]},t=function(){if(r)return;r=!0,s()};c.attachEvent("unload",t),c.unload_add=function(a){var b=c.random_string(8);return q[b]=a,r&&c.delay(s),b},c.unload_del=function(a){a in q&&delete q[a]},c.createIframe=function(b,d){var e=a.createElement("iframe"),f,g,h=function(){clearTimeout(f);try{e.onload=null}catch(a){}e.onerror=null},i=function(){e&&(h(),setTimeout(function(){e&&e.parentNode.removeChild(e),e=null},0),c.unload_del(g))},j=function(a){e&&(i(),d(a))},k=function(a,b){try{e&&e.contentWindow&&e.contentWindow.postMessage(a,b)}catch(c){}};return e.src=b,e.style.display="none",e.style.position="absolute",e.onerror=function(){j("onerror")},e.onload=function(){clearTimeout(f),f=setTimeout(function(){j("onload timeout")},2e3)},a.body.appendChild(e),f=setTimeout(function(){j("timeout")},15e3),g=c.unload_add(i),{post:k,cleanup:i,loaded:h}},c.createHtmlfile=function(a,d){var e=new ActiveXObject("htmlfile"),f,g,i,j=function(){clearTimeout(f)},k=function(){e&&(j(),c.unload_del(g),i.parentNode.removeChild(i),i=e=null,CollectGarbage())},l=function(a){e&&(k(),d(a))},m=function(a,b){try{i&&i.contentWindow&&i.contentWindow.postMessage(a,b)}catch(c){}};e.open(),e.write('<html><script>document.domain="'+document.domain+'";'+"</s"+"cript></html>"),e.close(),e.parentWindow[h]=b[h];var n=e.createElement("div");return e.body.appendChild(n),i=e.createElement("iframe"),n.appendChild(i),i.src=a,f=setTimeout(function(){l("timeout")},15e3),g=c.unload_add(k),{post:m,cleanup:k,loaded:j}};var u=function(){};u.prototype=new f(["chunk","finish"]),u.prototype._start=function(a,d,e,f){var g=this;try{g.xhr=new XMLHttpRequest}catch(h){}if(!g.xhr)try{g.xhr=new b.ActiveXObject("Microsoft.XMLHTTP")}catch(h){}if(b.ActiveXObject||b.XDomainRequest)d+=(d.indexOf("?")===-1?"?":"&")+"t="+ +(new Date);g.unload_ref=c.unload_add(function(){g._cleanup(!0)});try{g.xhr.open(a,d,!0)}catch(i){g.emit("finish",0,""),g._cleanup();return}if(!f||!f.no_credentials)g.xhr.withCredentials="true";if(f&&f.headers)for(var j in f.headers)g.xhr.setRequestHeader(j,f.headers[j]);g.xhr.onreadystatechange=function(){if(g.xhr){var a=g.xhr;switch(a.readyState){case 3:try{var b=a.status,c=a.responseText}catch(a){}b===1223&&(b=204),c&&c.length>0&&g.emit("chunk",b,c);break;case 4:var b=a.status;b===1223&&(b=204),g.emit("finish",b,a.responseText),g._cleanup(!1)}}},g.xhr.send(e)},u.prototype._cleanup=function(a){var b=this;if(!b.xhr)return;c.unload_del(b.unload_ref),b.xhr.onreadystatechange=function(){};if(a)try{b.xhr.abort()}catch(d){}b.unload_ref=b.xhr=null},u.prototype.close=function(){var a=this;a.nuke(),a._cleanup(!0)};var v=c.XHRCorsObject=function(){var a=this,b=arguments;c.delay(function(){a._start.apply(a,b)})};v.prototype=new u;var w=c.XHRLocalObject=function(a,b,d){var e=this;c.delay(function(){e._start(a,b,d,{no_credentials:!0})})};w.prototype=new u;var x=c.XDRObject=function(a,b,d){var e=this;c.delay(function(){e._start(a,b,d)})};x.prototype=new f(["chunk","finish"]),x.prototype._start=function(a,b,d){var e=this,f=new XDomainRequest;b+=(b.indexOf("?")===-1?"?":"&")+"t="+ +(new Date);var g=f.ontimeout=f.onerror=function(){e.emit("finish",0,""),e._cleanup(!1)};f.onprogress=function(){e.emit("chunk",200,f.responseText)},f.onload=function(){e.emit("finish",200,f.responseText),e._cleanup(!1)},e.xdr=f,e.unload_ref=c.unload_add(function(){e._cleanup(!0)});try{e.xdr.open(a,b),e.xdr.send(d)}catch(h){g()}},x.prototype._cleanup=function(a){var b=this;if(!b.xdr)return;c.unload_del(b.unload_ref),b.xdr.ontimeout=b.xdr.onerror=b.xdr.onprogress=b.xdr.onload=null;if(a)try{b.xdr.abort()}catch(d){}b.unload_ref=b.xdr=null},x.prototype.close=function(){var a=this;a.nuke(),a._cleanup(!0)},c.isXHRCorsCapable=function(){return b.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest?1:b.XDomainRequest&&a.domain?2:L.enabled()?3:4};var y=function(a,d,e){if(this===b)return new y(a,d,e);var f=this,g;f._options={devel:!1,debug:!1,protocols_whitelist:[],info:undefined,rtt:undefined},e&&c.objectExtend(f._options,e),f._base_url=c.amendUrl(a),f._server=f._options.server||c.random_number_string(1e3),f._options.protocols_whitelist&&f._options.protocols_whitelist.length?g=f._options.protocols_whitelist:(typeof d=="string"&&d.length>0?g=[d]:c.isArray(d)?g=d:g=null,g&&f._debug('Deprecated API: Use "protocols_whitelist" option instead of supplying protocol list as a second parameter to SockJS constructor.')),f._protocols=[],f.protocol=null,f.readyState=y.CONNECTING,f._ir=S(f._base_url),f._ir.onfinish=function(a,b){f._ir=null,a?(f._options.info&&(a=c.objectExtend(a,f._options.info)),f._options.rtt&&(b=f._options.rtt),f._applyInfo(a,b,g),f._didClose()):f._didClose(1002,"Can't connect to server",!0)}};y.prototype=new d,y.version="0.3.4",y.CONNECTING=0,y.OPEN=1,y.CLOSING=2,y.CLOSED=3,y.prototype._debug=function(){this._options.debug&&c.log.apply(c,arguments)},y.prototype._dispatchOpen=function(){var a=this;a.readyState===y.CONNECTING?(a._transport_tref&&(clearTimeout(a._transport_tref),a._transport_tref=null),a.readyState=y.OPEN,a.dispatchEvent(new e("open"))):a._didClose(1006,"Server lost session")},y.prototype._dispatchMessage=function(a){var b=this;if(b.readyState!==y.OPEN)return;b.dispatchEvent(new e("message",{data:a}))},y.prototype._dispatchHeartbeat=function(a){var b=this;if(b.readyState!==y.OPEN)return;b.dispatchEvent(new e("heartbeat",{}))},y.prototype._didClose=function(a,b,d){var f=this;if(f.readyState!==y.CONNECTING&&f.readyState!==y.OPEN&&f.readyState!==y.CLOSING)throw new Error("INVALID_STATE_ERR");f._ir&&(f._ir.nuke(),f._ir=null),f._transport&&(f._transport.doCleanup(),f._transport=null);var g=new e("close",{code:a,reason:b,wasClean:c.userSetCode(a)});if(!c.userSetCode(a)&&f.readyState===y.CONNECTING&&!d){if(f._try_next_protocol(g))return;g=new e("close",{code:2e3,reason:"All transports failed",wasClean:!1,last_event:g})}f.readyState=y.CLOSED,c.delay(function(){f.dispatchEvent(g)})},y.prototype._didMessage=function(a){var b=this,c=a.slice(0,1);switch(c){case"o":b._dispatchOpen();break;case"a":var d=JSON.parse(a.slice(1)||"[]");for(var e=0;e<d.length;e++)b._dispatchMessage(d[e]);break;case"m":var d=JSON.parse(a.slice(1)||"null");b._dispatchMessage(d);break;case"c":var d=JSON.parse(a.slice(1)||"[]");b._didClose(d[0],d[1]);break;case"h":b._dispatchHeartbeat()}},y.prototype._try_next_protocol=function(b){var d=this;d.protocol&&(d._debug("Closed transport:",d.protocol,""+b),d.protocol=null),d._transport_tref&&(clearTimeout(d._transport_tref),d._transport_tref=null);for(;;){var e=d.protocol=d._protocols.shift();if(!e)return!1;if(y[e]&&y[e].need_body===!0&&(!a.body||typeof a.readyState!="undefined"&&a.readyState!=="complete"))return d._protocols.unshift(e),d.protocol="waiting-for-load",c.attachEvent("load",function(){d._try_next_protocol()}),!0;if(!!y[e]&&!!y[e].enabled(d._options)){var f=y[e].roundTrips||1,g=(d._options.rto||0)*f||5e3;d._transport_tref=c.delay(g,function(){d.readyState===y.CONNECTING&&d._didClose(2007,"Transport timeouted")});var h=c.random_string(8),i=d._base_url+"/"+d._server+"/"+h;return d._debug("Opening transport:",e," url:"+i," RTO:"+d._options.rto),d._transport=new y[e](d,i,d._base_url),!0}d._debug("Skipping transport:",e)}},y.prototype.close=function(a,b){var d=this;if(a&&!c.userSetCode(a))throw new Error("INVALID_ACCESS_ERR");return d.readyState!==y.CONNECTING&&d.readyState!==y.OPEN?!1:(d.readyState=y.CLOSING,d._didClose(a||1e3,b||"Normal closure"),!0)},y.prototype.send=function(a){var b=this;if(b.readyState===y.CONNECTING)throw new Error("INVALID_STATE_ERR");return b.readyState===y.OPEN&&b._transport.doSend(c.quote(""+a)),!0},y.prototype._applyInfo=function(b,d,e){var f=this;f._options.info=b,f._options.rtt=d,f._options.rto=c.countRTO(d),f._options.info.null_origin=!a.domain;var g=c.probeProtocols();f._protocols=c.detectProtocols(g,e,b)};var z=y.websocket=function(a,d){var e=this,f=d+"/websocket";f.slice(0,5)==="https"?f="wss"+f.slice(5):f="ws"+f.slice(4),e.ri=a,e.url=f;var g=b.WebSocket||b.MozWebSocket;e.ws=new g(e.url),e.ws.onmessage=function(a){e.ri._didMessage(a.data)},e.unload_ref=c.unload_add(function(){e.ws.close()}),e.ws.onclose=function(){e.ri._didMessage(c.closeFrame(1006,"WebSocket connection broken"))}};z.prototype.doSend=function(a){this.ws.send("["+a+"]")},z.prototype.doCleanup=function(){var a=this,b=a.ws;b&&(b.onmessage=b.onclose=null,b.close(),c.unload_del(a.unload_ref),a.unload_ref=a.ri=a.ws=null)},z.enabled=function(){return!!b.WebSocket||!!b.MozWebSocket},z.roundTrips=2;var A=function(){};A.prototype.send_constructor=function(a){var b=this;b.send_buffer=[],b.sender=a},A.prototype.doSend=function(a){var b=this;b.send_buffer.push(a),b.send_stop||b.send_schedule()},A.prototype.send_schedule_wait=function(){var a=this,b;a.send_stop=function(){a.send_stop=null,clearTimeout(b)},b=c.delay(25,function(){a.send_stop=null,a.send_schedule()})},A.prototype.send_schedule=function(){var a=this;if(a.send_buffer.length>0){var b="["+a.send_buffer.join(",")+"]";a.send_stop=a.sender(a.trans_url,b,function(b,c){a.send_stop=null,b===!1?a.ri._didClose(1006,"Sending error "+c):a.send_schedule_wait()}),a.send_buffer=[]}},A.prototype.send_destructor=function(){var a=this;a._send_stop&&a._send_stop(),a._send_stop=null};var B=function(b,d,e){var f=this;if(!("_send_form"in f)){var g=f._send_form=a.createElement("form"),h=f._send_area=a.createElement("textarea");h.name="d",g.style.display="none",g.style.position="absolute",g.method="POST",g.enctype="application/x-www-form-urlencoded",g.acceptCharset="UTF-8",g.appendChild(h),a.body.appendChild(g)}var g=f._send_form,h=f._send_area,i="a"+c.random_string(8);g.target=i,g.action=b+"/jsonp_send?i="+i;var j;try{j=a.createElement('<iframe name="'+i+'">')}catch(k){j=a.createElement("iframe"),j.name=i}j.id=i,g.appendChild(j),j.style.display="none";try{h.value=d}catch(l){c.log("Your browser is seriously broken. Go home! "+l.message)}g.submit();var m=function(a){if(!j.onerror)return;j.onreadystatechange=j.onerror=j.onload=null,c.delay(500,function(){j.parentNode.removeChild(j),j=null}),h.value="",e(!0)};return j.onerror=j.onload=m,j.onreadystatechange=function(a){j.readyState=="complete"&&m()},m},C=function(a){return function(b,c,d){var e=new a("POST",b+"/xhr_send",c);return e.onfinish=function(a,b){d(a===200||a===204,"http status "+a)},function(a){d(!1,a)}}},D=function(b,d){var e,f=a.createElement("script"),g,h=function(a){g&&(g.parentNode.removeChild(g),g=null),f&&(clearTimeout(e),f.parentNode.removeChild(f),f.onreadystatechange=f.onerror=f.onload=f.onclick=null,f=null,d(a),d=null)},i=!1,j=null;f.id="a"+c.random_string(8),f.src=b,f.type="text/javascript",f.charset="UTF-8",f.onerror=function(a){j||(j=setTimeout(function(){i||h(c.closeFrame(1006,"JSONP script loaded abnormally (onerror)"))},1e3))},f.onload=function(a){h(c.closeFrame(1006,"JSONP script loaded abnormally (onload)"))},f.onreadystatechange=function(a){if(/loaded|closed/.test(f.readyState)){if(f&&f.htmlFor&&f.onclick){i=!0;try{f.onclick()}catch(b){}}f&&h(c.closeFrame(1006,"JSONP script loaded abnormally (onreadystatechange)"))}};if(typeof f.async=="undefined"&&a.attachEvent)if(!/opera/i.test(navigator.userAgent)){try{f.htmlFor=f.id,f.event="onclick"}catch(k){}f.async=!0}else g=a.createElement("script"),g.text="try{var a = document.getElementById('"+f.id+"'); if(a)a.onerror();}catch(x){};",f.async=g.async=!1;typeof f.async!="undefined"&&(f.async=!0),e=setTimeout(function(){h(c.closeFrame(1006,"JSONP script loaded abnormally (timeout)"))},35e3);var l=a.getElementsByTagName("head")[0];return l.insertBefore(f,l.firstChild),g&&l.insertBefore(g,l.firstChild),h},E=y["jsonp-polling"]=function(a,b){c.polluteGlobalNamespace();var d=this;d.ri=a,d.trans_url=b,d.send_constructor(B),d._schedule_recv()};E.prototype=new A,E.prototype._schedule_recv=function(){var a=this,b=function(b){a._recv_stop=null,b&&(a._is_closing||a.ri._didMessage(b)),a._is_closing||a._schedule_recv()};a._recv_stop=F(a.trans_url+"/jsonp",D,b)},E.enabled=function(){return!0},E.need_body=!0,E.prototype.doCleanup=function(){var a=this;a._is_closing=!0,a._recv_stop&&a._recv_stop(),a.ri=a._recv_stop=null,a.send_destructor()};var F=function(a,d,e){var f="a"+c.random_string(6),g=a+"?c="+escape(h+"."+f),i=0,j=function(a){switch(i){case 0:delete b[h][f],e(a);break;case 1:e(a),i=2;break;case 2:delete b[h][f]}},k=d(g,j);b[h][f]=k;var l=function(){b[h][f]&&(i=1,b[h][f](c.closeFrame(1e3,"JSONP user aborted read")))};return l},G=function(){};G.prototype=new A,G.prototype.run=function(a,b,c,d,e){var f=this;f.ri=a,f.trans_url=b,f.send_constructor(C(e)),f.poll=new $(a,d,b+c,e)},G.prototype.doCleanup=function(){var a=this;a.poll&&(a.poll.abort(),a.poll=null)};var H=y["xhr-streaming"]=function(a,b){this.run(a,b,"/xhr_streaming",bd,c.XHRCorsObject)};H.prototype=new G,H.enabled=function(){return b.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest&&!/opera/i.test(navigator.userAgent)},H.roundTrips=2,H.need_body=!0;var I=y["xdr-streaming"]=function(a,b){this.run(a,b,"/xhr_streaming",bd,c.XDRObject)};I.prototype=new G,I.enabled=function(){return!!b.XDomainRequest},I.roundTrips=2;var J=y["xhr-polling"]=function(a,b){this.run(a,b,"/xhr",bd,c.XHRCorsObject)};J.prototype=new G,J.enabled=H.enabled,J.roundTrips=2;var K=y["xdr-polling"]=function(a,b){this.run(a,b,"/xhr",bd,c.XDRObject)};K.prototype=new G,K.enabled=I.enabled,K.roundTrips=2;var L=function(){};L.prototype.i_constructor=function(a,b,d){var e=this;e.ri=a,e.origin=c.getOrigin(d),e.base_url=d,e.trans_url=b;var f=d+"/iframe.html";e.ri._options.devel&&(f+="?t="+ +(new Date)),e.window_id=c.random_string(8),f+="#"+e.window_id,e.iframeObj=c.createIframe(f,function(a){e.ri._didClose(1006,"Unable to load an iframe ("+a+")")}),e.onmessage_cb=c.bind(e.onmessage,e),c.attachMessage(e.onmessage_cb)},L.prototype.doCleanup=function(){var a=this;if(a.iframeObj){c.detachMessage(a.onmessage_cb);try{a.iframeObj.iframe.contentWindow&&a.postMessage("c")}catch(b){}a.iframeObj.cleanup(),a.iframeObj=null,a.onmessage_cb=a.iframeObj=null}},L.prototype.onmessage=function(a){var b=this;if(a.origin!==b.origin)return;var c=a.data.slice(0,8),d=a.data.slice(8,9),e=a.data.slice(9);if(c!==b.window_id)return;switch(d){case"s":b.iframeObj.loaded(),b.postMessage("s",JSON.stringify([y.version,b.protocol,b.trans_url,b.base_url]));break;case"t":b.ri._didMessage(e)}},L.prototype.postMessage=function(a,b){var c=this;c.iframeObj.post(c.window_id+a+(b||""),c.origin)},L.prototype.doSend=function(a){this.postMessage("m",a)},L.enabled=function(){var a=navigator&&navigator.userAgent&&navigator.userAgent.indexOf("Konqueror")!==-1;return(typeof b.postMessage=="function"||typeof b.postMessage=="object")&&!a};var M,N=function(a,d){parent!==b?parent.postMessage(M+a+(d||""),"*"):c.log("Can't postMessage, no parent window.",a,d)},O=function(){};O.prototype._didClose=function(a,b){N("t",c.closeFrame(a,b))},O.prototype._didMessage=function(a){N("t",a)},O.prototype._doSend=function(a){this._transport.doSend(a)},O.prototype._doCleanup=function(){this._transport.doCleanup()},c.parent_origin=undefined,y.bootstrap_iframe=function(){var d;M=a.location.hash.slice(1);var e=function(a){if(a.source!==parent)return;typeof c.parent_origin=="undefined"&&(c.parent_origin=a.origin);if(a.origin!==c.parent_origin)return;var e=a.data.slice(0,8),f=a.data.slice(8,9),g=a.data.slice(9);if(e!==M)return;switch(f){case"s":var h=JSON.parse(g),i=h[0],j=h[1],k=h[2],l=h[3];i!==y.version&&c.log('Incompatibile SockJS! Main site uses: "'+i+'", the iframe:'+' "'+y.version+'".');if(!c.flatUrl(k)||!c.flatUrl(l)){c.log("Only basic urls are supported in SockJS");return}if(!c.isSameOriginUrl(k)||!c.isSameOriginUrl(l)){c.log("Can't connect to different domain from within an iframe. ("+JSON.stringify([b.location.href,k,l])+")");return}d=new O,d._transport=new O[j](d,k,l);break;case"m":d._doSend(g);break;case"c":d&&d._doCleanup(),d=null}};c.attachMessage(e),N("s")};var P=function(a,b){var d=this;c.delay(function(){d.doXhr(a,b)})};P.prototype=new f(["finish"]),P.prototype.doXhr=function(a,b){var d=this,e=(new Date).getTime(),f=new b("GET",a+"/info"),g=c.delay(8e3,function(){f.ontimeout()});f.onfinish=function(a,b){clearTimeout(g),g=null;if(a===200){var c=(new Date).getTime()-e,f=JSON.parse(b);typeof f!="object"&&(f={}),d.emit("finish",f,c)}else d.emit("finish")},f.ontimeout=function(){f.close(),d.emit("finish")}};var Q=function(b){var d=this,e=function(){var a=new L;a.protocol="w-iframe-info-receiver";var c=function(b){if(typeof b=="string"&&b.substr(0,1)==="m"){var c=JSON.parse(b.substr(1)),e=c[0],f=c[1];d.emit("finish",e,f)}else d.emit("finish");a.doCleanup(),a=null},e={_options:{},_didClose:c,_didMessage:c};a.i_constructor(e,b,b)};a.body?e():c.attachEvent("load",e)};Q.prototype=new f(["finish"]);var R=function(){var a=this;c.delay(function(){a.emit("finish",{},2e3)})};R.prototype=new f(["finish"]);var S=function(a){if(c.isSameOriginUrl(a))return new P(a,c.XHRLocalObject);switch(c.isXHRCorsCapable()){case 1:return new P(a,c.XHRLocalObject);case 2:return new P(a,c.XDRObject);case 3:return new Q(a);default:return new R}},T=O["w-iframe-info-receiver"]=function(a,b,d){var e=new P(d,c.XHRLocalObject);e.onfinish=function(b,c){a._didMessage("m"+JSON.stringify([b,c])),a._didClose()}};T.prototype.doCleanup=function(){};var U=y["iframe-eventsource"]=function(){var a=this;a.protocol="w-iframe-eventsource",a.i_constructor.apply(a,arguments)};U.prototype=new L,U.enabled=function(){return"EventSource"in b&&L.enabled()},U.need_body=!0,U.roundTrips=3;var V=O["w-iframe-eventsource"]=function(a,b){this.run(a,b,"/eventsource",_,c.XHRLocalObject)};V.prototype=new G;var W=y["iframe-xhr-polling"]=function(){var a=this;a.protocol="w-iframe-xhr-polling",a.i_constructor.apply(a,arguments)};W.prototype=new L,W.enabled=function(){return b.XMLHttpRequest&&L.enabled()},W.need_body=!0,W.roundTrips=3;var X=O["w-iframe-xhr-polling"]=function(a,b){this.run(a,b,"/xhr",bd,c.XHRLocalObject)};X.prototype=new G;var Y=y["iframe-htmlfile"]=function(){var a=this;a.protocol="w-iframe-htmlfile",a.i_constructor.apply(a,arguments)};Y.prototype=new L,Y.enabled=function(){return L.enabled()},Y.need_body=!0,Y.roundTrips=3;var Z=O["w-iframe-htmlfile"]=function(a,b){this.run(a,b,"/htmlfile",bc,c.XHRLocalObject)};Z.prototype=new G;var $=function(a,b,c,d){var e=this;e.ri=a,e.Receiver=b,e.recv_url=c,e.AjaxObject=d,e._scheduleRecv()};$.prototype._scheduleRecv=function(){var a=this,b=a.poll=new a.Receiver(a.recv_url,a.AjaxObject),c=0;b.onmessage=function(b){c+=1,a.ri._didMessage(b.data)},b.onclose=function(c){a.poll=b=b.onmessage=b.onclose=null,a.poll_is_closing||(c.reason==="permanent"?a.ri._didClose(1006,"Polling error ("+c.reason+")"):a._scheduleRecv())}},$.prototype.abort=function(){var a=this;a.poll_is_closing=!0,a.poll&&a.poll.abort()};var _=function(a){var b=this,d=new EventSource(a);d.onmessage=function(a){b.dispatchEvent(new e("message",{data:unescape(a.data)}))},b.es_close=d.onerror=function(a,f){var g=f?"user":d.readyState!==2?"network":"permanent";b.es_close=d.onmessage=d.onerror=null,d.close(),d=null,c.delay(200,function(){b.dispatchEvent(new e("close",{reason:g}))})}};_.prototype=new d,_.prototype.abort=function(){var a=this;a.es_close&&a.es_close({},!0)};var ba,bb=function(){if(ba===undefined)if("ActiveXObject"in b)try{ba=!!(new ActiveXObject("htmlfile"))}catch(a){}else ba=!1;return ba},bc=function(a){var d=this;c.polluteGlobalNamespace(),d.id="a"+c.random_string(6,26),a+=(a.indexOf("?")===-1?"?":"&")+"c="+escape(h+"."+d.id);var f=bb()?c.createHtmlfile:c.createIframe,g;b[h][d.id]={start:function(){g.loaded()},message:function(a){d.dispatchEvent(new e("message",{data:a}))},stop:function(){d.iframe_close({},"network")}},d.iframe_close=function(a,c){g.cleanup(),d.iframe_close=g=null,delete b[h][d.id],d.dispatchEvent(new e("close",{reason:c}))},g=f(a,function(a){d.iframe_close({},"permanent")})};bc.prototype=new d,bc.prototype.abort=function(){var a=this;a.iframe_close&&a.iframe_close({},"user")};var bd=function(a,b){var c=this,d=0;c.xo=new b("POST",a,null),c.xo.onchunk=function(a,b){if(a!==200)return;for(;;){var f=b.slice(d),g=f.indexOf("\n");if(g===-1)break;d+=g+1;var h=f.slice(0,g);c.dispatchEvent(new e("message",{data:h}))}},c.xo.onfinish=function(a,b){c.xo.onchunk(a,b),c.xo=null;var d=a===200?"network":"permanent";c.dispatchEvent(new e("close",{reason:d}))}};return bd.prototype=new d,bd.prototype.abort=function(){var a=this;a.xo&&(a.xo.close(),a.dispatchEvent(new e("close",{reason:"user"})),a.xo=null)},y.getUtils=function(){return c},y.getIframeTransport=function(){return L},y}(),"_sockjs_onload"in window&&setTimeout(_sockjs_onload,1),"function"=="function"&&__webpack_require__(228)&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){return SockJS}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))


/***/ }),
/* 230 */
/***/ (function(module, exports) {

/* eslint-disable */
// Generated by CoffeeScript 1.7.1

/*
 Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

 Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
 Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */

(function() {
    var Byte, Client, Frame, Stomp,
        __hasProp = {}.hasOwnProperty,
        __slice = [].slice;

    Byte = {
        LF: '\x0A',
        NULL: '\x00'
    };

    Frame = (function() {
        var unmarshallSingle;

        function Frame(command, headers, body) {
            this.command = command;
            this.headers = headers != null ? headers : {};
            this.body = body != null ? body : '';
        }

        Frame.prototype.toString = function() {
            var lines, name, skipContentLength, value, _ref;
            lines = [this.command];
            skipContentLength = this.headers['content-length'] === false ? true : false;
            if (skipContentLength) {
                delete this.headers['content-length'];
            }
            _ref = this.headers;
            for (name in _ref) {
                if (!__hasProp.call(_ref, name)) continue;
                value = _ref[name];
                lines.push("" + name + ":" + value);
            }
            if (this.body && !skipContentLength) {
                lines.push("content-length:" + (Frame.sizeOfUTF8(this.body)));
            }
            lines.push(Byte.LF + this.body);
            return lines.join(Byte.LF);
        };

        Frame.sizeOfUTF8 = function(s) {
            if (s) {
                return encodeURI(s).match(/%..|./g).length;
            } else {
                return 0;
            }
        };

        unmarshallSingle = function(data) {
            var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
            divider = data.search(RegExp("" + Byte.LF + Byte.LF));
            headerLines = data.substring(0, divider).split(Byte.LF);
            command = headerLines.shift();
            headers = {};
            trim = function(str) {
                return str.replace(/^\s+|\s+$/g, '');
            };
            _ref = headerLines.reverse();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                line = _ref[_i];
                idx = line.indexOf(':');
                headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
            }
            body = '';
            start = divider + 2;
            if (headers['content-length']) {
                len = parseInt(headers['content-length']);
                body = ('' + data).substring(start, start + len);
            } else {
                chr = null;
                for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
                    chr = data.charAt(i);
                    if (chr === Byte.NULL) {
                        break;
                    }
                    body += chr;
                }
            }
            return new Frame(command, headers, body);
        };

        Frame.unmarshall = function(datas) {
            var frame, frames, last_frame, r;
            frames = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
            r = {
                frames: [],
                partial: ''
            };
            r.frames = (function() {
                var _i, _len, _ref, _results;
                _ref = frames.slice(0, -1);
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    frame = _ref[_i];
                    _results.push(unmarshallSingle(frame));
                }
                return _results;
            })();
            last_frame = frames.slice(-1)[0];
            if (last_frame === Byte.LF || (last_frame.search(RegExp("" + Byte.NULL + Byte.LF + "*$"))) !== -1) {
                r.frames.push(unmarshallSingle(last_frame));
            } else {
                r.partial = last_frame;
            }
            return r;
        };

        Frame.marshall = function(command, headers, body) {
            var frame;
            frame = new Frame(command, headers, body);
            return frame.toString() + Byte.NULL;
        };

        return Frame;

    })();

    Client = (function() {
        var now;

        function Client(ws) {
            this.ws = ws;
            this.ws.binaryType = "arraybuffer";
            this.counter = 0;
            this.connected = false;
            this.heartbeat = {
                outgoing: 10000,
                incoming: 10000
            };
            this.maxWebSocketFrameSize = 16 * 1024;
            this.subscriptions = {};
            this.partialData = '';
        }

        Client.prototype.debug = function(message) {
            var _ref;
            return typeof window !== "undefined" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
        };

        now = function() {
            if (Date.now) {
                return Date.now();
            } else {
                return new Date().valueOf;
            }
        };

        Client.prototype._transmit = function(command, headers, body) {
            var out;
            out = Frame.marshall(command, headers, body);
            if (typeof this.debug === "function") {
                this.debug(">>> " + out);
            }
            while (true) {
                if (out.length > this.maxWebSocketFrameSize) {
                    this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
                    out = out.substring(this.maxWebSocketFrameSize);
                    if (typeof this.debug === "function") {
                        this.debug("remaining = " + out.length);
                    }
                } else {
                    return this.ws.send(out);
                }
            }
        };

        Client.prototype._setupHeartbeat = function(headers) {
            var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
            if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
                return;
            }
            _ref1 = (function() {
                var _i, _len, _ref1, _results;
                _ref1 = headers['heart-beat'].split(",");
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    v = _ref1[_i];
                    _results.push(parseInt(v));
                }
                return _results;
            })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
            if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
                ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
                if (typeof this.debug === "function") {
                    this.debug("send PING every " + ttl + "ms");
                }
                this.pinger = Stomp.setInterval(ttl, (function(_this) {
                    return function() {
                        _this.ws.send(Byte.LF);
                        return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
                    };
                })(this));
            }
            if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
                ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
                if (typeof this.debug === "function") {
                    this.debug("check PONG every " + ttl + "ms");
                }
                return this.ponger = Stomp.setInterval(ttl, (function(_this) {
                    return function() {
                        var delta;
                        delta = now() - _this.serverActivity;
                        if (delta > ttl * 2) {
                            if (typeof _this.debug === "function") {
                                _this.debug("did not receive server activity for the last " + delta + "ms");
                            }
                            return _this.ws.close();
                        }
                    };
                })(this));
            }
        };

        Client.prototype._parseConnect = function() {
            var args, connectCallback, errorCallback, headers;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            headers = {};
            switch (args.length) {
                case 2:
                    headers = args[0], connectCallback = args[1];
                    break;
                case 3:
                    if (args[1] instanceof Function) {
                        headers = args[0], connectCallback = args[1], errorCallback = args[2];
                    } else {
                        headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
                    }
                    break;
                case 4:
                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
                    break;
                default:
                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
            }
            return [headers, connectCallback, errorCallback];
        };

        Client.prototype.connect = function() {
            var args, errorCallback, headers, out;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            out = this._parseConnect.apply(this, args);
            headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
            if (typeof this.debug === "function") {
                this.debug("Opening Web Socket...");
            }
            this.ws.onmessage = (function(_this) {
                return function(evt) {
                    var arr, c, client, data, frame, messageID, onreceive, subscription, unmarshalledData, _i, _len, _ref, _results;
                    data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, ((function() {
                        var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = arr.length; _i < _len; _i++) {
                            c = arr[_i];
                            _results.push(String.fromCharCode(c));
                        }
                        return _results;
                    })()).join('')) : evt.data;
                    _this.serverActivity = now();
                    if (data === Byte.LF) {
                        if (typeof _this.debug === "function") {
                            _this.debug("<<< PONG");
                        }
                        return;
                    }
                    if (typeof _this.debug === "function") {
                        _this.debug("<<< " + data);
                    }
                    unmarshalledData = Frame.unmarshall(_this.partialData + data);
                    _this.partialData = unmarshalledData.partial;
                    _ref = unmarshalledData.frames;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        frame = _ref[_i];
                        switch (frame.command) {
                            case "CONNECTED":
                                if (typeof _this.debug === "function") {
                                    _this.debug("connected to server " + frame.headers.server);
                                }
                                _this.connected = true;
                                _this._setupHeartbeat(frame.headers);
                                _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
                                break;
                            case "MESSAGE":
                                subscription = frame.headers.subscription;
                                onreceive = _this.subscriptions[subscription] || _this.onreceive;
                                if (onreceive) {
                                    client = _this;
                                    messageID = frame.headers["message-id"];
                                    frame.ack = function(headers) {
                                        if (headers == null) {
                                            headers = {};
                                        }
                                        return client.ack(messageID, subscription, headers);
                                    };
                                    frame.nack = function(headers) {
                                        if (headers == null) {
                                            headers = {};
                                        }
                                        return client.nack(messageID, subscription, headers);
                                    };
                                    _results.push(onreceive(frame));
                                } else {
                                    _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
                                }
                                break;
                            case "RECEIPT":
                                _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
                                break;
                            case "ERROR":
                                _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
                                break;
                            default:
                                _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
                        }
                    }
                    return _results;
                };
            })(this);
            this.ws.onclose = (function(_this) {
                return function() {
                    var msg;
                    msg = "Whoops! Lost connection to " + _this.ws.url;
                    if (typeof _this.debug === "function") {
                        _this.debug(msg);
                    }
                    _this._cleanUp();
                    return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
                };
            })(this);
            return this.ws.onopen = (function(_this) {
                return function() {
                    if (typeof _this.debug === "function") {
                        _this.debug('Web Socket Opened...');
                    }
                    headers["accept-version"] = Stomp.VERSIONS.supportedVersions();
                    headers["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
                    return _this._transmit("CONNECT", headers);
                };
            })(this);
        };

        Client.prototype.disconnect = function(disconnectCallback, headers) {
            if (headers == null) {
                headers = {};
            }
            this._transmit("DISCONNECT", headers);
            this.ws.onclose = null;
            this.ws.close();
            this._cleanUp();
            return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
        };

        Client.prototype._cleanUp = function() {
            this.connected = false;
            if (this.pinger) {
                Stomp.clearInterval(this.pinger);
            }
            if (this.ponger) {
                return Stomp.clearInterval(this.ponger);
            }
        };

        Client.prototype.send = function(destination, headers, body) {
            if (headers == null) {
                headers = {};
            }
            if (body == null) {
                body = '';
            }
            headers.destination = destination;
            return this._transmit("SEND", headers, body);
        };

        Client.prototype.subscribe = function(destination, callback, headers) {
            var client;
            if (headers == null) {
                headers = {};
            }
            if (!headers.id) {
                headers.id = "sub-" + this.counter++;
            }
            headers.destination = destination;
            this.subscriptions[headers.id] = callback;
            this._transmit("SUBSCRIBE", headers);
            client = this;
            return {
                id: headers.id,
                unsubscribe: function() {
                    return client.unsubscribe(headers.id);
                }
            };
        };

        Client.prototype.unsubscribe = function(id) {
            delete this.subscriptions[id];
            return this._transmit("UNSUBSCRIBE", {
                id: id
            });
        };

        Client.prototype.begin = function(transaction) {
            var client, txid;
            txid = transaction || "tx-" + this.counter++;
            this._transmit("BEGIN", {
                transaction: txid
            });
            client = this;
            return {
                id: txid,
                commit: function() {
                    return client.commit(txid);
                },
                abort: function() {
                    return client.abort(txid);
                }
            };
        };

        Client.prototype.commit = function(transaction) {
            return this._transmit("COMMIT", {
                transaction: transaction
            });
        };

        Client.prototype.abort = function(transaction) {
            return this._transmit("ABORT", {
                transaction: transaction
            });
        };

        Client.prototype.ack = function(messageID, subscription, headers) {
            if (headers == null) {
                headers = {};
            }
            headers["message-id"] = messageID;
            headers.subscription = subscription;
            return this._transmit("ACK", headers);
        };

        Client.prototype.nack = function(messageID, subscription, headers) {
            if (headers == null) {
                headers = {};
            }
            headers["message-id"] = messageID;
            headers.subscription = subscription;
            return this._transmit("NACK", headers);
        };

        return Client;

    })();

    Stomp = {
        VERSIONS: {
            V1_0: '1.0',
            V1_1: '1.1',
            V1_2: '1.2',
            supportedVersions: function() {
                return '1.1,1.0';
            }
        },
        client: function(url, protocols) {
            var klass, ws;
            if (protocols == null) {
                protocols = ['v10.stomp', 'v11.stomp'];
            }
            klass = Stomp.WebSocketClass || WebSocket;
            ws = new klass(url, protocols);
            return new Client(ws);
        },
        over: function(ws) {
            return new Client(ws);
        },
        Frame: Frame
    };

    if (typeof exports !== "undefined" && exports !== null) {
        exports.Stomp = Stomp;
    }

    if (typeof window !== "undefined" && window !== null) {
        Stomp.setInterval = function(interval, f) {
            return window.setInterval(f, interval);
        };
        Stomp.clearInterval = function(id) {
            return window.clearInterval(id);
        };
        window.Stomp = Stomp;
    } else if (!exports) {
        self.Stomp = Stomp;
    }

}).call(this);


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "install", function() { return install; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__THREE_renderers_WebGLRenderer_js__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__THREE_renderers_WebGLRenderTarget_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__THREE_core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__THREE_math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__THREE_core_Clock_js__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__THREE_scenes_Scene_js__ = __webpack_require__(450);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__THREE_objects_Group_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__THREE_lights_DirectionalLight_js__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__THREE_lights_AmbientLight_js__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__THREE_core_Raycaster_js__ = __webpack_require__(262);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__THREE_objects_Mesh_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__THREE_materials_MeshBasicMaterial_js__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__THREE_materials_MeshPhongMaterial_js__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__THREE_materials_LineBasicMaterial_js__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__THREE_materials_PointsMaterial_js__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__THREE_materials_MeshLambertMaterial_js__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__THREE_materials_RawShaderMaterial_js__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__THREE_geometries_TubeGeometry_js__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__THREE_extras_curves_CatmullRomCurve3_js__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__THREE_math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__THREE_math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__THREE_math_Vector4_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__THREE_math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__THREE_math_Quaternion_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__THREE_math_Box3_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__THREE_core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__THREE_math_Euler_js__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__THREE_cameras_PerspectiveCamera_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__THREE_cameras_OrthographicCamera_js__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__THREE_math_Plane_js__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__THREE_core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__THREE_core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__THREE_geometries_PlaneGeometry_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__THREE_core_InstancedBufferAttribute_js__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__THREE_geometries_EdgesGeometry_js__ = __webpack_require__(274);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__THREE_geometries_TextGeometry_js__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__THREE_core_InstancedBufferGeometry_js__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__THREE_objects_Points_js__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__THREE_math_Frustum_js__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__THREE_geometries_BoxGeometry_js__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__THREE_helpers_BoxHelper_js__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__THREE_objects_Line_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__THREE_objects_LineSegments_js__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__THREE_loaders_TextureLoader_js__ = __webpack_require__(285);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__THREE_loaders_FileLoader_js__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__THREE_loaders_LoadingManager_js__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__THREE_loaders_FontLoader_js__ = __webpack_require__(283);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__THREE_materials_ShaderMaterial_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__THREE_renderers_shaders_UniformsUtils_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__THREE_textures_Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__THREE_postprocessing_EffectComposer_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__THREE_postprocessing_SMAAPass_js__ = __webpack_require__(296);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__THREE_postprocessing_SSAARenderPass_js__ = __webpack_require__(297);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__THREE_postprocessing_RenderPass_js__ = __webpack_require__(295);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__THREE_postprocessing_MaskPass_js__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__THREE_postprocessing_ShaderPass_js__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__THREE_pms_VertexIndex_js__ = __webpack_require__(294);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__THREE_pms_VertexAttribute_js__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__THREE_pms_VertexAttributeArray_js__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__THREE_pms_VertexIndexRange_js__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__THREE_pms_PMBufferGeometry_js__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__THREE_pms_PMInstanceBufferGeometry_js__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__THREE_pms_InstancedMesh_js__ = __webpack_require__(292);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__THREE_pms_PmLineSegments_js__ = __webpack_require__(293);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__tool_base64__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__components_dwg_vue__ = __webpack_require__(635);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__components_dwg_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_68__components_dwg_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue__ = __webpack_require__(642);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__model_model_vue__ = __webpack_require__(641);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__model_model_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_70__model_model_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71_axios__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_71_axios__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72_qs__ = __webpack_require__(620);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72_qs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_72_qs__);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "dwg", function() { return __WEBPACK_IMPORTED_MODULE_68__components_dwg_vue___default.a; });
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "model", function() { return __WEBPACK_IMPORTED_MODULE_70__model_model_vue___default.a; });
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "panorama", function() { return __WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue___default.a; });

window.$CCBIM = {};
window.$CCBIM.render = {};
window.$CCBIM.handle = {};
window.$CCBIM.octreeInfo = [];
window.$CCBIM.mRefTriangleArr = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
window.$CCBIM.userModelGroupMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
window.$CCBIM.RefGeomeryMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
window.$CCBIM.floorPlanGraph = [];
window.$CCBIM.sortRef = [];
window.$CCBIM.render.$ccbimFloorDisplay = [];
window.$CCBIM.render.$ccbimFloorNameDisplay = [];
window.$CCBIM.render.$ccbimComTypeDisplay = [];
window.UUID_Index = 1;
window.echarts = window.echarts;

window.$CCBIM.render.scene = null;

window.$CCBIM.sceneManager = null;

window.$CCBIM.projectManager = null;







































































window.$CCBIM.WebGL = {
  DoubleSide: 2,
  NormalBlending: 1,
  NoBlending: 0,
  RepeatWrapping: 1000,
  AlphaFormat: 1021,
  WebGLRenderer: __WEBPACK_IMPORTED_MODULE_1__THREE_renderers_WebGLRenderer_js__["a" /* WebGLRenderer */],
  WebGLRenderTarget: __WEBPACK_IMPORTED_MODULE_2__THREE_renderers_WebGLRenderTarget_js__["a" /* WebGLRenderTarget */],
  EventDispatcher: __WEBPACK_IMPORTED_MODULE_3__THREE_core_EventDispatcher_js__["a" /* EventDispatcher */],
  Color: __WEBPACK_IMPORTED_MODULE_4__THREE_math_Color_js__["a" /* Color */],
  Clock: __WEBPACK_IMPORTED_MODULE_5__THREE_core_Clock_js__["a" /* Clock */],
  Scene: __WEBPACK_IMPORTED_MODULE_6__THREE_scenes_Scene_js__["a" /* Scene */],
  Group: __WEBPACK_IMPORTED_MODULE_7__THREE_objects_Group_js__["a" /* Group */],
  DirectionalLight: __WEBPACK_IMPORTED_MODULE_8__THREE_lights_DirectionalLight_js__["a" /* DirectionalLight */],
  AmbientLight: __WEBPACK_IMPORTED_MODULE_9__THREE_lights_AmbientLight_js__["a" /* AmbientLight */],
  Raycaster: __WEBPACK_IMPORTED_MODULE_10__THREE_core_Raycaster_js__["a" /* Raycaster */],
  Mesh: __WEBPACK_IMPORTED_MODULE_11__THREE_objects_Mesh_js__["a" /* Mesh */],

  MeshBasicMaterial: __WEBPACK_IMPORTED_MODULE_12__THREE_materials_MeshBasicMaterial_js__["a" /* MeshBasicMaterial */],
  MeshPhongMaterial: __WEBPACK_IMPORTED_MODULE_13__THREE_materials_MeshPhongMaterial_js__["a" /* MeshPhongMaterial */],
  LineBasicMaterial: __WEBPACK_IMPORTED_MODULE_14__THREE_materials_LineBasicMaterial_js__["a" /* LineBasicMaterial */],
  PointsMaterial: __WEBPACK_IMPORTED_MODULE_15__THREE_materials_PointsMaterial_js__["a" /* PointsMaterial */],
  MeshLambertMaterial: __WEBPACK_IMPORTED_MODULE_16__THREE_materials_MeshLambertMaterial_js__["a" /* MeshLambertMaterial */],
  RawShaderMaterial: __WEBPACK_IMPORTED_MODULE_17__THREE_materials_RawShaderMaterial_js__["a" /* RawShaderMaterial */],
  TextGeometry: __WEBPACK_IMPORTED_MODULE_36__THREE_geometries_TextGeometry_js__["a" /* TextGeometry */],
  TubeBufferGeometry: __WEBPACK_IMPORTED_MODULE_18__THREE_geometries_TubeGeometry_js__["a" /* TubeBufferGeometry */],
  CatmullRomCurve3: __WEBPACK_IMPORTED_MODULE_19__THREE_extras_curves_CatmullRomCurve3_js__["a" /* CatmullRomCurve3 */],
  Vector2: __WEBPACK_IMPORTED_MODULE_20__THREE_math_Vector2_js__["a" /* Vector2 */],
  Vector3: __WEBPACK_IMPORTED_MODULE_21__THREE_math_Vector3_js__["a" /* Vector3 */],
  Vector4: __WEBPACK_IMPORTED_MODULE_22__THREE_math_Vector4_js__["a" /* Vector4 */],
  Matrix4: __WEBPACK_IMPORTED_MODULE_23__THREE_math_Matrix4_js__["a" /* Matrix4 */],
  Quaternion: __WEBPACK_IMPORTED_MODULE_24__THREE_math_Quaternion_js__["a" /* Quaternion */],
  Box3: __WEBPACK_IMPORTED_MODULE_25__THREE_math_Box3_js__["a" /* Box3 */],
  Object3D: __WEBPACK_IMPORTED_MODULE_26__THREE_core_Object3D_js__["a" /* Object3D */],
  Plane: __WEBPACK_IMPORTED_MODULE_30__THREE_math_Plane_js__["a" /* Plane */],
  Points: __WEBPACK_IMPORTED_MODULE_38__THREE_objects_Points_js__["a" /* Points */],
  Euler: __WEBPACK_IMPORTED_MODULE_27__THREE_math_Euler_js__["a" /* Euler */],
  PerspectiveCamera: __WEBPACK_IMPORTED_MODULE_28__THREE_cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */],
  OrthographicCamera: __WEBPACK_IMPORTED_MODULE_29__THREE_cameras_OrthographicCamera_js__["a" /* OrthographicCamera */],
  BufferGeometry: __WEBPACK_IMPORTED_MODULE_31__THREE_core_BufferGeometry_js__["a" /* BufferGeometry */],
  Geometry: __WEBPACK_IMPORTED_MODULE_32__THREE_core_Geometry_js__["a" /* Geometry */],
  PlaneBufferGeometry: __WEBPACK_IMPORTED_MODULE_33__THREE_geometries_PlaneGeometry_js__["a" /* PlaneBufferGeometry */],
  PlaneGeometry: __WEBPACK_IMPORTED_MODULE_33__THREE_geometries_PlaneGeometry_js__["b" /* PlaneGeometry */],
  InstancedBufferGeometry: __WEBPACK_IMPORTED_MODULE_37__THREE_core_InstancedBufferGeometry_js__["a" /* InstancedBufferGeometry */],
  Frustum: __WEBPACK_IMPORTED_MODULE_39__THREE_math_Frustum_js__["a" /* Frustum */],
  BoxGeometry: __WEBPACK_IMPORTED_MODULE_40__THREE_geometries_BoxGeometry_js__["a" /* BoxGeometry */],
  EdgesGeometry: __WEBPACK_IMPORTED_MODULE_35__THREE_geometries_EdgesGeometry_js__["a" /* EdgesGeometry */],
  BoxHelper: __WEBPACK_IMPORTED_MODULE_41__THREE_helpers_BoxHelper_js__["a" /* BoxHelper */],
  LineSegments: __WEBPACK_IMPORTED_MODULE_43__THREE_objects_LineSegments_js__["a" /* LineSegments */],
  Line: __WEBPACK_IMPORTED_MODULE_42__THREE_objects_Line_js__["a" /* Line */],
  TextureLoader: __WEBPACK_IMPORTED_MODULE_44__THREE_loaders_TextureLoader_js__["a" /* TextureLoader */],
  FileLoader: __WEBPACK_IMPORTED_MODULE_45__THREE_loaders_FileLoader_js__["a" /* FileLoader */],
  DefaultLoadingManager: __WEBPACK_IMPORTED_MODULE_46__THREE_loaders_LoadingManager_js__["a" /* DefaultLoadingManager */],
  FontLoader: __WEBPACK_IMPORTED_MODULE_47__THREE_loaders_FontLoader_js__["a" /* FontLoader */],
  Float64BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["a" /* Float64BufferAttribute */],
  Float32BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["b" /* Float32BufferAttribute */],
  Float32BufferAttributeModel: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["c" /* Float32BufferAttributeModel */],
  Uint32BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["d" /* Uint32BufferAttribute */],
  Int32BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["e" /* Int32BufferAttribute */],
  Uint16BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["f" /* Uint16BufferAttribute */],
  Int16BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["g" /* Int16BufferAttribute */],
  Uint8ClampedBufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["h" /* Uint8ClampedBufferAttribute */],
  Uint8BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["i" /* Uint8BufferAttribute */],
  Int8BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["j" /* Int8BufferAttribute */],
  BufferAttribute: __WEBPACK_IMPORTED_MODULE_50__THREE_core_BufferAttribute_js__["k" /* BufferAttribute */],
  InstancedBufferAttribute: __WEBPACK_IMPORTED_MODULE_34__THREE_core_InstancedBufferAttribute_js__["a" /* InstancedBufferAttribute */],

  EffectComposer: __WEBPACK_IMPORTED_MODULE_52__THREE_postprocessing_EffectComposer_js__["a" /* EffectComposer */],
  Pass: __WEBPACK_IMPORTED_MODULE_52__THREE_postprocessing_EffectComposer_js__["b" /* Pass */],
  SMAAPass: __WEBPACK_IMPORTED_MODULE_53__THREE_postprocessing_SMAAPass_js__["a" /* SMAAPass */],

  Texture: __WEBPACK_IMPORTED_MODULE_51__THREE_textures_Texture_js__["a" /* Texture */],
  SSAARenderPass: __WEBPACK_IMPORTED_MODULE_54__THREE_postprocessing_SSAARenderPass_js__["a" /* SSAARenderPass */],
  RenderPass: __WEBPACK_IMPORTED_MODULE_55__THREE_postprocessing_RenderPass_js__["a" /* RenderPass */],
  MaskPass: __WEBPACK_IMPORTED_MODULE_56__THREE_postprocessing_MaskPass_js__["a" /* MaskPass */],
  ClearMaskPass: __WEBPACK_IMPORTED_MODULE_56__THREE_postprocessing_MaskPass_js__["b" /* ClearMaskPass */],
  ShaderPass: __WEBPACK_IMPORTED_MODULE_57__THREE_postprocessing_ShaderPass_js__["a" /* ShaderPass */],
  ShaderMaterial: __WEBPACK_IMPORTED_MODULE_48__THREE_materials_ShaderMaterial_js__["a" /* ShaderMaterial */],
  UniformsUtils: __WEBPACK_IMPORTED_MODULE_49__THREE_renderers_shaders_UniformsUtils_js__["a" /* UniformsUtils */],
  LinearFilter: __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__["a" /* LinearFilter */],
  RGBFormat: __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__["b" /* RGBFormat */],
  RGBAFormat: __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__["c" /* RGBAFormat */],
  NearestFilter: __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__["d" /* NearestFilter */],
  DRAWMODE: __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__["e" /* DRAWMODE */],
  INDEXUPDATEMODE: __WEBPACK_IMPORTED_MODULE_58__THREE_constants_js__["f" /* INDEXUPDATEMODE */],
  PMBufferGeometry: __WEBPACK_IMPORTED_MODULE_63__THREE_pms_PMBufferGeometry_js__["a" /* PMBufferGeometry */],
  PMInstanceBufferGeometry: __WEBPACK_IMPORTED_MODULE_64__THREE_pms_PMInstanceBufferGeometry_js__["a" /* PMInstanceBufferGeometry */],
  PMInstanceAttribute: __WEBPACK_IMPORTED_MODULE_64__THREE_pms_PMInstanceBufferGeometry_js__["b" /* PMInstanceAttribute */],
  VertexAttribute: __WEBPACK_IMPORTED_MODULE_60__THREE_pms_VertexAttribute_js__["a" /* VertexAttribute */],
  VertexAttributeArray: __WEBPACK_IMPORTED_MODULE_61__THREE_pms_VertexAttributeArray_js__["a" /* VertexAttributeArray */],
  VertexIndex: __WEBPACK_IMPORTED_MODULE_59__THREE_pms_VertexIndex_js__["a" /* VertexIndex */],
  VertexIndexRange: __WEBPACK_IMPORTED_MODULE_62__THREE_pms_VertexIndexRange_js__["a" /* VertexIndexRange */],
  InstancedMesh: __WEBPACK_IMPORTED_MODULE_65__THREE_pms_InstancedMesh_js__["a" /* InstancedMesh */],
  PmLineSegments: __WEBPACK_IMPORTED_MODULE_66__THREE_pms_PmLineSegments_js__["a" /* PmLineSegments */]
};

window.$CCBIM.render.baseImg = __WEBPACK_IMPORTED_MODULE_67__tool_base64__["a" /* default */];





__WEBPACK_IMPORTED_MODULE_71_axios___default.a.defaults.headers['X-Requested-With'] = 'XMLHttpRequest';
__WEBPACK_IMPORTED_MODULE_71_axios___default.a.defaults.headers['Accept'] = 'application/json';

function install(Vue, options) {
  Vue.prototype.$ccbimAxios = __WEBPACK_IMPORTED_MODULE_71_axios___default.a;
  Vue.prototype.$qs = __WEBPACK_IMPORTED_MODULE_72_qs___default.a;
  Vue.component(__WEBPACK_IMPORTED_MODULE_68__components_dwg_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_68__components_dwg_vue___default.a);
  Vue.component(__WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue___default.a);
  Vue.component(__WEBPACK_IMPORTED_MODULE_70__model_model_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_70__model_model_vue___default.a);
}


/* harmony default export */ __webpack_exports__["default"] = ({
  install: function install(Vue, options) {
    Vue.prototype.$ccbimAxios = __WEBPACK_IMPORTED_MODULE_71_axios___default.a;
    Vue.prototype.$qs = __WEBPACK_IMPORTED_MODULE_72_qs___default.a;
    Vue.component(__WEBPACK_IMPORTED_MODULE_68__components_dwg_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_68__components_dwg_vue___default.a);
    Vue.component(__WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_69__panorama_panorama_vue___default.a);
    Vue.component(__WEBPACK_IMPORTED_MODULE_70__model_model_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_70__model_model_vue___default.a);
  }
});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = fetch;

var asPromise = __webpack_require__(138),
    inquire   = __webpack_require__(139);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(241);

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);
var bind = __webpack_require__(144);
var Axios = __webpack_require__(243);
var defaults = __webpack_require__(87);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(141);
axios.CancelToken = __webpack_require__(242);
axios.isCancel = __webpack_require__(142);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(257);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(141);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(87);
var utils = __webpack_require__(17);
var InterceptorManager = __webpack_require__(244);
var dispatchRequest = __webpack_require__(245);
var isAbsoluteURL = __webpack_require__(253);
var combineURLs = __webpack_require__(251);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);
var transformData = __webpack_require__(248);
var isCancel = __webpack_require__(142);
var defaults = __webpack_require__(87);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(143);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(17);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__ = __webpack_require__(4);





function DirectGeometry() {

			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];

			this.groups = [];

			this.morphTargets = {};

			this.skinWeights = [];
			this.skinIndices = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(DirectGeometry.prototype, {

			computeGroups: function computeGroups(geometry) {

						var group;
						var groups = [];
						var materialIndex = undefined;

						var faces = geometry.faces;

						for (var i = 0; i < faces.length; i++) {

									var face = faces[i];

									if (face.materialIndex !== materialIndex) {

												materialIndex = face.materialIndex;

												if (group !== undefined) {

															group.count = i * 3 - group.start;
															groups.push(group);
												}

												group = {
															start: i * 3,
															materialIndex: materialIndex
												};
									}
						}

						if (group !== undefined) {

									group.count = i * 3 - group.start;
									groups.push(group);
						}

						this.groups = groups;
			},

			fromGeometry: function fromGeometry(geometry) {

						var faces = geometry.faces;
						var vertices = geometry.vertices;
						var faceVertexUvs = geometry.faceVertexUvs;

						var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
						var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;

						var morphTargets = geometry.morphTargets;
						var morphTargetsLength = morphTargets.length;

						var morphTargetsPosition;

						if (morphTargetsLength > 0) {

									morphTargetsPosition = [];

									for (var i = 0; i < morphTargetsLength; i++) {

												morphTargetsPosition[i] = {
															name: morphTargets[i].name,
															data: []
												};
									}

									this.morphTargets.position = morphTargetsPosition;
						}

						var morphNormals = geometry.morphNormals;
						var morphNormalsLength = morphNormals.length;

						var morphTargetsNormal;

						if (morphNormalsLength > 0) {

									morphTargetsNormal = [];

									for (var i = 0; i < morphNormalsLength; i++) {

												morphTargetsNormal[i] = {
															name: morphNormals[i].name,
															data: []
												};
									}

									this.morphTargets.normal = morphTargetsNormal;
						}

						var skinIndices = geometry.skinIndices;
						var skinWeights = geometry.skinWeights;

						var hasSkinIndices = skinIndices.length === vertices.length;
						var hasSkinWeights = skinWeights.length === vertices.length;

						if (vertices.length > 0 && faces.length === 0) {

									console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
						}

						for (var i = 0; i < faces.length; i++) {

									var face = faces[i];

									this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);

									var vertexNormals = face.vertexNormals;

									if (vertexNormals.length === 3) {

												this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
									} else {

												var normal = face.normal;

												this.normals.push(normal, normal, normal);
									}

									var vertexColors = face.vertexColors;

									if (vertexColors.length === 3) {

												this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
									} else {

												var color = face.color;

												this.colors.push(color, color, color);
									}

									if (hasFaceVertexUv === true) {

												var vertexUvs = faceVertexUvs[0][i];

												if (vertexUvs !== undefined) {

															this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
												} else {

															console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);

															this.uvs.push(new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]());
												}
									}

									if (hasFaceVertexUv2 === true) {

												var vertexUvs = faceVertexUvs[1][i];

												if (vertexUvs !== undefined) {

															this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
												} else {

															console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);

															this.uvs2.push(new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */](), new __WEBPACK_IMPORTED_MODULE_1__math_Vector2_js__["a" /* Vector2 */]());
												}
									}

									for (var j = 0; j < morphTargetsLength; j++) {

												var morphTarget = morphTargets[j].vertices;

												morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
									}

									for (var j = 0; j < morphNormalsLength; j++) {

												var morphNormal = morphNormals[j].vertexNormals[i];

												morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
									}

									if (hasSkinIndices) {

												this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
									}

									if (hasSkinWeights) {

												this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
									}
						}

						this.computeGroups(geometry);

						this.verticesNeedUpdate = geometry.verticesNeedUpdate;
						this.normalsNeedUpdate = geometry.normalsNeedUpdate;
						this.colorsNeedUpdate = geometry.colorsNeedUpdate;
						this.uvsNeedUpdate = geometry.uvsNeedUpdate;
						this.groupsNeedUpdate = geometry.groupsNeedUpdate;

						return this;
			}

});



/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InstancedBufferAttribute; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__BufferAttribute_js__ = __webpack_require__(12);




function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {

	if (typeof normalized === 'number') {

		meshPerAttribute = normalized;

		normalized = false;

		console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
	}

	__WEBPACK_IMPORTED_MODULE_2__BufferAttribute_js__["k" /* BufferAttribute */].call(this, array, itemSize, normalized);

	this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedBufferAttribute.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__BufferAttribute_js__["k" /* BufferAttribute */].prototype), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function copy(source) {

		__WEBPACK_IMPORTED_MODULE_2__BufferAttribute_js__["k" /* BufferAttribute */].prototype.copy.call(this, source);

		this.meshPerAttribute = source.meshPerAttribute;

		return this;
	},

	toJSON: function toJSON() {

		var data = __WEBPACK_IMPORTED_MODULE_2__BufferAttribute_js__["k" /* BufferAttribute */].prototype.toJSON.call(this);

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;
	}

});



/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InstancedBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__BufferGeometry_js__ = __webpack_require__(18);




function InstancedBufferGeometry() {

	__WEBPACK_IMPORTED_MODULE_2__BufferGeometry_js__["a" /* BufferGeometry */].call(this);

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;
}

InstancedBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__BufferGeometry_js__["a" /* BufferGeometry */].prototype), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function copy(source) {

		__WEBPACK_IMPORTED_MODULE_2__BufferGeometry_js__["a" /* BufferGeometry */].prototype.copy.call(this, source);

		this.maxInstancedCount = source.maxInstancedCount;

		return this;
	},

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	toJSON: function toJSON() {

		var data = __WEBPACK_IMPORTED_MODULE_2__BufferGeometry_js__["a" /* BufferGeometry */].prototype.toJSON.call(this);

		data.maxInstancedCount = this.maxInstancedCount;

		data.isInstancedBufferGeometry = true;

		return data;
	}

});



/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Layers; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);



function Layers() {

	this.mask = 1 | 0;
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Layers.prototype, {

	set: function set(channel) {

		this.mask = 1 << channel | 0;
	},

	enable: function enable(channel) {

		this.mask |= 1 << channel | 0;
	},

	toggle: function toggle(channel) {

		this.mask ^= 1 << channel | 0;
	},

	disable: function disable(channel) {

		this.mask &= ~(1 << channel | 0);
	},

	test: function test(layers) {

		return (this.mask & layers.mask) !== 0;
	}

});



/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Raycaster; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Ray_js__ = __webpack_require__(53);




function Raycaster(origin, direction, near, far) {

	this.ray = new __WEBPACK_IMPORTED_MODULE_2__math_Ray_js__["a" /* Ray */](origin, direction);


	this.near = near || 0;
	this.far = far || Infinity;

	this.params = {
		Mesh: {},
		Line: {},
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_define_properties___default()(this.params, {
		PointCloud: {
			get: function get() {

				console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
				return this.Points;
			}
		}
	});
}

function ascSort(a, b) {

	return a.distance - b.distance;
}

function _intersectObject(object, raycaster, intersects, recursive) {

	if (object.visible === false) return;

	object.raycast(raycaster, intersects);

	if (recursive === true) {

		var children = object.children;

		for (var i = 0, l = children.length; i < l; i++) {

			_intersectObject(children[i], raycaster, intersects, true);
		}
	}
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(Raycaster.prototype, {

	linePrecision: 1,

	set: function set(origin, direction) {

		this.ray.set(origin, direction);
	},

	setFromCamera: function setFromCamera(coords, camera) {

		if (camera && camera.isPerspectiveCamera) {

			this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
			this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
			this._camera = camera;
		} else if (camera && camera.isOrthographicCamera) {

			this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
			this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
			this._camera = camera;
		} else {

			console.error('THREE.Raycaster: Unsupported camera type.');
		}
	},

	intersectObject: function intersectObject(object, recursive, optionalTarget) {

		var intersects = optionalTarget || [];

		_intersectObject(object, this, intersects, recursive);

		intersects.sort(ascSort);

		return intersects;
	},

	intersectObjects: function intersectObjects(objects, recursive, optionalTarget) {

		var intersects = optionalTarget || [];

		if (Array.isArray(objects) === false) {

			console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
			return intersects;
		}

		for (var i = 0, l = objects.length; i < l; i++) {

			_intersectObject(objects[i], this, intersects, recursive);
		}

		intersects.sort(ascSort);

		return intersects;
	},

	intersectRenderObjects: function intersectRenderObjects(currentRenderList, recursive, fastTest, ignoreLine) {
		var intersects = [];
		var objects = currentRenderList.opaque;
		for (var i = objects.length - 1; i >= 0; i--) {
			var object = objects[i].object;
			if (object.isLine && ignoreLine) {
				continue;
			}
			_intersectObject(object, this, intersects, recursive);
			if (fastTest && intersects.length > 0) {
				break;
			}
		}

		objects = currentRenderList.transparent;
		for (var i = objects.length - 1; i >= 0; i--) {
			_intersectObject(objects[i].object, this, intersects, recursive);
		}
		intersects.sort(ascSort);
		return intersects;
	}

});



/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Earcut; });


var Earcut = {

	triangulate: function triangulate(data, holeIndices, dim) {

		dim = dim || 2;

		var hasHoles = holeIndices && holeIndices.length,
		    outerLen = hasHoles ? holeIndices[0] * dim : data.length,
		    outerNode = linkedList(data, 0, outerLen, dim, true),
		    triangles = [];

		if (!outerNode) return triangles;

		var minX, minY, maxX, maxY, x, y, invSize;

		if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

		if (data.length > 80 * dim) {

			minX = maxX = data[0];
			minY = maxY = data[1];

			for (var i = dim; i < outerLen; i += dim) {

				x = data[i];
				y = data[i + 1];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
			}

			invSize = Math.max(maxX - minX, maxY - minY);
			invSize = invSize !== 0 ? 1 / invSize : 0;
		}

		earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

		return triangles;
	}

};

function linkedList(data, start, end, dim, clockwise) {

	var i, last;

	if (clockwise === signedArea(data, start, end, dim) > 0) {

		for (i = start; i < end; i += dim) {
			last = insertNode(i, data[i], data[i + 1], last);
		}
	} else {

		for (i = end - dim; i >= start; i -= dim) {
			last = insertNode(i, data[i], data[i + 1], last);
		}
	}

	if (last && equals(last, last.next)) {

		removeNode(last);
		last = last.next;
	}

	return last;
}

function filterPoints(start, end) {

	if (!start) return start;
	if (!end) end = start;

	var p = start,
	    again;

	do {

		again = false;

		if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {

			removeNode(p);
			p = end = p.prev;
			if (p === p.next) break;
			again = true;
		} else {

			p = p.next;
		}
	} while (again || p !== end);

	return end;
}

function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {

	if (!ear) return;

	if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

	var stop = ear,
	    prev,
	    next;

	while (ear.prev !== ear.next) {

		prev = ear.prev;
		next = ear.next;

		if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
			triangles.push(prev.i / dim);
			triangles.push(ear.i / dim);
			triangles.push(next.i / dim);

			removeNode(ear);

			ear = next.next;
			stop = next.next;

			continue;
		}

		ear = next;

		if (ear === stop) {

			if (!pass) {

				earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
			} else if (pass === 1) {

				ear = cureLocalIntersections(ear, triangles, dim);
				earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
			} else if (pass === 2) {

				splitEarcut(ear, triangles, dim, minX, minY, invSize);
			}

			break;
		}
	}
}

function isEar(ear) {

	var a = ear.prev,
	    b = ear,
	    c = ear.next;

	if (area(a, b, c) >= 0) return false;
	var p = ear.next.next;

	while (p !== ear.prev) {

		if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {

			return false;
		}

		p = p.next;
	}

	return true;
}

function isEarHashed(ear, minX, minY, invSize) {

	var a = ear.prev,
	    b = ear,
	    c = ear.next;

	if (area(a, b, c) >= 0) return false;

	var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
	    minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
	    maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
	    maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;

	var minZ = zOrder(minTX, minTY, minX, minY, invSize),
	    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

	var p = ear.nextZ;

	while (p && p.z <= maxZ) {

		if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
		p = p.nextZ;
	}

	p = ear.prevZ;

	while (p && p.z >= minZ) {

		if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;

		p = p.prevZ;
	}

	return true;
}

function cureLocalIntersections(start, triangles, dim) {

	var p = start;

	do {

		var a = p.prev,
		    b = p.next.next;

		if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

			triangles.push(a.i / dim);
			triangles.push(p.i / dim);
			triangles.push(b.i / dim);

			removeNode(p);
			removeNode(p.next);

			p = start = b;
		}

		p = p.next;
	} while (p !== start);

	return p;
}

function splitEarcut(start, triangles, dim, minX, minY, invSize) {

	var a = start;

	do {

		var b = a.next.next;

		while (b !== a.prev) {

			if (a.i !== b.i && isValidDiagonal(a, b)) {

				var c = splitPolygon(a, b);

				a = filterPoints(a, a.next);
				c = filterPoints(c, c.next);

				earcutLinked(a, triangles, dim, minX, minY, invSize);
				earcutLinked(c, triangles, dim, minX, minY, invSize);
				return;
			}

			b = b.next;
		}

		a = a.next;
	} while (a !== start);
}

function eliminateHoles(data, holeIndices, outerNode, dim) {

	var queue = [],
	    i,
	    len,
	    start,
	    end,
	    list;

	for (i = 0, len = holeIndices.length; i < len; i++) {

		start = holeIndices[i] * dim;
		end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
		list = linkedList(data, start, end, dim, false);
		if (list === list.next) list.steiner = true;
		queue.push(getLeftmost(list));
	}

	queue.sort(compareX);

	for (i = 0; i < queue.length; i++) {

		eliminateHole(queue[i], outerNode);
		outerNode = filterPoints(outerNode, outerNode.next);
	}

	return outerNode;
}

function compareX(a, b) {

	return a.x - b.x;
}

function eliminateHole(hole, outerNode) {

	outerNode = findHoleBridge(hole, outerNode);

	if (outerNode) {

		var b = splitPolygon(outerNode, hole);

		filterPoints(b, b.next);
	}
}

function findHoleBridge(hole, outerNode) {

	var p = outerNode,
	    hx = hole.x,
	    hy = hole.y,
	    qx = -Infinity,
	    m;

	do {

		if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {

			var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

			if (x <= hx && x > qx) {

				qx = x;

				if (x === hx) {

					if (hy === p.y) return p;
					if (hy === p.next.y) return p.next;
				}

				m = p.x < p.next.x ? p : p.next;
			}
		}

		p = p.next;
	} while (p !== outerNode);

	if (!m) return null;

	if (hx === qx) return m.prev;

	var stop = m,
	    mx = m.x,
	    my = m.y,
	    tanMin = Infinity,
	    tan;

	p = m.next;

	while (p !== stop) {

		if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

			tan = Math.abs(hy - p.y) / (hx - p.x);

			if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {

				m = p;
				tanMin = tan;
			}
		}

		p = p.next;
	}

	return m;
}

function indexCurve(start, minX, minY, invSize) {

	var p = start;

	do {

		if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;
	} while (p !== start);

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked(p);
}

function sortLinked(list) {

	var i,
	    p,
	    q,
	    e,
	    tail,
	    numMerges,
	    pSize,
	    qSize,
	    inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while (p) {

			numMerges++;
			q = p;
			pSize = 0;

			for (i = 0; i < inSize; i++) {

				pSize++;
				q = q.nextZ;
				if (!q) break;
			}

			qSize = inSize;

			while (pSize > 0 || qSize > 0 && q) {

				if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {

					e = p;
					p = p.nextZ;
					pSize--;
				} else {

					e = q;
					q = q.nextZ;
					qSize--;
				}

				if (tail) tail.nextZ = e;else list = e;

				e.prevZ = tail;
				tail = e;
			}

			p = q;
		}

		tail.nextZ = null;
		inSize *= 2;
	} while (numMerges > 1);

	return list;
}

function zOrder(x, y, minX, minY, invSize) {

	x = 32767 * (x - minX) * invSize;
	y = 32767 * (y - minY) * invSize;

	x = (x | x << 8) & 0x00FF00FF;
	x = (x | x << 4) & 0x0F0F0F0F;
	x = (x | x << 2) & 0x33333333;
	x = (x | x << 1) & 0x55555555;

	y = (y | y << 8) & 0x00FF00FF;
	y = (y | y << 4) & 0x0F0F0F0F;
	y = (y | y << 2) & 0x33333333;
	y = (y | y << 1) & 0x55555555;

	return x | y << 1;
}

function getLeftmost(start) {

	var p = start,
	    leftmost = start;

	do {

		if (p.x < leftmost.x) leftmost = p;
		p = p.next;
	} while (p !== start);

	return leftmost;
}

function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {

	return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

function isValidDiagonal(a, b) {

	return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

function area(p, q, r) {

	return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

function equals(p1, p2) {

	return p1.x === p2.x && p1.y === p2.y;
}

function intersects(p1, q1, p2, q2) {

	if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;

	return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

function intersectsPolygon(a, b) {

	var p = a;

	do {

		if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {

			return true;
		}

		p = p.next;
	} while (p !== a);

	return false;
}

function locallyInside(a, b) {

	return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

function middleInside(a, b) {

	var p = a,
	    inside = false,
	    px = (a.x + b.x) / 2,
	    py = (a.y + b.y) / 2;

	do {

		if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {

			inside = !inside;
		}

		p = p.next;
	} while (p !== a);

	return inside;
}

function splitPolygon(a, b) {

	var a2 = new Node(a.i, a.x, a.y),
	    b2 = new Node(b.i, b.x, b.y),
	    an = a.next,
	    bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;
}

function insertNode(i, x, y, last) {

	var p = new Node(i, x, y);

	if (!last) {

		p.prev = p;
		p.next = p;
	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;
	}

	return p;
}

function removeNode(p) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
	this.i = i;

	this.x = x;
	this.y = y;

	this.prev = null;
	this.next = null;

	this.z = null;

	this.prevZ = null;
	this.nextZ = null;

	this.steiner = false;
}

function signedArea(data, start, end, dim) {

	var sum = 0;

	for (var i = start, j = end - dim; i < end; i += dim) {

		sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
		j = i;
	}

	return sum;
}



/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImageUtils; });


var _canvas;

var ImageUtils = {

			getDataURL: function getDataURL(image) {

						var canvas;

						if (typeof HTMLCanvasElement == 'undefined') {

									return image.src;
						} else if (image instanceof HTMLCanvasElement) {

									canvas = image;
						} else {

									if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');

									_canvas.width = image.width;
									_canvas.height = image.height;

									var context = _canvas.getContext('2d');

									if (image instanceof ImageData) {

												context.putImageData(image, 0, 0);
									} else {

												context.drawImage(image, 0, 0, image.width, image.height);
									}

									canvas = _canvas;
						}

						if (canvas.width > 2048 || canvas.height > 2048) {

									return canvas.toDataURL('image/jpeg', 0.6);
						} else {

									return canvas.toDataURL('image/png');
						}
			}

};



/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CurvePath; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__curves_Curves_js__ = __webpack_require__(271);





function CurvePath() {

		__WEBPACK_IMPORTED_MODULE_2__Curve_js__["a" /* Curve */].call(this);

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false;
}

CurvePath.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Curve_js__["a" /* Curve */].prototype), {

		constructor: CurvePath,

		add: function add(curve) {

				this.curves.push(curve);
		},

		closePath: function closePath() {
				var startPoint = this.curves[0].getPoint(0);
				var endPoint = this.curves[this.curves.length - 1].getPoint(1);

				if (!startPoint.equals(endPoint)) {

						this.curves.push(new __WEBPACK_IMPORTED_MODULE_3__curves_Curves_js__["LineCurve"](endPoint, startPoint));
				}
		},

		getPoint: function getPoint(t) {

				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;

				while (i < curveLengths.length) {

						if (curveLengths[i] >= d) {

								var diff = curveLengths[i] - d;
								var curve = this.curves[i];

								var segmentLength = curve.getLength();
								var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

								return curve.getPointAt(u);
						}

						i++;
				}

				return null;
		},

		getLength: function getLength() {

				var lens = this.getCurveLengths();
				return lens[lens.length - 1];
		},

		updateArcLengths: function updateArcLengths() {

				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getCurveLengths();
		},

		getCurveLengths: function getCurveLengths() {

				if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {

						return this.cacheLengths;
				}

				var lengths = [],
				    sums = 0;

				for (var i = 0, l = this.curves.length; i < l; i++) {

						sums += this.curves[i].getLength();
						lengths.push(sums);
				}

				this.cacheLengths = lengths;

				return lengths;
		},

		getSpacedPoints: function getSpacedPoints(divisions) {

				if (divisions === undefined) divisions = 40;

				var points = [];

				for (var i = 0; i <= divisions; i++) {

						points.push(this.getPoint(i / divisions));
				}

				if (this.autoClose) {

						points.push(points[0]);
				}

				return points;
		},

		getPoints: function getPoints(divisions) {

				divisions = divisions || 12;

				var points = [],
				    last;

				for (var i = 0, curves = this.curves; i < curves.length; i++) {

						var curve = curves[i];
						var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;

						var pts = curve.getPoints(resolution);

						for (var j = 0; j < pts.length; j++) {

								var point = pts[j];

								if (last && last.equals(point)) continue;

								points.push(point);
								last = point;
						}
				}

				if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {

						points.push(points[0]);
				}

				return points;
		},

		copy: function copy(source) {

				__WEBPACK_IMPORTED_MODULE_2__Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

				this.curves = [];

				for (var i = 0, l = source.curves.length; i < l; i++) {

						var curve = source.curves[i];

						this.curves.push(curve.clone());
				}

				this.autoClose = source.autoClose;

				return this;
		},

		toJSON: function toJSON() {

				var data = __WEBPACK_IMPORTED_MODULE_2__Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

				data.autoClose = this.autoClose;
				data.curves = [];

				for (var i = 0, l = this.curves.length; i < l; i++) {

						var curve = this.curves[i];
						data.curves.push(curve.toJSON());
				}

				return data;
		},

		fromJSON: function fromJSON(json) {

				__WEBPACK_IMPORTED_MODULE_2__Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

				this.autoClose = json.autoClose;
				this.curves = [];

				for (var i = 0, l = json.curves.length; i < l; i++) {

						var curve = json.curves[i];
						this.curves.push(new __WEBPACK_IMPORTED_MODULE_3__curves_Curves_js__[curve.type]().fromJSON(curve));
				}

				return this;
		}

});



/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Font; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ShapePath_js__ = __webpack_require__(268);






function Font(data) {

	this.type = 'Font';

	this.data = data;
}

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(Font.prototype, {

	isFont: true,

	generateShapes: function generateShapes(text, size) {

		if (size === undefined) size = 100;

		var shapes = [];
		var paths = createPaths(text, size, this.data);

		for (var p = 0, pl = paths.length; p < pl; p++) {

			Array.prototype.push.apply(shapes, paths[p].toShapes());
		}

		return shapes;
	}

});

function createPaths(text, size, data) {

	var chars = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default.a ? __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_array_from___default()(text) : String(text).split('');
	var scale = size / data.resolution;
	var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

	var paths = [];

	var offsetX = 0,
	    offsetY = 0;

	for (var i = 0; i < chars.length; i++) {

		var char = chars[i];

		if (char === '\n') {

			offsetX = 0;
			offsetY -= line_height;
		} else {

			var ret = createPath(char, scale, offsetX, offsetY, data);
			offsetX += ret.offsetX;
			paths.push(ret.path);
		}
	}

	return paths;
}

function createPath(char, scale, offsetX, offsetY, data) {

	var glyph = data.glyphs[char] || data.glyphs['?'];

	if (!glyph) return;

	var path = new __WEBPACK_IMPORTED_MODULE_2__ShapePath_js__["a" /* ShapePath */]();

	var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if (glyph.o) {

		var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

		for (var i = 0, l = outline.length; i < l;) {

			var action = outline[i++];

			switch (action) {

				case 'm':

					x = outline[i++] * scale + offsetX;
					y = outline[i++] * scale + offsetY;

					path.moveTo(x, y);

					break;

				case 'l':

					x = outline[i++] * scale + offsetX;
					y = outline[i++] * scale + offsetY;

					path.lineTo(x, y);

					break;

				case 'q':

					cpx = outline[i++] * scale + offsetX;
					cpy = outline[i++] * scale + offsetY;
					cpx1 = outline[i++] * scale + offsetX;
					cpy1 = outline[i++] * scale + offsetY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					break;

				case 'b':

					cpx = outline[i++] * scale + offsetX;
					cpy = outline[i++] * scale + offsetY;
					cpx1 = outline[i++] * scale + offsetX;
					cpy1 = outline[i++] * scale + offsetY;
					cpx2 = outline[i++] * scale + offsetX;
					cpy2 = outline[i++] * scale + offsetY;

					path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);

					break;

			}
		}
	}

	return { offsetX: glyph.ha * scale, path: path };
}



/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Shape; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Path_js__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Math_js__ = __webpack_require__(8);





function Shape(points) {

		__WEBPACK_IMPORTED_MODULE_2__Path_js__["a" /* Path */].call(this, points);

		this.uuid = __WEBPACK_IMPORTED_MODULE_3__math_Math_js__["a" /* _Math */].generateUUID();

		this.type = 'Shape';

		this.holes = [];
}

Shape.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Path_js__["a" /* Path */].prototype), {

		constructor: Shape,

		getPointsHoles: function getPointsHoles(divisions) {

				var holesPts = [];

				for (var i = 0, l = this.holes.length; i < l; i++) {

						holesPts[i] = this.holes[i].getPoints(divisions);
				}

				return holesPts;
		},

		extractPoints: function extractPoints(divisions) {

				return {

						shape: this.getPoints(divisions),
						holes: this.getPointsHoles(divisions)

				};
		},

		copy: function copy(source) {

				__WEBPACK_IMPORTED_MODULE_2__Path_js__["a" /* Path */].prototype.copy.call(this, source);

				this.holes = [];

				for (var i = 0, l = source.holes.length; i < l; i++) {

						var hole = source.holes[i];

						this.holes.push(hole.clone());
				}

				return this;
		},

		toJSON: function toJSON() {

				var data = __WEBPACK_IMPORTED_MODULE_2__Path_js__["a" /* Path */].prototype.toJSON.call(this);

				data.uuid = this.uuid;
				data.holes = [];

				for (var i = 0, l = this.holes.length; i < l; i++) {

						var hole = this.holes[i];
						data.holes.push(hole.toJSON());
				}

				return data;
		},

		fromJSON: function fromJSON(json) {

				__WEBPACK_IMPORTED_MODULE_2__Path_js__["a" /* Path */].prototype.fromJSON.call(this, json);

				this.uuid = json.uuid;
				this.holes = [];

				for (var i = 0, l = json.holes.length; i < l; i++) {

						var hole = json.holes[i];
						this.holes.push(new __WEBPACK_IMPORTED_MODULE_2__Path_js__["a" /* Path */]().fromJSON(hole));
				}

				return this;
		}

});



/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapePath; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Path_js__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Shape_js__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ShapeUtils_js__ = __webpack_require__(148);









function ShapePath() {

		this.type = 'ShapePath';

		this.color = new __WEBPACK_IMPORTED_MODULE_2__math_Color_js__["a" /* Color */]();

		this.subPaths = [];
		this.currentPath = null;
}

__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(ShapePath.prototype, {

		moveTo: function moveTo(x, y) {

				this.currentPath = new __WEBPACK_IMPORTED_MODULE_3__Path_js__["a" /* Path */]();
				this.subPaths.push(this.currentPath);
				this.currentPath.moveTo(x, y);
		},

		lineTo: function lineTo(x, y) {

				this.currentPath.lineTo(x, y);
		},

		quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {

				this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
		},

		bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

				this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
		},

		splineThru: function splineThru(pts) {

				this.currentPath.splineThru(pts);
		},

		toShapes: function toShapes(isCCW, noHoles) {

				function toShapesNoHoles(inSubpaths) {

						var shapes = [];

						for (var i = 0, l = inSubpaths.length; i < l; i++) {

								var tmpPath = inSubpaths[i];

								var tmpShape = new __WEBPACK_IMPORTED_MODULE_4__Shape_js__["a" /* Shape */]();
								tmpShape.curves = tmpPath.curves;

								shapes.push(tmpShape);
						}

						return shapes;
				}

				function isPointInsidePolygon(inPt, inPolygon) {

						var polyLen = inPolygon.length;

						var inside = false;
						for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {

								var edgeLowPt = inPolygon[p];
								var edgeHighPt = inPolygon[q];

								var edgeDx = edgeHighPt.x - edgeLowPt.x;
								var edgeDy = edgeHighPt.y - edgeLowPt.y;

								if (Math.abs(edgeDy) > __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_epsilon___default.a) {
										if (edgeDy < 0) {

												edgeLowPt = inPolygon[q];edgeDx = -edgeDx;
												edgeHighPt = inPolygon[p];edgeDy = -edgeDy;
										}
										if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

										if (inPt.y === edgeLowPt.y) {

												if (inPt.x === edgeLowPt.x) return true;
										} else {

												var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
												if (perpEdge === 0) return true;
												if (perpEdge < 0) continue;
												inside = !inside;
										}
								} else {
										if (inPt.y !== edgeLowPt.y) continue;
										if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
								}
						}

						return inside;
				}

				var isClockWise = __WEBPACK_IMPORTED_MODULE_5__ShapeUtils_js__["a" /* ShapeUtils */].isClockWise;

				var subPaths = this.subPaths;
				if (subPaths.length === 0) return [];

				if (noHoles === true) return toShapesNoHoles(subPaths);

				var solid,
				    tmpPath,
				    tmpShape,
				    shapes = [];

				if (subPaths.length === 1) {

						tmpPath = subPaths[0];
						tmpShape = new __WEBPACK_IMPORTED_MODULE_4__Shape_js__["a" /* Shape */]();
						tmpShape.curves = tmpPath.curves;
						shapes.push(tmpShape);
						return shapes;
				}

				var holesFirst = !isClockWise(subPaths[0].getPoints());
				holesFirst = isCCW ? !holesFirst : holesFirst;

				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;

				newShapes[mainIdx] = undefined;
				newShapeHoles[mainIdx] = [];

				for (var i = 0, l = subPaths.length; i < l; i++) {

						tmpPath = subPaths[i];
						tmpPoints = tmpPath.getPoints();
						solid = isClockWise(tmpPoints);
						solid = isCCW ? !solid : solid;

						if (solid) {

								if (!holesFirst && newShapes[mainIdx]) mainIdx++;

								newShapes[mainIdx] = { s: new __WEBPACK_IMPORTED_MODULE_4__Shape_js__["a" /* Shape */](), p: tmpPoints };
								newShapes[mainIdx].s.curves = tmpPath.curves;

								if (holesFirst) mainIdx++;
								newShapeHoles[mainIdx] = [];
						} else {

								newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
						}
				}

				if (!newShapes[0]) return toShapesNoHoles(subPaths);

				if (newShapes.length > 1) {

						var ambiguous = false;
						var toChange = [];

						for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

								betterShapeHoles[sIdx] = [];
						}

						for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

								var sho = newShapeHoles[sIdx];

								for (var hIdx = 0; hIdx < sho.length; hIdx++) {

										var ho = sho[hIdx];
										var hole_unassigned = true;

										for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {

												if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {

														if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
														if (hole_unassigned) {

																hole_unassigned = false;
																betterShapeHoles[s2Idx].push(ho);
														} else {

																ambiguous = true;
														}
												}
										}
										if (hole_unassigned) {

												betterShapeHoles[sIdx].push(ho);
										}
								}
						}

						if (toChange.length > 0) {
								if (!ambiguous) newShapeHoles = betterShapeHoles;
						}
				}

				var tmpHoles;

				for (var i = 0, il = newShapes.length; i < il; i++) {

						tmpShape = newShapes[i].s;
						shapes.push(tmpShape);
						tmpHoles = newShapeHoles[i];

						for (var j = 0, jl = tmpHoles.length; j < jl; j++) {

								tmpShape.holes.push(tmpHoles[j].h);
						}
				}

				return shapes;
		}

});



/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArcCurve; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EllipseCurve_js__ = __webpack_require__(90);



function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

	__WEBPACK_IMPORTED_MODULE_1__EllipseCurve_js__["a" /* EllipseCurve */].call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

	this.type = 'ArcCurve';
}

ArcCurve.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__EllipseCurve_js__["a" /* EllipseCurve */].prototype);
ArcCurve.prototype.constructor = ArcCurve;

ArcCurve.prototype.isArcCurve = true;



/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CubicBezierCurve3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);





function CubicBezierCurve3(v0, v1, v2, v3) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'CubicBezierCurve3';

	this.v0 = v0 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
	this.v1 = v1 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
	this.v2 = v2 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
	this.v3 = v3 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
}

CubicBezierCurve3.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

	var v0 = this.v0,
	    v1 = this.v1,
	    v2 = this.v2,
	    v3 = this.v3;

	point.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["b" /* CubicBezier */])(t, v0.x, v1.x, v2.x, v3.x), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["b" /* CubicBezier */])(t, v0.y, v1.y, v2.y, v3.y), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["b" /* CubicBezier */])(t, v0.z, v1.z, v2.z, v3.z));

	return point;
};

CubicBezierCurve3.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.v0.copy(source.v0);
	this.v1.copy(source.v1);
	this.v2.copy(source.v2);
	this.v3.copy(source.v3);

	return this;
};

CubicBezierCurve3.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;
};

CubicBezierCurve3.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.v0.fromArray(json.v0);
	this.v1.fromArray(json.v1);
	this.v2.fromArray(json.v2);
	this.v3.fromArray(json.v3);

	return this;
};



/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ArcCurve_js__ = __webpack_require__(269);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return __WEBPACK_IMPORTED_MODULE_0__ArcCurve_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__CatmullRomCurve3_js__ = __webpack_require__(150);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return __WEBPACK_IMPORTED_MODULE_1__CatmullRomCurve3_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CubicBezierCurve_js__ = __webpack_require__(151);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return __WEBPACK_IMPORTED_MODULE_2__CubicBezierCurve_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CubicBezierCurve3_js__ = __webpack_require__(270);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return __WEBPACK_IMPORTED_MODULE_3__CubicBezierCurve3_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EllipseCurve_js__ = __webpack_require__(90);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return __WEBPACK_IMPORTED_MODULE_4__EllipseCurve_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__LineCurve_js__ = __webpack_require__(152);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return __WEBPACK_IMPORTED_MODULE_5__LineCurve_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__LineCurve3_js__ = __webpack_require__(272);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return __WEBPACK_IMPORTED_MODULE_6__LineCurve3_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__QuadraticBezierCurve_js__ = __webpack_require__(153);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return __WEBPACK_IMPORTED_MODULE_7__QuadraticBezierCurve_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__QuadraticBezierCurve3_js__ = __webpack_require__(273);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return __WEBPACK_IMPORTED_MODULE_8__QuadraticBezierCurve3_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__SplineCurve_js__ = __webpack_require__(154);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return __WEBPACK_IMPORTED_MODULE_9__SplineCurve_js__["a"]; });











/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineCurve3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__ = __webpack_require__(25);




function LineCurve3(v1, v2) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'LineCurve3';

	this.v1 = v1 || new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
	this.v2 = v2 || new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();
}

LineCurve3.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype);
LineCurve3.prototype.constructor = LineCurve3;

LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_1__math_Vector3_js__["a" /* Vector3 */]();

	if (t === 1) {

		point.copy(this.v2);
	} else {

		point.copy(this.v2).sub(this.v1);
		point.multiplyScalar(t).add(this.v1);
	}

	return point;
};

LineCurve3.prototype.getPointAt = function (u, optionalTarget) {

	return this.getPoint(u, optionalTarget);
};

LineCurve3.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.v1.copy(source.v1);
	this.v2.copy(source.v2);

	return this;
};

LineCurve3.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;
};

LineCurve3.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_2__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.v1.fromArray(json.v1);
	this.v2.fromArray(json.v2);

	return this;
};



/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QuadraticBezierCurve3; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);





function QuadraticBezierCurve3(v0, v1, v2) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].call(this);

	this.type = 'QuadraticBezierCurve3';

	this.v0 = v0 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
	this.v1 = v1 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
	this.v2 = v2 || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
}

QuadraticBezierCurve3.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {

	var point = optionalTarget || new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

	var v0 = this.v0,
	    v1 = this.v1,
	    v2 = this.v2;

	point.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["c" /* QuadraticBezier */])(t, v0.x, v1.x, v2.x), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["c" /* QuadraticBezier */])(t, v0.y, v1.y, v2.y), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_Interpolations_js__["c" /* QuadraticBezier */])(t, v0.z, v1.z, v2.z));

	return point;
};

QuadraticBezierCurve3.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.copy.call(this, source);

	this.v0.copy(source.v0);
	this.v1.copy(source.v1);
	this.v2.copy(source.v2);

	return this;
};

QuadraticBezierCurve3.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.toJSON.call(this);

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;
};

QuadraticBezierCurve3.prototype.fromJSON = function (json) {

	__WEBPACK_IMPORTED_MODULE_1__core_Curve_js__["a" /* Curve */].prototype.fromJSON.call(this, json);

	this.v0.fromArray(json.v0);
	this.v1.fromArray(json.v1);
	this.v2.fromArray(json.v2);

	return this;
};



/***/ }),
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EdgesGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Math_js__ = __webpack_require__(8);








function EdgesGeometry(geometry, thresholdAngle) {

	__WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);

	this.type = 'EdgesGeometry';

	this.parameters = {
		thresholdAngle: thresholdAngle
	};

	thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

	var vertices = [];

	var thresholdDot = Math.cos(__WEBPACK_IMPORTED_MODULE_4__math_Math_js__["a" /* _Math */].DEG2RAD * thresholdAngle);
	var edge = [0, 0],
	    edges = {},
	    edge1,
	    edge2;
	var key,
	    keys = ['a', 'b', 'c'];

	var geometry2;

	if (geometry.isBufferGeometry) {

		geometry2 = new __WEBPACK_IMPORTED_MODULE_3__core_Geometry_js__["a" /* Geometry */]();
		geometry2.fromBufferGeometry(geometry);
	} else {

		geometry2 = geometry.clone();
	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var sourceVertices = geometry2.vertices;
	var faces = geometry2.faces;

	for (var i = 0, l = faces.length; i < l; i++) {

		var face = faces[i];

		for (var j = 0; j < 3; j++) {

			edge1 = face[keys[j]];
			edge2 = face[keys[(j + 1) % 3]];
			edge[0] = Math.min(edge1, edge2);
			edge[1] = Math.max(edge1, edge2);

			key = edge[0] + ',' + edge[1];

			if (edges[key] === undefined) {

				edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: undefined };
			} else {

				edges[key].face2 = i;
			}
		}
	}

	for (key in edges) {

		var e = edges[key];

		if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {

			var vertex = sourceVertices[e.index1];
			vertices.push(vertex.x, vertex.y, vertex.z);

			vertex = sourceVertices[e.index2];
			vertices.push(vertex.x, vertex.y, vertex.z);
		}
	}

	this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_2__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](vertices, 3));
}

EdgesGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;



/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ExtrudeGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExtrudeBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign__ = __webpack_require__(526);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__extras_ShapeUtils_js__ = __webpack_require__(148);












function ExtrudeGeometry(shapes, options) {

		__WEBPACK_IMPORTED_MODULE_3__core_Geometry_js__["a" /* Geometry */].call(this);

		this.type = 'ExtrudeGeometry';

		this.parameters = {
				shapes: shapes,
				options: options
		};

		this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
		this.mergeVertices();
}

ExtrudeGeometry.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_3__core_Geometry_js__["a" /* Geometry */].prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON = function () {

		var data = __WEBPACK_IMPORTED_MODULE_3__core_Geometry_js__["a" /* Geometry */].prototype.toJSON.call(this);

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON(shapes, options, data);
};

function ExtrudeBufferGeometry(shapes, options) {

		__WEBPACK_IMPORTED_MODULE_4__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
				shapes: shapes,
				options: options
		};

		shapes = Array.isArray(shapes) ? shapes : [shapes];

		var scope = this;

		var verticesArray = [];
		var uvArray = [];

		for (var i = 0, l = shapes.length; i < l; i++) {

				var shape = shapes[i];
				addShape(shape);
		}

		this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_5__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](verticesArray, 3));
		this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_5__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](uvArray, 2));

		this.computeVertexNormals();

		function addShape(shape) {

				var placeholder = [];

				var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				var steps = options.steps !== undefined ? options.steps : 1;
				var depth = options.depth !== undefined ? options.depth : 100;

				var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

				var extrudePath = options.extrudePath;

				var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

				if (options.amount !== undefined) {

						console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
						depth = options.amount;
				}

				var extrudePts,
				    extrudeByPath = false;
				var splineTube, binormal, normal, position2;

				if (extrudePath) {

						extrudePts = extrudePath.getSpacedPoints(steps);

						extrudeByPath = true;
						bevelEnabled = false;

						splineTube = extrudePath.computeFrenetFrames(steps, false);

						binormal = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();
						normal = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();
						position2 = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();
				}

				if (!bevelEnabled) {

						bevelSegments = 0;
						bevelThickness = 0;
						bevelSize = 0;
						bevelOffset = 0;
				}

				var ahole, h, hl;

				var shapePoints = shape.extractPoints(curveSegments);

				var vertices = shapePoints.shape;
				var holes = shapePoints.holes;

				var reverse = !__WEBPACK_IMPORTED_MODULE_8__extras_ShapeUtils_js__["a" /* ShapeUtils */].isClockWise(vertices);

				if (reverse) {

						vertices = vertices.reverse();

						for (h = 0, hl = holes.length; h < hl; h++) {

								ahole = holes[h];

								if (__WEBPACK_IMPORTED_MODULE_8__extras_ShapeUtils_js__["a" /* ShapeUtils */].isClockWise(ahole)) {

										holes[h] = ahole.reverse();
								}
						}
				}

				var faces = __WEBPACK_IMPORTED_MODULE_8__extras_ShapeUtils_js__["a" /* ShapeUtils */].triangulateShape(vertices, holes);

				var contour = vertices;

				for (h = 0, hl = holes.length; h < hl; h++) {

						ahole = holes[h];

						vertices = vertices.concat(ahole);
				}

				function scalePt2(pt, vec, size) {

						if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");

						return vec.clone().multiplyScalar(size).add(pt);
				}

				var b,
				    bs,
				    t,
				    z,
				    vert,
				    vlen = vertices.length,
				    face,
				    flen = faces.length;

				function getBevelVec(inPt, inPrev, inNext) {

						var v_trans_x, v_trans_y, shrink_by;

						var v_prev_x = inPt.x - inPrev.x,
						    v_prev_y = inPt.y - inPrev.y;
						var v_next_x = inNext.x - inPt.x,
						    v_next_y = inNext.y - inPt.y;

						var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

						var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

						if (Math.abs(collinear0) > __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

								var v_prev_len = Math.sqrt(v_prev_lensq);
								var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

								var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
								var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;

								var ptNextShift_x = inNext.x - v_next_y / v_next_len;
								var ptNextShift_y = inNext.y + v_next_x / v_next_len;

								var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

								v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
								v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

								var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
								if (v_trans_lensq <= 2) {

										return new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](v_trans_x, v_trans_y);
								} else {

										shrink_by = Math.sqrt(v_trans_lensq / 2);
								}
						} else {

								var direction_eq = false;
								if (v_prev_x > __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

										if (v_next_x > __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

												direction_eq = true;
										}
								} else {

										if (v_prev_x < -__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

												if (v_next_x < -__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_number_epsilon___default.a) {

														direction_eq = true;
												}
										} else {

												if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign___default()(v_prev_y) === __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign___default()(v_next_y)) {

														direction_eq = true;
												}
										}
								}

								if (direction_eq) {
										v_trans_x = -v_prev_y;
										v_trans_y = v_prev_x;
										shrink_by = Math.sqrt(v_prev_lensq);
								} else {
										v_trans_x = v_prev_x;
										v_trans_y = v_prev_y;
										shrink_by = Math.sqrt(v_prev_lensq / 2);
								}
						}

						return new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				var contourMovements = [];

				for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

						if (j === il) j = 0;
						if (k === il) k = 0;

						contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
				}

				var holesMovements = [],
				    oneHoleMovements,
				    verticesMovements = contourMovements.concat();

				for (h = 0, hl = holes.length; h < hl; h++) {

						ahole = holes[h];

						oneHoleMovements = [];

						for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

								if (j === il) j = 0;
								if (k === il) k = 0;

								oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
						}

						holesMovements.push(oneHoleMovements);
						verticesMovements = verticesMovements.concat(oneHoleMovements);
				}

				for (b = 0; b < bevelSegments; b++) {

						t = b / bevelSegments;
						z = bevelThickness * Math.cos(t * Math.PI / 2);
						bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

						for (i = 0, il = contour.length; i < il; i++) {

								vert = scalePt2(contour[i], contourMovements[i], bs);

								v(vert.x, vert.y, -z);
						}

						for (h = 0, hl = holes.length; h < hl; h++) {

								ahole = holes[h];
								oneHoleMovements = holesMovements[h];

								for (i = 0, il = ahole.length; i < il; i++) {

										vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

										v(vert.x, vert.y, -z);
								}
						}
				}

				bs = bevelSize + bevelOffset;

				for (i = 0; i < vlen; i++) {

						vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

						if (!extrudeByPath) {

								v(vert.x, vert.y, 0);
						} else {

								normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
								binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

								position2.copy(extrudePts[0]).add(normal).add(binormal);

								v(position2.x, position2.y, position2.z);
						}
				}

				var s;

				for (s = 1; s <= steps; s++) {

						for (i = 0; i < vlen; i++) {

								vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

								if (!extrudeByPath) {

										v(vert.x, vert.y, depth / steps * s);
								} else {

										normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
										binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

										position2.copy(extrudePts[s]).add(normal).add(binormal);

										v(position2.x, position2.y, position2.z);
								}
						}
				}

				for (b = bevelSegments - 1; b >= 0; b--) {

						t = b / bevelSegments;
						z = bevelThickness * Math.cos(t * Math.PI / 2);
						bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

						for (i = 0, il = contour.length; i < il; i++) {

								vert = scalePt2(contour[i], contourMovements[i], bs);
								v(vert.x, vert.y, depth + z);
						}

						for (h = 0, hl = holes.length; h < hl; h++) {

								ahole = holes[h];
								oneHoleMovements = holesMovements[h];

								for (i = 0, il = ahole.length; i < il; i++) {

										vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

										if (!extrudeByPath) {

												v(vert.x, vert.y, depth + z);
										} else {

												v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
										}
								}
						}
				}

				buildLidFaces();

				buildSideFaces();

				function buildLidFaces() {

						var start = verticesArray.length / 3;

						if (bevelEnabled) {

								var layer = 0;
								var offset = vlen * layer;

								for (i = 0; i < flen; i++) {

										face = faces[i];
										f3(face[2] + offset, face[1] + offset, face[0] + offset);
								}

								layer = steps + bevelSegments * 2;
								offset = vlen * layer;

								for (i = 0; i < flen; i++) {

										face = faces[i];
										f3(face[0] + offset, face[1] + offset, face[2] + offset);
								}
						} else {

								for (i = 0; i < flen; i++) {

										face = faces[i];
										f3(face[2], face[1], face[0]);
								}

								for (i = 0; i < flen; i++) {

										face = faces[i];
										f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
								}
						}

						scope.addGroup(start, verticesArray.length / 3 - start, 0);
				}

				function buildSideFaces() {

						var start = verticesArray.length / 3;
						var layeroffset = 0;
						sidewalls(contour, layeroffset);
						layeroffset += contour.length;

						for (h = 0, hl = holes.length; h < hl; h++) {

								ahole = holes[h];
								sidewalls(ahole, layeroffset);

								layeroffset += ahole.length;
						}

						scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {

						var j, k;
						i = contour.length;

						while (--i >= 0) {

								j = i;
								k = i - 1;
								if (k < 0) k = contour.length - 1;

								var s = 0,
								    sl = steps + bevelSegments * 2;

								for (s = 0; s < sl; s++) {

										var slen1 = vlen * s;
										var slen2 = vlen * (s + 1);

										var a = layeroffset + j + slen1,
										    b = layeroffset + k + slen1,
										    c = layeroffset + k + slen2,
										    d = layeroffset + j + slen2;

										f4(a, b, c, d);
								}
						}
				}

				function v(x, y, z) {

						placeholder.push(x);
						placeholder.push(y);
						placeholder.push(z);
				}

				function f3(a, b, c) {

						addVertex(a);
						addVertex(b);
						addVertex(c);

						var nextIndex = verticesArray.length / 3;
						var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);

						addUV(uvs[0]);
						addUV(uvs[1]);
						addUV(uvs[2]);
				}

				function f4(a, b, c, d) {

						addVertex(a);
						addVertex(b);
						addVertex(d);

						addVertex(b);
						addVertex(c);
						addVertex(d);

						var nextIndex = verticesArray.length / 3;
						var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);

						addUV(uvs[0]);
						addUV(uvs[1]);
						addUV(uvs[3]);

						addUV(uvs[1]);
						addUV(uvs[2]);
						addUV(uvs[3]);
				}

				function addVertex(index) {

						verticesArray.push(placeholder[index * 3 + 0]);
						verticesArray.push(placeholder[index * 3 + 1]);
						verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {

						uvArray.push(vector2.x);
						uvArray.push(vector2.y);
				}
		}
}

ExtrudeBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_4__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON = function () {

		var data = __WEBPACK_IMPORTED_MODULE_4__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype.toJSON.call(this);

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON(shapes, options, data);
};

var WorldUVGenerator = {

		generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {

				var a_x = vertices[indexA * 3];
				var a_y = vertices[indexA * 3 + 1];
				var b_x = vertices[indexB * 3];
				var b_y = vertices[indexB * 3 + 1];
				var c_x = vertices[indexC * 3];
				var c_y = vertices[indexC * 3 + 1];

				return [new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](a_x, a_y), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](b_x, b_y), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](c_x, c_y)];
		},

		generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {

				var a_x = vertices[indexA * 3];
				var a_y = vertices[indexA * 3 + 1];
				var a_z = vertices[indexA * 3 + 2];
				var b_x = vertices[indexB * 3];
				var b_y = vertices[indexB * 3 + 1];
				var b_z = vertices[indexB * 3 + 2];
				var c_x = vertices[indexC * 3];
				var c_y = vertices[indexC * 3 + 1];
				var c_z = vertices[indexC * 3 + 2];
				var d_x = vertices[indexD * 3];
				var d_y = vertices[indexD * 3 + 1];
				var d_z = vertices[indexD * 3 + 2];

				if (Math.abs(a_y - b_y) < 0.01) {

						return [new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](a_x, 1 - a_z), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](b_x, 1 - b_z), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](c_x, 1 - c_z), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](d_x, 1 - d_z)];
				} else {

						return [new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](a_y, 1 - a_z), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](b_y, 1 - b_z), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](c_y, 1 - c_z), new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](d_y, 1 - d_z)];
				}
		}
};

function toJSON(shapes, options, data) {

		data.shapes = [];

		if (Array.isArray(shapes)) {

				for (var i = 0, l = shapes.length; i < l; i++) {

						var shape = shapes[i];

						data.shapes.push(shape.uuid);
				}
		} else {

				data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();

		return data;
}



/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextGeometry; });
/* unused harmony export TextBufferGeometry */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ExtrudeGeometry_js__ = __webpack_require__(275);






function TextGeometry(text, parameters) {

	__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].call(this);

	this.type = 'TextGeometry';

	this.parameters = {
		text: text,
		parameters: parameters
	};

	this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
	this.mergeVertices();
}

TextGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].prototype);
TextGeometry.prototype.constructor = TextGeometry;

function TextBufferGeometry(text, parameters) {

	parameters = parameters || {};

	var font = parameters.font;

	if (!(font && font.isFont)) {

		console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
		return new __WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */]();
	}

	var shapes = font.generateShapes(text, parameters.size);

	parameters.depth = parameters.height !== undefined ? parameters.height : 50;

	if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
	if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
	if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

	__WEBPACK_IMPORTED_MODULE_2__ExtrudeGeometry_js__["a" /* ExtrudeBufferGeometry */].call(this, shapes, parameters);

	this.type = 'TextBufferGeometry';
}

TextBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__ExtrudeGeometry_js__["a" /* ExtrudeBufferGeometry */].prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;



/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TubeGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TubeBufferGeometry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__ = __webpack_require__(2);









function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {

	__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].call(this);

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');

	var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);

	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;

	this.fromBufferGeometry(bufferGeometry);
	this.mergeVertices();
}

TubeGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__core_Geometry_js__["a" /* Geometry */].prototype);
TubeGeometry.prototype.constructor = TubeGeometry;

function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {

	__WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].call(this);

	this.type = 'TubeBufferGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var frames = path.computeFrenetFrames(tubularSegments, closed);

	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;

	var vertex = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
	var normal = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();
	var uv = new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */]();
	var P = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

	var i, j;

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	generateBufferData();

	this.setIndex(indices);
	this.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](vertices, 3));
	this.addAttribute('normal', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](normals, 3));
	this.addAttribute('uv', new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute_js__["b" /* Float32BufferAttribute */](uvs, 2));

	function generateBufferData() {

		for (i = 0; i < tubularSegments; i++) {

			generateSegment(i);
		}

		generateSegment(closed === false ? tubularSegments : 0);

		generateUVs();

		generateIndices();
	}

	function generateSegment(i) {

		P = path.getPointAt(i / tubularSegments, P);

		var N = frames.normals[i];
		var B = frames.binormals[i];

		for (j = 0; j <= radialSegments; j++) {

			var v = j / radialSegments * Math.PI * 2;

			var sin = Math.sin(v);
			var cos = -Math.cos(v);

			normal.x = cos * N.x + sin * B.x;
			normal.y = cos * N.y + sin * B.y;
			normal.z = cos * N.z + sin * B.z;
			normal.normalize();

			normals.push(normal.x, normal.y, normal.z);

			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;

			vertices.push(vertex.x, vertex.y, vertex.z);
		}
	}

	function generateIndices() {

		for (j = 1; j <= tubularSegments; j++) {

			for (i = 1; i <= radialSegments; i++) {

				var a = (radialSegments + 1) * (j - 1) + (i - 1);
				var b = (radialSegments + 1) * j + (i - 1);
				var c = (radialSegments + 1) * j + i;
				var d = (radialSegments + 1) * (j - 1) + i;

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}
	}

	function generateUVs() {

		for (i = 0; i <= tubularSegments; i++) {

			for (j = 0; j <= radialSegments; j++) {

				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;

				uvs.push(uv.x, uv.y);
			}
		}
	}
}

TubeBufferGeometry.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON = function () {

	var data = __WEBPACK_IMPORTED_MODULE_2__core_BufferGeometry_js__["a" /* BufferGeometry */].prototype.toJSON.call(this);

	data.path = this.parameters.path.toJSON();

	return data;
};



/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BoxHelper; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Box3_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objects_LineSegments_js__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__materials_LineBasicMaterial_js__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_BufferGeometry_js__ = __webpack_require__(18);









function BoxHelper(object, color) {

	this.object = object;

	if (color === undefined) color = 0xffff00;

	var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
	var positions = new Float32Array(8 * 3);

	var geometry = new __WEBPACK_IMPORTED_MODULE_5__core_BufferGeometry_js__["a" /* BufferGeometry */]();
	geometry.setIndex(new __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute_js__["k" /* BufferAttribute */](indices, 1));
	geometry.addAttribute('position', new __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute_js__["k" /* BufferAttribute */](positions, 3));

	__WEBPACK_IMPORTED_MODULE_2__objects_LineSegments_js__["a" /* LineSegments */].call(this, geometry, new __WEBPACK_IMPORTED_MODULE_3__materials_LineBasicMaterial_js__["a" /* LineBasicMaterial */]({ color: color }));

	this.matrixAutoUpdate = false;

	this.update();
}

BoxHelper.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__objects_LineSegments_js__["a" /* LineSegments */].prototype);
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = function () {

	var box = new __WEBPACK_IMPORTED_MODULE_1__math_Box3_js__["a" /* Box3 */]();

	return function update(object) {

		if (object !== undefined) {

			console.warn('THREE.BoxHelper: .update() has no longer arguments.');
		}

		if (this.object !== undefined) {

			box.setFromObject(this.object);
		}

		if (box.isEmpty()) return;

		var min = box.min;
		var max = box.max;

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[0] = max.x;array[1] = max.y;array[2] = max.z;
		array[3] = min.x;array[4] = max.y;array[5] = max.z;
		array[6] = min.x;array[7] = min.y;array[8] = max.z;
		array[9] = max.x;array[10] = min.y;array[11] = max.z;
		array[12] = max.x;array[13] = max.y;array[14] = min.z;
		array[15] = min.x;array[16] = max.y;array[17] = min.z;
		array[18] = min.x;array[19] = min.y;array[20] = min.z;
		array[21] = max.x;array[22] = min.y;array[23] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();
	};
}();

BoxHelper.prototype.setFromObject = function (object) {

	this.object = object;
	this.update();

	return this;
};

BoxHelper.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_2__objects_LineSegments_js__["a" /* LineSegments */].prototype.copy.call(this, source);

	this.object = source.object;

	return this;
};

BoxHelper.prototype.clone = function () {

	return new this.constructor().copy(this);
};



/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmbientLight; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Light_js__ = __webpack_require__(156);




function AmbientLight(color, intensity) {

	__WEBPACK_IMPORTED_MODULE_2__Light_js__["a" /* Light */].call(this, color, intensity);

	this.type = 'AmbientLight';

	this.castShadow = undefined;
}

AmbientLight.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Light_js__["a" /* Light */].prototype), {

	constructor: AmbientLight,

	isAmbientLight: true

});



/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectionalLight; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Light_js__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__DirectionalLightShadow_js__ = __webpack_require__(281);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_Object3D_js__ = __webpack_require__(14);






function DirectionalLight(color, intensity) {

	__WEBPACK_IMPORTED_MODULE_2__Light_js__["a" /* Light */].call(this, color, intensity);

	this.type = 'DirectionalLight';

	this.position.copy(__WEBPACK_IMPORTED_MODULE_4__core_Object3D_js__["a" /* Object3D */].DefaultUp);
	this.updateMatrix();

	this.target = new __WEBPACK_IMPORTED_MODULE_4__core_Object3D_js__["a" /* Object3D */]();

	this.shadow = new __WEBPACK_IMPORTED_MODULE_3__DirectionalLightShadow_js__["a" /* DirectionalLightShadow */]();
}

DirectionalLight.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Light_js__["a" /* Light */].prototype), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function copy(source) {

		__WEBPACK_IMPORTED_MODULE_2__Light_js__["a" /* Light */].prototype.copy.call(this, source);

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;
	}

});



/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectionalLightShadow; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LightShadow_js__ = __webpack_require__(282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cameras_OrthographicCamera_js__ = __webpack_require__(88);





function DirectionalLightShadow() {

  __WEBPACK_IMPORTED_MODULE_2__LightShadow_js__["a" /* LightShadow */].call(this, new __WEBPACK_IMPORTED_MODULE_3__cameras_OrthographicCamera_js__["a" /* OrthographicCamera */](-5, 5, 5, -5, 0.5, 500));
}

DirectionalLightShadow.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__LightShadow_js__["a" /* LightShadow */].prototype), {

  constructor: DirectionalLightShadow

});



/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LightShadow; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__ = __webpack_require__(4);




function LightShadow(camera) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](512, 512);

	this.map = null;
	this.matrix = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(LightShadow.prototype, {

	copy: function copy(source) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy(source.mapSize);

		return this;
	},

	clone: function clone() {

		return new this.constructor().copy(this);
	},

	toJSON: function toJSON() {

		var object = {};

		if (this.bias !== 0) object.bias = this.bias;
		if (this.radius !== 1) object.radius = this.radius;
		if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON(false).object;
		delete object.camera.matrix;

		return object;
	}

});



/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FontLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extras_core_Font_js__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__FileLoader_js__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LoadingManager_js__ = __webpack_require__(64);





function FontLoader(manager) {

	this.manager = manager !== undefined ? manager : __WEBPACK_IMPORTED_MODULE_3__LoadingManager_js__["a" /* DefaultLoadingManager */];
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(FontLoader.prototype, {

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new __WEBPACK_IMPORTED_MODULE_2__FileLoader_js__["a" /* FileLoader */](this.manager);
		loader.setPath(this.path);
		loader.load(url, function (text) {

			var json;

			try {

				json = JSON.parse(text);
			} catch (e) {

				console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
				json = JSON.parse(text.substring(65, text.length - 2));
			}

			var font = scope.parse(json);

			if (onLoad) onLoad(font);
		}, onProgress, onError);
	},

	parse: function parse(json) {

		return new __WEBPACK_IMPORTED_MODULE_1__extras_core_Font_js__["a" /* Font */](json);
	},

	setPath: function setPath(value) {

		this.path = value;
		return this;
	}

});



/***/ }),
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImageLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cache_js__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LoadingManager_js__ = __webpack_require__(64);






function ImageLoader(manager) {

		this.manager = manager !== undefined ? manager : __WEBPACK_IMPORTED_MODULE_2__LoadingManager_js__["a" /* DefaultLoadingManager */];
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(ImageLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function load(url, onLoad, onProgress, onError) {

				if (url === undefined) url = '';

				if (this.path !== undefined) url = this.path + url;

				url = this.manager.resolveURL(url);

				var scope = this;

				var cached = __WEBPACK_IMPORTED_MODULE_1__Cache_js__["a" /* Cache */].get(url);

				if (cached !== undefined) {

						scope.manager.itemStart(url);

						setTimeout(function () {

								if (onLoad) onLoad(cached);

								scope.manager.itemEnd(url);
						}, 0);

						return cached;
				}

				var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

				function onImageLoad() {

						image.removeEventListener('load', onImageLoad, false);
						image.removeEventListener('error', onImageError, false);

						__WEBPACK_IMPORTED_MODULE_1__Cache_js__["a" /* Cache */].add(url, this);

						if (onLoad) onLoad(this);

						scope.manager.itemEnd(url);
				}

				function onImageError(event) {

						image.removeEventListener('load', onImageLoad, false);
						image.removeEventListener('error', onImageError, false);

						if (onError) onError(event);

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
				}

				image.addEventListener('load', onImageLoad, false);
				image.addEventListener('error', onImageError, false);

				if (url.substr(0, 5) !== 'data:') {

						if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
				}

				scope.manager.itemStart(url);

				image.src = url;

				return image;
		},

		setCrossOrigin: function setCrossOrigin(value) {

				this.crossOrigin = value;
				return this;
		},

		setPath: function setPath(value) {

				this.path = value;
				return this;
		}

});



/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextureLoader; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ImageLoader_js__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__textures_Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LoadingManager_js__ = __webpack_require__(64);








function TextureLoader(manager) {

	this.manager = manager !== undefined ? manager : __WEBPACK_IMPORTED_MODULE_4__LoadingManager_js__["a" /* DefaultLoadingManager */];
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(TextureLoader.prototype, {

	crossOrigin: 'anonymous',

	load: function load(url, onLoad, onProgress, onError) {

		var texture = new __WEBPACK_IMPORTED_MODULE_3__textures_Texture_js__["a" /* Texture */]();

		var loader = new __WEBPACK_IMPORTED_MODULE_2__ImageLoader_js__["a" /* ImageLoader */](this.manager);
		loader.setCrossOrigin(this.crossOrigin);
		loader.setPath(this.path);

		loader.load(url, function (image) {

			texture.image = image;

			var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;

			texture.format = isJPEG ? __WEBPACK_IMPORTED_MODULE_1__constants_js__["b" /* RGBFormat */] : __WEBPACK_IMPORTED_MODULE_1__constants_js__["c" /* RGBAFormat */];
			texture.needsUpdate = true;

			if (onLoad !== undefined) {

				onLoad(texture);
			}
		}, onProgress, onError);

		return texture;
	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
		return this;
	},

	setPath: function setPath(value) {

		this.path = value;
		return this;
	}

});



/***/ }),
/* 286 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshDepthMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);




function MeshDepthMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].call(this);

	this.type = 'MeshDepthMaterial';

	this.depthPacking = __WEBPACK_IMPORTED_MODULE_2__constants_js__["L" /* BasicDepthPacking */];

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.setValues(parameters);
}

MeshDepthMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;
};



/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshDistanceMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__ = __webpack_require__(2);




function MeshDistanceMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].call(this);

	this.type = 'MeshDistanceMaterial';

	this.referencePosition = new __WEBPACK_IMPORTED_MODULE_2__math_Vector3_js__["a" /* Vector3 */]();
	this.nearDistance = 1;
	this.farDistance = 1000;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.fog = false;
	this.lights = false;

	this.setValues(parameters);
}

MeshDistanceMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.referencePosition.copy(source.referencePosition);
	this.nearDistance = source.nearDistance;
	this.farDistance = source.farDistance;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	return this;
};



/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshLambertMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Color_js__ = __webpack_require__(9);





function MeshLambertMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].call(this);

	this.type = 'MeshLambertMaterial';

	this.color = new __WEBPACK_IMPORTED_MODULE_3__math_Color_js__["a" /* Color */](0xffffff);

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new __WEBPACK_IMPORTED_MODULE_3__math_Color_js__["a" /* Color */](0x000000);
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = __WEBPACK_IMPORTED_MODULE_2__constants_js__["z" /* MultiplyOperation */];
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues(parameters);
}

MeshLambertMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_1__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.color.copy(source.color);

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy(source.emissive);
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;
};



/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MeshPhongMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Material_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Color_js__ = __webpack_require__(9);






function MeshPhongMaterial(parameters) {

	__WEBPACK_IMPORTED_MODULE_2__Material_js__["a" /* Material */].call(this);

	this.type = 'MeshPhongMaterial';

	this.color = new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0xffffff);
	this.specular = new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x111111);
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000);
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = __WEBPACK_IMPORTED_MODULE_1__constants_js__["A" /* TangentSpaceNormalMap */];
	this.normalScale = new __WEBPACK_IMPORTED_MODULE_3__math_Vector2_js__["a" /* Vector2 */](1, 1);

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = __WEBPACK_IMPORTED_MODULE_1__constants_js__["z" /* MultiplyOperation */];
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues(parameters);
}

MeshPhongMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__Material_js__["a" /* Material */].prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function (source) {

	__WEBPACK_IMPORTED_MODULE_2__Material_js__["a" /* Material */].prototype.copy.call(this, source);

	this.color.copy(source.color);
	this.specular.copy(source.specular);
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy(source.emissive);
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy(source.normalScale);

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;
};



/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RawShaderMaterial; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ShaderMaterial_js__ = __webpack_require__(50);



function RawShaderMaterial(parameters) {

  __WEBPACK_IMPORTED_MODULE_1__ShaderMaterial_js__["a" /* ShaderMaterial */].call(this, parameters);

  this.type = 'RawShaderMaterial';
}

RawShaderMaterial.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__ShaderMaterial_js__["a" /* ShaderMaterial */].prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;



/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Points; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Sphere_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Ray_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_Object3D_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__materials_PointsMaterial_js__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_BufferGeometry_js__ = __webpack_require__(18);











function Points(geometry, material) {

			__WEBPACK_IMPORTED_MODULE_6__core_Object3D_js__["a" /* Object3D */].call(this);

			this.type = 'Points';

			this.geometry = geometry !== undefined ? geometry : new __WEBPACK_IMPORTED_MODULE_9__core_BufferGeometry_js__["a" /* BufferGeometry */]();
			this.material = material !== undefined ? material : new __WEBPACK_IMPORTED_MODULE_8__materials_PointsMaterial_js__["a" /* PointsMaterial */]({ color: Math.random() * 0xffffff });

			this.updateMorphTargets();
}

Points.prototype = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_6__core_Object3D_js__["a" /* Object3D */].prototype), {

			constructor: Points,

			isPoints: true,

			raycast: function () {

						var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_5__math_Matrix4_js__["a" /* Matrix4 */]();
						var ray = new __WEBPACK_IMPORTED_MODULE_4__math_Ray_js__["a" /* Ray */]();
						var sphere = new __WEBPACK_IMPORTED_MODULE_3__math_Sphere_js__["a" /* Sphere */]();

						return function raycast(raycaster, intersects) {

									var object = this;
									var geometry = this.geometry;
									var matrixWorld = this.matrixWorld;
									var threshold = raycaster.params.Points.threshold;

									if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

									sphere.copy(geometry.boundingSphere);
									sphere.applyMatrix4(matrixWorld);
									sphere.radius += threshold;

									if (raycaster.ray.intersectsSphere(sphere) === false) return;

									inverseMatrix.getInverse(matrixWorld);
									ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

									var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
									var localThresholdSq = localThreshold * localThreshold;
									var position = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();
									var intersectPoint = new __WEBPACK_IMPORTED_MODULE_7__math_Vector3_js__["a" /* Vector3 */]();

									function testPoint(point, index) {

												var rayPointDistanceSq = ray.distanceSqToPoint(point);

												if (rayPointDistanceSq < localThresholdSq) {

															ray.closestPointToPoint(point, intersectPoint);
															intersectPoint.applyMatrix4(matrixWorld);

															var distance = raycaster.ray.origin.distanceTo(intersectPoint);

															if (distance < raycaster.near || distance > raycaster.far) return;

															intersects.push({

																		distance: distance,
																		distanceToRay: Math.sqrt(rayPointDistanceSq),
																		point: intersectPoint.clone(),
																		index: index,
																		face: null,
																		object: object

															});
												}
									}

									if (geometry.isBufferGeometry) {

												var index = geometry.index;
												var attributes = geometry.attributes;
												var positions = attributes.position.array;

												if (index !== null) {

															var indices = index.array;

															for (var i = 0, il = indices.length; i < il; i++) {

																		var a = indices[i];

																		position.fromArray(positions, a * 3);

																		testPoint(position, a);
															}
												} else {

															for (var i = 0, l = positions.length / 3; i < l; i++) {

																		position.fromArray(positions, i * 3);

																		testPoint(position, i);
															}
												}
									} else {

												var vertices = geometry.vertices;

												for (var i = 0, l = vertices.length; i < l; i++) {

															testPoint(vertices[i], i);
												}
									}
						};
			}(),

			updateMorphTargets: function updateMorphTargets() {

						var geometry = this.geometry;
						var m, ml, name;

						var morphAttributes = geometry.morphAttributes;
						var keys = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(morphAttributes);

						if (keys.length > 0) {

									var morphAttribute = morphAttributes[keys[0]];

									if (morphAttribute !== undefined) {

												this.morphTargetInfluences = [];
												this.morphTargetDictionary = {};

												for (m = 0, ml = morphAttribute.length; m < ml; m++) {

															name = morphAttribute[m].name || String(m);

															this.morphTargetInfluences.push(0);
															this.morphTargetDictionary[name] = m;
												}
									}
						}
			},

			clone: function clone() {

						return new this.constructor(this.geometry, this.material).copy(this);
			}

});



/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InstancedMesh; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Sphere__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Ray__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Triangle__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Matrix4__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Vector2__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_Face3__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__objects_Mesh__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__PMInstanceBufferGeometry__ = __webpack_require__(165);













function InstancedMesh(geometry, material) {

  __WEBPACK_IMPORTED_MODULE_10__objects_Mesh__["a" /* Mesh */].call(this, geometry, material);
  this.type = 'InstancedMesh';

  this.frustumCulled = false;
}
InstancedMesh.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_10__objects_Mesh__["a" /* Mesh */].prototype), {
  constructor: InstancedMesh,

  isInstanceMesh: true,

  raycast: function () {
    var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4__["a" /* Matrix4 */]();
    var ray = new __WEBPACK_IMPORTED_MODULE_4__math_Ray__["a" /* Ray */]();
    var sphere = new __WEBPACK_IMPORTED_MODULE_3__math_Sphere__["a" /* Sphere */]();

    var vA = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();
    var vB = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();
    var vC = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();
    var tempA = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();
    var tempB = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();
    var tempC = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();

    var uvA = new __WEBPACK_IMPORTED_MODULE_8__math_Vector2__["a" /* Vector2 */]();
    var uvB = new __WEBPACK_IMPORTED_MODULE_8__math_Vector2__["a" /* Vector2 */]();
    var uvC = new __WEBPACK_IMPORTED_MODULE_8__math_Vector2__["a" /* Vector2 */]();

    var barycoord = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();

    var intersectionPoint = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();
    var intersectionPointWorld = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3__["a" /* Vector3 */]();

    function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
      __WEBPACK_IMPORTED_MODULE_6__math_Triangle__["a" /* Triangle */].getBarycoord(point, p1, p2, p3, barycoord);

      uv1.multiplyScalar(barycoord.x);
      uv2.multiplyScalar(barycoord.y);
      uv3.multiplyScalar(barycoord.z);

      uv1.add(uv2).add(uv3);

      return uv1.clone();
    }

    function checkIntersection(object, itemMat, material, raycaster, ray, pA, pB, pC, point) {
      var intersect;
      if (material.side === __WEBPACK_IMPORTED_MODULE_2__constants__["g" /* BackSide */]) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== __WEBPACK_IMPORTED_MODULE_2__constants__["h" /* DoubleSide */], point);
      }
      if (intersect === null) return null;
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(itemMat);
      var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);

      if (distance < raycaster.near || distance > raycaster.far) return null;

      return {
        distance: distance,
        point: intersectionPointWorld.clone(),
        object: object
      };
    }

    function checkBufferGeometryIntersection(object, itemMat, material, raycaster, ray, position, uv, a, b, c) {
      vA.fromBufferAttribute(position, a);
      vB.fromBufferAttribute(position, b);
      vC.fromBufferAttribute(position, c);

      var intersection = checkIntersection(object, itemMat, material, raycaster, ray, vA, vB, vC, intersectionPoint);

      if (intersection) {
        if (uv) {
          uvA.fromBufferAttribute(uv, a);
          uvB.fromBufferAttribute(uv, b);
          uvC.fromBufferAttribute(uv, c);

          intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
        }

        var face = new __WEBPACK_IMPORTED_MODULE_9__core_Face3__["a" /* Face3 */](a, b, c);
        tempA.set(vA.x, vA.y, vA.z);
        tempA.applyMatrix4(itemMat);
        tempB.set(vB.x, vB.y, vB.z);
        tempB.applyMatrix4(itemMat);
        tempC.set(vC.x, vC.y, vC.z);
        tempC.applyMatrix4(itemMat);
        __WEBPACK_IMPORTED_MODULE_6__math_Triangle__["a" /* Triangle */].getNormal(tempA, tempB, tempC, face.normal);

        intersection.face = face;
      }
      return intersection;
    }

    return function raycast(raycaster, intersects) {
      if (!this.geometry || !this.material || !this.geometry.isPMInstanceBufferGeometry) {
        return;
      }

      var material = this.material;

      var geometry = this.geometry;
      var index = geometry.getIndex(__WEBPACK_IMPORTED_MODULE_2__constants__["e" /* DRAWMODE */].TRIANGLES);
      var position = geometry.getBufferAttribute('position');
      var uv = geometry.getBufferAttribute('uv');
      if (!index || !position) {
        return;
      }

      var start = 0;
      var end = index.count;
      var instanceMatR1 = geometry.getInstanceBufferAttribute(__WEBPACK_IMPORTED_MODULE_11__PMInstanceBufferGeometry__["b" /* PMInstanceAttribute */].MatrixR1.name);
      var instanceMatR2 = geometry.getInstanceBufferAttribute(__WEBPACK_IMPORTED_MODULE_11__PMInstanceBufferGeometry__["b" /* PMInstanceAttribute */].MatrixR2.name);
      var instanceMatR3 = geometry.getInstanceBufferAttribute(__WEBPACK_IMPORTED_MODULE_11__PMInstanceBufferGeometry__["b" /* PMInstanceAttribute */].MatrixR3.name);
      var instanceMatR4 = geometry.getInstanceBufferAttribute(__WEBPACK_IMPORTED_MODULE_11__PMInstanceBufferGeometry__["b" /* PMInstanceAttribute */].MatrixR4.name);
      if (!instanceMatR1 || !instanceMatR2 || !instanceMatR3 || !instanceMatR4) {
        return;
      }

      var matrixCount = instanceMatR1.count;
      var instanceCount = this.geometry.instancedCount;

      var pickMatrixIndexArray = geometry.getPickMatrixIndexArray();
      if (pickMatrixIndexArray.length === 0) {
        for (var i = 0; i < instanceCount; i++) {
          if (i < matrixCount) {
            pickMatrixIndexArray.push(i);
          }
        }
      }

      var tempMatrix = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4__["a" /* Matrix4 */]();

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();


      for (var _i = 0, il = pickMatrixIndexArray.length; _i < il; _i++) {
        var matrixIndex = pickMatrixIndexArray[_i];
        if (matrixIndex < 0 || matrixIndex >= matrixCount) {
          continue;
        }

        tempMatrix.set(instanceMatR1.array[matrixIndex * 4], instanceMatR2.array[matrixIndex * 4], instanceMatR3.array[matrixIndex * 4], instanceMatR4.array[matrixIndex * 4], instanceMatR1.array[matrixIndex * 4 + 1], instanceMatR2.array[matrixIndex * 4 + 1], instanceMatR3.array[matrixIndex * 4 + 1], instanceMatR4.array[matrixIndex * 4 + 1], instanceMatR1.array[matrixIndex * 4 + 2], instanceMatR2.array[matrixIndex * 4 + 2], instanceMatR3.array[matrixIndex * 4 + 2], instanceMatR4.array[matrixIndex * 4 + 2], instanceMatR1.array[matrixIndex * 4 + 3], instanceMatR2.array[matrixIndex * 4 + 3], instanceMatR3.array[matrixIndex * 4 + 3], instanceMatR4.array[matrixIndex * 4 + 3]);

        sphere.copy(geometry.boundingSphere);

        sphere.applyMatrix4(tempMatrix);

        if (raycaster.ray.intersectsSphere(sphere) === false) continue;

        inverseMatrix.getInverse(tempMatrix);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

        if (geometry.boundingBox !== null) {
          if (ray.intersectsBox(geometry.boundingBox) === false) continue;
        }
        var intersection;
        var a, b, c;

        for (var j = start, jl = end; j < jl; j += 3) {
          a = index.getX(j);
          b = index.getX(j + 1);
          c = index.getX(j + 2);

          intersection = checkBufferGeometryIntersection(this, tempMatrix, material, raycaster, ray, position, uv, a, b, c);

          if (intersection) {
            intersection.matrixIndex = matrixIndex;
            intersects.push(intersection);
          }
        }
      }
    };
  }()
});



/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PmLineSegments; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objects_Line_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Sphere__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Matrix4__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Ray__ = __webpack_require__(53);









function PmLineSegments(geometry, material) {

  __WEBPACK_IMPORTED_MODULE_2__objects_Line_js__["a" /* Line */].call(this, geometry, material);

  this.type = 'PmLineSegments';

  this.splitRegion = null;
}

PmLineSegments.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__objects_Line_js__["a" /* Line */].prototype), {

  constructor: PmLineSegments,

  isLineSegments: true,

  computeLineDistances: function () {

    var start = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
    var end = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();

    return function computeLineDistances() {

      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {

        if (geometry.index === null) {

          var positionAttribute = geometry.getBufferAttribute('position');
          var lineDistances = [];

          for (var i = 0, l = positionAttribute.count; i < l; i += 2) {

            start.fromBufferAttribute(positionAttribute, i);
            end.fromBufferAttribute(positionAttribute, i + 1);

            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
          }

          geometry.addAttribute('lineDistance', new __WEBPACK_IMPORTED_MODULE_4__core_BufferAttribute__["b" /* Float32BufferAttribute */](lineDistances, 1));
        } else {

          console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {

        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;

        for (var i = 0, l = vertices.length; i < l; i += 2) {

          start.copy(vertices[i]);
          end.copy(vertices[i + 1]);

          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
        }
      }

      return this;
    };
  }(),

  raycast: function () {

    var inverseMatrix = new __WEBPACK_IMPORTED_MODULE_6__math_Matrix4__["a" /* Matrix4 */]();
    var ray = new __WEBPACK_IMPORTED_MODULE_7__math_Ray__["a" /* Ray */]();
    var sphere = new __WEBPACK_IMPORTED_MODULE_5__math_Sphere__["a" /* Sphere */]();

    return function raycast(raycaster, intersects) {

      var precision = raycaster.linePrecision;
      var precisionSq = precision * precision;

      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);

      if (raycaster.ray.intersectsSphere(sphere) === false) return;

      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

      var vStart = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
      var vEnd = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
      var vRay2SPt = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
      var dDisRay2SPt = 0.0;
      var vRay2EPt = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
      var dDisRay2EPt = 0.0;
      var step = this && this.isLineSegments ? 2 : 1;

      var positions = geometry.getBufferAttribute('position').array;

      var rayPt = ray.origin.clone();
      rayPt.z = 0;

      var rayX = ray.origin.x;
      var rayY = ray.origin.y;
      var needBreak = false;
      if (geometry.regionMask) {
        var count = geometry.regionMask.length;
        for (var i = 0; i < count; i++) {
          var region = geometry.regionMask[i];
          if (rayX < region.min.x || rayX > region.max.x || rayY < region.min.y || rayY > region.max.y) {
            continue;
          }
          var index = undefined;
          var indexLength = region.index.length;
          for (var j = 0; j < indexLength; j++) {

            index = region.index[j];
            vStart.set(positions[3 * index], positions[3 * index + 1], 0);

            index += 1;
            vEnd.set(positions[3 * index], positions[3 * index + 1], 0);

            vRay2SPt.set(rayX - vStart.x, rayY - vStart.y, 0);
            vRay2EPt.set(rayX - vEnd.x, rayY - vEnd.y, 0);

            dDisRay2SPt = vRay2SPt.lengthSq();
            dDisRay2EPt = vRay2EPt.lengthSq();

            if (dDisRay2SPt < precisionSq) {
              intersects.push({
                distance: Math.sqrt(dDisRay2SPt),

                point: vStart.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
              needBreak = true;
              break;
            } else if (dDisRay2EPt < precisionSq) {
              intersects.push({
                distance: Math.sqrt(dDisRay2EPt),

                point: vEnd.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
              needBreak = true;
              break;
            }
          }

          if (needBreak) {
            break;
          }
        }
      } else {
        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {

          vStart.fromArray(positions, 3 * i);
          vEnd.fromArray(positions, 3 * i + 3);

          vRay2SPt.subVectors(rayPt, vStart);
          vRay2EPt.subVectors(rayPt, vEnd);

          dDisRay2SPt = vRay2SPt.lengthSq();
          dDisRay2EPt = vRay2EPt.lengthSq();

          if (dDisRay2SPt < precisionSq) {
            intersects.push({
              distance: Math.sqrt(dDisRay2SPt),

              point: vStart.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
            break;
          } else if (dDisRay2EPt < precisionSq) {
            intersects.push({
              distance: Math.sqrt(dDisRay2EPt),

              point: vEnd.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
            break;
          }
        }
      }
    };
  }()

});



/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VertexIndex; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_EventDispatcher__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__VertexIndexRange__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__constants__ = __webpack_require__(3);








function drawRangeSortStable(a, b) {

  return a.getOffset() - b.getOffset();
}

function VertexIndex(drawMode) {
  this.buffer = undefined;

  this.bufferAttribute = undefined;

  this.updateMode = 0;

  this.drawMode = drawMode;

  this.indexRangeArray = [];

  this.drawRangeArray = [];

  this.pickRangeArray = [];
}

VertexIndex.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_4__core_EventDispatcher__["a" /* EventDispatcher */].prototype), {
  constructor: VertexIndex,

  isVertexIndex: true,

  getDrawMode: function getDrawMode() {

    return this.drawMode;
  },

  setIndex: function setIndex(index) {

    this.bufferAttribute = new __WEBPACK_IMPORTED_MODULE_3__core_BufferAttribute__["d" /* Uint32BufferAttribute */](index, 1);

    this.addUpdateMode(__WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].UPDATEBUFFER);
  },

  getBufferAttribute: function getBufferAttribute() {

    return this.bufferAttribute;
  },

  addIndexRange: function addIndexRange(value) {
    if (!value) {
      return;
    }
    this.indexRangeArray.push(value);
    value.setVertexIndex(this);
    this.addUpdateMode(__WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].SORTINDEXRANGE | __WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].UNIONDRAWRANGE);
  },

  clearIndexRange: function clearIndexRange() {
    this.indexRangeArray = [];
  },

  getIndexRangeArray: function getIndexRangeArray() {
    return this.indexRangeArray;
  },

  getDrawRangeArray: function getDrawRangeArray() {
    return this.drawRangeArray;
  },

  addUpdateMode: function addUpdateMode(value) {
    this.updateMode |= value;
  },
  removeUpdateMode: function removeUpdateMode(value) {
    this.updateMode &= ~value;
  },

  addPickRange: function addPickRange(indexRange) {
    if (!indexRange) {
      return;
    }
    this.pickRangeArray.push(indexRange);
  },

  removePickRange: function removePickRange(indexRange) {
    if (!indexRange) {
      return;
    }

    for (var i = 0, il = this.pickRangeArray.length; i < il; i++) {
      if (indexRange === this.pickRangeArray[i]) {
        this.pickRangeArray.splice(i, 1);
        break;
      }
    }
  },

  clearPickRangeArray: function clearPickRangeArray() {
    this.pickRangeArray = [];
  },

  getPickRangeArray: function getPickRangeArray() {
    return this.pickRangeArray;
  },

  update: function update(gl) {

    if (0 === this.updateMode || !this.bufferAttribute) {
      return;
    }

    if (this.updateMode & __WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].UPDATEBUFFER) {
      if (this.buffer) {
        gl.deleteBuffer(this.buffer);
      }

      this.buffer = gl.createBuffer();

      if (!this.buffer) {

        return;
      }

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferAttribute.array, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      this.removeUpdateMode(__WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].UPDATEBUFFER);
    }

    if (this.updateMode & __WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].SORTINDEXRANGE) {
      this.indexRangeArray.sort(drawRangeSortStable);
      this.removeUpdateMode(__WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].SORTINDEXRANGE);
    }

    if (this.updateMode & __WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].UNIONDRAWRANGE) {

      this.drawRangeArray = [];

      var curRange = void 0;
      for (var i = 0, il = this.indexRangeArray.length; i < il; i++) {
        var temRange = this.indexRangeArray[i];
        if (!temRange.getVisible()) {
          continue;
        }
        if (!curRange || !curRange.union(temRange)) {
          curRange = new __WEBPACK_IMPORTED_MODULE_5__VertexIndexRange__["a" /* VertexIndexRange */]();
          curRange.setRange(temRange.getOffset(), temRange.getCount());
          curRange.setTransparency(temRange.getTransparency(), temRange.getOpacity());
          curRange.setDiffuse(temRange.getDiffuse());
          this.drawRangeArray.push(curRange);
        }
      }

      this.removeUpdateMode(__WEBPACK_IMPORTED_MODULE_6__constants__["f" /* INDEXUPDATEMODE */].UNIONDRAWRANGE);
    }
  },

  bind: function bind(gl) {

    if (!this.buffer) {
      return;
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
  },

  release: function release(gl) {

    if (this.buffer) {

      gl.deleteBuffer(this.buffer);

      this.buffer = undefined;
    }

    this.bufferAttribute = undefined;

    this.needUpdate = false;
  }
});



/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RenderPass; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EffectComposer__ = __webpack_require__(54);






function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {

	__WEBPACK_IMPORTED_MODULE_2__EffectComposer__["b" /* Pass */].call(this);

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	this.clear = true;
	this.clearDepth = false;
	this.needsSwap = false;
};

RenderPass.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__EffectComposer__["b" /* Pass */].prototype), {

	constructor: RenderPass,

	render: function render(renderer, writeBuffer, readBuffer) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.scene.overrideMaterial = this.overrideMaterial;

		var oldClearColor, oldClearAlpha;

		if (this.clearColor) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor(this.clearColor, this.clearAlpha);
		}

		if (this.clearDepth) {

			renderer.clearDepth();
		}

		renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);

		if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
		renderer.render(this.scene, this.camera);

		if (this.clearColor) {

			renderer.setClearColor(oldClearColor, oldClearAlpha);
		}

		this.scene.overrideMaterial = null;
		renderer.autoClear = oldAutoClear;
	}

});



/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SMAAPass; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderers_WebGLRenderTarget_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__textures_Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__SMAAShader_js__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__renderers_shaders_UniformsUtils_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__materials_ShaderMaterial_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__SMAAShader__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__EffectComposer__ = __webpack_require__(54);













function SMAAPass(width, height) {

	__WEBPACK_IMPORTED_MODULE_9__EffectComposer__["b" /* Pass */].call(this);

	this.edgesRT = new __WEBPACK_IMPORTED_MODULE_3__renderers_WebGLRenderTarget_js__["a" /* WebGLRenderTarget */](width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: __WEBPACK_IMPORTED_MODULE_2__constants_js__["a" /* LinearFilter */],
		format: __WEBPACK_IMPORTED_MODULE_2__constants_js__["b" /* RGBFormat */]
	});
	this.edgesRT.texture.name = "SMAAPass.edges";

	this.weightsRT = new __WEBPACK_IMPORTED_MODULE_3__renderers_WebGLRenderTarget_js__["a" /* WebGLRenderTarget */](width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: __WEBPACK_IMPORTED_MODULE_2__constants_js__["a" /* LinearFilter */],
		format: __WEBPACK_IMPORTED_MODULE_2__constants_js__["c" /* RGBAFormat */]
	});
	this.weightsRT.texture.name = "SMAAPass.weights";

	var scope = this;

	var areaTextureImage = new Image();
	areaTextureImage.src = this.getAreaTexture();
	areaTextureImage.onload = function () {
		scope.areaTexture.needsUpdate = true;
	};

	this.areaTexture = new __WEBPACK_IMPORTED_MODULE_4__textures_Texture_js__["a" /* Texture */]();
	this.areaTexture.name = "SMAAPass.area";
	this.areaTexture.image = areaTextureImage;
	this.areaTexture.format = __WEBPACK_IMPORTED_MODULE_2__constants_js__["b" /* RGBFormat */];
	this.areaTexture.minFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["a" /* LinearFilter */];
	this.areaTexture.generateMipmaps = false;
	this.areaTexture.flipY = false;

	var searchTextureImage = new Image();
	searchTextureImage.src = this.getSearchTexture();
	searchTextureImage.onload = function () {
		scope.searchTexture.needsUpdate = true;
	};

	this.searchTexture = new __WEBPACK_IMPORTED_MODULE_4__textures_Texture_js__["a" /* Texture */]();
	this.searchTexture.name = "SMAAPass.search";
	this.searchTexture.image = searchTextureImage;
	this.searchTexture.magFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];
	this.searchTexture.minFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];
	this.searchTexture.generateMipmaps = false;
	this.searchTexture.flipY = false;

	if (__WEBPACK_IMPORTED_MODULE_5__SMAAShader_js__["a" /* SMAAEdgesShader */] === undefined) {

		console.error("THREE.SMAAPass relies on THREE.SMAAShader");
	}

	this.uniformsEdges = __WEBPACK_IMPORTED_MODULE_6__renderers_shaders_UniformsUtils_js__["c" /* clone */](__WEBPACK_IMPORTED_MODULE_5__SMAAShader_js__["a" /* SMAAEdgesShader */].uniforms);

	this.uniformsEdges["resolution"].value.set(1 / width, 1 / height);

	this.materialEdges = new __WEBPACK_IMPORTED_MODULE_7__materials_ShaderMaterial_js__["a" /* ShaderMaterial */]({
		defines: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, __WEBPACK_IMPORTED_MODULE_5__SMAAShader_js__["a" /* SMAAEdgesShader */].defines),
		uniforms: this.uniformsEdges,
		vertexShader: __WEBPACK_IMPORTED_MODULE_5__SMAAShader_js__["a" /* SMAAEdgesShader */].vertexShader,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_5__SMAAShader_js__["a" /* SMAAEdgesShader */].fragmentShader
	});

	this.uniformsWeights = __WEBPACK_IMPORTED_MODULE_6__renderers_shaders_UniformsUtils_js__["c" /* clone */](__WEBPACK_IMPORTED_MODULE_8__SMAAShader__["b" /* SMAAWeightsShader */].uniforms);

	this.uniformsWeights["resolution"].value.set(1 / width, 1 / height);
	this.uniformsWeights["tDiffuse"].value = this.edgesRT.texture;
	this.uniformsWeights["tArea"].value = this.areaTexture;
	this.uniformsWeights["tSearch"].value = this.searchTexture;

	this.materialWeights = new __WEBPACK_IMPORTED_MODULE_7__materials_ShaderMaterial_js__["a" /* ShaderMaterial */]({
		defines: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()({}, __WEBPACK_IMPORTED_MODULE_8__SMAAShader__["b" /* SMAAWeightsShader */].defines),
		uniforms: this.uniformsWeights,
		vertexShader: __WEBPACK_IMPORTED_MODULE_8__SMAAShader__["b" /* SMAAWeightsShader */].vertexShader,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_8__SMAAShader__["b" /* SMAAWeightsShader */].fragmentShader
	});

	this.uniformsBlend = __WEBPACK_IMPORTED_MODULE_6__renderers_shaders_UniformsUtils_js__["c" /* clone */](__WEBPACK_IMPORTED_MODULE_8__SMAAShader__["c" /* SMAABlendShader */].uniforms);

	this.uniformsBlend["resolution"].value.set(1 / width, 1 / height);
	this.uniformsBlend["tDiffuse"].value = this.weightsRT.texture;

	this.materialBlend = new __WEBPACK_IMPORTED_MODULE_7__materials_ShaderMaterial_js__["a" /* ShaderMaterial */]({
		uniforms: this.uniformsBlend,
		vertexShader: __WEBPACK_IMPORTED_MODULE_8__SMAAShader__["c" /* SMAABlendShader */].vertexShader,
		fragmentShader: __WEBPACK_IMPORTED_MODULE_8__SMAAShader__["c" /* SMAABlendShader */].fragmentShader
	});

	this.needsSwap = false;

	this.fsQuad = new __WEBPACK_IMPORTED_MODULE_9__EffectComposer__["b" /* Pass */].FullScreenQuad(null);
};

SMAAPass.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_9__EffectComposer__["b" /* Pass */].prototype), {

	constructor: SMAAPass,

	render: function render(renderer, writeBuffer, readBuffer) {

		this.uniformsEdges["tDiffuse"].value = readBuffer.texture;

		this.fsQuad.material = this.materialEdges;

		renderer.setRenderTarget(this.edgesRT);
		if (this.clear) renderer.clear();
		this.fsQuad.render(renderer);

		this.fsQuad.material = this.materialWeights;

		renderer.setRenderTarget(this.weightsRT);
		if (this.clear) renderer.clear();
		this.fsQuad.render(renderer);

		this.uniformsBlend["tColor"].value = readBuffer.texture;

		this.fsQuad.material = this.materialBlend;

		if (this.renderToScreen) {

			renderer.setRenderTarget(null);
			this.fsQuad.render(renderer);
		} else {

			renderer.setRenderTarget(writeBuffer);
			if (this.clear) renderer.clear();
			this.fsQuad.render(renderer);
		}
	},

	setSize: function setSize(width, height) {

		this.edgesRT.setSize(width, height);
		this.weightsRT.setSize(width, height);

		this.materialEdges.uniforms['resolution'].value.set(1 / width, 1 / height);
		this.materialWeights.uniforms['resolution'].value.set(1 / width, 1 / height);
		this.materialBlend.uniforms['resolution'].value.set(1 / width, 1 / height);
	},

	getAreaTexture: function getAreaTexture() {

		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';
	},

	getSearchTexture: function getSearchTexture() {

		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';
	}

});



/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SSAARenderPass; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__CopyShader__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderers_shaders_UniformsUtils__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__materials_ShaderMaterial__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__EffectComposer__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__renderers_WebGLRenderTarget__ = __webpack_require__(65);











function SSAARenderPass(scene, camera, clearColor, clearAlpha) {

	__WEBPACK_IMPORTED_MODULE_6__EffectComposer__["b" /* Pass */].call(this);

	this.scene = scene;
	this.camera = camera;

	this.sampleLevel = 4;
	this.unbiased = true;

	this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	if (__WEBPACK_IMPORTED_MODULE_2__CopyShader__["a" /* CopyShader */] === undefined) console.error("THREE.SSAARenderPass relies on THREE.CopyShader");

	var copyShader = __WEBPACK_IMPORTED_MODULE_2__CopyShader__["a" /* CopyShader */];
	this.copyUniforms = __WEBPACK_IMPORTED_MODULE_3__renderers_shaders_UniformsUtils__["c" /* clone */](copyShader.uniforms);

	this.copyMaterial = new __WEBPACK_IMPORTED_MODULE_4__materials_ShaderMaterial__["a" /* ShaderMaterial */]({
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		premultipliedAlpha: true,
		transparent: true,
		blending: __WEBPACK_IMPORTED_MODULE_5__constants__["q" /* AdditiveBlending */],
		depthTest: false,
		depthWrite: false
	});

	this.fsQuad = new THREE.Pass.FullScreenQuad(this.copyMaterial);
};

SSAARenderPass.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_6__EffectComposer__["b" /* Pass */].prototype), {

	constructor: SSAARenderPass,

	dispose: function dispose() {

		if (this.sampleRenderTarget) {

			this.sampleRenderTarget.dispose();
			this.sampleRenderTarget = null;
		}
	},

	setSize: function setSize(width, height) {

		if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);
	},

	render: function render(renderer, writeBuffer, readBuffer) {

		if (!this.sampleRenderTarget) {

			this.sampleRenderTarget = new __WEBPACK_IMPORTED_MODULE_7__renderers_WebGLRenderTarget__["a" /* WebGLRenderTarget */](readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.sampleRenderTarget.texture.name = "SSAARenderPass.sample";
		}

		var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var oldClearColor = renderer.getClearColor().getHex();
		var oldClearAlpha = renderer.getClearAlpha();

		var baseSampleWeight = 1.0 / jitterOffsets.length;
		var roundingRange = 1 / 32;
		this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;

		var width = readBuffer.width,
		    height = readBuffer.height;

		for (var i = 0; i < jitterOffsets.length; i++) {

			var jitterOffset = jitterOffsets[i];

			if (this.camera.setViewOffset) {

				this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, width, height);
			}

			var sampleWeight = baseSampleWeight;

			if (this.unbiased) {

				var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;
				sampleWeight += roundingRange * uniformCenteredDistribution;
			}

			this.copyUniforms["opacity"].value = sampleWeight;
			renderer.setClearColor(this.clearColor, this.clearAlpha);
			renderer.setRenderTarget(this.sampleRenderTarget);
			renderer.clear();
			renderer.render(this.scene, this.camera);

			renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);

			if (i === 0) {

				renderer.setClearColor(0x000000, 0.0);
				renderer.clear();
			}

			this.fsQuad.render(renderer);
		}

		if (this.camera.clearViewOffset) this.camera.clearViewOffset();

		renderer.autoClear = autoClear;
		renderer.setClearColor(oldClearColor, oldClearAlpha);
	}

});

SSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];



/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Math_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textures_DataTexture_js__ = __webpack_require__(452);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Frustum_js__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shaders_ShaderLib_js__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shaders_UniformsLib_js__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__math_Vector4_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__webgl_WebGLAnimation_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__webgl_WebGLAttributes_js__ = __webpack_require__(426);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__webgl_WebGLBackground_js__ = __webpack_require__(427);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__webgl_WebGLBufferRenderer_js__ = __webpack_require__(428);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__webgl_WebGLCapabilities_js__ = __webpack_require__(429);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__webgl_WebGLClipping_js__ = __webpack_require__(430);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__webgl_WebGLExtensions_js__ = __webpack_require__(431);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__webgl_WebGLGeometries_js__ = __webpack_require__(432);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__webgl_WebGLIndexedBufferRenderer_js__ = __webpack_require__(433);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__webgl_WebGLInfo_js__ = __webpack_require__(434);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__webgl_WebGLMorphtargets_js__ = __webpack_require__(436);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__webgl_WebGLObjects_js__ = __webpack_require__(437);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__webgl_WebGLPrograms_js__ = __webpack_require__(439);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__webgl_WebGLProperties_js__ = __webpack_require__(440);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__webgl_WebGLRenderLists_js__ = __webpack_require__(441);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__webgl_WebGLRenderStates_js__ = __webpack_require__(442);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__webgl_WebGLShadowMap_js__ = __webpack_require__(444);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__webgl_WebGLState_js__ = __webpack_require__(445);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__webgl_WebGLTextures_js__ = __webpack_require__(446);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__webgl_WebGLUniforms_js__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__webgl_WebGLUtils_js__ = __webpack_require__(447);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__webvr_WebVRManager_js__ = __webpack_require__(448);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__webvr_WebXRManager_js__ = __webpack_require__(449);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__math_Color__ = __webpack_require__(9);





































function WebGLRenderer(parameters) {

	console.log('THREE.WebGLRenderer', __WEBPACK_IMPORTED_MODULE_0__constants_js__["B" /* REVISION */]);

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
	    _context = parameters.context !== undefined ? parameters.context : null,
	    _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	    _depth = parameters.depth !== undefined ? parameters.depth : true,
	    _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	    _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	    _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	    _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	    _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
	    _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	var currentRenderList = null;
	var currentRenderState = null;

	this.domElement = _canvas;
	this.context = null;

	this.debug = {
		checkShaderErrors: true
	};

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	this.sortObjects = true;

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	this.gammaFactor = 2.0;
	this.gammaInput = false;
	this.gammaOutput = false;

	this.physicallyCorrectLights = false;

	this.toneMapping = __WEBPACK_IMPORTED_MODULE_0__constants_js__["C" /* LinearToneMapping */];
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	var _this = this,
	    _isContextLost = false,
	    _framebuffer = null,
	    _currentActiveCubeFace = 0,
	    _currentActiveMipmapLevel = 0,
	    _currentRenderTarget = null,
	    _currentFramebuffer = null,
	    _currentMaterialId = -1,
	    _currentGeometryProgram = {
		geometry: null,
		program: null,
		wireframe: false
	},
	    _currentCamera = null,
	    _currentArrayCamera = null,
	    _currentViewport = new __WEBPACK_IMPORTED_MODULE_10__math_Vector4_js__["a" /* Vector4 */](),
	    _currentScissor = new __WEBPACK_IMPORTED_MODULE_10__math_Vector4_js__["a" /* Vector4 */](),
	    _currentScissorTest = null,
	    _width = _canvas.width,
	    _height = _canvas.height,
	    _pixelRatio = 1,
	    _viewport = new __WEBPACK_IMPORTED_MODULE_10__math_Vector4_js__["a" /* Vector4 */](0, 0, _width, _height),
	    _scissor = new __WEBPACK_IMPORTED_MODULE_10__math_Vector4_js__["a" /* Vector4 */](0, 0, _width, _height),
	    _scissorTest = false,
	    _frustum = new __WEBPACK_IMPORTED_MODULE_3__math_Frustum_js__["a" /* Frustum */](),
	    _clipping = new __WEBPACK_IMPORTED_MODULE_16__webgl_WebGLClipping_js__["a" /* WebGLClipping */](),
	    _clippingEnabled = false,
	    _localClippingEnabled = false,
	    _projScreenMatrix = new __WEBPACK_IMPORTED_MODULE_4__math_Matrix4_js__["a" /* Matrix4 */](),
	    _vector3 = new __WEBPACK_IMPORTED_MODULE_9__math_Vector3_js__["a" /* Vector3 */]();

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;
	}

	var _gl;

	try {

		var contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
			xrCompatible: true
		};

		_canvas.addEventListener('webglcontextlost', onContextLost, false);
		_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

		_gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

		if (_gl === null) {

			if (_canvas.getContext('webgl') !== null) {

				throw new Error('Error creating WebGL context with your selected attributes.');
			} else {

				throw new Error('Error creating WebGL context.');
			}
		}

		if (_gl.getShaderPrecisionFormat === undefined) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
			};
		}
	} catch (error) {

		console.error('THREE.WebGLRenderer: ' + error.message);
		throw error;
	}

	var extensions, capabilities, state, info;
	var properties, textures, attributes, geometries, objects;
	var programCache, renderLists, renderStates;

	var background, morphtargets, bufferRenderer, indexedBufferRenderer;

	var utils;

	function initGLContext() {

		extensions = new __WEBPACK_IMPORTED_MODULE_17__webgl_WebGLExtensions_js__["a" /* WebGLExtensions */](_gl);

		capabilities = new __WEBPACK_IMPORTED_MODULE_15__webgl_WebGLCapabilities_js__["a" /* WebGLCapabilities */](_gl, extensions, parameters);

		if (!capabilities.isWebGL2) {

			extensions.get('WEBGL_depth_texture');
			extensions.get('OES_texture_float');
			extensions.get('OES_texture_half_float');
			extensions.get('OES_texture_half_float_linear');
			extensions.get('OES_standard_derivatives');
			extensions.get('OES_element_index_uint');
			extensions.get('ANGLE_instanced_arrays');
		}

		extensions.get('OES_texture_float_linear');

		utils = new __WEBPACK_IMPORTED_MODULE_31__webgl_WebGLUtils_js__["a" /* WebGLUtils */](_gl, extensions, capabilities);

		state = new __WEBPACK_IMPORTED_MODULE_28__webgl_WebGLState_js__["a" /* WebGLState */](_gl, extensions, utils, capabilities);
		state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
		state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

		info = new __WEBPACK_IMPORTED_MODULE_20__webgl_WebGLInfo_js__["a" /* WebGLInfo */](_gl);
		properties = new __WEBPACK_IMPORTED_MODULE_24__webgl_WebGLProperties_js__["a" /* WebGLProperties */]();
		textures = new __WEBPACK_IMPORTED_MODULE_29__webgl_WebGLTextures_js__["a" /* WebGLTextures */](_gl, extensions, state, properties, capabilities, utils, info, parameters.useOffScreenCanvas);
		attributes = new __WEBPACK_IMPORTED_MODULE_12__webgl_WebGLAttributes_js__["a" /* WebGLAttributes */](_gl);
		geometries = new __WEBPACK_IMPORTED_MODULE_18__webgl_WebGLGeometries_js__["a" /* WebGLGeometries */](_gl, attributes, info);
		objects = new __WEBPACK_IMPORTED_MODULE_22__webgl_WebGLObjects_js__["a" /* WebGLObjects */](geometries, info);
		morphtargets = new __WEBPACK_IMPORTED_MODULE_21__webgl_WebGLMorphtargets_js__["a" /* WebGLMorphtargets */](_gl);
		programCache = new __WEBPACK_IMPORTED_MODULE_23__webgl_WebGLPrograms_js__["a" /* WebGLPrograms */](_this, extensions, capabilities);
		renderLists = new __WEBPACK_IMPORTED_MODULE_25__webgl_WebGLRenderLists_js__["a" /* WebGLRenderLists */]();
		renderStates = new __WEBPACK_IMPORTED_MODULE_26__webgl_WebGLRenderStates_js__["a" /* WebGLRenderStates */]();

		background = new __WEBPACK_IMPORTED_MODULE_13__webgl_WebGLBackground_js__["a" /* WebGLBackground */](_this, state, objects, _premultipliedAlpha);

		bufferRenderer = new __WEBPACK_IMPORTED_MODULE_14__webgl_WebGLBufferRenderer_js__["a" /* WebGLBufferRenderer */](_gl, extensions, info, capabilities);
		indexedBufferRenderer = new __WEBPACK_IMPORTED_MODULE_19__webgl_WebGLIndexedBufferRenderer_js__["a" /* WebGLIndexedBufferRenderer */](_gl, extensions, info, capabilities);

		info.programs = programCache.programs;

		_this.context = _gl;
		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
		_this.info = info;
	}

	initGLContext();

	var vr = typeof navigator !== 'undefined' && 'xr' in navigator && 'supportsSession' in navigator.xr ? new __WEBPACK_IMPORTED_MODULE_33__webvr_WebXRManager_js__["a" /* WebXRManager */](_this) : new __WEBPACK_IMPORTED_MODULE_32__webvr_WebVRManager_js__["a" /* WebVRManager */](_this);

	this.vr = vr;

	var shadowMap = new __WEBPACK_IMPORTED_MODULE_27__webgl_WebGLShadowMap_js__["a" /* WebGLShadowMap */](_this, objects, capabilities.maxTextureSize);

	this.shadowMap = shadowMap;

	this.getContext = function () {

		return _gl;
	};

	this.getFrustum = function () {

		return _frustum;
	};

	this.getRenderList = function (scene, camera, sortObjects) {
		var temRenderList = undefined;
		if (scene.visible === false) {
			return temRenderList;
		}

		if (scene.autoUpdate === true) scene.updateMatrixWorld();

		if (camera.parent === null) camera.updateMatrixWorld();

		currentRenderState = renderStates.get(scene, camera);
		currentRenderState.init();

		_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		_frustum.setFromMatrix(_projScreenMatrix);

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

		temRenderList = renderLists.get(scene, camera);
		temRenderList.init();
		var oldRenderList = currentRenderList;
		currentRenderList = temRenderList;

		var temRenderState = renderStates.get(scene, camera);
		temRenderState.init();
		var oldRenderState = currentRenderState;
		currentRenderState = temRenderState;

		projectObject(scene, camera, sortObjects);
		currentRenderList = oldRenderList;
		currentRenderState = oldRenderState;
		temRenderState = null;
		return temRenderList;
	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();
	};

	this.forceContextLoss = function () {

		var extension = extensions.get('WEBGL_lose_context');
		if (extension) extension.loseContext();
	};

	this.forceContextRestore = function () {

		var extension = extensions.get('WEBGL_lose_context');
		if (extension) extension.restoreContext();
	};

	this.getPixelRatio = function () {

		return _pixelRatio;
	};

	this.setPixelRatio = function (value) {

		if (value === undefined) return;

		_pixelRatio = value;

		this.setSize(_width, _height, false);
	};

	this.getSize = function (target) {

		if (target === undefined) {

			console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');

			target = new __WEBPACK_IMPORTED_MODULE_8__math_Vector2_js__["a" /* Vector2 */]();
		}

		return target.set(_width, _height);
	};

	this.setSize = function (width, height, updateStyle) {

		if (vr.isPresenting()) {

			console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
			return;
		}

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if (updateStyle !== false) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';
		}

		this.setViewport(0, 0, width, height);
	};

	this.getDrawingBufferSize = function (target) {

		if (target === undefined) {

			console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');

			target = new __WEBPACK_IMPORTED_MODULE_8__math_Vector2_js__["a" /* Vector2 */]();
		}

		return target.set(_width * _pixelRatio, _height * _pixelRatio);
	};

	this.setDrawingBufferSize = function (width, height, pixelRatio) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		this.setViewport(0, 0, width, height);
	};

	this.getCurrentViewport = function (target) {

		if (target === undefined) {

			console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');

			target = new __WEBPACK_IMPORTED_MODULE_10__math_Vector4_js__["a" /* Vector4 */]();
		}

		return target.copy(_currentViewport);
	};

	this.getViewport = function (target) {

		return target.copy(_viewport);
	};

	this.setViewport = function (x, y, width, height) {

		if (x.isVector4) {

			_viewport.set(x.x, x.y, x.z, x.w);
		} else {

			_viewport.set(x, y, width, height);
		}

		state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
	};

	this.getScissor = function (target) {

		return target.copy(_scissor);
	};

	this.setScissor = function (x, y, width, height) {

		if (x.isVector4) {

			_scissor.set(x.x, x.y, x.z, x.w);
		} else {

			_scissor.set(x, y, width, height);
		}

		state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
	};

	this.getScissorTest = function () {

		return _scissorTest;
	};

	this.setScissorTest = function (boolean) {

		state.setScissorTest(_scissorTest = boolean);
	};

	this.getClearColor = function () {

		return background.getClearColor();
	};

	this.setClearColor = function () {

		background.setClearColor.apply(background, arguments);
	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();
	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply(background, arguments);
	};

	this.clear = function (color, depth, stencil) {

		var bits = 0;

		if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
		if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
		if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear(bits);
	};

	this.clearColor = function () {

		this.clear(true, false, false);
	};

	this.clearDepth = function () {

		this.clear(false, true, false);
	};

	this.clearStencil = function () {

		this.clear(false, false, true);
	};

	this.dispose = function () {

		_canvas.removeEventListener('webglcontextlost', onContextLost, false);
		_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		objects.dispose();

		vr.dispose();

		animation.stop();
	};

	function onContextLost(event) {

		event.preventDefault();

		console.log('THREE.WebGLRenderer: Context Lost.');

		_isContextLost = true;
	}

	function onContextRestore() {

		console.log('THREE.WebGLRenderer: Context Restored.');

		_isContextLost = false;

		initGLContext();
	}

	function onMaterialDispose(event) {

		var material = event.target;

		material.removeEventListener('dispose', onMaterialDispose);

		deallocateMaterial(material);
	}

	function deallocateMaterial(material) {

		releaseMaterialProgramReference(material);

		properties.remove(material);
	}

	function releaseMaterialProgramReference(material) {

		var programInfo = properties.get(material).program;

		material.program = undefined;

		if (programInfo !== undefined) {

			programCache.releaseProgram(programInfo);
		}
	}

	function renderObjectImmediate(object, program) {

		object.render(function (object) {

			_this.renderBufferImmediate(object, program);
		});
	}

	this.renderBufferImmediate = function (object, program) {

		state.initAttributes();

		var buffers = properties.get(object);

		if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
		if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
		if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
		if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

		var programAttributes = program.getAttributes();

		if (object.hasPositions) {

			_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
			_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

			state.enableAttribute(programAttributes.position);
			_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
		}

		if (object.hasNormals) {

			_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
			_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

			state.enableAttribute(programAttributes.normal);
			_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
		}

		if (object.hasUvs) {

			_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
			_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

			state.enableAttribute(programAttributes.uv);
			_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
		}

		if (object.hasColors) {

			_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
			_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

			state.enableAttribute(programAttributes.color);
			_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
		}

		state.disableUnusedAttributes();

		_gl.drawArrays(_gl.TRIANGLES, 0, object.count);

		object.count = 0;
	};
	this.lookupSingleUniform = function (uniformList, name) {
		for (var k = 0, kl = uniformList.length; k < kl; k++) {
			if (uniformList[k].id === name) {
				return uniformList[k];
			}
		}
		return undefined;
	};
	this.renderPMBufferGeometry = function (geometry, state, program, material, isTransparentList) {
		if (geometry.isPMInstanceBufferGeometry) {
			if (geometry.getTransparency() === undefined) {
				if (material.transparent !== isTransparentList) {
					return;
				}
			} else {
				if (geometry.getTransparency() !== isTransparentList) {
					return;
				}
			}
		}

		var renderer = indexedBufferRenderer;

		state.initAttributes();

		var attributeArray = geometry.getAttributeArray();
		attributeArray.bind(_gl, program, state, 0);

		if (geometry.isPMInstanceBufferGeometry) {

			var instanceAttributeArray = geometry.getInstanceAttributeArray();
			instanceAttributeArray.bind(_gl, program, state, 1);
		}

		var curDiffuse = undefined;
		var curOpacity = undefined;
		var uniformList = properties.get(material).uniformsList;
		var uploadOpacity = undefined;
		var uploadDiffuse = undefined;
		var uploadDisableMap = undefined;

		var indexArray = geometry.getIndexArray();
		for (var i = 0, il = indexArray.length; i < il; i++) {

			var indexAttribute = indexArray[i];

			switch (indexAttribute.getDrawMode()) {

				case __WEBPACK_IMPORTED_MODULE_34__constants__["e" /* DRAWMODE */].TRIANGLES:
					renderer.setMode(_gl.TRIANGLES);
					break;

				case __WEBPACK_IMPORTED_MODULE_34__constants__["e" /* DRAWMODE */].TRIANGLE_STRIP:
					renderer.setMode(_gl.TRIANGLE_STRIP);
					break;

				case __WEBPACK_IMPORTED_MODULE_34__constants__["e" /* DRAWMODE */].TRIANGLE_FAN:
					renderer.setMode(_gl.TRIANGLE_FAN);
					break;
				case __WEBPACK_IMPORTED_MODULE_34__constants__["e" /* DRAWMODE */].LINES:
					renderer.setMode(_gl.LINES);
					break;
				case __WEBPACK_IMPORTED_MODULE_34__constants__["e" /* DRAWMODE */].LINE_LOOP:
					renderer.setMode(_gl.LINE_LOOP);
					break;
				case __WEBPACK_IMPORTED_MODULE_34__constants__["e" /* DRAWMODE */].LINE_STRIP:
					renderer.setMode(_gl.LINE_STRIP);
					break;
			}

			indexAttribute.bind(_gl);

			renderer.setIndex({
				type: _gl.UNSIGNED_INT,
				bytesPerElement: 4
			});

			if (isTransparentList) {
				state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			} else {
				state.setBlending(__WEBPACK_IMPORTED_MODULE_34__constants__["D" /* NoBlending */]);
			}

			var drawRangeArray = indexAttribute.getDrawRangeArray();
			for (var j = 0, jl = drawRangeArray.length; j < jl; j++) {
				var drawRange = drawRangeArray[j];

				if (geometry.isPMInstanceBufferGeometry) {

					renderer.renderInstances(drawRange.getOffset(), drawRange.getCount(), geometry.getInstancedCount());
				} else {

					if (drawRange.getTransparency() !== undefined && drawRange.getTransparency() !== isTransparentList) {
						continue;
					}

					if (isTransparentList) {
						var realOpacity = drawRange.getTransparency() !== undefined && drawRange.getOpacity() !== undefined ? drawRange.getOpacity() : material.opacity;

						if (curOpacity === undefined || !__WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].compareFloat(curOpacity, realOpacity)) {
							curOpacity = realOpacity;

							if (uploadOpacity) {
								uploadOpacity.setValue(_gl, curOpacity);
							} else {
								uploadOpacity = this.lookupSingleUniform(uniformList, 'opacity');
								if (uploadOpacity) {
									uploadOpacity.setValue(_gl, curOpacity);
								}
							}
						}
					}

					if (drawRange.getDiffuse() !== curDiffuse) {
						curDiffuse = drawRange.getDiffuse() !== undefined ? drawRange.getDiffuse() : material.color;

						if (uploadDiffuse) {
							uploadDiffuse.setValue(_gl, curDiffuse);
						} else {
							uploadDiffuse = this.lookupSingleUniform(uniformList, 'diffuse');
							if (uploadDiffuse) {
								uploadDiffuse.setValue(_gl, curDiffuse);
							}
						}

						if (material.map) {
							if (uploadDisableMap) {
								uploadDisableMap.setValue(_gl, drawRange.getDiffuse() === undefined ? false : true);
							} else {
								uploadDisableMap = this.lookupSingleUniform(uniformList, 'disableMap');
								if (uploadDisableMap) {
									uploadDisableMap.setValue(_gl, drawRange.getDiffuse() === undefined ? false : true);
								}
							}
						}
					}

					renderer.render(drawRange.getOffset(), drawRange.getCount());
				}
			}

			if (curOpacity !== undefined && !__WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].compareFloat(curOpacity, material.opacity) && uploadOpacity) {
				uploadOpacity.setValue(_gl, material.opacity);
			}

			if (curDiffuse !== undefined && uploadDiffuse) {
				uploadDiffuse.setValue(_gl, material.color);
				if (uploadDisableMap) {
					uploadDisableMap.setValue(_gl, false);
				}
			}

			state.disableUnusedAttributes();
		}
	}, this.renderBufferDirect = function (camera, fog, geometry, material, object, group, isTransparentList) {

		var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;

		state.setMaterial(material, frontFaceCW);

		var program = setProgram(camera, fog, material, object);

		var updateBuffers = false;

		if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {

			_currentGeometryProgram.geometry = geometry.id;
			_currentGeometryProgram.program = program.id;
			_currentGeometryProgram.wireframe = material.wireframe === true;
			updateBuffers = true;
		}

		if (object.morphTargetInfluences) {

			morphtargets.update(object, geometry, material, program);

			updateBuffers = true;
		}

		if (geometry.isPMBufferGeometry) {

			this.renderPMBufferGeometry(geometry, state, program, material, isTransparentList);
		} else {

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if (material.wireframe === true) {

				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			var attribute;
			var renderer = bufferRenderer;

			if (index !== null) {

				attribute = attributes.get(index);

				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			}

			if (updateBuffers) {

				setupVertexAttributes(material, program, geometry);

				if (index !== null) {

					_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
				}
			}

			var dataCount = Infinity;

			if (index !== null) {

				dataCount = index.count;
			} else if (position !== undefined) {

				dataCount = position.count;
			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max(rangeStart, groupStart);
			var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

			var drawCount = Math.max(0, drawEnd - drawStart + 1);

			if (drawCount === 0) return;

			if (object.isMesh) {

				if (material.wireframe === true) {

					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {

					switch (object.drawMode) {

						case __WEBPACK_IMPORTED_MODULE_0__constants_js__["y" /* TrianglesDrawMode */]:
							renderer.setMode(_gl.TRIANGLES);
							break;

						case __WEBPACK_IMPORTED_MODULE_0__constants_js__["E" /* TriangleStripDrawMode */]:
							renderer.setMode(_gl.TRIANGLE_STRIP);
							break;

						case __WEBPACK_IMPORTED_MODULE_0__constants_js__["F" /* TriangleFanDrawMode */]:
							renderer.setMode(_gl.TRIANGLE_FAN);
							break;

					}
				}
			} else if (object.isLine) {

				var lineWidth = material.linewidth;

				if (lineWidth === undefined) lineWidth = 1;

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {

					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {

					renderer.setMode(_gl.LINE_LOOP);
				} else {

					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {

				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {

				renderer.setMode(_gl.TRIANGLES);
			}

			if (geometry && geometry.isInstancedBufferGeometry) {

				renderer.renderInstances(drawStart, drawCount, geometry.maxInstancedCount);
			} else {

				renderer.render(drawStart, drawCount);
			}
		}
	};

	function setupVertexAttributes(material, program, geometry) {

		if (geometry && geometry.isInstancedBufferGeometry && !capabilities.isWebGL2) {

			if (extensions.get('ANGLE_instanced_arrays') === null) {

				console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for (var name in programAttributes) {

			var programAttribute = programAttributes[name];

			if (programAttribute >= 0) {

				var geometryAttribute = geometryAttributes[name];

				if (geometryAttribute !== undefined) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attribute = attributes.get(geometryAttribute);

					if (attribute === undefined) continue;

					var buffer = attribute.buffer;
					var type = attribute.type;
					var bytesPerElement = attribute.bytesPerElement;

					if (geometryAttribute.isInterleavedBufferAttribute) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if (data && data.isInstancedInterleavedBuffer) {

							state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

							if (geometry.maxInstancedCount === undefined) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;
							}
						} else {

							state.enableAttribute(programAttribute);
						}

						_gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
						_gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
					} else {

						if (geometryAttribute.isInstancedBufferAttribute) {

							state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

							if (geometry.maxInstancedCount === undefined) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
							}
						} else {

							state.enableAttribute(programAttribute);
						}

						_gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
						_gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
					}
				} else if (materialDefaultAttributeValues !== undefined) {

					var value = materialDefaultAttributeValues[name];

					if (value !== undefined) {

						switch (value.length) {

							case 2:
								_gl.vertexAttrib2fv(programAttribute, value);
								break;

							case 3:
								_gl.vertexAttrib3fv(programAttribute, value);
								break;

							case 4:
								_gl.vertexAttrib4fv(programAttribute, value);
								break;

							default:
								_gl.vertexAttrib1fv(programAttribute, value);

						}
					}
				}
			}
		}

		state.disableUnusedAttributes();
	}

	this.compile = function (scene, camera) {

		currentRenderState = renderStates.get(scene, camera);
		currentRenderState.init();

		scene.traverse(function (object) {

			if (object.isLight) {

				currentRenderState.pushLight(object);

				if (object.castShadow) {

					currentRenderState.pushShadow(object);
				}
			}
		});

		currentRenderState.setupLights(camera);

		scene.traverse(function (object) {

			if (object.material) {

				if (Array.isArray(object.material)) {

					for (var i = 0; i < object.material.length; i++) {

						initMaterial(object.material[i], scene.fog, object);
					}
				} else {

					initMaterial(object.material, scene.fog, object);
				}
			}
		});
	};

	var onAnimationFrameCallback = null;

	function onAnimationFrame(time) {

		if (vr.isPresenting()) return;
		if (onAnimationFrameCallback) onAnimationFrameCallback(time);
	}

	var animation = new __WEBPACK_IMPORTED_MODULE_11__webgl_WebGLAnimation_js__["a" /* WebGLAnimation */]();
	animation.setAnimationLoop(onAnimationFrame);

	if (typeof window !== 'undefined') animation.setContext(window);

	this.setAnimationLoop = function (callback) {

		onAnimationFrameCallback = callback;
		vr.setAnimationLoop(callback);

		animation.start();
	};

	this.render = function (scene, camera) {

		var renderTarget, forceClear;

		if (arguments[2] !== undefined) {

			console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
			renderTarget = arguments[2];
		}

		if (arguments[3] !== undefined) {

			console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
			forceClear = arguments[3];
		}

		if (!(camera && camera.isCamera)) {

			console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
			return;
		}

		if (_isContextLost) return;

		_currentGeometryProgram.geometry = null;
		_currentGeometryProgram.program = null;
		_currentGeometryProgram.wireframe = false;
		_currentMaterialId = -1;
		_currentCamera = null;

		if (scene.autoUpdate === true) scene.updateMatrixWorld();

		if (camera.parent === null) camera.updateMatrixWorld();

		if (vr.enabled) {

			camera = vr.getCamera(camera);
		}

		currentRenderState = renderStates.get(scene, camera);
		currentRenderState.init();

		scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);

		_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
		_frustum.setFromMatrix(_projScreenMatrix);

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

		currentRenderList = renderLists.get(scene, camera);
		currentRenderList.init();

		projectObject(scene, camera, 0, _this.sortObjects);

		if (_this.sortObjects === true) {

			currentRenderList.sort();
		}

		if (_clippingEnabled) _clipping.beginShadows();

		var shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render(shadowsArray, scene, camera);

		currentRenderState.setupLights(camera);

		if (_clippingEnabled) _clipping.endShadows();

		if (this.info.autoReset) this.info.reset();

		if (renderTarget !== undefined) {

			this.setRenderTarget(renderTarget);
		}

		background.render(currentRenderList, scene, camera, forceClear);

		var opaqueObjects = currentRenderList.opaque;
		var transparentObjects = currentRenderList.transparent;

		if (scene.overrideMaterial) {

			var overrideMaterial = scene.overrideMaterial;

			if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial, false);
			if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial, true);
		} else {

			if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, undefined, false);

			if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, undefined, true);
		}

		scene.onAfterRender(_this, scene, camera);

		if (_currentRenderTarget !== null) {

			textures.updateRenderTargetMipmap(_currentRenderTarget);

			textures.updateMultisampleRenderTarget(_currentRenderTarget);
		}

		state.buffers.depth.setTest(true);
		state.buffers.depth.setMask(true);
		state.buffers.color.setMask(true);

		state.setPolygonOffset(false);

		if (vr.enabled) {

			vr.submitFrame();
		}

		currentRenderList = null;
		currentRenderState = null;
	};

	function projectObject(object, camera, groupOrder, sortObjects) {

		if (object.visible === false) return;

		var visible = object.layers.test(camera.layers);

		if (visible) {

			if (object.isGroup) {

				groupOrder = object.renderOrder;
			} else if (object.isLOD) {

				if (object.autoUpdate === true) object.update(camera);
			} else if (object.isLight) {

				currentRenderState.pushLight(object);

				if (object.castShadow) {

					currentRenderState.pushShadow(object);
				}
			} else if (object.isSprite) {

				if (!object.frustumCulled || _frustum.intersectsSprite(object)) {

					if (sortObjects) {

						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					var geometry = objects.update(object);
					var material = object.material;

					if (material.visible) {

						currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
					}
				}
			} else if (object.isImmediateRenderObject) {

				if (sortObjects) {

					_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
				}

				currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
			} else if (object.isMesh || object.isLine || object.isPoints) {

				if (object.isSkinnedMesh) {

					object.skeleton.update();
				}

				if (!object.frustumCulled || _frustum.intersectsObject(object)) {

					if (sortObjects) {

						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					var geometry = objects.update(object);
					var material = object.material;

					if (Array.isArray(material)) {

						var groups = geometry.groups;

						for (var i = 0, l = groups.length; i < l; i++) {

							var group = groups[i];
							var groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {

								currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
							}
						}
					} else if (material.visible) {

						currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
					}
				}
			}
		}

		var children = object.children;

		for (var i = 0, l = children.length; i < l; i++) {

			projectObject(children[i], camera, groupOrder, sortObjects);
		}
	}

	function renderObjects(renderList, scene, camera, overrideMaterial, isTransparentList) {

		for (var i = 0, l = renderList.length; i < l; i++) {

			var renderItem = renderList[i];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			if (camera.isArrayCamera) {

				_currentArrayCamera = camera;

				var cameras = camera.cameras;

				for (var j = 0, jl = cameras.length; j < jl; j++) {

					var camera2 = cameras[j];

					if (object.layers.test(camera2.layers)) {

						state.viewport(_currentViewport.copy(camera2.viewport));

						currentRenderState.setupLights(camera2);

						renderObject(object, scene, camera2, geometry, material, group, isTransparentList);
					}
				}
			} else {

				_currentArrayCamera = null;

				renderObject(object, scene, camera, geometry, material, group, isTransparentList);
			}
		}
	}

	function renderObject(object, scene, camera, geometry, material, group, isTransparentList) {

		object.onBeforeRender(_this, scene, camera, geometry, material, group);
		currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);

		object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
		object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

		if (object.isImmediateRenderObject) {

			state.setMaterial(material);

			var program = setProgram(camera, scene.fog, material, object);

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;

			renderObjectImmediate(object, program);
		} else {

			_this.renderBufferDirect(camera, scene.fog, geometry, material, object, group, isTransparentList);
		}

		object.onAfterRender(_this, scene, camera, geometry, material, group);
		currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
	}

	function initMaterial(material, fog, object) {

		var materialProperties = properties.get(material);

		var lights = currentRenderState.state.lights;
		var shadowsArray = currentRenderState.state.shadowsArray;

		var lightsStateVersion = lights.state.version;

		var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);

		if (parameters.offsetVertexPosition) {
			parameters.offsetVertexPosition;
		}
		var code = programCache.getProgramCode(material, parameters);

		var program = materialProperties.program;
		var programChange = true;

		if (program === undefined) {
			material.addEventListener('dispose', onMaterialDispose);
		} else if (program.code !== code) {
			releaseMaterialProgramReference(material);
		} else if (materialProperties.lightsStateVersion !== lightsStateVersion) {

			materialProperties.lightsStateVersion = lightsStateVersion;

			programChange = false;
		} else if (parameters.shaderID !== undefined) {
			return;
		} else {
			programChange = false;
		}

		if (programChange) {

			if (parameters.shaderID) {

				var shader = __WEBPACK_IMPORTED_MODULE_5__shaders_ShaderLib_js__["a" /* ShaderLib */][parameters.shaderID];

				materialProperties.shader = {
					name: material.type,
					uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__["b" /* cloneUniforms */])(shader.uniforms),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};
			} else {

				materialProperties.shader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};
			}

			material.onBeforeCompile(materialProperties.shader, _this);

			code = programCache.getProgramCode(material, parameters);

			program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);

			materialProperties.program = program;
			material.program = program;
		}

		var programAttributes = program.getAttributes();

		if (material.morphTargets) {

			material.numSupportedMorphTargets = 0;

			for (var i = 0; i < _this.maxMorphTargets; i++) {

				if (programAttributes['morphTarget' + i] >= 0) {

					material.numSupportedMorphTargets++;
				}
			}
		}

		if (material.morphNormals) {

			material.numSupportedMorphNormals = 0;

			for (var i = 0; i < _this.maxMorphNormals; i++) {

				if (programAttributes['morphNormal' + i] >= 0) {

					material.numSupportedMorphNormals++;
				}
			}
		}

		var uniforms = materialProperties.shader.uniforms;

		if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;
		}

		materialProperties.fog = fog;

		materialProperties.lightsStateVersion = lightsStateVersion;

		if (material.lights) {

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.pointLights.value = lights.state.point;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
		}

		var progUniforms = materialProperties.program.getUniforms(),
		    uniformsList = __WEBPACK_IMPORTED_MODULE_30__webgl_WebGLUniforms_js__["a" /* WebGLUniforms */].seqWithValue(progUniforms.seq, uniforms);

		materialProperties.uniformsList = uniformsList;
	}

	function setProgram(camera, fog, material, object) {

		textures.resetTextureUnits();

		var materialProperties = properties.get(material);
		var lights = currentRenderState.state.lights;

		if (_clippingEnabled) {

			if (_localClippingEnabled || camera !== _currentCamera) {

				var useCache = camera === _currentCamera && material.id === _currentMaterialId;

				_clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
			}
		}

		if (material.needsUpdate === false) {

			if (materialProperties.program === undefined) {

				material.needsUpdate = true;
			} else if (material.fog && materialProperties.fog !== fog) {

				material.needsUpdate = true;
			} else if (material.lights && materialProperties.lightsStateVersion !== lights.state.version) {

				material.needsUpdate = true;
			} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {

				material.needsUpdate = true;
			}
		}

		if (material.needsUpdate) {

			initMaterial(material, fog, object);
			material.needsUpdate = false;
		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program;
		var p_uniforms = program.getUniforms();
		var m_uniforms = materialProperties.shader.uniforms;

		if (state.useProgram(program.program)) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;
		}

		if (material.id !== _currentMaterialId) {

			_currentMaterialId = material.id;

			refreshMaterial = true;
		}

		if (refreshProgram || _currentCamera !== camera) {

			p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

			if (capabilities.logarithmicDepthBuffer) {

				p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
			}

			if (_currentCamera !== camera) {

				_currentCamera = camera;

				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if (uCamPos !== undefined) {

					uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
				}
			}

			if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {

				p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
			}
		}

		if (material.skinning) {

			p_uniforms.setOptional(_gl, object, 'bindMatrix');
			p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

			var skeleton = object.skeleton;

			if (skeleton) {

				var bones = skeleton.bones;

				if (capabilities.floatVertexTextures) {

					if (skeleton.boneTexture === undefined) {

						var size = Math.sqrt(bones.length * 4);
						size = __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].ceilPowerOfTwo(size);
						size = Math.max(size, 4);

						var boneMatrices = new Float32Array(size * size * 4);
						boneMatrices.set(skeleton.boneMatrices);

						var boneTexture = new __WEBPACK_IMPORTED_MODULE_2__textures_DataTexture_js__["a" /* DataTexture */](boneMatrices, size, size, __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RGBAFormat */], __WEBPACK_IMPORTED_MODULE_0__constants_js__["G" /* FloatType */]);
						boneTexture.needsUpdate = true;

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;
					}

					p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
					p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
				} else {

					p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
				}
			}
		}

		if (refreshMaterial) {

			p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
			p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

			if (material.lights) {

				markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
			}

			if (fog && material.fog) {

				refreshUniformsFog(m_uniforms, fog);
			}

			if (material.isMeshBasicMaterial) {

				refreshUniformsCommon(m_uniforms, material);
			} else if (material.isMeshLambertMaterial) {

				refreshUniformsCommon(m_uniforms, material);
				refreshUniformsLambert(m_uniforms, material);
			} else if (material.isMeshPhongMaterial) {

				refreshUniformsCommon(m_uniforms, material);

				if (material.isMeshToonMaterial) {

					refreshUniformsToon(m_uniforms, material);
				} else {

					refreshUniformsPhong(m_uniforms, material);
				}
			} else if (material.isMeshStandardMaterial) {

				refreshUniformsCommon(m_uniforms, material);

				if (material.isMeshPhysicalMaterial) {

					refreshUniformsPhysical(m_uniforms, material);
				} else {

					refreshUniformsStandard(m_uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {

				refreshUniformsCommon(m_uniforms, material);

				refreshUniformsMatcap(m_uniforms, material);
			} else if (material.isMeshDepthMaterial) {

				refreshUniformsCommon(m_uniforms, material);
				refreshUniformsDepth(m_uniforms, material);
			} else if (material.isMeshDistanceMaterial) {

				refreshUniformsCommon(m_uniforms, material);
				refreshUniformsDistance(m_uniforms, material);
			} else if (material.isMeshNormalMaterial) {

				refreshUniformsCommon(m_uniforms, material);
				refreshUniformsNormal(m_uniforms, material);
			} else if (material.isLineBasicMaterial) {

				refreshUniformsLine(m_uniforms, material);

				if (material.isLineDashedMaterial) {

					refreshUniformsDash(m_uniforms, material);
				}
			} else if (material.isPointsMaterial) {

				refreshUniformsPoints(m_uniforms, material);
			} else if (material.isSpriteMaterial) {

				refreshUniformsSprites(m_uniforms, material);
			} else if (material.isShadowMaterial) {

				m_uniforms.color.value.copy(material.color);
				m_uniforms.opacity.value = material.opacity;
			}

			if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = __WEBPACK_IMPORTED_MODULE_6__shaders_UniformsLib_js__["a" /* UniformsLib */].LTC_1;
			if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = __WEBPACK_IMPORTED_MODULE_6__shaders_UniformsLib_js__["a" /* UniformsLib */].LTC_2;

			__WEBPACK_IMPORTED_MODULE_30__webgl_WebGLUniforms_js__["a" /* WebGLUniforms */].upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
		}

		if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {

			__WEBPACK_IMPORTED_MODULE_30__webgl_WebGLUniforms_js__["a" /* WebGLUniforms */].upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			material.uniformsNeedUpdate = false;
		}

		if (material.isSpriteMaterial) {

			p_uniforms.setValue(_gl, 'center', object.center);
		}

		if (material.vertexOffset) {
			p_uniforms.setValue(_gl, 'positionOffset', material.vertexOffsetValue);
		}

		p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
		p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
		p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

		return program;
	}

	function refreshUniformsCommon(uniforms, material) {

		uniforms.opacity.value = material.opacity;

		if (material.color) {

			uniforms.diffuse.value.copy(material.color);
		}

		if (material.emissive) {

			uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
		}

		if (material.map) {

			uniforms.map.value = material.map;
		}

		if (material.alphaMap) {

			uniforms.alphaMap.value = material.alphaMap;
		}

		if (material.specularMap) {

			uniforms.specularMap.value = material.specularMap;
		}

		if (material.envMap) {

			uniforms.envMap.value = material.envMap;

			uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
		}

		if (material.lightMap) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;
		}

		if (material.aoMap) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;
		}

		var uvScaleMap;

		if (material.map) {

			uvScaleMap = material.map;
		} else if (material.specularMap) {

			uvScaleMap = material.specularMap;
		} else if (material.displacementMap) {

			uvScaleMap = material.displacementMap;
		} else if (material.normalMap) {

			uvScaleMap = material.normalMap;
		} else if (material.bumpMap) {

			uvScaleMap = material.bumpMap;
		} else if (material.roughnessMap) {

			uvScaleMap = material.roughnessMap;
		} else if (material.metalnessMap) {

			uvScaleMap = material.metalnessMap;
		} else if (material.alphaMap) {

			uvScaleMap = material.alphaMap;
		} else if (material.emissiveMap) {

			uvScaleMap = material.emissiveMap;
		}

		if (uvScaleMap !== undefined) {
			if (uvScaleMap.isWebGLRenderTarget) {

				uvScaleMap = uvScaleMap.texture;
			}

			if (uvScaleMap.matrixAutoUpdate === true) {

				uvScaleMap.updateMatrix();
			}

			uniforms.uvTransform.value.copy(uvScaleMap.matrix);
		}
	}

	function refreshUniformsLine(uniforms, material) {

		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
	}

	function refreshUniformsDash(uniforms, material) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;
	}

	function refreshUniformsPoints(uniforms, material) {

		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;

		uniforms.map.value = material.map;

		if (material.map !== null) {

			if (material.map.matrixAutoUpdate === true) {

				material.map.updateMatrix();
			}

			uniforms.uvTransform.value.copy(material.map.matrix);
		}
	}

	function refreshUniformsSprites(uniforms, material) {

		uniforms.diffuse.value.copy(material.color);
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;
		uniforms.map.value = material.map;

		if (material.map !== null) {

			if (material.map.matrixAutoUpdate === true) {

				material.map.updateMatrix();
			}

			uniforms.uvTransform.value.copy(material.map.matrix);
		}
	}

	function refreshUniformsFog(uniforms, fog) {

		uniforms.fogColor.value.copy(fog.color);

		if (fog.isFog) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;
		} else if (fog.isFogExp2) {

			uniforms.fogDensity.value = fog.density;
		}
	}

	function refreshUniformsLambert(uniforms, material) {

		if (material.emissiveMap) {

			uniforms.emissiveMap.value = material.emissiveMap;
		}
	}

	function refreshUniformsPhong(uniforms, material) {

		uniforms.specular.value.copy(material.specular);
		uniforms.shininess.value = Math.max(material.shininess, 1e-4);

		if (material.emissiveMap) {

			uniforms.emissiveMap.value = material.emissiveMap;
		}

		if (material.bumpMap) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.bumpScale.value *= -1;
		}

		if (material.normalMap) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.normalScale.value.negate();
		}

		if (material.displacementMap) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}

	function refreshUniformsToon(uniforms, material) {

		refreshUniformsPhong(uniforms, material);

		if (material.gradientMap) {

			uniforms.gradientMap.value = material.gradientMap;
		}
	}

	function refreshUniformsStandard(uniforms, material) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if (material.roughnessMap) {

			uniforms.roughnessMap.value = material.roughnessMap;
		}

		if (material.metalnessMap) {

			uniforms.metalnessMap.value = material.metalnessMap;
		}

		if (material.emissiveMap) {

			uniforms.emissiveMap.value = material.emissiveMap;
		}

		if (material.bumpMap) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.bumpScale.value *= -1;
		}

		if (material.normalMap) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.normalScale.value.negate();
		}

		if (material.displacementMap) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}

		if (material.envMap) {
			uniforms.envMapIntensity.value = material.envMapIntensity;
		}
	}

	function refreshUniformsPhysical(uniforms, material) {

		refreshUniformsStandard(uniforms, material);

		uniforms.reflectivity.value = material.reflectivity;

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	}

	function refreshUniformsMatcap(uniforms, material) {

		if (material.matcap) {

			uniforms.matcap.value = material.matcap;
		}

		if (material.bumpMap) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.bumpScale.value *= -1;
		}

		if (material.normalMap) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.normalScale.value.negate();
		}

		if (material.displacementMap) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}

	function refreshUniformsDepth(uniforms, material) {

		if (material.displacementMap) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}

	function refreshUniformsDistance(uniforms, material) {

		if (material.displacementMap) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}

		uniforms.referencePosition.value.copy(material.referencePosition);
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;
	}

	function refreshUniformsNormal(uniforms, material) {

		if (material.bumpMap) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.bumpScale.value *= -1;
		}

		if (material.normalMap) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy(material.normalScale);
			if (material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */]) uniforms.normalScale.value.negate();
		}

		if (material.displacementMap) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;
		}
	}

	function markUniformsLightsNeedsUpdate(uniforms, value) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;
	}

	this.setFramebuffer = function (value) {

		if (_framebuffer !== value) _gl.bindFramebuffer(_gl.FRAMEBUFFER, value);

		_framebuffer = value;
	};

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;
	};

	this.getActiveMipMapLevel = function () {

		return _currentActiveMipmapLevel;
	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;
	};

	this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipMapLevel) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipMapLevel;

		if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

			textures.setupRenderTarget(renderTarget);
		}

		var framebuffer = _framebuffer;
		var isCube = false;

		if (renderTarget) {

			var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLRenderTargetCube) {

				framebuffer = __webglFramebuffer[activeCubeFace || 0];
				isCube = true;
			} else if (renderTarget.isWebGLMultisampleRenderTarget) {

				framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
			} else {

				framebuffer = __webglFramebuffer;
			}

			_currentViewport.copy(renderTarget.viewport);
			_currentScissor.copy(renderTarget.scissor);
			_currentScissorTest = renderTarget.scissorTest;
		} else {

			_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
			_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
			_currentScissorTest = _scissorTest;
		}

		if (_currentFramebuffer !== framebuffer) {

			_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			_currentFramebuffer = framebuffer;
		}

		state.viewport(_currentViewport);
		state.scissor(_currentScissor);
		state.setScissorTest(_currentScissorTest);

		if (isCube) {

			var textureProperties = properties.get(renderTarget.texture);
			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipMapLevel || 0);
		}
	};

	this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {

		if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {

			console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
			return;
		}

		var framebuffer = properties.get(renderTarget).__webglFramebuffer;

		if (renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== undefined) {

			framebuffer = framebuffer[activeCubeFaceIndex];
		}

		if (framebuffer) {

			var restore = false;

			if (framebuffer !== _currentFramebuffer) {

				_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

				restore = true;
			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if (textureFormat !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RGBAFormat */] && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {

					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
					return;
				}

				if (textureType !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["t" /* UnsignedByteType */] && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === __WEBPACK_IMPORTED_MODULE_0__constants_js__["G" /* FloatType */] && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === __WEBPACK_IMPORTED_MODULE_0__constants_js__["H" /* HalfFloatType */] && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {

					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
					return;
				}

				if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {

					if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {

						_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
					}
				} else {

					console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
				}
			} finally {

				if (restore) {

					_gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
				}
			}
		}
	};

	this.copyFramebufferToTexture = function (position, texture, level) {

		var width = texture.image.width;
		var height = texture.image.height;
		var glFormat = utils.convert(texture.format);

		textures.setTexture2D(texture, 0);

		_gl.copyTexImage2D(_gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0);
	};

	this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {

		var width = srcTexture.image.width;
		var height = srcTexture.image.height;
		var glFormat = utils.convert(dstTexture.format);
		var glType = utils.convert(dstTexture.type);

		textures.setTexture2D(dstTexture, 0);

		if (srcTexture.isDataTexture) {

			_gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
		} else {

			_gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
		}
	};

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
	}
}



/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n");

/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n");

/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n");

/***/ }),
/* 302 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n");

/***/ }),
/* 304 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvec3 transformed = vec3( position );\n");

/***/ }),
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n\n#ifdef USE_INSTANCE_ATTRIBUTE\n  mat3 normalMat = mat3(vec3(instanceMatrixR1), vec3(instanceMatrixR2), vec3(instanceMatrixR3));\n  vec3 objectNormal = normalize(normalMat * vec3( normal ));\n#else\n  vec3 objectNormal = vec3( normal );\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n");

/***/ }),
/* 306 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t// but who must be converted to luminous irradiance for surface lighting calculation\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\tif( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n#else\n\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n\t// See F_Schlick\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n\treturn Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney\u2019s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)\u22C5G(v) / 4(n\u22C5l)(n\u22C5v)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney\u2019s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n\treturn specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Ag\xFCera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n");

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n");

/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if NUM_CLIPPING_PLANES > 0\n\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n");

/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n");

/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n");

/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n");

/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n");

/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n");

/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif\n");

/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\nbool compareFloat( in float f1, in float f2, in float prec) {\n  if(abs(f1 - f2) - prec > 0.0) {\n    return false;\n  }\n  \n  return true;\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n");

/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\t// float powScale = exp2(roughnessLevel + mipLevel);\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\n\tfloat rcpPowScale = 1.0 / powScale;\n\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\n\t// round to nearest mipmap if we are not interpolating.\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\n\t// Tri linear interpolation.\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n\tvec4 result = mix(color10, color20, t);\n\n\treturn vec4(result.rgb, 1.0);\n}\n\n#endif\n");

/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n");

/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n");

/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 321 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n");

/***/ }),
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n");

/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( DITHERING )\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n");

/***/ }),
/* 324 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( DITHERING )\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n");

/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n");

/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n");

/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n");

/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n");

/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\tenvColor = envMapTexelToLinear( envColor );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n");

/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n");

/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n");

/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n");

/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n");

/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef TOON\n\n\tuniform sampler2D gradientMap;\n\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t\t// dotNL will be from -1.0 to 1.0\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t\t#ifdef USE_GRADIENTMAP\n\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t\t#else\n\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t\t#endif\n\n\n\t}\n\n#endif\n");

/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_INSTANCE_ATTRIBUTE\n\n  if ( compareFloat(vInstanceState.x, 0.0, 0.1) )\n  {\n    discard;\n  }\n  float fInstanceColorMode = vInstanceState.y;\n  if( compareFloat(fInstanceColorMode, 3.0, 0.1) )\n  {\n     diffuseColor.w = vInstanceColor.w;\n  }\n  else if ( compareFloat(fInstanceColorMode, 2.0, 0.1) )\n  {\n     diffuseColor.xyz = vInstanceColor.xyz;\n  }\n  else if ( compareFloat(fInstanceColorMode, 1.0, 0.1) )\n  {\n     diffuseColor = vInstanceColor;\n  }\n  \n#endif\n");

/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_INSTANCE_ATTRIBUTE\n\n  varying vec4 vInstanceColor;\n  varying vec2 vInstanceState;\n  \n#endif\n");

/***/ }),
/* 341 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_INSTANCE_ATTRIBUTE\n\n\tattribute vec4 instanceMatrixR1;\n\tattribute vec4 instanceMatrixR2;\n\tattribute vec4 instanceMatrixR3;\n\tattribute vec4 instanceMatrixR4;\n\t\n\tattribute vec4 instanceColor;\n\tattribute vec2 instanceState;\n\n  varying vec4 vInstanceColor;\n  varying vec2 vInstanceState;\n  \n#endif\n");

/***/ }),
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_INSTANCE_ATTRIBUTE\n\n\tvInstanceColor = instanceColor;\n\tvInstanceState = instanceState;\n\n#endif\n");

/***/ }),
/* 343 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_LIGHTMAP\n\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n");

/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n");

/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n");

/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n");

/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tirradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n\n#endif\n");

/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\t// TODO (abelnation): implement\n\n\t}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\n#endif\n");

/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n");

/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n");

/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t#ifdef TOON\n\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#else\n\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\n\t#endif\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n");

/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n");

/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t// Defer to the IndirectSpecular function to compute\n\t// the indirectDiffuse if energy preservation is enabled.\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#endif\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\n\t// Both indirect specular and diffuse light accumulate here\n\t// if energy preservation enabled, and PMREM provided.\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n\t#else\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n\t#endif\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n");

/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n");

/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\n#endif\n");

/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n\t#else\n\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\tgl_Position.z *= gl_Position.w;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MAP\n\n  #ifdef USE_INSTANCE_ATTRIBUTE\n    if ( !compareFloat(fInstanceColorMode, 2.0, 0.1) && !compareFloat(fInstanceColorMode, 1.0, 0.1))\n    {\n      vec4 texelColor = texture2D( map, vUv );\n\t    texelColor = mapTexelToLinear( texelColor );\n\t    diffuseColor *= texelColor;\n    }\n  #else\n    if(false == disableMap) {\n      vec4 texelColor = texture2D( map, vUv );\n\t    texelColor = mapTexelToLinear( texelColor );\n\t    diffuseColor *= texelColor;\n    }\n  #endif\n\n#endif\n");

/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n");

/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MAP\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n");

/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MAP\n\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n\n#endif\n");

/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n");

/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n");

/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n");

/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_NORMALMAP\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t\t#ifdef FLIP_SIDED\n\n\t\t\tnormal = - normal;\n\n\t\t#endif\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tnormal = normalize( normalMatrix * normal );\n\n\t#else // tangent-space normal map\n\n\t\t#ifdef USE_TANGENT\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\n\t\t#else\n\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n\t\t#endif\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n");

/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tuniform mat3 normalMatrix;\n\n\t#else\n\n\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t\treturn normalize( tsn * mapN );\n\n\t\t}\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_OFFSET_VERTEX_POSITION\n  uniform float positionOffset;\n#endif\n");

/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_OFFSET_VERTEX_POSITION\n  transformed += objectNormal * positionOffset;\n#endif\n");

/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n");

/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n");

/***/ }),
/* 374 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_INSTANCE_ATTRIBUTE\n  mat4 instanceMat = mat4(instanceMatrixR1, instanceMatrixR2, instanceMatrixR3, instanceMatrixR4);\n  vec4 mvPosition = modelViewMatrix * instanceMat * vec4( transformed, 1.0 );\n#else\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n");

/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n");

/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n");

/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n");

/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n");

/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n");

/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n");

/***/ }),
/* 381 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n");

/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n");

/***/ }),
/* 384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n");

/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n");

/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n");

/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n");

/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}\n");

/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n");

/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif\n");

/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif\n");

/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n");

/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n\n#endif\n");

/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n");

/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n");

/***/ }),
/* 396 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n");

/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n");

/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\nvoid main() {\n\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n");

/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n");

/***/ }),
/* 400 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\n\t#endif\n\n}\n");

/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n");

/***/ }),
/* 402 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n");

/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n");

/***/ }),
/* 404 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n");

/***/ }),
/* 405 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n");

/***/ }),
/* 406 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n");

/***/ }),
/* 407 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\n\tvLineDistance = scale * lineDistance;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 408 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 diffuse;\nuniform float opacity;\nuniform bool disableMap;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <instance_attribute_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <instance_attribute_fragment>\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n");

/***/ }),
/* 409 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <instance_attribute_pars_vertex>\n#include <offset_vertex_position_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#include <instance_attribute_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <offset_vertex_position_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 410 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nuniform bool disableMap;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <instance_attribute_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <instance_attribute_fragment>\n\t\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n");

/***/ }),
/* 411 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <instance_attribute_pars_vertex>\n#include <offset_vertex_position_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <instance_attribute_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <offset_vertex_position_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n");

/***/ }),
/* 412 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform bool disableMap;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n");

/***/ }),
/* 413 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\tvNormal = normalize( transformedNormal );\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n");

/***/ }),
/* 414 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool disableMap;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <instance_attribute_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <instance_attribute_fragment>\n\t\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n");

/***/ }),
/* 415 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <instance_attribute_pars_vertex>\n#include <offset_vertex_position_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <instance_attribute_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <offset_vertex_position_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 416 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform bool disableMap;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <instance_attribute_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <instance_attribute_fragment>\n\t\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n");

/***/ }),
/* 417 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <instance_attribute_pars_vertex>\n#include <offset_vertex_position_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <instance_attribute_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <offset_vertex_position_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 418 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n");

/***/ }),
/* 419 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n");

/***/ }),
/* 420 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n");

/***/ }),
/* 421 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 422 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <fog_fragment>\n\n}\n");

/***/ }),
/* 423 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 424 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n");

/***/ }),
/* 425 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ("\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n");

/***/ }),
/* 426 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLAttributes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map__);



function WebGLAttributes(gl) {

		var buffers = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map___default.a();

		function createBuffer(attribute, bufferType) {

				var array = attribute.array;
				var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

				var buffer = gl.createBuffer();

				gl.bindBuffer(bufferType, buffer);
				gl.bufferData(bufferType, array, usage);

				attribute.onUploadCallback();

				var type = gl.FLOAT;

				if (array instanceof Float32Array) {

						type = gl.FLOAT;
				} else if (array instanceof Float64Array) {

						console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
				} else if (array instanceof Uint16Array) {

						type = gl.UNSIGNED_SHORT;
				} else if (array instanceof Int16Array) {

						type = gl.SHORT;
				} else if (array instanceof Uint32Array) {

						type = gl.UNSIGNED_INT;
				} else if (array instanceof Int32Array) {

						type = gl.INT;
				} else if (array instanceof Int8Array) {

						type = gl.BYTE;
				} else if (array instanceof Uint8Array) {

						type = gl.UNSIGNED_BYTE;
				}

				return {
						buffer: buffer,
						type: type,
						bytesPerElement: array.BYTES_PER_ELEMENT,
						version: attribute.version
				};
		}

		function updateBuffer(buffer, attribute, bufferType) {

				var array = attribute.array;
				var updateRange = attribute.updateRange;

				gl.bindBuffer(bufferType, buffer);

				if (attribute.dynamic === false) {

						gl.bufferData(bufferType, array, gl.STATIC_DRAW);
				} else if (updateRange.count === -1) {

						gl.bufferSubData(bufferType, 0, array);
				} else if (updateRange.count === 0) {

						console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
				} else {

						gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));

						updateRange.count = -1;
				}
		}

		function get(attribute) {

				if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

				return buffers.get(attribute);
		}

		function remove(attribute) {

				if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

				var data = buffers.get(attribute);

				if (data) {

						gl.deleteBuffer(data.buffer);

						buffers.delete(attribute);
				}
		}

		function update(attribute, bufferType) {

				if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

				var data = buffers.get(attribute);

				if (data === undefined) {

						buffers.set(attribute, createBuffer(attribute, bufferType));
				} else if (data.version < attribute.version) {

						updateBuffer(data.buffer, attribute, bufferType);

						data.version = attribute.version;
				}
		}

		return {

				get: get,
				remove: remove,
				update: update

		};
}



/***/ }),
/* 427 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLBackground; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometries_BoxGeometry_js__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometries_PlaneGeometry_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__materials_ShaderMaterial_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__objects_Mesh_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__ = __webpack_require__(37);











function WebGLBackground(renderer, state, objects, premultipliedAlpha) {

			var clearColor = new __WEBPACK_IMPORTED_MODULE_4__math_Color_js__["a" /* Color */](0x000000);
			var clearAlpha = 0;

			var planeMesh;
			var boxMesh;

			var currentBackground = null;
			var currentBackgroundVersion = 0;

			function render(renderList, scene, camera, forceClear) {

						var background = scene.background;

						var vr = renderer.vr;
						var session = vr.getSession && vr.getSession();

						if (session && session.environmentBlendMode === 'additive') {

									background = null;
						}

						if (background === null) {

									setClear(clearColor, clearAlpha);
									currentBackground = null;
									currentBackgroundVersion = 0;
						} else if (background && background.isColor) {

									setClear(background, 1);
									forceClear = true;
									currentBackground = null;
									currentBackgroundVersion = 0;
						}

						if (renderer.autoClear || forceClear) {

									renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
						}

						if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {

									if (boxMesh === undefined) {

												boxMesh = new __WEBPACK_IMPORTED_MODULE_5__objects_Mesh_js__["a" /* Mesh */](new __WEBPACK_IMPORTED_MODULE_1__geometries_BoxGeometry_js__["b" /* BoxBufferGeometry */](1, 1, 1), new __WEBPACK_IMPORTED_MODULE_3__materials_ShaderMaterial_js__["a" /* ShaderMaterial */]({
															type: 'BackgroundCubeMaterial',
															uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__["b" /* cloneUniforms */])(__WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__["a" /* ShaderLib */].cube.uniforms),
															vertexShader: __WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__["a" /* ShaderLib */].cube.vertexShader,
															fragmentShader: __WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__["a" /* ShaderLib */].cube.fragmentShader,
															side: __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */],
															depthTest: false,
															depthWrite: false,
															fog: false
												}));

												boxMesh.geometry.removeAttribute('normal');
												boxMesh.geometry.removeAttribute('uv');

												boxMesh.onBeforeRender = function (renderer, scene, camera) {

															this.matrixWorld.copyPosition(camera.matrixWorld);
												};

												Object.defineProperty(boxMesh.material, 'map', {

															get: function get() {

																		return this.uniforms.tCube.value;
															}

												});

												objects.update(boxMesh);
									}

									var texture = background.isWebGLRenderTargetCube ? background.texture : background;
									boxMesh.material.uniforms.tCube.value = texture;
									boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;

									if (currentBackground !== background || currentBackgroundVersion !== texture.version) {

												boxMesh.material.needsUpdate = true;

												currentBackground = background;
												currentBackgroundVersion = texture.version;
									}

									renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
						} else if (background && background.isTexture) {

									if (planeMesh === undefined) {

												planeMesh = new __WEBPACK_IMPORTED_MODULE_5__objects_Mesh_js__["a" /* Mesh */](new __WEBPACK_IMPORTED_MODULE_2__geometries_PlaneGeometry_js__["a" /* PlaneBufferGeometry */](2, 2), new __WEBPACK_IMPORTED_MODULE_3__materials_ShaderMaterial_js__["a" /* ShaderMaterial */]({
															type: 'BackgroundMaterial',
															uniforms: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__shaders_UniformsUtils_js__["b" /* cloneUniforms */])(__WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__["a" /* ShaderLib */].background.uniforms),
															vertexShader: __WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__["a" /* ShaderLib */].background.vertexShader,
															fragmentShader: __WEBPACK_IMPORTED_MODULE_6__shaders_ShaderLib_js__["a" /* ShaderLib */].background.fragmentShader,
															side: __WEBPACK_IMPORTED_MODULE_0__constants_js__["j" /* FrontSide */],
															depthTest: false,
															depthWrite: false,
															fog: false
												}));

												planeMesh.geometry.removeAttribute('normal');

												Object.defineProperty(planeMesh.material, 'map', {

															get: function get() {

																		return this.uniforms.t2D.value;
															}

												});

												objects.update(planeMesh);
									}

									planeMesh.material.uniforms.t2D.value = background;

									if (background.matrixAutoUpdate === true) {

												background.updateMatrix();
									}

									planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

									if (currentBackground !== background || currentBackgroundVersion !== background.version) {

												planeMesh.material.needsUpdate = true;

												currentBackground = background;
												currentBackgroundVersion = background.version;
									}

									renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
						}
			}

			function setClear(color, alpha) {

						state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
			}

			return {

						getClearColor: function getClearColor() {

									return clearColor;
						},
						setClearColor: function setClearColor(color, alpha) {

									clearColor.set(color);
									clearAlpha = alpha !== undefined ? alpha : 1;
									setClear(clearColor, clearAlpha);
						},
						getClearAlpha: function getClearAlpha() {

									return clearAlpha;
						},
						setClearAlpha: function setClearAlpha(alpha) {

									clearAlpha = alpha;
									setClear(clearColor, clearAlpha);
						},
						render: render

			};
}



/***/ }),
/* 428 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLBufferRenderer; });


function WebGLBufferRenderer(gl, extensions, info, capabilities) {

	var mode;

	function setMode(value) {

		mode = value;
	}

	function render(start, count) {

		gl.drawArrays(mode, start, count);

		info.update(count, mode);
	}

	function renderInstances(geometry, start, count) {

		var extension;

		if (capabilities.isWebGL2) {

			extension = gl;
		} else {

			extension = extensions.get('ANGLE_instanced_arrays');

			if (extension === null) {

				console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}

		extension[capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](mode, start, count, geometry.maxInstancedCount);

		info.update(count, mode, geometry.maxInstancedCount);
	}

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
}



/***/ }),
/* 429 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLCapabilities; });


function WebGLCapabilities(gl, extensions, parameters) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

				if (maxAnisotropy !== undefined) return maxAnisotropy;

				var extension = extensions.get('EXT_texture_filter_anisotropic');

				if (extension !== null) {

						maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
				} else {

						maxAnisotropy = 0;
				}

				return maxAnisotropy;
		}

		function getMaxPrecision(precision) {

				if (precision === 'highp') {

						if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {

								return 'highp';
						}

						precision = 'mediump';
				}

				if (precision === 'mediump') {

						if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {

								return 'mediump';
						}
				}

				return 'lowp';
		}

		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {

				console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
				precision = maxPrecision;
		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

		var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		var maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;

		return {

				isWebGL2: isWebGL2,

				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,

				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,

				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,

				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures,

				maxSamples: maxSamples

		};
}



/***/ }),
/* 430 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLClipping; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Matrix3_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Plane_js__ = __webpack_require__(94);





function WebGLClipping() {

		var scope = this,
		    globalState = null,
		    numGlobalPlanes = 0,
		    localClippingEnabled = false,
		    renderingShadows = false,
		    plane = new __WEBPACK_IMPORTED_MODULE_1__math_Plane_js__["a" /* Plane */](),
		    viewNormalMatrix = new __WEBPACK_IMPORTED_MODULE_0__math_Matrix3_js__["a" /* Matrix3 */](),
		    uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {

				var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;

				localClippingEnabled = enableLocalClipping;

				globalState = projectPlanes(planes, camera, 0);
				numGlobalPlanes = planes.length;

				return enabled;
		};

		this.beginShadows = function () {

				renderingShadows = true;
				projectPlanes(null);
		};

		this.endShadows = function () {

				renderingShadows = false;
				resetGlobalState();
		};

		this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {

				if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {

						if (renderingShadows) {

								projectPlanes(null);
						} else {

								resetGlobalState();
						}
				} else {

						var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						    lGlobal = nGlobal * 4,
						    dstArray = cache.clippingState || null;

						uniform.value = dstArray;

						dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

						for (var i = 0; i !== lGlobal; ++i) {

								dstArray[i] = globalState[i];
						}

						cache.clippingState = dstArray;
						this.numIntersection = clipIntersection ? this.numPlanes : 0;
						this.numPlanes += nGlobal;
				}
		};

		function resetGlobalState() {

				if (uniform.value !== globalState) {

						uniform.value = globalState;
						uniform.needsUpdate = numGlobalPlanes > 0;
				}

				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {

				var nPlanes = planes !== null ? planes.length : 0,
				    dstArray = null;

				if (nPlanes !== 0) {

						dstArray = uniform.value;

						if (skipTransform !== true || dstArray === null) {

								var flatSize = dstOffset + nPlanes * 4,
								    viewMatrix = camera.matrixWorldInverse;

								viewNormalMatrix.getNormalMatrix(viewMatrix);

								if (dstArray === null || dstArray.length < flatSize) {

										dstArray = new Float32Array(flatSize);
								}

								for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {

										plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

										plane.normal.toArray(dstArray, i4);
										dstArray[i4 + 3] = plane.constant;
								}
						}

						uniform.value = dstArray;
						uniform.needsUpdate = true;
				}

				scope.numPlanes = nPlanes;

				return dstArray;
		}
}



/***/ }),
/* 431 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLExtensions; });


function WebGLExtensions(gl) {

			var extensions = {};

			return {

						get: function get(name) {

									if (extensions[name] !== undefined) {

												return extensions[name];
									}

									var extension;

									switch (name) {

												case 'WEBGL_depth_texture':
															extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
															break;

												case 'EXT_texture_filter_anisotropic':
															extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
															break;

												case 'WEBGL_compressed_texture_s3tc':
															extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
															break;

												case 'WEBGL_compressed_texture_pvrtc':
															extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
															break;

												default:
															extension = gl.getExtension(name);

									}

									if (extension === null) {

												console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
									}

									extensions[name] = extension;

									return extension;
						}

			};
}



/***/ }),
/* 432 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLGeometries; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_BufferAttribute_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_js__ = __webpack_require__(100);






function WebGLGeometries(gl, attributes, info) {

	var geometries = {};
	var wireframeAttributes = {};

	function onGeometryDispose(event) {

		var geometry = event.target;
		var buffergeometry = geometries[geometry.id];

		if (buffergeometry.index !== null) {

			attributes.remove(buffergeometry.index);
		}

		for (var name in buffergeometry.attributes) {

			attributes.remove(buffergeometry.attributes[name]);
		}

		geometry.removeEventListener('dispose', onGeometryDispose);

		delete geometries[geometry.id];

		var attribute = wireframeAttributes[buffergeometry.id];

		if (attribute) {

			attributes.remove(attribute);
			delete wireframeAttributes[buffergeometry.id];
		}

		info.memory.geometries--;
	}

	function get(object, geometry) {

		var buffergeometry = geometries[geometry.id];

		if (buffergeometry) return buffergeometry;

		geometry.addEventListener('dispose', onGeometryDispose);

		if (geometry.isPMBufferGeometry) {

			buffergeometry = geometry;
		} else if (geometry.isBufferGeometry) {

			buffergeometry = geometry;
		} else if (geometry.isGeometry) {

			if (geometry._bufferGeometry === undefined) {

				geometry._bufferGeometry = new __WEBPACK_IMPORTED_MODULE_1__core_BufferGeometry_js__["a" /* BufferGeometry */]().setFromObject(object);
			}

			buffergeometry = geometry._bufferGeometry;
		}

		geometries[geometry.id] = buffergeometry;

		info.memory.geometries++;

		return buffergeometry;
	}

	function update(geometry) {

		if (geometry.isPMBufferGeometry) {

			var indexArray = geometry.getIndexArray();
			for (var _i = 0, il = indexArray.length; _i < il; _i++) {

				indexArray[_i].update(gl);
			}

			geometry.getAttributeArray().update(gl);

			if (geometry.isPMInstanceBufferGeometry) {

				geometry.getInstanceAttributeArray().update(gl);
			}
		} else {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if (index !== null) {

				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}

			for (var name in geometryAttributes) {

				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			}

			var morphAttributes = geometry.morphAttributes;

			for (var name in morphAttributes) {

				var array = morphAttributes[name];

				for (var i = 0, l = array.length; i < l; i++) {

					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}
	}

	function getWireframeAttribute(geometry) {

		var attribute = wireframeAttributes[geometry.id];

		if (attribute) return attribute;

		var indices = [];

		var geometryIndex = geometry.index;
		var geometryAttributes = geometry.attributes;

		if (geometryIndex !== null) {

			var array = geometryIndex.array;

			for (var i = 0, l = array.length; i < l; i += 3) {

				var a = array[i + 0];
				var b = array[i + 1];
				var c = array[i + 2];

				indices.push(a, b, b, c, c, a);
			}
		} else {

			var array = geometryAttributes.position.array;

			for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push(a, b, b, c, c, a);
			}
		}

		attribute = new (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_js__["a" /* arrayMax */])(indices) > 65535 ? __WEBPACK_IMPORTED_MODULE_0__core_BufferAttribute_js__["d" /* Uint32BufferAttribute */] : __WEBPACK_IMPORTED_MODULE_0__core_BufferAttribute_js__["f" /* Uint16BufferAttribute */])(indices, 1);

		attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);

		wireframeAttributes[geometry.id] = attribute;

		return attribute;
	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};
}



/***/ }),
/* 433 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLIndexedBufferRenderer; });


function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {

	var mode;

	function setMode(value) {

		mode = value;
	}

	var type, bytesPerElement;

	function setIndex(value) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;
	}

	function render(start, count) {

		gl.drawElements(mode, count, type, start * bytesPerElement);

		info.update(count, mode);
	}

	function renderInstances(start, count, instancedCount) {

		if (instancedCount <= 0) {

			return;
		}

		var extension;

		if (capabilities.isWebGL2) {

			extension = gl;
		} else {

			var extension = extensions.get('ANGLE_instanced_arrays');

			if (extension === null) {

				console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
				return;
			}
		}

		extension[capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](mode, count, type, start * bytesPerElement, instancedCount);

		info.update(count, mode, instancedCount);
	}

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
}



/***/ }),
/* 434 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLInfo; });


function WebGLInfo(gl) {

	var memory = {
		geometries: 0,
		textures: 0
	};

	var render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update(count, mode, instanceCount) {

		instanceCount = instanceCount || 1;

		render.calls++;

		switch (mode) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * (count / 3);
				break;

			case gl.TRIANGLE_STRIP:
			case gl.TRIANGLE_FAN:
				render.triangles += instanceCount * (count - 2);
				break;

			case gl.LINES:
				render.lines += instanceCount * (count / 2);
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * (count - 1);
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
				break;

		}
	}

	function reset() {

		render.frame++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;
	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};
}



/***/ }),
/* 435 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLLights; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_Color_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__ = __webpack_require__(2);







function UniformsCache() {

				var lights = {};

				return {

								get: function get(light) {

												if (lights[light.id] !== undefined) {

																return lights[light.id];
												}

												var uniforms;

												switch (light.type) {

																case 'DirectionalLight':
																				uniforms = {
																								direction: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),

																								shadow: false,
																								shadowBias: 0,
																								shadowRadius: 1,
																								shadowMapSize: new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */]()
																				};
																				break;

																case 'SpotLight':
																				uniforms = {
																								position: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								direction: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
																								distance: 0,
																								coneCos: 0,
																								penumbraCos: 0,
																								decay: 0,

																								shadow: false,
																								shadowBias: 0,
																								shadowRadius: 1,
																								shadowMapSize: new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */]()
																				};
																				break;

																case 'PointLight':
																				uniforms = {
																								position: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
																								distance: 0,
																								decay: 0,

																								shadow: false,
																								shadowBias: 0,
																								shadowRadius: 1,
																								shadowMapSize: new __WEBPACK_IMPORTED_MODULE_2__math_Vector2_js__["a" /* Vector2 */](),
																								shadowCameraNear: 1,
																								shadowCameraFar: 1000
																				};
																				break;

																case 'HemisphereLight':
																				uniforms = {
																								direction: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								skyColor: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
																								groundColor: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */]()
																				};
																				break;

																case 'RectAreaLight':
																				uniforms = {
																								color: new __WEBPACK_IMPORTED_MODULE_0__math_Color_js__["a" /* Color */](),
																								position: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								halfWidth: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */](),
																								halfHeight: new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]()
																				};
																				break;

												}

												lights[light.id] = uniforms;

												return uniforms;
								}

				};
}

var nextVersion = 0;

function WebGLLights() {

				var cache = new UniformsCache();

				var state = {

								version: 0,

								hash: {
												directionalLength: -1,
												pointLength: -1,
												spotLength: -1,
												rectAreaLength: -1,
												hemiLength: -1,
												shadowsLength: -1
								},

								ambient: [0, 0, 0],
								probe: [],
								directional: [],
								directionalShadowMap: [],
								directionalShadowMatrix: [],
								spot: [],
								spotShadowMap: [],
								spotShadowMatrix: [],
								rectArea: [],
								point: [],
								pointShadowMap: [],
								pointShadowMatrix: [],
								hemi: []

				};

				for (var i = 0; i < 9; i++) {
								state.probe.push(new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]());
				}var vector3 = new __WEBPACK_IMPORTED_MODULE_3__math_Vector3_js__["a" /* Vector3 */]();
				var matrix4 = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();
				var matrix42 = new __WEBPACK_IMPORTED_MODULE_1__math_Matrix4_js__["a" /* Matrix4 */]();

				function setup(lights, shadows, camera) {

								var r = 0,
								    g = 0,
								    b = 0;

								for (var i = 0; i < 9; i++) {
												state.probe[i].set(0, 0, 0);
								}var directionalLength = 0;
								var pointLength = 0;
								var spotLength = 0;
								var rectAreaLength = 0;
								var hemiLength = 0;

								var viewMatrix = camera.matrixWorldInverse;

								for (var i = 0, l = lights.length; i < l; i++) {

												var light = lights[i];

												var color = light.color;
												var intensity = light.intensity;
												var distance = light.distance;

												var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

												if (light.isAmbientLight) {

																r += color.r * intensity;
																g += color.g * intensity;
																b += color.b * intensity;
												} else if (light.isLightProbe) {

																for (var j = 0; j < 9; j++) {

																				state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
																}
												} else if (light.isDirectionalLight) {

																var uniforms = cache.get(light);

																uniforms.color.copy(light.color).multiplyScalar(light.intensity);
																uniforms.direction.setFromMatrixPosition(light.matrixWorld);
																vector3.setFromMatrixPosition(light.target.matrixWorld);
																uniforms.direction.sub(vector3);
																uniforms.direction.transformDirection(viewMatrix);

																uniforms.shadow = light.castShadow;

																if (light.castShadow) {

																				var shadow = light.shadow;

																				uniforms.shadowBias = shadow.bias;
																				uniforms.shadowRadius = shadow.radius;
																				uniforms.shadowMapSize = shadow.mapSize;
																}

																state.directionalShadowMap[directionalLength] = shadowMap;
																state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
																state.directional[directionalLength] = uniforms;

																directionalLength++;
												} else if (light.isSpotLight) {

																var uniforms = cache.get(light);

																uniforms.position.setFromMatrixPosition(light.matrixWorld);
																uniforms.position.applyMatrix4(viewMatrix);

																uniforms.color.copy(color).multiplyScalar(intensity);
																uniforms.distance = distance;

																uniforms.direction.setFromMatrixPosition(light.matrixWorld);
																vector3.setFromMatrixPosition(light.target.matrixWorld);
																uniforms.direction.sub(vector3);
																uniforms.direction.transformDirection(viewMatrix);

																uniforms.coneCos = Math.cos(light.angle);
																uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
																uniforms.decay = light.decay;

																uniforms.shadow = light.castShadow;

																if (light.castShadow) {

																				var shadow = light.shadow;

																				uniforms.shadowBias = shadow.bias;
																				uniforms.shadowRadius = shadow.radius;
																				uniforms.shadowMapSize = shadow.mapSize;
																}

																state.spotShadowMap[spotLength] = shadowMap;
																state.spotShadowMatrix[spotLength] = light.shadow.matrix;
																state.spot[spotLength] = uniforms;

																spotLength++;
												} else if (light.isRectAreaLight) {

																var uniforms = cache.get(light);

																uniforms.color.copy(color).multiplyScalar(intensity);

																uniforms.position.setFromMatrixPosition(light.matrixWorld);
																uniforms.position.applyMatrix4(viewMatrix);

																matrix42.identity();
																matrix4.copy(light.matrixWorld);
																matrix4.premultiply(viewMatrix);
																matrix42.extractRotation(matrix4);

																uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
																uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

																uniforms.halfWidth.applyMatrix4(matrix42);
																uniforms.halfHeight.applyMatrix4(matrix42);

																state.rectArea[rectAreaLength] = uniforms;

																rectAreaLength++;
												} else if (light.isPointLight) {

																var uniforms = cache.get(light);

																uniforms.position.setFromMatrixPosition(light.matrixWorld);
																uniforms.position.applyMatrix4(viewMatrix);

																uniforms.color.copy(light.color).multiplyScalar(light.intensity);
																uniforms.distance = light.distance;
																uniforms.decay = light.decay;

																uniforms.shadow = light.castShadow;

																if (light.castShadow) {

																				var shadow = light.shadow;

																				uniforms.shadowBias = shadow.bias;
																				uniforms.shadowRadius = shadow.radius;
																				uniforms.shadowMapSize = shadow.mapSize;
																				uniforms.shadowCameraNear = shadow.camera.near;
																				uniforms.shadowCameraFar = shadow.camera.far;
																}

																state.pointShadowMap[pointLength] = shadowMap;
																state.pointShadowMatrix[pointLength] = light.shadow.matrix;
																state.point[pointLength] = uniforms;

																pointLength++;
												} else if (light.isHemisphereLight) {

																var uniforms = cache.get(light);

																uniforms.direction.setFromMatrixPosition(light.matrixWorld);
																uniforms.direction.transformDirection(viewMatrix);
																uniforms.direction.normalize();

																uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
																uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

																state.hemi[hemiLength] = uniforms;

																hemiLength++;
												}
								}

								state.ambient[0] = r;
								state.ambient[1] = g;
								state.ambient[2] = b;

								var hash = state.hash;

								if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.shadowsLength !== shadows.length) {

												state.directional.length = directionalLength;
												state.spot.length = spotLength;
												state.rectArea.length = rectAreaLength;
												state.point.length = pointLength;
												state.hemi.length = hemiLength;

												hash.directionalLength = directionalLength;
												hash.pointLength = pointLength;
												hash.spotLength = spotLength;
												hash.rectAreaLength = rectAreaLength;
												hash.hemiLength = hemiLength;
												hash.shadowsLength = shadows.length;

												state.version = nextVersion++;
								}
				}

				return {
								setup: setup,
								state: state
				};
}



/***/ }),
/* 436 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLMorphtargets; });


function absNumericalSort(a, b) {

		return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {

		var influencesList = {};
		var morphInfluences = new Float32Array(8);

		function update(object, geometry, material, program) {

				var objectInfluences = object.morphTargetInfluences;

				var length = objectInfluences.length;

				var influences = influencesList[geometry.id];

				if (influences === undefined) {

						influences = [];

						for (var i = 0; i < length; i++) {

								influences[i] = [i, 0];
						}

						influencesList[geometry.id] = influences;
				}

				var morphTargets = material.morphTargets && geometry.morphAttributes.position;
				var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

				for (var i = 0; i < length; i++) {

						var influence = influences[i];

						if (influence[1] !== 0) {

								if (morphTargets) geometry.removeAttribute('morphTarget' + i);
								if (morphNormals) geometry.removeAttribute('morphNormal' + i);
						}
				}

				for (var i = 0; i < length; i++) {

						var influence = influences[i];

						influence[0] = i;
						influence[1] = objectInfluences[i];
				}

				influences.sort(absNumericalSort);

				for (var i = 0; i < 8; i++) {

						var influence = influences[i];

						if (influence) {

								var index = influence[0];
								var value = influence[1];

								if (value) {

										if (morphTargets) geometry.addAttribute('morphTarget' + i, morphTargets[index]);
										if (morphNormals) geometry.addAttribute('morphNormal' + i, morphNormals[index]);

										morphInfluences[i] = value;
										continue;
								}
						}

						morphInfluences[i] = 0;
				}

				program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}

		return {

				update: update

		};
}



/***/ }),
/* 437 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLObjects; });


function WebGLObjects(geometries, info) {

		var updateList = {};

		function update(object) {

				var frame = info.render.frame;

				var geometry = object.geometry;
				var buffergeometry = geometries.get(object, geometry);

				if (updateList[buffergeometry.id] !== frame) {

						if (geometry.isGeometry) {

								buffergeometry.updateFromObject(object);
						}

						geometries.update(buffergeometry);

						updateList[buffergeometry.id] = frame;
				}

				return buffergeometry;
		}

		function dispose() {

				updateList = {};
		}

		return {

				update: update,
				dispose: dispose

		};
}



/***/ }),
/* 438 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLProgram; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WebGLUniforms_js__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebGLShader_js__ = __webpack_require__(443);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants_js__ = __webpack_require__(3);







var programIdCount = 0;

function addLineNumbers(string) {

	var lines = string.split('\n');

	for (var i = 0; i < lines.length; i++) {

		lines[i] = i + 1 + ': ' + lines[i];
	}

	return lines.join('\n');
}

function getEncodingComponents(encoding) {

	switch (encoding) {

		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["u" /* LinearEncoding */]:
			return ['Linear', '( value )'];
		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["Q" /* sRGBEncoding */]:
			return ['sRGB', '( value )'];
		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["R" /* RGBEEncoding */]:
			return ['RGBE', '( value )'];
		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["S" /* RGBM7Encoding */]:
			return ['RGBM', '( value, 7.0 )'];
		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["T" /* RGBM16Encoding */]:
			return ['RGBM', '( value, 16.0 )'];
		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["U" /* RGBDEncoding */]:
			return ['RGBD', '( value, 256.0 )'];
		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["M" /* GammaEncoding */]:
			return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
		default:
			throw new Error('unsupported encoding: ' + encoding);

	}
}

function getShaderErrors(gl, shader, type) {

	var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	var log = gl.getShaderInfoLog(shader).trim();

	if (status && log === '') return '';

	var source = gl.getShaderSource(shader);

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}

function getTexelDecodingFunction(functionName, encoding) {

	var components = getEncodingComponents(encoding);
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {

	var components = getEncodingComponents(encoding);
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {

	var toneMappingName;

	switch (toneMapping) {

		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["C" /* LinearToneMapping */]:
			toneMappingName = 'Linear';
			break;

		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["V" /* ReinhardToneMapping */]:
			toneMappingName = 'Reinhard';
			break;

		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["W" /* Uncharted2ToneMapping */]:
			toneMappingName = 'Uncharted2';
			break;

		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["X" /* CineonToneMapping */]:
			toneMappingName = 'OptimizedCineon';
			break;

		case __WEBPACK_IMPORTED_MODULE_3__constants_js__["Y" /* ACESFilmicToneMapping */]:
			toneMappingName = 'ACESFilmic';
			break;

		default:
			throw new Error('unsupported toneMapping: ' + toneMapping);

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(extensions, parameters, rendererExtensions) {

	extensions = extensions || {};

	var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];

	return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {

	var chunks = [];

	for (var name in defines) {

		var value = defines[name];

		if (value === false) continue;

		chunks.push('#define ' + name + ' ' + value);
	}

	return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {

	var attributes = {};

	var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

	for (var i = 0; i < n; i++) {

		var info = gl.getActiveAttrib(program, i);
		var name = info.name;

		attributes[name] = gl.getAttribLocation(program, name);
	}

	return attributes;
}

function filterEmptyLine(string) {

	return string !== '';
}

function replaceLightNums(string, parameters) {

	return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}

function replaceClippingPlaneNums(string, parameters) {

	return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

function parseIncludes(string) {

	var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function replace(match, include) {

		var replace = __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__["a" /* ShaderChunk */][include];

		if (replace === undefined) {

			throw new Error('Can not resolve #include <' + include + '>');
		}

		return parseIncludes(replace);
	}

	return string.replace(pattern, replace);
}

function unrollLoops(string) {

	var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

	function replace(match, start, end, snippet) {

		var unroll = '';

		for (var i = parseInt(start); i < parseInt(end); i++) {

			unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
		}

		return unroll;
	}

	return string.replace(pattern, replace);
}

function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {

	var gl = renderer.context;

	var defines = material.defines;

	var vertexShader = shader.vertexShader;
	var fragmentShader = shader.fragmentShader;

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if (parameters.shadowMapType === __WEBPACK_IMPORTED_MODULE_3__constants_js__["K" /* PCFShadowMap */]) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	} else if (parameters.shadowMapType === __WEBPACK_IMPORTED_MODULE_3__constants_js__["Z" /* PCFSoftShadowMap */]) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	}

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

	if (parameters.envMap) {

		switch (material.envMap.mapping) {

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["I" /* CubeReflectionMapping */]:
			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_0" /* CubeRefractionMapping */]:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["N" /* CubeUVReflectionMapping */]:
			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["O" /* CubeUVRefractionMapping */]:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_1" /* EquirectangularReflectionMapping */]:
			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_2" /* EquirectangularRefractionMapping */]:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_3" /* SphericalReflectionMapping */]:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

		switch (material.envMap.mapping) {

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_0" /* CubeRefractionMapping */]:
			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_2" /* EquirectangularRefractionMapping */]:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

		switch (material.combine) {

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["z" /* MultiplyOperation */]:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_4" /* MixOperation */]:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case __WEBPACK_IMPORTED_MODULE_3__constants_js__["_5" /* AddOperation */]:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}
	}

	var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;

	var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions(material.extensions, parameters, extensions);

	var customDefines = generateDefines(defines);

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if (material.isRawShaderMaterial) {

		prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

		if (prefixVertex.length > 0) {

			prefixVertex += '\n';
		}

		prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

		if (prefixFragment.length > 0) {

			prefixFragment += '\n';
		}
	} else {

		prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.instanceElement ? "#define USE_INSTANCE_ATTRIBUTE" : '', parameters.offsetVertexPosition ? "#define USE_OFFSET_VERTEX_POSITION" : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');

		prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.envMap && (capabilities.isWebGL2 || extensions.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', parameters.toneMapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["_6" /* NoToneMapping */] ? '#define TONE_MAPPING' : '', parameters.toneMapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["_6" /* NoToneMapping */] ? __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__["a" /* ShaderChunk */]['tonemapping_pars_fragment'] : '', parameters.toneMapping !== __WEBPACK_IMPORTED_MODULE_3__constants_js__["_6" /* NoToneMapping */] ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? __WEBPACK_IMPORTED_MODULE_2__shaders_ShaderChunk_js__["a" /* ShaderChunk */]['encodings_pars_fragment'] : '', parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '', parameters.instanceElement ? "#define USE_INSTANCE_ATTRIBUTE" : '', '\n'].filter(filterEmptyLine).join('\n');
	}

	vertexShader = parseIncludes(vertexShader);
	vertexShader = replaceLightNums(vertexShader, parameters);
	vertexShader = replaceClippingPlaneNums(vertexShader, parameters);

	fragmentShader = parseIncludes(fragmentShader);
	fragmentShader = replaceLightNums(fragmentShader, parameters);
	fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);

	vertexShader = unrollLoops(vertexShader);
	fragmentShader = unrollLoops(fragmentShader);

	if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {

		var isGLSL3ShaderMaterial = false;

		var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

		if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {

			isGLSL3ShaderMaterial = true;

			vertexShader = vertexShader.replace(versionRegex, '');
			fragmentShader = fragmentShader.replace(versionRegex, '');
		}

		prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;

		prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	var glVertexShader = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__WebGLShader_js__["a" /* WebGLShader */])(gl, gl.VERTEX_SHADER, vertexGlsl);
	var glFragmentShader = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__WebGLShader_js__["a" /* WebGLShader */])(gl, gl.FRAGMENT_SHADER, fragmentGlsl);

	gl.attachShader(program, glVertexShader);
	gl.attachShader(program, glFragmentShader);

	if (material.index0AttributeName !== undefined) {

		gl.bindAttribLocation(program, 0, material.index0AttributeName);
	} else if (parameters.morphTargets === true) {
		gl.bindAttribLocation(program, 0, 'position');
	}

	gl.linkProgram(program);

	if (renderer.debug.checkShaderErrors) {

		var programLog = gl.getProgramInfoLog(program).trim();
		var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
		var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();

		var runnable = true;
		var haveDiagnostics = true;

		if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {

			runnable = false;

			var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
			var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');

			console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
		} else if (programLog !== '') {

			console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
		} else if (vertexLog === '' || fragmentLog === '') {

			haveDiagnostics = false;
		}

		if (haveDiagnostics) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};
		}
	}

	gl.deleteShader(glVertexShader);
	gl.deleteShader(glFragmentShader);

	var cachedUniforms;

	this.getUniforms = function () {

		if (cachedUniforms === undefined) {

			cachedUniforms = new __WEBPACK_IMPORTED_MODULE_0__WebGLUniforms_js__["a" /* WebGLUniforms */](gl, program);
		}

		return cachedUniforms;
	};

	var cachedAttributes;

	this.getAttributes = function () {

		if (cachedAttributes === undefined) {

			cachedAttributes = fetchAttributeLocations(gl, program);
		}

		return cachedAttributes;
	};

	this.destroy = function () {

		gl.deleteProgram(program);
		this.program = undefined;
	};

	this.name = shader.name;
	this.id = programIdCount++;
	this.code = code;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;
}



/***/ }),
/* 439 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLPrograms; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebGLProgram_js__ = __webpack_require__(438);





function WebGLPrograms(renderer, extensions, capabilities) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "instanceElement", "offsetVertexPosition"];

	function allocateBones(object) {

		var skeleton = object.skeleton;
		var bones = skeleton.bones;

		if (capabilities.floatVertexTextures) {

			return 1024;
		} else {

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

			var maxBones = Math.min(nVertexMatrices, bones.length);

			if (maxBones < bones.length) {

				console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
				return 0;
			}

			return maxBones;
		}
	}

	function getTextureEncodingFromMap(map, gammaOverrideLinear) {

		var encoding;

		if (!map) {

			encoding = __WEBPACK_IMPORTED_MODULE_0__constants_js__["u" /* LinearEncoding */];
		} else if (map.isTexture) {

			encoding = map.encoding;
		} else if (map.isWebGLRenderTarget) {

			console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
			encoding = map.texture.encoding;
		}

		if (encoding === __WEBPACK_IMPORTED_MODULE_0__constants_js__["u" /* LinearEncoding */] && gammaOverrideLinear) {

			encoding = __WEBPACK_IMPORTED_MODULE_0__constants_js__["M" /* GammaEncoding */];
		}

		return encoding;
	}

	this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {

		var shaderID = shaderIDs[material.type];

		var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
		var precision = capabilities.precision;

		if (material.precision !== null) {

			precision = capabilities.getMaxPrecision(material.precision);

			if (precision !== material.precision) {

				console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
			}
		}

		var currentRenderTarget = renderer.getRenderTarget();

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
			map: !!material.map,
			mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
			matcap: !!material.matcap,
			matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
			envMap: !!material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
			envMapCubeUV: !!material.envMap && (material.envMap.mapping === __WEBPACK_IMPORTED_MODULE_0__constants_js__["N" /* CubeUVReflectionMapping */] || material.envMap.mapping === __WEBPACK_IMPORTED_MODULE_0__constants_js__["O" /* CubeUVRefractionMapping */]),
			lightMap: !!material.lightMap,
			aoMap: !!material.aoMap,
			emissiveMap: !!material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			objectSpaceNormalMap: material.normalMapType === __WEBPACK_IMPORTED_MODULE_0__constants_js__["P" /* ObjectSpaceNormalMap */],
			displacementMap: !!material.displacementMap,
			roughnessMap: !!material.roughnessMap,
			metalnessMap: !!material.metalnessMap,
			specularMap: !!material.specularMap,
			alphaMap: !!material.alphaMap,

			gradientMap: !!material.gradientMap,

			combine: material.combine,

			vertexTangents: material.normalMap && material.vertexTangents,
			vertexColors: material.vertexColors,

			fog: !!fog,
			useFog: material.fog,
			fogExp: fog && fog.isFogExp2,

			flatShading: material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["h" /* DoubleSide */],
			flipSided: material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */],

			depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,

			instanceElement: material.instanceMaterial !== undefined ? material.instanceMaterial : false,

			offsetVertexPosition: material.vertexOffset ? true : false

		};

		return parameters;
	};

	this.getProgramCode = function (material, parameters) {

		var array = [];

		if (parameters.shaderID) {

			array.push(parameters.shaderID);
		} else {

			array.push(material.fragmentShader);
			array.push(material.vertexShader);
		}

		if (material.defines !== undefined) {

			for (var name in material.defines) {

				array.push(name);
				array.push(material.defines[name]);
			}
		}

		for (var i = 0; i < parameterNames.length; i++) {

			array.push(parameters[parameterNames[i]]);
		}

		array.push(material.onBeforeCompile.toString());

		array.push(renderer.gammaOutput);

		array.push(renderer.gammaFactor);

		return array.join();
	};

	this.acquireProgram = function (material, shader, parameters, code) {

		var program;

		for (var p = 0, pl = programs.length; p < pl; p++) {

			var programInfo = programs[p];

			if (programInfo.code === code) {

				program = programInfo;
				++program.usedTimes;

				break;
			}
		}

		if (program === undefined) {

			program = new __WEBPACK_IMPORTED_MODULE_1__WebGLProgram_js__["a" /* WebGLProgram */](renderer, extensions, code, material, shader, parameters, capabilities);
			programs.push(program);
		}

		return program;
	};

	this.releaseProgram = function (program) {

		if (--program.usedTimes === 0) {
			var i = programs.indexOf(program);
			programs[i] = programs[programs.length - 1];
			programs.pop();

			program.destroy();
		}
	};

	this.programs = programs;
}



/***/ }),
/* 440 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLProperties; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map__);



function WebGLProperties() {

	var properties = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map___default.a();

	function get(object) {

		var map = properties.get(object);

		if (map === undefined) {

			map = {};
			properties.set(object, map);
		}

		return map;
	}

	function remove(object) {

		properties.delete(object);
	}

	function update(object, key, value) {

		properties.get(object)[key] = value;
	}

	function dispose() {

		properties = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_weak_map___default.a();
	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};
}



/***/ }),
/* 441 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderLists; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(3);


function painterSortStable(a, b) {

	if (a.groupOrder !== b.groupOrder) {

		return a.groupOrder - b.groupOrder;
	} else if (a.renderOrder !== b.renderOrder) {

		return a.renderOrder - b.renderOrder;
	} else if (a.program !== b.program) {

		return a.program.id - b.program.id;
	} else if (a.material.id !== b.material.id) {

		return a.material.id - b.material.id;
	} else if (a.z !== b.z) {

		return a.z - b.z;
	} else {

		return a.id - b.id;
	}
}

function reversePainterSortStable(a, b) {

	if (a.groupOrder !== b.groupOrder) {

		return a.groupOrder - b.groupOrder;
	} else if (a.renderOrder !== b.renderOrder) {

		return a.renderOrder - b.renderOrder;
	} else if (a.z !== b.z) {

		return b.z - a.z;
	} else {

		return a.id - b.id;
	}
}

function WebGLRenderList() {

	var renderItems = [];
	var renderItemsIndex = 0;

	var opaque = [];
	var transparent = [];

	var defaultProgram = { id: -1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;
	}

	function getNextRenderItem(object, geometry, material, groupOrder, z, group) {

		var renderItem = renderItems[renderItemsIndex];

		if (renderItem === undefined) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: material.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[renderItemsIndex] = renderItem;
		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = material.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
		}

		renderItemsIndex++;

		return renderItem;
	}

	function push(object, geometry, material, groupOrder, z, group) {

		var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

		if (geometry.isPMBufferGeometry || geometry.isPMInstanceBufferGeometry) {
			var mod = 0;
			if (geometry.isPMInstanceBufferGeometry) {
				if (geometry.getTransparency() === undefined) {
					if (material.transparent === true) {
						mod |= 1;
					} else {
						mod |= 2;
					}
				} else {
					if (geometry.getTransparency()) {
						mod |= 1;
					} else {
						mod |= 2;
					}
				}
			} else {
				var indexArray = geometry.getIndexArray();
				for (var i = 0, il = indexArray.length; i < il; i++) {
					var indexAttribute = indexArray[i];
					var drawRangeArray = indexAttribute.getDrawRangeArray();
					for (var j = 0, jl = drawRangeArray.length; j < jl; j++) {
						if (mod === 3) {
							break;
						}
						var drawRange = drawRangeArray[j];
						if (drawRange.getTransparency() === undefined) {
							if (material.transparent === true) {
								mod |= 1;
							} else {
								mod |= 2;
							}
						} else {
							if (drawRange.getTransparency()) {
								mod |= 1;
							} else {
								mod |= 2;
							}
						}
					}
					if (mod === 3) {
						break;
					}
				}
			}
			if (mod & 1) {
				transparent.push(renderItem);
			}
			if (mod & 2) {
				opaque.push(renderItem);
			}
		} else {
			(material.transparent === true ? transparent : opaque).push(renderItem);
		}
	}

	function unshift(object, geometry, material, groupOrder, z, group) {

		var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

		(material.transparent === true ? transparent : opaque).unshift(renderItem);
	}

	function sort() {

		if (opaque.length > 1) opaque.sort(painterSortStable);
		if (transparent.length > 1) transparent.sort(reversePainterSortStable);
	}

	return {
		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,

		sort: sort
	};
}

function WebGLRenderLists() {

	var lists = {};

	function onSceneDispose(event) {

		var scene = event.target;

		scene.removeEventListener('dispose', onSceneDispose);

		delete lists[scene.id];
	}

	function get(scene, camera) {

		var cameras = lists[scene.id];
		var list;
		if (cameras === undefined) {

			list = new WebGLRenderList();
			lists[scene.id] = {};
			lists[scene.id][camera.id] = list;

			scene.addEventListener('dispose', onSceneDispose);
		} else {

			list = cameras[camera.id];
			if (list === undefined) {

				list = new WebGLRenderList();
				cameras[camera.id] = list;
			}
		}

		return list;
	}

	function dispose() {

		lists = {};
	}

	return {
		get: get,
		dispose: dispose
	};
}



/***/ }),
/* 442 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLRenderStates; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WebGLLights_js__ = __webpack_require__(435);




function WebGLRenderState() {

	var lights = new __WEBPACK_IMPORTED_MODULE_0__WebGLLights_js__["a" /* WebGLLights */]();

	var lightsArray = [];
	var shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;
	}

	function pushLight(light) {

		lightsArray.push(light);
	}

	function pushShadow(shadowLight) {

		shadowsArray.push(shadowLight);
	}

	function setupLights(camera) {

		lights.setup(lightsArray, shadowsArray, camera);
	}

	var state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,

		pushLight: pushLight,
		pushShadow: pushShadow
	};
}

function WebGLRenderStates() {

	var renderStates = {};

	function onSceneDispose(event) {

		var scene = event.target;

		scene.removeEventListener('dispose', onSceneDispose);

		delete renderStates[scene.id];
	}

	function get(scene, camera) {

		var renderState;

		if (renderStates[scene.id] === undefined) {

			renderState = new WebGLRenderState();
			renderStates[scene.id] = {};
			renderStates[scene.id][camera.id] = renderState;

			scene.addEventListener('dispose', onSceneDispose);
		} else {

			if (renderStates[scene.id][camera.id] === undefined) {

				renderState = new WebGLRenderState();
				renderStates[scene.id][camera.id] = renderState;
			} else {

				renderState = renderStates[scene.id][camera.id];
			}
		}

		return renderState;
	}

	function dispose() {

		renderStates = {};
	}

	return {
		get: get,
		dispose: dispose
	};
}



/***/ }),
/* 443 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLShader; });


function WebGLShader(gl, type, string) {

	var shader = gl.createShader(type);

	gl.shaderSource(shader, string);
	gl.compileShader(shader);

	return shader;
}



/***/ }),
/* 444 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLShadowMap; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__WebGLRenderTarget_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__materials_MeshDepthMaterial_js__ = __webpack_require__(286);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__materials_MeshDistanceMaterial_js__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__math_Frustum_js__ = __webpack_require__(93);












function WebGLShadowMap(_renderer, _objects, maxTextureSize) {

		var _frustum = new __WEBPACK_IMPORTED_MODULE_8__math_Frustum_js__["a" /* Frustum */](),
		    _projScreenMatrix = new __WEBPACK_IMPORTED_MODULE_7__math_Matrix4_js__["a" /* Matrix4 */](),
		    _shadowMapSize = new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](),
		    _maxShadowMapSize = new __WEBPACK_IMPORTED_MODULE_6__math_Vector2_js__["a" /* Vector2 */](maxTextureSize, maxTextureSize),
		    _lookTarget = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
		    _lightPositionWorld = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](),
		    _MorphingFlag = 1,
		    _SkinningFlag = 2,
		    _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
		    _depthMaterials = new Array(_NumberOfMaterialVariants),
		    _distanceMaterials = new Array(_NumberOfMaterialVariants),
		    _materialCache = {};

		var shadowSide = { 0: __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */], 1: __WEBPACK_IMPORTED_MODULE_0__constants_js__["j" /* FrontSide */], 2: __WEBPACK_IMPORTED_MODULE_0__constants_js__["h" /* DoubleSide */] };

		var cubeDirections = [new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](1, 0, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](-1, 0, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, 1), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, -1), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, -1, 0)];

		var cubeUps = [new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 1, 0), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, 1), new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */](0, 0, -1)];

		var cube2DViewPorts = [new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */](), new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */]()];

		for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {

				var useMorphing = (i & _MorphingFlag) !== 0;
				var useSkinning = (i & _SkinningFlag) !== 0;

				var depthMaterial = new __WEBPACK_IMPORTED_MODULE_2__materials_MeshDepthMaterial_js__["a" /* MeshDepthMaterial */]({

						depthPacking: __WEBPACK_IMPORTED_MODULE_0__constants_js__["J" /* RGBADepthPacking */],

						morphTargets: useMorphing,
						skinning: useSkinning

				});

				_depthMaterials[i] = depthMaterial;

				var distanceMaterial = new __WEBPACK_IMPORTED_MODULE_3__materials_MeshDistanceMaterial_js__["a" /* MeshDistanceMaterial */]({

						morphTargets: useMorphing,
						skinning: useSkinning

				});

				_distanceMaterials[i] = distanceMaterial;
		}

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["K" /* PCFShadowMap */];

		this.render = function (lights, scene, camera) {

				if (scope.enabled === false) return;
				if (scope.autoUpdate === false && scope.needsUpdate === false) return;

				if (lights.length === 0) return;

				var currentRenderTarget = _renderer.getRenderTarget();
				var activeCubeFace = _renderer.getActiveCubeFace();
				var activeMipMapLevel = _renderer.getActiveMipMapLevel();

				var _state = _renderer.state;

				_state.setBlending(__WEBPACK_IMPORTED_MODULE_0__constants_js__["D" /* NoBlending */]);
				_state.buffers.color.setClear(1, 1, 1, 1);
				_state.buffers.depth.setTest(true);
				_state.setScissorTest(false);

				var faceCount;

				for (var i = 0, il = lights.length; i < il; i++) {

						var light = lights[i];
						var shadow = light.shadow;
						var isPointLight = light && light.isPointLight;

						if (shadow === undefined) {

								console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
								continue;
						}

						var shadowCamera = shadow.camera;

						_shadowMapSize.copy(shadow.mapSize);
						_shadowMapSize.min(_maxShadowMapSize);

						if (isPointLight) {

								var vpWidth = _shadowMapSize.x;
								var vpHeight = _shadowMapSize.y;

								cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);

								cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);

								cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);

								cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);

								cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);

								cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);

								_shadowMapSize.x *= 4.0;
								_shadowMapSize.y *= 2.0;
						}

						if (shadow.map === null) {

								var pars = { minFilter: __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */], magFilter: __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */], format: __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RGBAFormat */] };

								shadow.map = new __WEBPACK_IMPORTED_MODULE_1__WebGLRenderTarget_js__["a" /* WebGLRenderTarget */](_shadowMapSize.x, _shadowMapSize.y, pars);
								shadow.map.texture.name = light.name + ".shadowMap";

								shadowCamera.updateProjectionMatrix();
						}

						if (shadow.isSpotLightShadow) {

								shadow.update(light);
						}

						var shadowMap = shadow.map;
						var shadowMatrix = shadow.matrix;

						_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
						shadowCamera.position.copy(_lightPositionWorld);

						if (isPointLight) {

								faceCount = 6;

								shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
						} else {

								faceCount = 1;

								_lookTarget.setFromMatrixPosition(light.target.matrixWorld);
								shadowCamera.lookAt(_lookTarget);
								shadowCamera.updateMatrixWorld();

								shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);

								shadowMatrix.multiply(shadowCamera.projectionMatrix);
								shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
						}

						_renderer.setRenderTarget(shadowMap);
						_renderer.clear();

						for (var face = 0; face < faceCount; face++) {

								if (isPointLight) {

										_lookTarget.copy(shadowCamera.position);
										_lookTarget.add(cubeDirections[face]);
										shadowCamera.up.copy(cubeUps[face]);
										shadowCamera.lookAt(_lookTarget);
										shadowCamera.updateMatrixWorld();

										var vpDimensions = cube2DViewPorts[face];
										_state.viewport(vpDimensions);
								}

								_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
								_frustum.setFromMatrix(_projScreenMatrix);

								renderObject(scene, camera, shadowCamera, isPointLight);
						}
				}

				scope.needsUpdate = false;

				_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipMapLevel);
		};

		function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {

				var geometry = object.geometry;

				var result = null;

				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;

				if (isPointLight) {

						materialVariants = _distanceMaterials;
						customMaterial = object.customDistanceMaterial;
				}

				if (!customMaterial) {

						var useMorphing = false;

						if (material.morphTargets) {

								if (geometry && geometry.isBufferGeometry) {

										useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
								} else if (geometry && geometry.isGeometry) {

										useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
								}
						}

						if (object.isSkinnedMesh && material.skinning === false) {

								console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
						}

						var useSkinning = object.isSkinnedMesh && material.skinning;

						var variantIndex = 0;

						if (useMorphing) variantIndex |= _MorphingFlag;
						if (useSkinning) variantIndex |= _SkinningFlag;

						result = materialVariants[variantIndex];
				} else {

						result = customMaterial;
				}

				if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {

						var keyA = result.uuid,
						    keyB = material.uuid;

						var materialsForVariant = _materialCache[keyA];

						if (materialsForVariant === undefined) {

								materialsForVariant = {};
								_materialCache[keyA] = materialsForVariant;
						}

						var cachedMaterial = materialsForVariant[keyB];

						if (cachedMaterial === undefined) {

								cachedMaterial = result.clone();
								materialsForVariant[keyB] = cachedMaterial;
						}

						result = cachedMaterial;
				}

				result.visible = material.visible;
				result.wireframe = material.wireframe;

				result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];

				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;
				result.clipIntersection = material.clipIntersection;

				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;

				if (isPointLight && result.isMeshDistanceMaterial) {

						result.referencePosition.copy(lightPositionWorld);
						result.nearDistance = shadowCameraNear;
						result.farDistance = shadowCameraFar;
				}

				return result;
		}

		function renderObject(object, camera, shadowCamera, isPointLight) {

				if (object.visible === false) return;

				var visible = object.layers.test(camera.layers);

				if (visible && (object.isMesh || object.isLine || object.isPoints)) {

						if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {

								object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

								var geometry = _objects.update(object);
								var material = object.material;

								if (Array.isArray(material)) {

										var groups = geometry.groups;

										for (var k = 0, kl = groups.length; k < kl; k++) {

												var group = groups[k];
												var groupMaterial = material[group.materialIndex];

												if (groupMaterial && groupMaterial.visible) {

														var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
														_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
												}
										}
								} else if (material.visible) {

										var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
										_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
								}
						}
				}

				var children = object.children;

				for (var i = 0, l = children.length; i < l; i++) {

						renderObject(children[i], camera, shadowCamera, isPointLight);
				}
		}
}



/***/ }),
/* 445 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLState; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__ = __webpack_require__(36);





function WebGLState(gl, extensions, utils, capabilities) {

		function ColorBuffer() {

				var locked = false;

				var color = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();
				var currentColorMask = null;
				var currentColorClear = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */](0, 0, 0, 0);

				return {

						setMask: function setMask(colorMask) {

								if (currentColorMask !== colorMask && !locked) {

										gl.colorMask(colorMask, colorMask, colorMask, colorMask);
										currentColorMask = colorMask;
								}
						},

						setLocked: function setLocked(lock) {

								locked = lock;
						},

						setClear: function setClear(r, g, b, a, premultipliedAlpha) {

								if (premultipliedAlpha === true) {

										r *= a;g *= a;b *= a;
								}

								color.set(r, g, b, a);

								if (currentColorClear.equals(color) === false) {

										gl.clearColor(r, g, b, a);
										currentColorClear.copy(color);
								}
						},

						reset: function reset() {

								locked = false;

								currentColorMask = null;
								currentColorClear.set(-1, 0, 0, 0);
						}

				};
		}

		function DepthBuffer() {

				var locked = false;

				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;

				return {

						setTest: function setTest(depthTest) {

								if (depthTest) {

										enable(gl.DEPTH_TEST);
								} else {

										disable(gl.DEPTH_TEST);
								}
						},

						setMask: function setMask(depthMask) {

								if (currentDepthMask !== depthMask && !locked) {

										gl.depthMask(depthMask);
										currentDepthMask = depthMask;
								}
						},

						setFunc: function setFunc(depthFunc) {

								if (currentDepthFunc !== depthFunc) {

										if (depthFunc) {

												switch (depthFunc) {

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_14" /* NeverDepth */]:

																gl.depthFunc(gl.NEVER);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_15" /* AlwaysDepth */]:

																gl.depthFunc(gl.ALWAYS);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_16" /* LessDepth */]:

																gl.depthFunc(gl.LESS);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["o" /* LessEqualDepth */]:

																gl.depthFunc(gl.LEQUAL);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_17" /* EqualDepth */]:

																gl.depthFunc(gl.EQUAL);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_18" /* GreaterEqualDepth */]:

																gl.depthFunc(gl.GEQUAL);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_19" /* GreaterDepth */]:

																gl.depthFunc(gl.GREATER);
																break;

														case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_20" /* NotEqualDepth */]:

																gl.depthFunc(gl.NOTEQUAL);
																break;

														default:

																gl.depthFunc(gl.LEQUAL);

												}
										} else {

												gl.depthFunc(gl.LEQUAL);
										}

										currentDepthFunc = depthFunc;
								}
						},

						setLocked: function setLocked(lock) {

								locked = lock;
						},

						setClear: function setClear(depth) {

								if (currentDepthClear !== depth) {

										gl.clearDepth(depth);
										currentDepthClear = depth;
								}
						},

						reset: function reset() {

								locked = false;

								currentDepthMask = null;
								currentDepthFunc = null;
								currentDepthClear = null;
						}

				};
		}

		function StencilBuffer() {

				var locked = false;

				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;

				return {

						setTest: function setTest(stencilTest) {

								if (stencilTest) {

										enable(gl.STENCIL_TEST);
								} else {

										disable(gl.STENCIL_TEST);
								}
						},

						setMask: function setMask(stencilMask) {

								if (currentStencilMask !== stencilMask && !locked) {

										gl.stencilMask(stencilMask);
										currentStencilMask = stencilMask;
								}
						},

						setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {

								if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {

										gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

										currentStencilFunc = stencilFunc;
										currentStencilRef = stencilRef;
										currentStencilFuncMask = stencilMask;
								}
						},

						setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {

								if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {

										gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

										currentStencilFail = stencilFail;
										currentStencilZFail = stencilZFail;
										currentStencilZPass = stencilZPass;
								}
						},

						setLocked: function setLocked(lock) {

								locked = lock;
						},

						setClear: function setClear(stencil) {

								if (currentStencilClear !== stencil) {

										gl.clearStencil(stencil);
										currentStencilClear = stencil;
								}
						},

						reset: function reset() {

								locked = false;

								currentStencilMask = null;
								currentStencilFunc = null;
								currentStencilRef = null;
								currentStencilFuncMask = null;
								currentStencilFail = null;
								currentStencilZFail = null;
								currentStencilZPass = null;
								currentStencilClear = null;
						}

				};
		}

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		var newAttributes = new Uint8Array(maxVertexAttributes);
		var enabledAttributes = new Uint8Array(maxVertexAttributes);
		var attributeDivisors = new Uint8Array(maxVertexAttributes);

		var enabledCapabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter(gl.VERSION);

		if (glVersion.indexOf('WebGL') !== -1) {

				version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
				lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {

				version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
				lineWidthAvailable = version >= 2.0;
		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();
		var currentViewport = new __WEBPACK_IMPORTED_MODULE_1__math_Vector4_js__["a" /* Vector4 */]();

		function createTexture(type, target, count) {

				var data = new Uint8Array(4);
				var texture = gl.createTexture();

				gl.bindTexture(type, texture);
				gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

				for (var i = 0; i < count; i++) {

						gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
				}

				return texture;
		}

		var emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);

		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(__WEBPACK_IMPORTED_MODULE_0__constants_js__["o" /* LessEqualDepth */]);

		setFlipSided(false);
		setCullFace(__WEBPACK_IMPORTED_MODULE_0__constants_js__["_21" /* CullFaceBack */]);
		enable(gl.CULL_FACE);

		setBlending(__WEBPACK_IMPORTED_MODULE_0__constants_js__["D" /* NoBlending */]);

		function initAttributes() {

				for (var i = 0, l = newAttributes.length; i < l; i++) {

						newAttributes[i] = 0;
				}
		}

		function enableAttribute(attribute) {

				enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {

				newAttributes[attribute] = 1;

				if (enabledAttributes[attribute] === 0) {

						gl.enableVertexAttribArray(attribute);
						enabledAttributes[attribute] = 1;
				}

				if (attributeDivisors[attribute] !== meshPerAttribute) {

						var extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');

						extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
						attributeDivisors[attribute] = meshPerAttribute;
				}
		}

		function disableUnusedAttributes() {

				for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {

						if (enabledAttributes[i] !== newAttributes[i]) {

								gl.disableVertexAttribArray(i);
								enabledAttributes[i] = 0;
						}
				}
		}

		function enable(id) {

				if (enabledCapabilities[id] !== true) {

						gl.enable(id);
						enabledCapabilities[id] = true;
				}
		}

		function disable(id) {

				if (enabledCapabilities[id] !== false) {

						gl.disable(id);
						enabledCapabilities[id] = false;
				}
		}

		function getCompressedTextureFormats() {

				if (compressedTextureFormats === null) {

						compressedTextureFormats = [];

						if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1') || extensions.get('WEBGL_compressed_texture_astc')) {

								var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);

								for (var i = 0; i < formats.length; i++) {

										compressedTextureFormats.push(formats[i]);
								}
						}
				}

				return compressedTextureFormats;
		}

		function useProgram(program) {

				if (currentProgram !== program) {

						gl.useProgram(program);

						currentProgram = program;

						return true;
				}

				return false;
		}

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {

				if (blending === __WEBPACK_IMPORTED_MODULE_0__constants_js__["D" /* NoBlending */]) {

						if (currentBlendingEnabled) {

								disable(gl.BLEND);
								currentBlendingEnabled = false;
						}

						return;
				}

				if (!currentBlendingEnabled) {

						enable(gl.BLEND);
						currentBlendingEnabled = true;
				}

				if (blending !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_22" /* CustomBlending */]) {

						if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {

								if (currentBlendEquation !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["n" /* AddEquation */] || currentBlendEquationAlpha !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["n" /* AddEquation */]) {

										gl.blendEquation(gl.FUNC_ADD);

										currentBlendEquation = __WEBPACK_IMPORTED_MODULE_0__constants_js__["n" /* AddEquation */];
										currentBlendEquationAlpha = __WEBPACK_IMPORTED_MODULE_0__constants_js__["n" /* AddEquation */];
								}

								if (premultipliedAlpha) {

										switch (blending) {

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["i" /* NormalBlending */]:
														gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
														break;

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["q" /* AdditiveBlending */]:
														gl.blendFunc(gl.ONE, gl.ONE);
														break;

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_23" /* SubtractiveBlending */]:
														gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
														break;

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_24" /* MultiplyBlending */]:
														gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
														break;

												default:
														console.error('THREE.WebGLState: Invalid blending: ', blending);
														break;

										}
								} else {

										switch (blending) {

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["i" /* NormalBlending */]:
														gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
														break;

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["q" /* AdditiveBlending */]:
														gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
														break;

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_23" /* SubtractiveBlending */]:
														gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
														break;

												case __WEBPACK_IMPORTED_MODULE_0__constants_js__["_24" /* MultiplyBlending */]:
														gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
														break;

												default:
														console.error('THREE.WebGLState: Invalid blending: ', blending);
														break;

										}
								}

								currentBlendSrc = null;
								currentBlendDst = null;
								currentBlendSrcAlpha = null;
								currentBlendDstAlpha = null;

								currentBlending = blending;
								currentPremultipledAlpha = premultipliedAlpha;
						}

						return;
				}

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {

						gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));

						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;
				}

				if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {

						gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));

						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;
				}

				currentBlending = blending;
				currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {

				material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["h" /* DoubleSide */] ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);

				var flipSided = material.side === __WEBPACK_IMPORTED_MODULE_0__constants_js__["g" /* BackSide */];
				if (frontFaceCW) flipSided = !flipSided;

				setFlipSided(flipSided);

				material.blending === __WEBPACK_IMPORTED_MODULE_0__constants_js__["i" /* NormalBlending */] && material.transparent === false ? setBlending(__WEBPACK_IMPORTED_MODULE_0__constants_js__["D" /* NoBlending */]) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);

				depthBuffer.setFunc(material.depthFunc);
				depthBuffer.setTest(material.depthTest);
				depthBuffer.setMask(material.depthWrite);
				colorBuffer.setMask(material.colorWrite);

				setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		}

		function setFlipSided(flipSided) {

				if (currentFlipSided !== flipSided) {

						if (flipSided) {

								gl.frontFace(gl.CW);
						} else {

								gl.frontFace(gl.CCW);
						}

						currentFlipSided = flipSided;
				}
		}

		function setCullFace(cullFace) {

				if (cullFace !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_25" /* CullFaceNone */]) {

						enable(gl.CULL_FACE);

						if (cullFace !== currentCullFace) {

								if (cullFace === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_21" /* CullFaceBack */]) {

										gl.cullFace(gl.BACK);
								} else if (cullFace === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_26" /* CullFaceFront */]) {

										gl.cullFace(gl.FRONT);
								} else {

										gl.cullFace(gl.FRONT_AND_BACK);
								}
						}
				} else {

						disable(gl.CULL_FACE);
				}

				currentCullFace = cullFace;
		}

		function setLineWidth(width) {

				if (width !== currentLineWidth) {

						if (lineWidthAvailable) gl.lineWidth(width);

						currentLineWidth = width;
				}
		}

		function setPolygonOffset(polygonOffset, factor, units) {

				if (polygonOffset) {

						enable(gl.POLYGON_OFFSET_FILL);

						if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {

								gl.polygonOffset(factor, units);

								currentPolygonOffsetFactor = factor;
								currentPolygonOffsetUnits = units;
						}
				} else {

						disable(gl.POLYGON_OFFSET_FILL);
				}
		}

		function setScissorTest(scissorTest) {

				if (scissorTest) {

						enable(gl.SCISSOR_TEST);
				} else {

						disable(gl.SCISSOR_TEST);
				}
		}

		function activeTexture(webglSlot) {

				if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

				if (currentTextureSlot !== webglSlot) {

						gl.activeTexture(webglSlot);
						currentTextureSlot = webglSlot;
				}
		}

		function bindTexture(webglType, webglTexture) {

				if (currentTextureSlot === null) {

						activeTexture();
				}

				var boundTexture = currentBoundTextures[currentTextureSlot];

				if (boundTexture === undefined) {

						boundTexture = { type: undefined, texture: undefined };
						currentBoundTextures[currentTextureSlot] = boundTexture;
				}

				if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {

						gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

						boundTexture.type = webglType;
						boundTexture.texture = webglTexture;
				}
		}

		function compressedTexImage2D() {

				try {

						gl.compressedTexImage2D.apply(gl, arguments);
				} catch (error) {

						console.error('THREE.WebGLState:', error);
				}
		}

		function texImage2D() {

				try {

						gl.texImage2D.apply(gl, arguments);
				} catch (error) {

						console.error('THREE.WebGLState:', error);
				}
		}

		function texImage3D() {

				try {

						gl.texImage3D.apply(gl, arguments);
				} catch (error) {

						console.error('THREE.WebGLState:', error);
				}
		}

		function scissor(scissor) {

				if (currentScissor.equals(scissor) === false) {

						gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
						currentScissor.copy(scissor);
				}
		}

		function viewport(viewport) {

				if (currentViewport.equals(viewport) === false) {

						gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
						currentViewport.copy(viewport);
				}
		}

		function reset() {

				for (var i = 0; i < enabledAttributes.length; i++) {

						if (enabledAttributes[i] === 1) {

								gl.disableVertexAttribArray(i);
								enabledAttributes[i] = 0;
						}
				}

				enabledCapabilities = {};

				compressedTextureFormats = null;

				currentTextureSlot = null;
				currentBoundTextures = {};

				currentProgram = null;

				currentBlending = null;

				currentFlipSided = null;
				currentCullFace = null;

				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();
		}

		return {

				buffers: {
						color: colorBuffer,
						depth: depthBuffer,
						stencil: stencilBuffer
				},

				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,

				useProgram: useProgram,

				setBlending: setBlending,
				setMaterial: setMaterial,

				setFlipSided: setFlipSided,
				setCullFace: setCullFace,

				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,

				setScissorTest: setScissorTest,

				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,
				texImage3D: texImage3D,

				scissor: scissor,
				viewport: viewport,

				reset: reset

		};
}



/***/ }),
/* 446 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLTextures; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_Math_js__ = __webpack_require__(8);





function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info, enableOffScreenCanvas) {

	var _videoTextures = {};
	var _canvas;

	var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && enableOffScreenCanvas;

	function createCanvas(width, height) {

		return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	}

	function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {

		var scale = 1;

		if (image.width > maxSize || image.height > maxSize) {

			scale = maxSize / Math.max(image.width, image.height);
		}

		if (scale < 1 || needsPowerOfTwo === true) {

			if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {

				var floor = needsPowerOfTwo ? __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].floorPowerOfTwo : Math.floor;

				var width = floor(scale * image.width);
				var height = floor(scale * image.height);

				if (_canvas === undefined) _canvas = createCanvas(width, height);

				var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;

				canvas.width = width;
				canvas.height = height;

				var context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, width, height);

				console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');

				return canvas;
			} else {

				if ('data' in image) {

					console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
				}

				return image;
			}
		}

		return image;
	}

	function isPowerOfTwo(image) {

		return __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].isPowerOfTwo(image.width) && __WEBPACK_IMPORTED_MODULE_1__math_Math_js__["a" /* _Math */].isPowerOfTwo(image.height);
	}

	function textureNeedsPowerOfTwo(texture) {

		if (capabilities.isWebGL2) return false;

		return texture.wrapS !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["r" /* ClampToEdgeWrapping */] || texture.wrapT !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["r" /* ClampToEdgeWrapping */] || texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */] && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* LinearFilter */];
	}

	function textureNeedsGenerateMipmaps(texture, supportsMips) {

		return texture.generateMipmaps && supportsMips && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */] && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* LinearFilter */];
	}

	function generateMipmap(target, texture, width, height) {

		_gl.generateMipmap(target);

		var textureProperties = properties.get(texture);

		textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
	}

	function getInternalFormat(glFormat, glType) {

		if (!capabilities.isWebGL2) return glFormat;

		var internalFormat = glFormat;

		if (glFormat === _gl.RED) {

			if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
		}

		if (glFormat === _gl.RGB) {

			if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
		}

		if (glFormat === _gl.RGBA) {

			if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
			if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
			if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
		}

		if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {

			extensions.get('EXT_color_buffer_float');
		} else if (internalFormat === _gl.RGB16F || internalFormat === _gl.RGB32F) {

			console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');
		}

		return internalFormat;
	}

	function filterFallback(f) {

		if (f === __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */] || f === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_7" /* NearestMipMapNearestFilter */] || f === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_8" /* NearestMipMapLinearFilter */]) {

			return _gl.NEAREST;
		}

		return _gl.LINEAR;
	}

	function onTextureDispose(event) {

		var texture = event.target;

		texture.removeEventListener('dispose', onTextureDispose);

		deallocateTexture(texture);

		if (texture.isVideoTexture) {

			delete _videoTextures[texture.id];
		}

		info.memory.textures--;
	}

	function onRenderTargetDispose(event) {

		var renderTarget = event.target;

		renderTarget.removeEventListener('dispose', onRenderTargetDispose);

		deallocateRenderTarget(renderTarget);

		info.memory.textures--;
	}

	function deallocateTexture(texture) {

		var textureProperties = properties.get(texture);

		if (textureProperties.__webglInit === undefined) return;

		_gl.deleteTexture(textureProperties.__webglTexture);

		properties.remove(texture);
	}

	function deallocateRenderTarget(renderTarget) {

		var renderTargetProperties = properties.get(renderTarget);
		var textureProperties = properties.get(renderTarget.texture);

		if (!renderTarget) return;

		if (textureProperties.__webglTexture !== undefined) {

			_gl.deleteTexture(textureProperties.__webglTexture);
		}

		if (renderTarget.depthTexture) {

			renderTarget.depthTexture.dispose();
		}

		if (renderTarget.isWebGLRenderTargetCube) {

			for (var i = 0; i < 6; i++) {

				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
			}
		} else {

			_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
			if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
		}

		properties.remove(renderTarget.texture);
		properties.remove(renderTarget);
	}

	var textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;
	}

	function allocateTextureUnit() {

		var textureUnit = textureUnits;

		if (textureUnit >= capabilities.maxTextures) {

			console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
		}

		textureUnits += 1;

		return textureUnit;
	}

	function setTexture2D(texture, slot) {

		var textureProperties = properties.get(texture);

		if (texture.isVideoTexture) updateVideoTexture(texture);

		if (texture.version > 0 && textureProperties.__version !== texture.version) {

			var image = texture.image;

			if (image === undefined) {

				console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
			} else if (image.complete === false) {

				console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
			} else {

				uploadTexture(textureProperties, texture, slot);
				return;
			}
		}

		state.activeTexture(_gl.TEXTURE0 + slot);
		state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
	}

	function setTexture2DArray(texture, slot) {

		var textureProperties = properties.get(texture);

		if (texture.version > 0 && textureProperties.__version !== texture.version) {

			uploadTexture(textureProperties, texture, slot);
			return;
		}

		state.activeTexture(_gl.TEXTURE0 + slot);
		state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
	}

	function setTexture3D(texture, slot) {

		var textureProperties = properties.get(texture);

		if (texture.version > 0 && textureProperties.__version !== texture.version) {

			uploadTexture(textureProperties, texture, slot);
			return;
		}

		state.activeTexture(_gl.TEXTURE0 + slot);
		state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
	}

	function setTextureCube(texture, slot) {

		var textureProperties = properties.get(texture);

		if (texture.image.length === 6) {

			if (texture.version > 0 && textureProperties.__version !== texture.version) {

				initTexture(textureProperties, texture);

				state.activeTexture(_gl.TEXTURE0 + slot);
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

				_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

				var isCompressed = texture && texture.isCompressedTexture;
				var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;

				var cubeImage = [];

				for (var i = 0; i < 6; i++) {

					if (!isCompressed && !isDataTexture) {

						cubeImage[i] = resizeImage(texture.image[i], false, true, capabilities.maxCubemapSize);
					} else {

						cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
					}
				}

				var image = cubeImage[0],
				    supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2,
				    glFormat = utils.convert(texture.format),
				    glType = utils.convert(texture.type),
				    glInternalFormat = getInternalFormat(glFormat, glType);

				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

				for (var i = 0; i < 6; i++) {

					if (!isCompressed) {

						if (isDataTexture) {

							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
						} else {

							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
						}
					} else {

						var mipmap,
						    mipmaps = cubeImage[i].mipmaps;

						for (var j = 0, jl = mipmaps.length; j < jl; j++) {

							mipmap = mipmaps[j];

							if (texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RGBAFormat */] && texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* RGBFormat */]) {

								if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {

									state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
								} else {

									console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
								}
							} else {

								state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
							}
						}
					}
				}

				if (!isCompressed) {

					textureProperties.__maxMipLevel = 0;
				} else {

					textureProperties.__maxMipLevel = mipmaps.length - 1;
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
				}

				textureProperties.__version = texture.version;

				if (texture.onUpdate) texture.onUpdate(texture);
			} else {

				state.activeTexture(_gl.TEXTURE0 + slot);
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
			}
		}
	}

	function setTextureCubeDynamic(texture, slot) {

		state.activeTexture(_gl.TEXTURE0 + slot);
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
	}

	function setTextureParameters(textureType, texture, supportsMips) {

		var extension;

		if (supportsMips) {

			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));

			if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, utils.convert(texture.wrapR));
			}

			_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));
			_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter));
		} else {

			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
			_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

			if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
			}

			if (texture.wrapS !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["r" /* ClampToEdgeWrapping */] || texture.wrapT !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["r" /* ClampToEdgeWrapping */]) {

				console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
			}

			_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
			_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

			if (texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */] && texture.minFilter !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* LinearFilter */]) {

				console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
			}
		}

		extension = extensions.get('EXT_texture_filter_anisotropic');

		if (extension) {

			if (texture.type === __WEBPACK_IMPORTED_MODULE_0__constants_js__["G" /* FloatType */] && extensions.get('OES_texture_float_linear') === null) return;
			if (texture.type === __WEBPACK_IMPORTED_MODULE_0__constants_js__["H" /* HalfFloatType */] && (capabilities.isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

			if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {

				_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
				properties.get(texture).__currentAnisotropy = texture.anisotropy;
			}
		}
	}

	function initTexture(textureProperties, texture) {

		if (textureProperties.__webglInit === undefined) {

			textureProperties.__webglInit = true;

			texture.addEventListener('dispose', onTextureDispose);

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures++;
		}
	}

	function uploadTexture(textureProperties, texture, slot) {

		var textureType = _gl.TEXTURE_2D;

		if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
		if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;

		initTexture(textureProperties, texture);

		state.activeTexture(_gl.TEXTURE0 + slot);
		state.bindTexture(textureType, textureProperties.__webglTexture);

		_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
		_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
		_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

		var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
		var image = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);

		var supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2,
		    glFormat = utils.convert(texture.format),
		    glType = utils.convert(texture.type),
		    glInternalFormat = getInternalFormat(glFormat, glType);

		setTextureParameters(textureType, texture, supportsMips);

		var mipmap,
		    mipmaps = texture.mipmaps;

		if (texture.isDepthTexture) {

			glInternalFormat = _gl.DEPTH_COMPONENT;

			if (texture.type === __WEBPACK_IMPORTED_MODULE_0__constants_js__["G" /* FloatType */]) {

				if (!capabilities.isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
				glInternalFormat = _gl.DEPTH_COMPONENT32F;
			} else if (capabilities.isWebGL2) {
				glInternalFormat = _gl.DEPTH_COMPONENT16;
			}

			if (texture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_9" /* DepthFormat */] && glInternalFormat === _gl.DEPTH_COMPONENT) {
				if (texture.type !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* UnsignedShortType */] && texture.type !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_11" /* UnsignedIntType */]) {

					console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');

					texture.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* UnsignedShortType */];
					glType = utils.convert(texture.type);
				}
			}

			if (texture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_12" /* DepthStencilFormat */]) {

				glInternalFormat = _gl.DEPTH_STENCIL;

				if (texture.type !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["_13" /* UnsignedInt248Type */]) {

					console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');

					texture.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["_13" /* UnsignedInt248Type */];
					glType = utils.convert(texture.type);
				}
			}

			state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
		} else if (texture.isDataTexture) {

			if (mipmaps.length > 0 && supportsMips) {

				for (var i = 0, il = mipmaps.length; i < il; i++) {

					mipmap = mipmaps[i];
					state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {

				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			}
		} else if (texture.isCompressedTexture) {

			for (var i = 0, il = mipmaps.length; i < il; i++) {

				mipmap = mipmaps[i];

				if (texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RGBAFormat */] && texture.format !== __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* RGBFormat */]) {

					if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {

						state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
					} else {

						console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
					}
				} else {

					state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
				}
			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;
		} else if (texture.isDataTexture2DArray) {

			state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			textureProperties.__maxMipLevel = 0;
		} else if (texture.isDataTexture3D) {

			state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			textureProperties.__maxMipLevel = 0;
		} else {

			if (mipmaps.length > 0 && supportsMips) {

				for (var i = 0, il = mipmaps.length; i < il; i++) {

					mipmap = mipmaps[i];
					state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {

				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
				textureProperties.__maxMipLevel = 0;
			}
		}

		if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

			generateMipmap(_gl.TEXTURE_2D, texture, image.width, image.height);
		}

		textureProperties.__version = texture.version;

		if (texture.onUpdate) texture.onUpdate(texture);
	}

	function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {

		var glFormat = utils.convert(renderTarget.texture.format);
		var glType = utils.convert(renderTarget.texture.type);
		var glInternalFormat = getInternalFormat(glFormat, glType);
		state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
		_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
		_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
		_gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}

	function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {

		_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

		if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {

			if (isMultisample) {

				var samples = getRenderTargetSamples(renderTarget);

				_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
			} else {

				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
			}

			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
		} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {

			if (isMultisample) {

				var samples = getRenderTargetSamples(renderTarget);

				_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
			} else {

				_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
			}

			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
		} else {

			var glFormat = utils.convert(renderTarget.texture.format);
			var glType = utils.convert(renderTarget.texture.type);
			var glInternalFormat = getInternalFormat(glFormat, glType);

			if (isMultisample) {

				var samples = getRenderTargetSamples(renderTarget);

				_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
			} else {

				_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
			}
		}

		_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	}

	function setupDepthTexture(framebuffer, renderTarget) {

		var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
		if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

		_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

		if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {

			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
		}

		if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}

		setTexture2D(renderTarget.depthTexture, 0);

		var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

		if (renderTarget.depthTexture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_9" /* DepthFormat */]) {

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
		} else if (renderTarget.depthTexture.format === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_12" /* DepthStencilFormat */]) {

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
		} else {

			throw new Error('Unknown depthTexture format');
		}
	}

	function setupDepthRenderbuffer(renderTarget) {

		var renderTargetProperties = properties.get(renderTarget);

		var isCube = renderTarget.isWebGLRenderTargetCube === true;

		if (renderTarget.depthTexture) {

			if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');

			setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
		} else {

			if (isCube) {

				renderTargetProperties.__webglDepthbuffer = [];

				for (var i = 0; i < 6; i++) {

					_gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
					renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
				}
			} else {

				_gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
			}
		}

		_gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
	}

	function setupRenderTarget(renderTarget) {

		var renderTargetProperties = properties.get(renderTarget);
		var textureProperties = properties.get(renderTarget.texture);

		renderTarget.addEventListener('dispose', onRenderTargetDispose);

		textureProperties.__webglTexture = _gl.createTexture();

		info.memory.textures++;

		var isCube = renderTarget.isWebGLRenderTargetCube === true;
		var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
		var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;

		if (isCube) {

			renderTargetProperties.__webglFramebuffer = [];

			for (var i = 0; i < 6; i++) {

				renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
			}
		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if (isMultisample) {

				if (capabilities.isWebGL2) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
					var glFormat = utils.convert(renderTarget.texture.format);
					var glType = utils.convert(renderTarget.texture.type);
					var glInternalFormat = getInternalFormat(glFormat, glType);
					var samples = getRenderTargetSamples(renderTarget);
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

					_gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
					_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

					if (renderTarget.depthBuffer) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
					}

					_gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
				} else {

					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		if (isCube) {

			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips);

			for (var i = 0; i < 6; i++) {

				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
			}

			if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {

				generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
			}

			state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
		} else {

			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
			setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, supportsMips);
			setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);

			if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {

				generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
			}

			state.bindTexture(_gl.TEXTURE_2D, null);
		}

		if (renderTarget.depthBuffer) {

			setupDepthRenderbuffer(renderTarget);
		}
	}

	function updateRenderTargetMipmap(renderTarget) {

		var texture = renderTarget.texture;
		var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;

		if (textureNeedsGenerateMipmaps(texture, supportsMips)) {

			var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get(texture).__webglTexture;

			state.bindTexture(target, webglTexture);
			generateMipmap(target, texture, renderTarget.width, renderTarget.height);
			state.bindTexture(target, null);
		}
	}

	function updateMultisampleRenderTarget(renderTarget) {

		if (renderTarget.isWebGLMultisampleRenderTarget) {

			if (capabilities.isWebGL2) {

				var renderTargetProperties = properties.get(renderTarget);

				_gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				_gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

				var width = renderTarget.width;
				var height = renderTarget.height;
				var mask = _gl.COLOR_BUFFER_BIT;

				if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
				if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;

				_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
			} else {

				console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
			}
		}
	}

	function getRenderTargetSamples(renderTarget) {

		return capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(capabilities.maxSamples, renderTarget.samples) : 0;
	}

	function updateVideoTexture(texture) {

		var id = texture.id;
		var frame = info.render.frame;

		if (_videoTextures[id] !== frame) {

			_videoTextures[id] = frame;
			texture.update();
		}
	}

	var warnedTexture2D = false;
	var warnedTextureCube = false;

	function safeSetTexture2D(texture, slot) {

		if (texture && texture.isWebGLRenderTarget) {

			if (warnedTexture2D === false) {

				console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
				warnedTexture2D = true;
			}

			texture = texture.texture;
		}

		setTexture2D(texture, slot);
	}

	function safeSetTextureCube(texture, slot) {

		if (texture && texture.isWebGLRenderTargetCube) {

			if (warnedTextureCube === false) {

				console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
				warnedTextureCube = true;
			}

			texture = texture.texture;
		}

		if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
			setTextureCube(texture, slot);
		} else {
			setTextureCubeDynamic(texture, slot);
		}
	}

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;
}



/***/ }),
/* 447 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebGLUtils; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(3);




function WebGLUtils(gl, extensions, capabilities) {

		function convert(p) {

				var extension;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["w" /* RepeatWrapping */]) return gl.REPEAT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["r" /* ClampToEdgeWrapping */]) return gl.CLAMP_TO_EDGE;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["x" /* MirroredRepeatWrapping */]) return gl.MIRRORED_REPEAT;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["d" /* NearestFilter */]) return gl.NEAREST;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_7" /* NearestMipMapNearestFilter */]) return gl.NEAREST_MIPMAP_NEAREST;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_8" /* NearestMipMapLinearFilter */]) return gl.NEAREST_MIPMAP_LINEAR;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* LinearFilter */]) return gl.LINEAR;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_27" /* LinearMipMapNearestFilter */]) return gl.LINEAR_MIPMAP_NEAREST;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["s" /* LinearMipMapLinearFilter */]) return gl.LINEAR_MIPMAP_LINEAR;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["t" /* UnsignedByteType */]) return gl.UNSIGNED_BYTE;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_28" /* UnsignedShort4444Type */]) return gl.UNSIGNED_SHORT_4_4_4_4;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_29" /* UnsignedShort5551Type */]) return gl.UNSIGNED_SHORT_5_5_5_1;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_30" /* UnsignedShort565Type */]) return gl.UNSIGNED_SHORT_5_6_5;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_31" /* ByteType */]) return gl.BYTE;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_32" /* ShortType */]) return gl.SHORT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_10" /* UnsignedShortType */]) return gl.UNSIGNED_SHORT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_33" /* IntType */]) return gl.INT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_11" /* UnsignedIntType */]) return gl.UNSIGNED_INT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["G" /* FloatType */]) return gl.FLOAT;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["H" /* HalfFloatType */]) {

						if (capabilities.isWebGL2) return gl.HALF_FLOAT;

						extension = extensions.get('OES_texture_half_float');

						if (extension !== null) return extension.HALF_FLOAT_OES;
				}

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_34" /* AlphaFormat */]) return gl.ALPHA;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* RGBFormat */]) return gl.RGB;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RGBAFormat */]) return gl.RGBA;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_35" /* LuminanceFormat */]) return gl.LUMINANCE;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_36" /* LuminanceAlphaFormat */]) return gl.LUMINANCE_ALPHA;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_9" /* DepthFormat */]) return gl.DEPTH_COMPONENT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_12" /* DepthStencilFormat */]) return gl.DEPTH_STENCIL;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_37" /* RedFormat */]) return gl.RED;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["n" /* AddEquation */]) return gl.FUNC_ADD;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_38" /* SubtractEquation */]) return gl.FUNC_SUBTRACT;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_39" /* ReverseSubtractEquation */]) return gl.FUNC_REVERSE_SUBTRACT;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_40" /* ZeroFactor */]) return gl.ZERO;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_41" /* OneFactor */]) return gl.ONE;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_42" /* SrcColorFactor */]) return gl.SRC_COLOR;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_43" /* OneMinusSrcColorFactor */]) return gl.ONE_MINUS_SRC_COLOR;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["l" /* SrcAlphaFactor */]) return gl.SRC_ALPHA;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["m" /* OneMinusSrcAlphaFactor */]) return gl.ONE_MINUS_SRC_ALPHA;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_44" /* DstAlphaFactor */]) return gl.DST_ALPHA;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_45" /* OneMinusDstAlphaFactor */]) return gl.ONE_MINUS_DST_ALPHA;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_46" /* DstColorFactor */]) return gl.DST_COLOR;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_47" /* OneMinusDstColorFactor */]) return gl.ONE_MINUS_DST_COLOR;
				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_48" /* SrcAlphaSaturateFactor */]) return gl.SRC_ALPHA_SATURATE;

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_49" /* RGB_S3TC_DXT1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_50" /* RGBA_S3TC_DXT1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_51" /* RGBA_S3TC_DXT3_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_52" /* RGBA_S3TC_DXT5_Format */]) {

						extension = extensions.get('WEBGL_compressed_texture_s3tc');

						if (extension !== null) {

								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_49" /* RGB_S3TC_DXT1_Format */]) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_50" /* RGBA_S3TC_DXT1_Format */]) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_51" /* RGBA_S3TC_DXT3_Format */]) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_52" /* RGBA_S3TC_DXT5_Format */]) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
						}
				}

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_53" /* RGB_PVRTC_4BPPV1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_54" /* RGB_PVRTC_2BPPV1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_55" /* RGBA_PVRTC_4BPPV1_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_56" /* RGBA_PVRTC_2BPPV1_Format */]) {

						extension = extensions.get('WEBGL_compressed_texture_pvrtc');

						if (extension !== null) {

								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_53" /* RGB_PVRTC_4BPPV1_Format */]) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_54" /* RGB_PVRTC_2BPPV1_Format */]) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_55" /* RGBA_PVRTC_4BPPV1_Format */]) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_56" /* RGBA_PVRTC_2BPPV1_Format */]) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
						}
				}

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_57" /* RGB_ETC1_Format */]) {

						extension = extensions.get('WEBGL_compressed_texture_etc1');

						if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
				}

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_58" /* RGBA_ASTC_4x4_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_59" /* RGBA_ASTC_5x4_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_60" /* RGBA_ASTC_5x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_61" /* RGBA_ASTC_6x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_62" /* RGBA_ASTC_6x6_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_63" /* RGBA_ASTC_8x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_64" /* RGBA_ASTC_8x6_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_65" /* RGBA_ASTC_8x8_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_66" /* RGBA_ASTC_10x5_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_67" /* RGBA_ASTC_10x6_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_68" /* RGBA_ASTC_10x8_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_69" /* RGBA_ASTC_10x10_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_70" /* RGBA_ASTC_12x10_Format */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_71" /* RGBA_ASTC_12x12_Format */]) {

						extension = extensions.get('WEBGL_compressed_texture_astc');

						if (extension !== null) {

								return p;
						}
				}

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_72" /* MinEquation */] || p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_73" /* MaxEquation */]) {

						if (capabilities.isWebGL2) {

								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_72" /* MinEquation */]) return gl.MIN;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_73" /* MaxEquation */]) return gl.MAX;
						}

						extension = extensions.get('EXT_blend_minmax');

						if (extension !== null) {

								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_72" /* MinEquation */]) return extension.MIN_EXT;
								if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_73" /* MaxEquation */]) return extension.MAX_EXT;
						}
				}

				if (p === __WEBPACK_IMPORTED_MODULE_0__constants_js__["_13" /* UnsignedInt248Type */]) {

						if (capabilities.isWebGL2) return gl.UNSIGNED_INT_24_8;

						extension = extensions.get('WEBGL_depth_texture');

						if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
				}

				return 0;
		}

		return { convert: convert };
}



/***/ }),
/* 448 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebVRManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objects_Group_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_Vector4_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_Quaternion_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__cameras_ArrayCamera_js__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__cameras_PerspectiveCamera_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__webgl_WebGLAnimation_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__WebVRUtils_js__ = __webpack_require__(175);















function WebVRManager(renderer) {

		var renderWidth, renderHeight;
		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		var controllers = [];
		var standingMatrix = new __WEBPACK_IMPORTED_MODULE_3__math_Matrix4_js__["a" /* Matrix4 */]();
		var standingMatrixInverse = new __WEBPACK_IMPORTED_MODULE_3__math_Matrix4_js__["a" /* Matrix4 */]();

		var framebufferScaleFactor = 1.0;

		var referenceSpaceType = 'local-floor';

		if (typeof window !== 'undefined' && 'VRFrameData' in window) {

				frameData = new window.VRFrameData();
				window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
		}

		var matrixWorldInverse = new __WEBPACK_IMPORTED_MODULE_3__math_Matrix4_js__["a" /* Matrix4 */]();
		var tempQuaternion = new __WEBPACK_IMPORTED_MODULE_7__math_Quaternion_js__["a" /* Quaternion */]();
		var tempPosition = new __WEBPACK_IMPORTED_MODULE_5__math_Vector3_js__["a" /* Vector3 */]();

		var cameraL = new __WEBPACK_IMPORTED_MODULE_9__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
		cameraL.viewport = new __WEBPACK_IMPORTED_MODULE_6__math_Vector4_js__["a" /* Vector4 */]();
		cameraL.layers.enable(1);

		var cameraR = new __WEBPACK_IMPORTED_MODULE_9__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
		cameraR.viewport = new __WEBPACK_IMPORTED_MODULE_6__math_Vector4_js__["a" /* Vector4 */]();
		cameraR.layers.enable(2);

		var cameraVR = new __WEBPACK_IMPORTED_MODULE_8__cameras_ArrayCamera_js__["a" /* ArrayCamera */]([cameraL, cameraR]);
		cameraVR.layers.enable(1);
		cameraVR.layers.enable(2);

		function isPresenting() {

				return device !== null && device.isPresenting === true;
		}

		var currentSize = new __WEBPACK_IMPORTED_MODULE_4__math_Vector2_js__["a" /* Vector2 */](),
		    currentPixelRatio;

		function onVRDisplayPresentChange() {

				if (isPresenting()) {

						var eyeParameters = device.getEyeParameters('left');
						renderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor;
						renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

						currentPixelRatio = renderer.getPixelRatio();
						renderer.getSize(currentSize);

						renderer.setDrawingBufferSize(renderWidth, renderHeight, 1);

						cameraL.viewport.set(0, 0, renderWidth / 2, renderHeight);
						cameraR.viewport.set(renderWidth / 2, 0, renderWidth / 2, renderHeight);

						animation.start();

						scope.dispatchEvent({ type: 'sessionstart' });
				} else {

						if (scope.enabled) {

								renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
						}

						animation.stop();

						scope.dispatchEvent({ type: 'sessionend' });
				}
		}

		var triggers = [];

		function findGamepad(id) {

				var gamepads = navigator.getGamepads && navigator.getGamepads();

				for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {

						var gamepad = gamepads[i];

						if (gamepad && (gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch') || gamepad.id.startsWith('HTC Vive Focus') || gamepad.id.startsWith('Spatial Controller'))) {

								if (j === id) return gamepad;

								j++;
						}
				}
		}

		function updateControllers() {

				for (var i = 0; i < controllers.length; i++) {

						var controller = controllers[i];

						var gamepad = findGamepad(i);

						if (gamepad !== undefined && gamepad.pose !== undefined) {

								if (gamepad.pose === null) return;

								var pose = gamepad.pose;

								if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);

								if (pose.position !== null) controller.position.fromArray(pose.position);
								if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
								controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
								controller.matrix.premultiply(standingMatrix);
								controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
								controller.matrixWorldNeedsUpdate = true;
								controller.visible = true;

								var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

								if (triggers[i] === undefined) triggers[i] = false;

								if (triggers[i] !== gamepad.buttons[buttonId].pressed) {

										triggers[i] = gamepad.buttons[buttonId].pressed;

										if (triggers[i] === true) {

												controller.dispatchEvent({ type: 'selectstart' });
										} else {

												controller.dispatchEvent({ type: 'selectend' });
												controller.dispatchEvent({ type: 'select' });
										}
								}
						} else {

								controller.visible = false;
						}
				}
		}

		function updateViewportFromBounds(viewport, bounds) {

				if (bounds !== null && bounds.length === 4) {

						viewport.set(bounds[0] * renderWidth, bounds[1] * renderHeight, bounds[2] * renderWidth, bounds[3] * renderHeight);
				}
		}

		this.enabled = false;

		this.getController = function (id) {

				var controller = controllers[id];

				if (controller === undefined) {

						controller = new __WEBPACK_IMPORTED_MODULE_2__objects_Group_js__["a" /* Group */]();
						controller.matrixAutoUpdate = false;
						controller.visible = false;

						controllers[id] = controller;
				}

				return controller;
		};

		this.getDevice = function () {

				return device;
		};

		this.setDevice = function (value) {

				if (value !== undefined) device = value;

				animation.setContext(value);
		};

		this.setFramebufferScaleFactor = function (value) {

				framebufferScaleFactor = value;
		};

		this.setReferenceSpaceType = function (value) {

				referenceSpaceType = value;
		};

		this.setPoseTarget = function (object) {

				if (object !== undefined) poseTarget = object;
		};

		this.getCamera = function (camera) {

				var userHeight = referenceSpaceType === 'local-floor' ? 1.6 : 0;

				if (isPresenting() === false) {

						camera.position.set(0, userHeight, 0);
						camera.rotation.set(0, 0, 0);

						return camera;
				}

				device.depthNear = camera.near;
				device.depthFar = camera.far;

				device.getFrameData(frameData);

				if (referenceSpaceType === 'local-floor') {

						var stageParameters = device.stageParameters;

						if (stageParameters) {

								standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
						} else {

								standingMatrix.makeTranslation(0, userHeight, 0);
						}
				}

				var pose = frameData.pose;
				var poseObject = poseTarget !== null ? poseTarget : camera;

				poseObject.matrix.copy(standingMatrix);
				poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);

				if (pose.orientation !== null) {

						tempQuaternion.fromArray(pose.orientation);
						poseObject.quaternion.multiply(tempQuaternion);
				}

				if (pose.position !== null) {

						tempQuaternion.setFromRotationMatrix(standingMatrix);
						tempPosition.fromArray(pose.position);
						tempPosition.applyQuaternion(tempQuaternion);
						poseObject.position.add(tempPosition);
				}

				poseObject.updateMatrixWorld();

				cameraL.near = camera.near;
				cameraR.near = camera.near;

				cameraL.far = camera.far;
				cameraR.far = camera.far;

				cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
				cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);

				standingMatrixInverse.getInverse(standingMatrix);

				if (referenceSpaceType === 'local-floor') {

						cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
						cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
				}

				var parent = poseObject.parent;

				if (parent !== null) {

						matrixWorldInverse.getInverse(parent.matrixWorld);

						cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
						cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
				}

				cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
				cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);

				cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
				cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);

				__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__WebVRUtils_js__["a" /* setProjectionFromUnion */])(cameraVR, cameraL, cameraR);

				var layers = device.getLayers();

				if (layers.length) {

						var layer = layers[0];

						updateViewportFromBounds(cameraL.viewport, layer.leftBounds);
						updateViewportFromBounds(cameraR.viewport, layer.rightBounds);
				}

				updateControllers();

				return cameraVR;
		};

		this.getStandingMatrix = function () {

				return standingMatrix;
		};

		this.isPresenting = isPresenting;

		var animation = new __WEBPACK_IMPORTED_MODULE_10__webgl_WebGLAnimation_js__["a" /* WebGLAnimation */]();

		this.setAnimationLoop = function (callback) {

				animation.setAnimationLoop(callback);

				if (isPresenting()) animation.start();
		};

		this.submitFrame = function () {

				if (isPresenting()) device.submitFrame();
		};

		this.dispose = function () {

				if (typeof window !== 'undefined') {

						window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
				}
		};

		this.setFrameOfReferenceType = function () {

				console.warn('THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.');
		};
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(WebVRManager.prototype, __WEBPACK_IMPORTED_MODULE_1__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype);



/***/ }),
/* 449 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebXRManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_EventDispatcher_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objects_Group_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_Matrix4_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cameras_ArrayCamera_js__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__cameras_PerspectiveCamera_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__webgl_WebGLAnimation_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__WebVRUtils_js__ = __webpack_require__(175);












function WebXRManager(renderer) {

	var scope = this;

	var gl = renderer.context;

	var session = null;

	var framebufferScaleFactor = 1.0;

	var referenceSpace = null;
	var referenceSpaceType = 'local-floor';

	var pose = null;

	var controllers = [];
	var inputSources = [];

	function isPresenting() {

		return session !== null && referenceSpace !== null;
	}

	var cameraL = new __WEBPACK_IMPORTED_MODULE_6__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
	cameraL.layers.enable(1);
	cameraL.viewport = new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */]();

	var cameraR = new __WEBPACK_IMPORTED_MODULE_6__cameras_PerspectiveCamera_js__["a" /* PerspectiveCamera */]();
	cameraR.layers.enable(2);
	cameraR.viewport = new __WEBPACK_IMPORTED_MODULE_4__math_Vector4_js__["a" /* Vector4 */]();

	var cameraVR = new __WEBPACK_IMPORTED_MODULE_5__cameras_ArrayCamera_js__["a" /* ArrayCamera */]([cameraL, cameraR]);
	cameraVR.layers.enable(1);
	cameraVR.layers.enable(2);

	this.enabled = false;

	this.getController = function (id) {

		var controller = controllers[id];

		if (controller === undefined) {

			controller = new __WEBPACK_IMPORTED_MODULE_2__objects_Group_js__["a" /* Group */]();
			controller.matrixAutoUpdate = false;
			controller.visible = false;

			controllers[id] = controller;
		}

		return controller;
	};

	function onSessionEvent(event) {

		for (var i = 0; i < controllers.length; i++) {

			if (inputSources[i] === event.inputSource) {

				controllers[i].dispatchEvent({ type: event.type });
			}
		}
	}

	function onSessionEnd() {

		renderer.setFramebuffer(null);
		renderer.setRenderTarget(renderer.getRenderTarget());
		animation.stop();

		scope.dispatchEvent({ type: 'sessionend' });
	}

	function onRequestReferenceSpace(value) {

		referenceSpace = value;

		animation.setContext(session);
		animation.start();

		scope.dispatchEvent({ type: 'sessionstart' });
	}

	this.setFramebufferScaleFactor = function (value) {

		framebufferScaleFactor = value;
	};

	this.setReferenceSpaceType = function (value) {

		referenceSpaceType = value;
	};

	this.getSession = function () {

		return session;
	};

	this.setSession = function (value) {

		session = value;

		if (session !== null) {

			session.addEventListener('select', onSessionEvent);
			session.addEventListener('selectstart', onSessionEvent);
			session.addEventListener('selectend', onSessionEvent);
			session.addEventListener('end', onSessionEnd);

			session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

			session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);

			inputSources = session.inputSources;

			session.addEventListener('inputsourceschange', function () {

				inputSources = session.inputSources;
				console.log(inputSources);

				for (var i = 0; i < controllers.length; i++) {

					var controller = controllers[i];
					controller.userData.inputSource = inputSources[i];
				}
			});
		}
	};

	function updateCamera(camera, parent) {

		if (parent === null) {

			camera.matrixWorld.copy(camera.matrix);
		} else {

			camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
		}

		camera.matrixWorldInverse.getInverse(camera.matrixWorld);
	}

	this.getCamera = function (camera) {

		if (isPresenting()) {

			var parent = camera.parent;
			var cameras = cameraVR.cameras;

			updateCamera(cameraVR, parent);

			for (var i = 0; i < cameras.length; i++) {

				updateCamera(cameras[i], parent);
			}

			camera.matrixWorld.copy(cameraVR.matrixWorld);

			var children = camera.children;

			for (var i = 0, l = children.length; i < l; i++) {

				children[i].updateMatrixWorld(true);
			}

			__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__WebVRUtils_js__["a" /* setProjectionFromUnion */])(cameraVR, cameraL, cameraR);

			return cameraVR;
		}

		return camera;
	};

	this.isPresenting = isPresenting;

	var onAnimationFrameCallback = null;

	function onAnimationFrame(time, frame) {

		pose = frame.getViewerPose(referenceSpace);

		if (pose !== null) {

			var views = pose.views;
			var baseLayer = session.renderState.baseLayer;

			renderer.setFramebuffer(baseLayer.framebuffer);

			for (var i = 0; i < views.length; i++) {

				var view = views[i];
				var viewport = baseLayer.getViewport(view);
				var viewMatrix = view.transform.inverse.matrix;

				var camera = cameraVR.cameras[i];
				camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
				camera.projectionMatrix.fromArray(view.projectionMatrix);
				camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

				if (i === 0) {

					cameraVR.matrix.copy(camera.matrix);
				}
			}
		}

		for (var i = 0; i < controllers.length; i++) {

			var controller = controllers[i];

			var inputSource = inputSources[i];

			if (inputSource) {

				var inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

				if (inputPose !== null) {

					controller.matrix.fromArray(inputPose.transform.matrix);
					controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
					controller.visible = true;

					continue;
				}
			}

			controller.visible = false;
		}

		if (onAnimationFrameCallback) onAnimationFrameCallback(time);
	}

	var animation = new __WEBPACK_IMPORTED_MODULE_7__webgl_WebGLAnimation_js__["a" /* WebGLAnimation */]();
	animation.setAnimationLoop(onAnimationFrame);

	this.setAnimationLoop = function (callback) {

		onAnimationFrameCallback = callback;
	};

	this.dispose = function () {};

	this.getStandingMatrix = function () {

		console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
		return new __WEBPACK_IMPORTED_MODULE_3__math_Matrix4_js__["a" /* Matrix4 */]();
	};

	this.getDevice = function () {

		console.warn('THREE.WebXRManager: getDevice() has been deprecated.');
	};

	this.setDevice = function () {

		console.warn('THREE.WebXRManager: setDevice() has been deprecated.');
	};

	this.setFrameOfReferenceType = function () {

		console.warn('THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.');
	};

	this.submitFrame = function () {};
}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(WebXRManager.prototype, __WEBPACK_IMPORTED_MODULE_1__core_EventDispatcher_js__["a" /* EventDispatcher */].prototype);



/***/ }),
/* 450 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Scene; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__ = __webpack_require__(14);




function Scene() {

	__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].call(this);

	this.type = 'Scene';

	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true;

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {

		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
	}
}

Scene.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype), {

	constructor: Scene,

	isScene: true,

	copy: function copy(source, recursive) {

		__WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype.copy.call(this, source, recursive);

		if (source.background !== null) this.background = source.background.clone();
		if (source.fog !== null) this.fog = source.fog.clone();
		if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;
	},

	toJSON: function toJSON(meta) {

		var data = __WEBPACK_IMPORTED_MODULE_2__core_Object3D_js__["a" /* Object3D */].prototype.toJSON.call(this, meta);

		if (this.background !== null) data.object.background = this.background.toJSON(meta);
		if (this.fog !== null) data.object.fog = this.fog.toJSON();

		return data;
	},

	dispose: function dispose() {

		this.dispatchEvent({ type: 'dispose' });
	}

});



/***/ }),
/* 451 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CubeTexture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);






function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : __WEBPACK_IMPORTED_MODULE_2__constants_js__["I" /* CubeReflectionMapping */];
	format = format !== undefined ? format : __WEBPACK_IMPORTED_MODULE_2__constants_js__["b" /* RGBFormat */];

	__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

	this.flipY = false;
}

CubeTexture.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].prototype);
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty(CubeTexture.prototype, 'images', {

	get: function get() {

		return this.image;
	},

	set: function set(value) {

		this.image = value;
	}

});



/***/ }),
/* 452 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataTexture; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);






function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

	__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];
	this.minFilter = minFilter !== undefined ? minFilter : __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];

	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;
}

DataTexture.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].prototype);
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;



/***/ }),
/* 453 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataTexture2DArray; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);






function DataTexture2DArray(data, width, height, depth) {

	__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].call(this, null);

	this.image = { data: data, width: width, height: height, depth: depth };

	this.magFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];
	this.minFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];

	this.wrapR = __WEBPACK_IMPORTED_MODULE_2__constants_js__["r" /* ClampToEdgeWrapping */];

	this.generateMipmaps = false;
	this.flipY = false;
}

DataTexture2DArray.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;



/***/ }),
/* 454 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataTexture3D; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Texture_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_js__ = __webpack_require__(3);






function DataTexture3D(data, width, height, depth) {

	__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].call(this, null);

	this.image = { data: data, width: width, height: height, depth: depth };

	this.magFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];
	this.minFilter = __WEBPACK_IMPORTED_MODULE_2__constants_js__["d" /* NearestFilter */];

	this.wrapR = __WEBPACK_IMPORTED_MODULE_2__constants_js__["r" /* ClampToEdgeWrapping */];

	this.generateMipmaps = false;
	this.flipY = false;
}

DataTexture3D.prototype = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_create___default()(__WEBPACK_IMPORTED_MODULE_1__Texture_js__["a" /* Texture */].prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;



/***/ }),
/* 455 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      originPoint: new window.$CCBIM.WebGL.Vector3(),
      maxDistance: Math.pow(120, 16),
      client: {
        mouseX: 0,
        mouseY: 0,
        coordinateX: 0,
        coordinateY: 0
      }
    };
  },

  methods: {
    setOriginPoint: function setOriginPoint() {
      var _view$Target = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(this.view.Target, 3);

      this.originPoint.x = _view$Target[0];
      this.originPoint.y = _view$Target[1];
      this.originPoint.z = _view$Target[2];
    },
    setCoordinate: function setCoordinate(e) {
      var coordinate = this.getDWGCoordinate(e);
      var x = e.clientX;
      var y = e.clientY;
      this.client = {
        mouseX: x - this.rect.left,
        mouseY: y - this.rect.top + 30,
        coordinateX: coordinate.x.toFixed(4),
        coordinateY: coordinate.y.toFixed(4)
      };
    },
    getDWGCoordinate: function getDWGCoordinate(e) {
      if (this.ProjectVersion < 107) {
        return this.getPoint(e);
      } else {
        var point = this.getPoint(e);
        return new window.$CCBIM.WebGL.Vector3().addVectors(point, this.originPoint);
      }
    },
    getPoint: function getPoint(e) {
      var rect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$refs.model.getBoundingClientRect();
      var camera = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.$CCBIM.camera;

      var mousePoint = new window.$CCBIM.WebGL.Vector3();

      mousePoint.x = (e.clientX - rect.left) / rect.width * 2 - 1;
      mousePoint.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      mousePoint.z = (camera.near + camera.far) / (camera.near - camera.far);
      mousePoint.unproject(camera);
      mousePoint.z = 1;
      return mousePoint;
    },
    displayNearest: function displayNearest(position) {
      var imagePositionsInRange = this.kdtree.nearest([position.x, position.y, position.z], 1, this.maxDistance);

      var _frustum = new window.$CCBIM.WebGL.Frustum();
      var _projScreenMatrix = new window.$CCBIM.WebGL.Matrix4();
      _projScreenMatrix.multiplyMatrices(window.$CCBIM.camera.projectionMatrix, window.$CCBIM.camera.matrixWorldInverse);
      _frustum.setFromMatrix(_projScreenMatrix);
      for (var i = 0, il = imagePositionsInRange.length; i < il; i++) {
        var object = imagePositionsInRange[i];
        var objectPoint = new window.$CCBIM.WebGL.Vector3().fromArray(object[0].obj);
        if (_frustum.containsPoint(objectPoint)) {}
      }
    }
  }
});

/***/ }),
/* 456 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      miniMapScene: null,
      miniMapCamera: null,
      boundingBox: {},
      showMini: false,
      miniMapDom: false,
      miniMapDomBottom: 90,
      sizeWidth: 400,
      sizeHeight: 200,

      boundingBoxMax: null
    };
  },

  props: {
    isOpenMiniMap: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    initDWGMiniMap: function initDWGMiniMap() {
      if (!this.isPhone) {
        this.updateBoundingBox();
        this.initDWGControllerData();
        if (this.isOpenMiniMap) {
          this.miniMapDom = true;
          this.initMiniMapWebGLRenderer();
        }
      }
    },
    initMiniMapWebGLRenderer: function initMiniMapWebGLRenderer() {
      var _boundingBox = this.boundingBox,
          w = _boundingBox.w,
          h = _boundingBox.h,
          x = _boundingBox.x,
          y = _boundingBox.y,
          z = _boundingBox.z;

      var multiple = w / h;
      var cameraWidth = w;
      var cameraHeight = h;
      if (multiple > this.sizeWidth / this.sizeHeight) {
        cameraWidth = w / 2;
        cameraHeight = cameraWidth * this.sizeHeight / this.sizeWidth;
      } else {
        cameraHeight = h / 2;
        cameraWidth = cameraHeight * this.sizeWidth / this.sizeHeight;
      }

      this.miniMapScene = new window.$CCBIM.WebGL.Scene();
      this.miniMapScene.add(window.$CCBIM.scene);

      this.miniMapCamera = new window.$CCBIM.WebGL.OrthographicCamera(-cameraWidth, cameraWidth, cameraHeight, -cameraHeight, 0.1, 900000);
      this.miniMapCamera.zoom = w > h ? w / h : h / w;
      this.miniMapCamera.position.x = x;
      this.miniMapCamera.position.y = y;
      this.miniMapCamera.position.z = z;
      this.miniMapScene.add(this.miniMapCamera);
    },
    updateBoundingBox: function updateBoundingBox() {
      var boundingBoxMax = new window.$CCBIM.WebGL.Vector3(-Infinity, -Infinity, -Infinity);
      var boundingBoxMin = new window.$CCBIM.WebGL.Vector3(+Infinity, +Infinity, +Infinity);
      for (var i = 0, il = window.$CCBIM.userModelGroup.children.length; i < il; i++) {
        var itemIndexBoundingBox = window.$CCBIM.userModelGroup.children[i].geometry.boundingBox;
        if (itemIndexBoundingBox.max.x > boundingBoxMax.x || itemIndexBoundingBox.max.y > boundingBoxMax.y || itemIndexBoundingBox.max.z > boundingBoxMax.z) {
          boundingBoxMax = itemIndexBoundingBox.max;
        }
        if (itemIndexBoundingBox.min.x < boundingBoxMin.x || itemIndexBoundingBox.min.y < boundingBoxMin.y || itemIndexBoundingBox.min.z < boundingBoxMin.z) {
          boundingBoxMin = itemIndexBoundingBox.min;
        }
      }
      this.boundingBox = {
        w: Math.abs(boundingBoxMax.x - boundingBoxMin.x) * 2,
        h: Math.abs(boundingBoxMax.y - boundingBoxMin.y) * 2,
        x: (boundingBoxMax.x + boundingBoxMin.x) / 2,
        y: (boundingBoxMax.y + boundingBoxMin.y) / 2,
        z: 9999
      };
    },
    initDWGControllerData: function initDWGControllerData() {
      var _boundingBox2 = this.boundingBox,
          w = _boundingBox2.w,
          h = _boundingBox2.h,
          x = _boundingBox2.x,
          y = _boundingBox2.y;

      window.$CCBIM.controller.left0 = w / -2;
      window.$CCBIM.controller.right0 = w / 2;
      window.$CCBIM.controller.top0 = h / 2;
      window.$CCBIM.controller.bottom0 = h / -2;
      window.$CCBIM.controller.target0 = new window.$CCBIM.WebGL.Vector3(x, y, 0);
      window.$CCBIM.controller.position0 = new window.$CCBIM.WebGL.Vector3(x, y, 90000);
    },
    resetDwgView: function resetDwgView() {
      this.needUpdate = true;
      if (this.EVer < 107) {
        this.setCameraPosition(this.view.Target);
        this.setControlsTarget(this.view.Target);
      } else {
        if (this.view.Twist && this.view.Twist !== 0) {
          if (this.boundingBoxMax === null) {
            this.boundingBoxMax = this.computeDWGBoundingBox();
          }
          console.log(this.boundingBoxMax);
          var boxCenter = {
            x: (this.boundingBoxMax.max.x + this.boundingBoxMax.min.x) / 2,
            y: (this.boundingBoxMax.max.y + this.boundingBoxMax.min.y) / 2,
            z: (this.boundingBoxMax.max.z + this.boundingBoxMax.min.z) / 2
          };
          console.log(boxCenter);
          this.setCameraPosition([boxCenter.x, boxCenter.y, 100]);
          this.setControlsTarget([boxCenter.x, boxCenter.y, 0]);
        } else {
          this.setCameraPosition([0, 0, 100]);
          this.setControlsTarget([0, 0, 0]);
        }
      }
      window.$CCBIM.camera.zoom = 1;
      window.$CCBIM.camera.updateProjectionMatrix();
    },
    resetDwgCenter: function resetDwgCenter() {
      this.needUpdate = true;
      window.$CCBIM.controller.reset();
    },
    miniHandle: function miniHandle() {
      if (this.miniMapDom) {
        this.showMini = false;
      }
    },
    updateMiniMap: function updateMiniMap() {
      var left = window.$CCBIM.camera.left / window.$CCBIM.camera.zoom;
      var right = window.$CCBIM.camera.right / window.$CCBIM.camera.zoom;
      var top = window.$CCBIM.camera.top / window.$CCBIM.camera.zoom;
      var bottom = window.$CCBIM.camera.bottom / window.$CCBIM.camera.zoom;

      var needResetMeshPosition = false;
      if (this.miniMapCamera.bottom > bottom && this.miniMapCamera.top < top && this.miniMapCamera.right < right && this.miniMapCamera.left > left) {
        bottom = this.miniMapCamera.bottom;
        top = this.miniMapCamera.top;
        right = this.miniMapCamera.right;
        left = this.miniMapCamera.left;
        needResetMeshPosition = true;
      }
      var geo = null;
      var mat = null;
      var positionBuffer = null;
      var positionData = null;
      var mesh = this.miniMapScene.getObjectByName('cameraView');
      if (mesh && mesh instanceof window.$CCBIM.WebGL.Mesh && mesh.geometry instanceof window.$CCBIM.WebGL.PMBufferGeometry) {
        positionBuffer = mesh.geometry.getBufferAttribute('position');
        positionData = positionBuffer.array;
        positionData[15] = positionData[12] = positionData[0] = right;
        positionData[16] = positionData[4] = positionData[1] = top;
        positionData[9] = positionData[6] = positionData[3] = left;
        positionData[13] = positionData[10] = positionData[7] = bottom;
        mesh.geometry.updateAttribute('position', 0, positionData);
        if (needResetMeshPosition) {
          mesh.position.set(this.miniMapCamera.position.x, this.miniMapCamera.position.y, 1);
        } else {
          mesh.position.set(window.$CCBIM.camera.position.x, window.$CCBIM.camera.position.y, 1);
        }
      } else {
        positionData = new Float32Array([right, top, 0, left, top, 0, left, bottom, 0, left, bottom, 0, right, bottom, 0, right, top, 0]);
        geo = new window.$CCBIM.WebGL.PMBufferGeometry();
        positionBuffer = new window.$CCBIM.WebGL.Float32BufferAttribute(positionData, 3);
        geo.addBufferAttribute('position', positionBuffer);

        var indexBuffer = new Float32Array(positionBuffer.array.length / 3);
        for (var i = 0, il = indexBuffer.length; i < il; i++) {
          indexBuffer[i] = i;
        }
        var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
        index.setIndex(indexBuffer);
        var indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
        indexRange.setRange(0, indexBuffer.length);
        index.addIndexRange(indexRange);
        geo.addVertexIndex(index);

        mat = new window.$CCBIM.WebGL.MeshBasicMaterial({ transparent: true, opacity: 0.7 });
        mesh = new window.$CCBIM.WebGL.Mesh(geo, mat);
        mesh.name = 'cameraView';
        mesh.position.set(window.$CCBIM.camera.position.x, window.$CCBIM.camera.position.y, 1);
        this.miniMapScene.add(mesh);
      }

      if (this.miniMapDom && this.$refs.viewMap) {
        var viewMap = this.$refs.viewMap.getBoundingClientRect();
        var viewModel = this.$refs.model.getBoundingClientRect();

        var oldViewPort = new window.$CCBIM.WebGL.Vector4();
        window.$CCBIM.WebGLRenderer.getViewport(oldViewPort);
        var oldScissor = new window.$CCBIM.WebGL.Vector4();
        window.$CCBIM.WebGLRenderer.getScissor(oldScissor);

        window.$CCBIM.WebGLRenderer.setScissorTest(true);
        window.$CCBIM.WebGLRenderer.setScissor(viewMap.left - viewModel.left, viewModel.bottom - viewMap.bottom, this.sizeWidth, this.sizeHeight);
        window.$CCBIM.WebGLRenderer.setViewport(viewMap.left - viewModel.left, viewModel.bottom - viewMap.bottom, this.sizeWidth, this.sizeHeight);

        window.$CCBIM.WebGLRenderer.render(this.miniMapScene, this.miniMapCamera);
        window.$CCBIM.WebGLRenderer.setViewport(oldViewPort.x, oldViewPort.y, oldViewPort.z, oldViewPort.w);

        window.$CCBIM.WebGLRenderer.setScissor(oldScissor.x, oldScissor.y, oldScissor.z, oldScissor.w);
        window.$CCBIM.WebGLRenderer.setScissorTest(false);
      }
    },
    miniMapHandle: function miniMapHandle(evt) {
      this.needUpdate = true;

      var _$refs$viewMini$getBo = this.$refs.viewMini.getBoundingClientRect(),
          width = _$refs$viewMini$getBo.width,
          height = _$refs$viewMini$getBo.height;

      var MousePoint = new window.$CCBIM.WebGL.Vector3();
      MousePoint.x = evt.offsetX / width * 2 - 1;
      MousePoint.y = -(evt.offsetY / height) * 2 + 1;
      MousePoint.z = (this.miniMapCamera.near + this.miniMapCamera.far) / (this.miniMapCamera.near - this.miniMapCamera.far);
      MousePoint.unproject(this.miniMapCamera);
      var target = new window.$CCBIM.WebGL.Vector2().copy(MousePoint);

      window.$CCBIM.camera.position.x = target.x;
      window.$CCBIM.camera.position.y = target.y;

      window.$CCBIM.controller.target.x = target.x;
      window.$CCBIM.controller.target.y = target.y;
    },
    miniMapDomShowHidden: function miniMapDomShowHidden(visible) {
      this.miniMapDom = visible;
      this.setNeedUpdate();
    }
  }
});

/***/ }),
/* 457 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {};
  },

  methods: {
    getDetector: function getDetector() {
      window.$CCBIM.render.$Detector = {
        canvas: !!window.CanvasRenderingContext2D,
        webgl: function () {
          try {
            var canvas = document.createElement('canvas');
            return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
          } catch (e) {
            return false;
          }
        }(),
        webgl2: function () {
          try {
            var canvas = document.createElement('canvas');
            return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));
          } catch (e) {
            return false;
          }
        }(),
        workers: !!window.Worker,
        fileapi: window.File && window.FileReader && window.FileList && window.Blob
      };
    }
  }
});

/***/ }),
/* 458 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      camera: null
    };
  },

  methods: {
    setOrthographicCamera: function setOrthographicCamera() {
      var _rect = this.rect,
          w = _rect.w,
          h = _rect.h;

      var width = 0;
      var height = 0;

      width = w / h * this.view.Height;
      height = this.view.Height;

      window.$CCBIM.camera = new window.$CCBIM.WebGL.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 10000000);
      if (this.EVer < 107) {
        this.setCameraPosition(this.view.Target);
      } else {
        this.setCameraPosition([0, 0, 100]);
      }
      window.$CCBIM.scene.add(window.$CCBIM.camera);
    },
    setCameraPosition: function setCameraPosition(items) {
      var _items = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(items, 3);

      window.$CCBIM.camera.position.x = _items[0];
      window.$CCBIM.camera.position.y = _items[1];
      window.$CCBIM.camera.position.z = _items[2];
    }
  }
});

/***/ }),
/* 459 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controls_CADControls_js__ = __webpack_require__(477);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      controller: null
    };
  },

  methods: {
    setCADControls: function setCADControls() {
      window.$CCBIM.controller = new __WEBPACK_IMPORTED_MODULE_1__controls_CADControls_js__["a" /* default */](window.$CCBIM.camera, this.$refs.model, this.rect);
      if (this.EVer < 107) {
        this.setControlsTarget(this.view.Target);
      } else {
        this.setControlsTarget([0, 0, 0]);
      }

      this.setOriginPoint();
      window.$CCBIM.controller.staticMoving = false;
      window.$CCBIM.controller.zoomSpeed = 0.07;
      window.$CCBIM.controller.panSpeed = 0.5;
      window.$CCBIM.controller.noRotate = true;
      window.$CCBIM.controller.minZoom = 0;
      window.$CCBIM.controller.maxZoom = Number.MAX_VALUE;
    },
    setControlsTarget: function setControlsTarget(target) {
      if (window.$CCBIM.controller.target) {
        var _target = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(target, 3);

        window.$CCBIM.controller.target.x = _target[0];
        window.$CCBIM.controller.target.y = _target[1];
        window.$CCBIM.controller.target.z = _target[2];
      }
    }
  }
});

/***/ }),
/* 460 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      originSize: {
        width: 0,
        height: 0
      },
      isMouseDown: false,

      isMouseMove: false,
      mouseDownX: 0,
      mouseDownY: 0,
      mouseMoveX: 0,
      mouseMoveY: 0,
      showBComInfoTop: 0,
      showBComInfoLeft: 0,

      isRightPopupMenu: false
    };
  },

  props: {
    width: {
      type: Number,
      default: 0
    }
  },
  watch: {
    width: function width(value) {
      this.onResize(value);
    }
  },
  methods: {
    bindEvent: function bindEvent() {
      var _this = this;

      window.onresize = function () {
        return _this.onResize();
      };
    },
    setWidth: function setWidth(value) {
      if (this.$refs.model) {
        this.rect = this.$refs.model.getBoundingClientRect();
        this.rect.w = this.rect.right - this.rect.left;
        if (value) {
          this.rect.w = value;
        }
        this.rect.h = window.innerHeight - this.rect.top;
        this.rect.wHalf = this.rect.w / 2;
        this.rect.hHalf = this.rect.h / 2;
      }
    },
    onResize: function onResize(value) {
      var _this2 = this;

      this.originSize.width = this.rect.w;
      this.originSize.height = this.rect.h;
      this.$nextTick(function () {
        _this2.setWidth(value);
        _this2.resize();
      });
    },
    resize: function resize() {
      this.needUpdate = true;
      var _rect = this.rect,
          w = _rect.w,
          h = _rect.h;

      if (this.rendererType === '3D') {} else {
        this.resizeDWG(w, h);
      }
      window.$CCBIM.controller.handleResize();
      if (window.$CCBIM.WebGLRenderer) {
        window.$CCBIM.WebGLRenderer.setSize(w, h);
      }
    },
    resizeDWG: function resizeDWG(w, h) {
      if (window.$CCBIM.camera) {
        window.$CCBIM.camera.left = window.$CCBIM.camera.left * w / this.originSize.width;
        window.$CCBIM.camera.right = window.$CCBIM.camera.right * w / this.originSize.width;
        window.$CCBIM.camera.top = window.$CCBIM.camera.top * h / this.originSize.height;
        window.$CCBIM.camera.bottom = window.$CCBIM.camera.bottom * h / this.originSize.height;
        window.$CCBIM.camera.updateProjectionMatrix();
      }
    },
    onModelkeydown: function onModelkeydown() {
      this.onBeforeUpdate();
    },
    ontouchMove: function ontouchMove(e) {
      e.preventDefault();
      this.isMouseMove = true;
      this.needUpdate = true;
    },
    onTouchEnd: function onTouchEnd(e) {
      e.preventDefault();

      if (this.rendererType === '3D') {} else {
        if (this.isCoordinate) {
          e = e.changedTouches[0];
          this.setCoordinate(e);
        }
      }
      this.isMouseMove = false;
      this.setNeedUpdate();
    },
    onModelMouseMove: function onModelMouseMove(e) {
      e.preventDefault();
      if (this.isMouseDown) {
        this.mouseMoveX = e.pageX;
        this.mouseMoveY = e.pageY;
        if (Math.abs(this.mouseMoveX - this.mouseDownX) > 20 || Math.abs(this.mouseMoveY - this.mouseDownY) > 20) {
          this.isMouseMove = true;
        }
      }

      if (this.isCoordinate) {
        this.setCoordinate(e);
      }

      if (this.isModelDis) {
        this.OnMouseMove_ModelDis(e);
      }

      if (this.isBoxChoose) {
        this.selectBoxMove(e);
      }
    },
    onModelMouseUp: function onModelMouseUp(e) {
      e.preventDefault();
      this.isMouseDown = false;
      this.needUpdate = true;

      if (this.rendererType === '3D') {} else {
        this.addMouseDWGMark(e);
        this.setNeedUpdate();
      }

      if (this.isBoxChoose) {
        this.selectBoxUp(e);
      }
    },
    onModelMouseDown: function onModelMouseDown(e) {
      e.preventDefault();
      this.isRightPopupMenu = false;
      this.isMouseDown = true;
      this.isMouseMove = false;

      this.mouseDownX = e.pageX;
      this.mouseDownY = e.pageY;

      if (this.isModelDis) {
        this.OnMouseDown_ModelDis(e);
      }

      if (this.isBoxChoose) {
        this.selectBoxDown(e);
      }
    },
    onDblclick: function onDblclick(e) {
      if (this.rendererType === '3D') {}
    },
    showRightPopupMenu: function showRightPopupMenu(e) {
      var _this3 = this;

      if (this.showClick) {
        this.isRightPopupMenu = true;
        this.$nextTick(function () {
          _this3.showBComInfoTop = _this3.getOffsetY(e) + 20;
          _this3.showBComInfoLeft = _this3.getOffsetX(e);
          var menu = _this3.$refs.rightPopupMenu;
          if (menu) {
            if (_this3.rect.w - _this3.getOffsetX(e) < menu.clientWidth) {
              _this3.showBComInfoLeft = _this3.getOffsetX(e) - menu.clientWidth;
            }
            if (_this3.rect.h - _this3.getOffsetY(e) < menu.clientHeight + 70) {
              _this3.showBComInfoTop = _this3.getOffsetY(e) - (menu.clientHeight + 70);
            }
          }
        });
      }
    },
    getOffsetX: function getOffsetX(e) {
      var event = e || window.event;
      var srcObj = event.target || event.srcElement;
      if (event.offsetX) {
        return event.offsetX;
      } else {
        var rect = srcObj.getBoundingClientRect();
        var clientX = event.clientX;
        return clientX - rect.left;
      }
    },
    getOffsetY: function getOffsetY(e) {
      var event = e || window.event;
      var srcObj = event.target || event.srcElement;
      if (event.offsetY) {
        return event.offsetY;
      } else {
        var rect = srcObj.getBoundingClientRect();
        var clientY = event.clientY;
        return clientY - rect.top;
      }
    }
  }
});

/***/ }),
/* 461 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set__ = __webpack_require__(528);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set__);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showStagesAll: false,

      stageSelectOn: {
        stageid: -1
      },

      stagesAll: [],

      showFloorDiv: false,

      floorTree: [],

      searchText: '',
      floorIdDisplay: new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a(),
      floorNameDisplay: new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a(),
      comTypeIdDisplay: new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a(),
      showFloorsData: [],

      showBComTypesData: [],

      floorIdNameMap: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a(),

      floorNameIdMap: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a(),

      projectLayerList: new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a(),

      modelMaterialMap: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a(),

      isShowAllComType: false
    };
  },

  props: {
    showFloors: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    showBComTypes: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  watch: {
    showFloors: function showFloors(list) {
      this.showFloorsData = list;
    },
    showBComTypes: function showBComTypes(list) {
      this.showBComTypesData = list;
    }
  },
  methods: {
    setDWGLayerList: function setDWGLayerList() {
      var _this = this;

      var list = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this.projectLayerList));
      this.floorTree = [];
      var allBuild = {};
      allBuild.text = '';
      allBuild.opened = true;
      allBuild.selected = true;
      allBuild.tier = '0';
      allBuild.children = [];

      list.forEach(function (item) {
        var layer = item;
        layer.color = _this.projectMate.get(item.matId);
        layer.text = item.name;
        layer.selected = true;
        allBuild.children.push(layer);
      });
      this.floorTree.push(allBuild);

      this.emitFloor();
    },
    inputSearch: function inputSearch() {
      var _this2 = this;

      var text = this.searchText;
      var patt = new RegExp(text);

      this.$refs.treeStrong.handleRecursionNodeChildren(this.floorTree[0], function (node) {
        if (text !== '' && node !== undefined) {
          var str = node.text;
          node.opened = false;
          if (patt.test(str)) {
            node.opened = true;
            _this2.$refs.treeStrong.handleParentNodeOpen(node);
          }
        }
      });

      this.$nextTick(function () {
        _this2.$refs.treeStrong.handleRecursionNodeDom(_this2.$refs.treeStrong, function (node) {
          if (text !== '' && node.model !== undefined) {
            var str = node.model.text;
            if (patt.test(str)) {
              node.$el.querySelector('.tree-anchor').style.color = '#00b589';
            } else {
              node.$el.querySelector('.tree-anchor').style.color = '#fff';
            }
          } else {
            node.$el.querySelector('.tree-anchor').style.color = '#fff';
          }
        });
      });
    },
    itemCheckedClick: function itemCheckedClick(item) {
      this.DWGLayerCallBack(item);
    },
    getFlatBufferFloorInfo: function getFlatBufferFloorInfo() {
      window.$CCBIM.render.$ccbimFloorInfoArr = [];
      this.$refs.treeStrong.handleRecursionNodeDom(this.$refs.treeStrong, function (node) {
        if (node.model && node.model.tier === '2') {
          var obj = {};
          obj.floorid = node.model.floorId;
          if (node.model.selected) {
            obj.state = 1;
          } else {
            var comTypeArr = [];
            for (var i = 0; i < node.model.children.length; i++) {
              for (var j = 0; j < node.model.children[i].children.length; j++) {
                if (node.model.children[i].children[j].selected) {
                  comTypeArr.push(node.model.children[i].children[j].comTypeId);
                }
              }
            }
            if (comTypeArr.length > 0) {
              obj.state = 2;
              obj.comtypeArr = comTypeArr;
            } else {
              obj.state = 0;
            }
          }
          window.$CCBIM.render.$ccbimFloorInfoArr.push(obj);
        }
      });
    },
    setModelPinListData: function setModelPinListData() {
      var _this3 = this;

      if (window.$CCBIM.buildInfo) {
        window.$CCBIM.buildInfo.forEach(function (build) {
          build.floors.forEach(function (floor) {
            if (floor.comtypeGroupInfo && floor.comtypeGroupInfo.length > 0) {
              window.$CCBIM.render.$ccbimFloorDisplay.push(floor.floorid);
              window.$CCBIM.render.$ccbimFloorNameDisplay.push(floor.floorname);

              _this3.floorIdNameMap.set(floor.floorid, floor.floorname);
              _this3.floorNameIdMap.set(floor.floorname, floor.floorid);

              floor.comtypeGroupInfo.forEach(function (comtypeGroupInfo) {
                if (comtypeGroupInfo.subcomtypeInfo && comtypeGroupInfo.subcomtypeInfo.length > 0) {
                  comtypeGroupInfo.subcomtypeInfo.forEach(function (subcomtypeInfo) {
                    window.$CCBIM.render.$ccbimComTypeDisplay.push(floor.floorid + '_' + subcomtypeInfo.id);
                  });
                }
              });
            }
          });
        });
        this.emitFloor();
      }
    },
    emitFloor: function emitFloor() {
      this.$emit('floors');
    },
    DWGLayerCallBack: function DWGLayerCallBack(item) {
      var _this4 = this;

      if (item.tier === '0') {
        item.children.forEach(function (x) {
          _this4.controlTheProjectDwg(item.selected, x.GeoInfo);
        });
      } else {
        this.controlTheProjectDwg(item.selected, item.GeoInfo);
      }
    },
    controlTheProjectDwg: function controlTheProjectDwg() {
      var isShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var bIds = arguments[1];

      this.miniMapNeedUpdate = true;
      window.$CCBIM.userModelGroup.children.forEach(function (item) {
        if (bIds) {
          var exsits = bIds.includes(item.userData.uuid);
          if (exsits && item.userData.floor && item.userData.AllowSelected) {
            item.visible = isShow;
          }
        }
      });
      this.setNeedUpdate();
    }
  }
});

/***/ }),
/* 462 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);

var LineBasicMatMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
var PointsMatMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
var MeshBasicMatMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      modelEdgeWorker: null,
      normalGeo: 0
    };
  },

  methods: {
    addGeomery: function addGeomery(data) {
      var GEO = data.type !== 'Mesh' ? new window.$CCBIM.WebGL.PMBufferGeometry() : new window.$CCBIM.WebGL.PlaneBufferGeometry(data.Width, data.Height, data.Column - 1, data.Row - 1);
      var vertexAttribute = new window.$CCBIM.WebGL.Float32BufferAttribute(data.vertices, 3);
      GEO.addBufferAttribute('position', vertexAttribute);

      GEO.computeVertexNormals();
      var model = null;
      var Mate = null;

      switch (data.type) {
        case undefined:
        case null:
        case 'Geometry':
          Mate = this.projectMate.get(data.material);
          model = new window.$CCBIM.WebGL.Mesh(GEO, Mate);
          break;
        case 'Line':
          {
            var lineColor = this.projectMate.get(data.material);
            var LineBasicMat = null;
            if (LineBasicMatMap.has(lineColor)) {
              LineBasicMat = LineBasicMatMap.get(lineColor);
            } else {
              LineBasicMat = new window.$CCBIM.WebGL.LineBasicMaterial({ color: lineColor, linewidth: 1, side: window.$CCBIM.WebGL.DoubleSide });
              LineBasicMatMap.set(lineColor, LineBasicMat);
            }

            var indexBuffer = new Float32Array(vertexAttribute.array.length / 3);
            for (var i = 0, il = indexBuffer.length; i < il; i++) {
              indexBuffer[i] = i;
            }
            var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.LINES);
            index.setIndex(indexBuffer);
            var indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
            indexRange.setRange(0, indexBuffer.length);
            index.addIndexRange(indexRange);
            GEO.addVertexIndex(index);
            GEO.computeBoundingBox();

            this.makeLineRegion(GEO);
            model = new window.$CCBIM.WebGL.PmLineSegments(GEO, LineBasicMat);
          }
          break;
        case 'Pt':
          {
            var PointColor = this.projectMate.get(data.material);
            var PointsMat = null;
            if (PointsMatMap.has(PointColor)) {
              PointsMat = PointsMatMap.get(PointColor);
            } else {
              PointsMat = new window.$CCBIM.WebGL.PointsMaterial({ color: PointColor, size: 1.5, side: window.$CCBIM.WebGL.DoubleSide, sizeAttenuation: false });
              PointsMatMap.set(PointColor, PointsMat);
            }

            var bufferGeometry = new window.$CCBIM.WebGL.BufferGeometry();
            var _vertexAttribute = new window.$CCBIM.WebGL.Float32BufferAttribute(data.vertices, 3);
            bufferGeometry.addAttribute('position', _vertexAttribute);
            bufferGeometry.computeVertexNormals();
            bufferGeometry.computeBoundingBox();

            model = new window.$CCBIM.WebGL.Points(bufferGeometry, PointsMat);
          }
          break;
        case 'Tri':
          {
            var TriColor = this.projectMate.get(data.material);
            var MeshBasicMat = null;
            if (MeshBasicMatMap.has(TriColor)) {
              MeshBasicMat = MeshBasicMatMap.get(TriColor);
            } else {
              MeshBasicMat = new window.$CCBIM.WebGL.MeshBasicMaterial({ color: TriColor, side: window.$CCBIM.WebGL.DoubleSide });
              MeshBasicMatMap.set(TriColor, MeshBasicMat);
            }

            var _indexBuffer = new Float32Array(vertexAttribute.array.length / 3);
            for (var _i = 0, _il = _indexBuffer.length; _i < _il; _i++) {
              _indexBuffer[_i] = _i;
            }
            var _index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
            _index.setIndex(_indexBuffer);
            var _indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
            _indexRange.setRange(0, _indexBuffer.length);
            _index.addIndexRange(_indexRange);
            GEO.addVertexIndex(_index);
            GEO.computeBoundingBox();

            this.makeMeshRegion(GEO);
            model = new window.$CCBIM.WebGL.Mesh(GEO, MeshBasicMat);
          }
          break;
      }
      if (data.visible) {
        this.normalGeo++;
      }
      model.receiveShadow = true;
      model.castShadow = true;
      model.userData = {
        uuid: data.uuid,
        Material: data.material,
        BComType: true,
        floor: true,
        stageId: data.stageId,
        visible: data.visible,
        AllowSelected: true
      };
      model.visible = data.visible;
      window.$CCBIM.userModelGroup.add(model);
      window.$CCBIM.userModelGroupMap.set(data.uuid, model);
      this.needUpdate = true;
    },


    makeLineRegion: function makeLineRegion(GEO) {
      var positions = GEO.getBufferAttribute('position').array;
      var bndBox = this.computeBndBox(positions);
      var cx = bndBox.max.x - bndBox.min.x;
      var cy = bndBox.max.y - bndBox.min.y;
      if (cx < 1 || cy < 1 || cx < 1000 && cy < 1000) {
        return;
      }
      var minX = bndBox.min.x;
      var minY = bndBox.min.y;
      var maxX = bndBox.max.x;
      var maxY = bndBox.max.y;
      var midX = (minX + maxX) / 2;
      var midY = (minY + maxY) / 2;
      this.computeRegion(GEO, minX, minY, maxX, maxY);
      var posLength = positions.length / 3;
      var x = 0;
      var y = 0;
      var regionMask1 = 0;
      var regionMask2 = 0;
      for (var i = 0; i < posLength; i += 2) {
        x = positions[i * 3];
        y = positions[i * 3 + 1];
        regionMask1 = this.computeRegionMask(x, y, midX, midY);
        GEO.regionMask[regionMask1].index.push(i);

        x = positions[(i + 1) * 3];
        y = positions[(i + 1) * 3 + 1];
        regionMask2 = this.computeRegionMask(x, y, midX, midY);
        if (regionMask2 !== regionMask1) {
          GEO.regionMask[regionMask2].index.push(i);
        }
      }
    },
    makeMeshRegion: function makeMeshRegion(GEO) {
      var positions = GEO.getBufferAttribute('position').array;
      var bndBox = this.computeBndBox(positions);
      var cx = bndBox.max.x - bndBox.min.x;
      var cy = bndBox.max.y - bndBox.min.y;
      if (cx < 1 || cy < 1 || cx < 1000 && cy < 1000) {
        return;
      }
      var minX = bndBox.min.x;
      var minY = bndBox.min.y;
      var maxX = bndBox.max.x;
      var maxY = bndBox.max.y;
      var midX = (minX + maxX) / 2;
      var midY = (minY + maxY) / 2;
      this.computeRegion(GEO, minX, minY, maxX, maxY);
      var posLength = positions.length / 3;
      var x = 0;
      var y = 0;
      var regionMask1 = 0;
      var regionMask2 = 0;
      var regionMask3 = 0;
      for (var i = 0; i < posLength; i += 3) {
        x = positions[i * 3];
        y = positions[i * 3 + 1];
        regionMask1 = this.computeRegionMask(x, y, midX, midY);
        GEO.regionMask[regionMask1].index.push(i);

        x = positions[(i + 1) * 3];
        y = positions[(i + 1) * 3 + 1];
        regionMask2 = this.computeRegionMask(x, y, midX, midY);
        if (regionMask2 !== regionMask1) {
          GEO.regionMask[regionMask2].index.push(i);
        }

        x = positions[(i + 2) * 3];
        y = positions[(i + 2) * 3 + 1];
        regionMask3 = this.computeRegionMask(x, y, midX, midY);
        if (regionMask3 !== regionMask1 && regionMask3 !== regionMask2) {
          GEO.regionMask[regionMask3].index.push(i);
        }
      }
    },
    computeBndBox: function computeBndBox(positions) {
      var size = positions.length / 3;
      var minPt = new window.$CCBIM.WebGL.Vector2();
      var maxPt = new window.$CCBIM.WebGL.Vector2();
      for (var i = 0; i < size; i++) {
        if (i === 0) {
          minPt.set(positions[i * 3], positions[i * 3 + 1]);
          maxPt.set(positions[i * 3], positions[i * 3 + 1]);
        } else {
          minPt.x = Math.min(minPt.x, positions[i * 3]);
          minPt.y = Math.min(minPt.y, positions[i * 3 + 1]);

          maxPt.x = Math.max(maxPt.x, positions[i * 3]);
          maxPt.y = Math.max(maxPt.y, positions[i * 3 + 1]);
        }
      }
      return {
        min: minPt,
        max: maxPt
      };
    },
    computeRegion: function computeRegion(GEO, minX, minY, maxX, maxY) {
      GEO.regionMask = [];
      var midX = (minX + maxX) / 2;
      var midY = (minY + maxY) / 2;
      GEO.regionMask.push({
        min: new window.$CCBIM.WebGL.Vector2(minX, minY),
        max: new window.$CCBIM.WebGL.Vector2(midX, midY),
        index: []
      });
      GEO.regionMask.push({
        min: new window.$CCBIM.WebGL.Vector2(midX, minY),
        max: new window.$CCBIM.WebGL.Vector2(maxX, midY),
        index: []
      });
      GEO.regionMask.push({
        min: new window.$CCBIM.WebGL.Vector2(minX, midY),
        max: new window.$CCBIM.WebGL.Vector2(midX, maxY),
        index: []
      });
      GEO.regionMask.push({
        min: new window.$CCBIM.WebGL.Vector2(midX, midY),
        max: new window.$CCBIM.WebGL.Vector2(maxX, maxY),
        index: []
      });
    },
    computeRegionMask: function computeRegionMask(x, y, midX, midY) {
      return (x > midX ? 1 : 0) | (y > midY ? 2 : 0);
    },

    computeDWGBoundingBox: function computeDWGBoundingBox() {
      var minPoint = {
        x: +Infinity,
        y: +Infinity,
        z: +Infinity
      };
      var maxPoint = {
        x: -Infinity,
        y: -Infinity,
        z: -Infinity
      };
      var geometryArray = window.$CCBIM.userModelGroup.children;
      for (var i = 0; i < geometryArray.length; i++) {
        geometryArray[i].geometry.computeBoundingBox();
        if (geometryArray[i].geometry.boundingBox.max.x > 1553512) {
          console.log(geometryArray[i].geometry.boundingBox.max.x);
        }
        if (geometryArray[i].geometry.boundingBox.max.y > 93656) {
          console.log(geometryArray[i].geometry.boundingBox.max.y);
        }
        if (geometryArray[i].geometry.boundingBox.min.x < 1546277) {
          console.log(geometryArray[i].geometry.boundingBox.min.x);
        }
        if (geometryArray[i].geometry.boundingBox.min.y < 87651) {
          console.log(geometryArray[i].geometry.boundingBox.min.y);
        }
      }
      for (var _i2 = 0; _i2 < geometryArray.length; _i2++) {
        if (geometryArray[_i2].geometry.boundingBox.min.x < minPoint.x) {
          minPoint.x = geometryArray[_i2].geometry.boundingBox.min.x;
        }
        if (geometryArray[_i2].geometry.boundingBox.min.y < minPoint.y) {
          minPoint.y = geometryArray[_i2].geometry.boundingBox.min.y;
        }
        if (geometryArray[_i2].geometry.boundingBox.min.z < minPoint.z) {
          minPoint.z = geometryArray[_i2].geometry.boundingBox.min.z;
        }
        if (geometryArray[_i2].geometry.boundingBox.max.x > maxPoint.x) {
          maxPoint.x = geometryArray[_i2].geometry.boundingBox.max.x;
        }
        if (geometryArray[_i2].geometry.boundingBox.max.y > maxPoint.y) {
          maxPoint.y = geometryArray[_i2].geometry.boundingBox.max.y;
        }
        if (geometryArray[_i2].geometry.boundingBox.max.z > maxPoint.z) {
          maxPoint.z = geometryArray[_i2].geometry.boundingBox.max.z;
        }
      }
      return {
        max: maxPoint,
        min: minPoint
      };
    },
    renderFinish: function renderFinish() {
      var _this = this;

      var loader = new window.$CCBIM.WebGL.FontLoader();
      loader.load(this.webGlFontUrl, function (font) {
        window.$CCBIM.render.webGlFont = font;
        _this.isUseWebGlFont = true;
      });
      if (this.rendererType === 'DWG') {
        this.initDWGMiniMap();

        this.setDWGLayerList();
      }
      this.isRenderFinish = true;

      window.$CCBIM.render.rendererType = this.rendererType;

      this.$emit('render');
      this.smaaSure = true;
      this.progress = 100;

      if (this.isHandle) {
        this.showHandle = this.isHandle;
      } else {
        this.showHandle = false;
      }
      this.setNeedUpdate();
    }
  }
});

/***/ }),
/* 463 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showHandle: false,

      isChoose: false,
      isBoxChoose: false,

      isCoordinate: false,

      isPositioning: false,

      isTwoPointDistance: false,

      isMeasureHeight: false,

      clearHeightDisControl: null,

      isOpenWalk: false,

      showMap: false,
      handleList: [{ href: '#icon-floor', name: '', type: 'floor', show: true, hover: false }, { href: '#icon-close', name: '', type: 'hideMark', show: true, hover: false }, { href: '#icon-open', name: '', type: 'showMark', show: false, hover: true }],
      handleDWGList: [{ href: '#icon-ceju', name: '', type: 'twoPointDistance', show: true, hover: false }, { href: '#icon-yuan', name: '', type: 'areaModel', show: false, hover: false }, { href: '#icon-coordinate', name: '', type: 'coordinate', show: true, hover: false }, { href: '#icon-choose', name: '', type: 'positioning', show: true, hover: false }],

      isUseWebGlFont: false
    };
  },

  props: {
    isHandle: {
      type: Boolean,
      default: true
    },

    isMark: {
      type: Boolean,
      default: true
    },

    isFloor: {
      type: Boolean,
      default: true
    },

    isChooseButton: {
      type: Boolean,
      default: true
    },

    isBoxChooseButton: {
      type: Boolean,
      default: true
    },

    isProfile: {
      type: Boolean,
      default: true
    },

    isWalk: {
      type: Boolean,
      default: true
    },

    isClearHeight: {
      type: Boolean,
      default: true
    },

    isModelMap: {
      type: Boolean,
      default: true
    },

    isCoordinateButton: {
      type: Boolean,
      default: true
    },

    isPositionButton: {
      type: Boolean,
      default: true
    },

    isDblClick: {
      type: Boolean,
      default: false
    },

    isShowGanttButton: {
      type: Boolean,
      default: false
    },

    definedChooseButton: {
      type: Boolean,
      default: false
    },

    definedProfileButton: {
      type: Boolean,
      default: false
    },

    definedWalkButton: {
      type: Boolean,
      default: false
    },

    definedMeasureHeightButton: {
      type: Boolean,
      default: false
    },

    definedShowMapButton: {
      type: Boolean,
      default: false
    },

    definedShowFloorButton: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    definedChooseButton: function definedChooseButton(status) {
      this.isChoose = status;
    },
    definedProfileButton: function definedProfileButton(status) {
      this.showClipping = status;
    },
    definedWalkButton: function definedWalkButton(status) {
      this.isOpenWalk = status;
    },
    definedMeasureHeightButton: function definedMeasureHeightButton(status) {
      this.isMeasureHeight = status;
    },
    definedShowMapButton: function definedShowMapButton(status) {
      this.showMap = status;
    },
    definedShowFloorButton: function definedShowFloorButton(status) {
      this.showFloorDiv = status;

      if (this.floorTree.length === 0) {
        this.initFloorTree(window.$CCBIM.buildInfo);
      }
    }
  },
  mounted: function mounted() {
    window.$CCBIM.handle.closeClipping = this.closeClipping;

    window.$CCBIM.handle.openWalk = this.setFirstPersonControl;

    window.$CCBIM.handle.closeWalk = this.closeWalk;

    window.$CCBIM.handle.openMeasureHeight = this.setModelHeightColor;

    window.$CCBIM.render.webGlFont = null;
  },

  methods: {
    setHandle: function setHandle() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.handleList), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          if (!this.isMark && item.type === 'hideMark' || !this.isFloor && item.type === 'floor') {
            item.show = false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.handleDWGList), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _item = _step2.value;

          if (!this.isCoordinateButton && _item.type === 'coordinate' || !this.isPositionButton && _item.type === 'positioning') {
            _item.show = false;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    },
    handleClick: function handleClick(item) {
      this.needUpdate = true;
      item.hover = !item.hover;
      switch (item.type) {
        case 'floor':
          this.showFloorDiv = !this.showFloorDiv;

          if (this.floorTree.length === 0) {
            this.initFloorTree(window.$CCBIM.buildInfo);
          }
          if (!item.hover) {
            this.closeFloorDiv();
          }
          break;

        case 'hideMark':
          this.handleList.forEach(function (x) {
            if (x.type === 'showMark') {
              x.show = true;
            }
          });
          item.show = false;
          item.hover = false;
          this.showMark = false;
          break;

        case 'showMark':
          this.handleList.forEach(function (x) {
            if (x.type === 'hideMark') {
              x.show = true;
            }
          });
          item.show = false;
          item.hover = true;
          this.showMark = true;
          break;

        case 'twoPointDistance':
          if (this.isUseWebGlFont) {
            this.isTwoPointDistance = !this.isTwoPointDistance;
            if (!item.hover) {
              window.$CCBIM.controller.SetCADCtrlMode(0);
            } else {
              window.$CCBIM.controller.SetCADCtrlMode(1);
            }
          } else {
            alert('webGL');
          }
          break;

        case 'areaModel':
          if (!item.hover) {
            window.$CCBIM.controller.SetCADCtrlMode(0);
          } else {
            window.$CCBIM.controller.SetCADCtrlMode(2);
          }
          break;

        case 'coordinate':
          this.isCoordinate = !this.isCoordinate;
          break;

        case 'positioning':
          this.isPositioning = !this.isPositioning;
          if (!item.hover) {
            this.delDwgMark(-1);
          }
          this.showClick = false;
          this.isRightPopupMenu = false;
          break;
      }
    },
    closeChoose: function closeChoose() {
      this.showClick = false;
      this.isRightPopupMenu = false;
    },
    closeFloorDiv: function closeFloorDiv() {
      this.handleList.forEach(function (x) {
        if (x.type === 'floor') {
          x.hover = false;
        }
      });
      this.showFloorDiv = false;
    },
    closeCoordinate: function closeCoordinate() {
      this.isCoordinate = false;
      this.handleList.forEach(function (x) {
        if (x.type === 'coordinate') {
          x.hover = false;
        }
      });
    },
    closeDistance: function closeDistance() {
      this.isTwoPointDistance = false;
    }
  }
});

/***/ }),
/* 464 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray__);




/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      scale: 1,

      EVer: 0,

      view: [],

      cloudUrl: '',
      jsons: [],
      size: 0,
      errorMsg: ''
    };
  },

  props: {
    node: '',
    version: '',

    urlIp: ''
  },
  methods: {
    modelConstructInfo: function modelConstructInfo() {
      var _this = this;

      var data = {};
      data['versionId'] = this.version;
      var CancelToken = this.$ccbimAxios.CancelToken;
      var source = CancelToken.source();
      this.ccbimAxiosAll.push(source);
      this.$ccbimAxios({
        method: 'post',
        url: this.urlIp + '/front/bimfile/modelConstructInfoCors.htm',
        cancelToken: source.token,
        data: this.$qs.stringify(data)
      }).then(function (res) {
        var data = res.data;

        if (data.success) {
          if (data.result.jsons.length === 0) {
            _this.errorMsg = '';
            return;
          }
          _this.jsons = data.result.jsons;

          _this.size = data.result.size;
          _this.loadProjectInfo();
        } else {
          _this.errorMsg = data.errorMsg;
        }
      }).catch(function (thrown) {
        if (_this.$ccbimAxios.isCancel(thrown)) {
          console.log('Request canceled', thrown.message);
        } else {}
      });
    },
    loadProjectInfo: function loadProjectInfo() {
      var _this2 = this;

      var ProjectInfo = this.jsons.filter(function (x) {
        return x.FileKey.includes('ProjectInfo');
      });
      var url = ProjectInfo[0].URI;
      var CancelToken = this.$ccbimAxios.CancelToken;
      var source = CancelToken.source();
      this.ccbimAxiosAll.push(source);
      this.$ccbimAxios({
        method: 'get',
        cancelToken: source.token,
        url: url
      }).then(function (res) {
        _this2.regularProjectInfo(res.data);
      }).catch(function (thrown) {
        if (_this2.$ccbimAxios.isCancel(thrown)) {
          console.log('Request canceled', thrown.message);
        } else {}
      });
    },
    regularProjectInfo: function regularProjectInfo(data) {
      this.scale = data.Scale || 1;
      window.$CCBIM.render.scale = this.scale;
      this.view = data.View || data.view;
      if (!this.isLocalLoad) {
        var url = this.jsons[0].URI;
        var length = url.lastIndexOf('/');
        this.cloudUrl = url.slice(0, length + 1);
      } else {
        this.cloudUrl = '/static/json/';
      }
      this.EVer = data.EVer;
      switch (data.Type) {
        case 'DWG':
          if (!this.isLocalLoad) {
            this.jsons.forEach(function (y) {
              data.fileList.map(function (file) {
                if (y.FileKey.indexOf(file.Path) > 0) {
                  file.Path = y.FileKey;
                }
              });
            });
          }
          this.rendererType = data.Type;

          this.setHandle();
          this.handleList = [].concat(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(this.handleDWGList), __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(this.handleList));

          this.setOrthographicCamera();

          this.setCADControls();

          this.initCADInfo(data);

          window.$CCBIM.scene.background = new window.$CCBIM.WebGL.Color('#000');
          break;
      }
    },
    localLoad: function localLoad(event) {
      var _this3 = this;

      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {
        var file, reader;
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                file = event.target.files[0];
                reader = new FileReader();

                reader.onload = function (evt) {
                  var data = JSON.parse(reader.result);
                  data.OctreeList.forEach(function (item) {
                    item.FileNameH = item.FileNameH.replace(/jsont/, 'buffer');
                  });
                  _this3.regularProjectInfo(data);
                  _this3.size = 2760199588;
                };
                reader.readAsText(file);

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this3);
      }))();
    }
  }
});

/***/ }),
/* 465 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__static_sockjs_min_js__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__static_sockjs_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__static_sockjs_min_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__static_stomp_js__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__static_stomp_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__static_stomp_js__);








/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      isShowPointImage: false,
      showMark: true,
      pointImageSrc: '',
      isPointImageSrc: false,
      pointImageTop: 0,
      pointImageLeft: 0,
      pointTextContent: '',
      isPointTextContent: false,
      pointList: [],
      pointSaveListMap: new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a(),
      pointListMap: new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a(),
      pointMap: new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a(),
      stompClient: null };
  },

  props: {
    modelMark: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  watch: {
    modelMark: function modelMark(items) {
      for (var i = 0; i < items.length; i++) {
        if (this.rendererType === 'DWG') {
          this.addDwgMark(items[i]);
        }
      }
    }
  },
  methods: {
    connectWebSocket: function connectWebSocket() {
      var _this = this;

      var socket = new window.SockJS(this.urlIp + '/websocket/');
      this.stompClient = window.Stomp.over(socket);
      this.stompClient.connect({}, function () {
        _this.stompClient.subscribe('/model/' + _this.version + '/msg', function (response) {
          var info = JSON.parse(response.body);
          console.log(info);

          _this.socketCallback(info);
        });
      });
    },
    socketCallback: function socketCallback(info) {
      if (this.rendererType === 'DWG') {} else if (this.rendererType === '3D') {
        if (info.type === 'MARKPOINT') {
          if (info.data.opt === 1) {
            this.$emit('socketAddMark', info);
          } else if (info.data.opt === 2) {} else if (info.data.opt === 3) {}
        }
      }
    },
    addModelMarkRequest: function addModelMarkRequest(extInfo) {
      var _this2 = this;

      return new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a(function (resolve) {
        if (__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default()(_this2.selectedGEO) === '{}') {
          return false;
        }
        _this2.$ccbimAxios({
          method: 'post',
          url: _this2.urlIp + '/front/bimfile/apply4Id'
        }).then(function (pointId) {
          if (pointId.data.success) {
            var viewInfo = _this2.selectedGEO.cameraPosition.x + ',' + _this2.selectedGEO.cameraPosition.y + ',' + _this2.selectedGEO.outWidth.width + ',' + _this2.selectedGEO.outWidth.height;

            var data = {
              'opt': 1,
              'modelId': _this2.version,
              'markingPointId': pointId.data.result,
              'pointInfo': __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default()({
                'floorId': _this2.selectedGEO.floorid,
                'handle': _this2.selectedGEO.DWGMark.x + ',' + _this2.selectedGEO.DWGMark.y,
                'viewInformation': viewInfo
              }),
              'extInfo': extInfo !== undefined || extInfo !== null ? __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default()(extInfo) : null
            };
            _this2.$ccbimAxios({
              method: 'post',
              url: _this2.urlIp + '/front/bimfile/markingpointadd',
              data: _this2.$qs.stringify(data)
            }).then(function (res) {
              var data = res.data;

              resolve(data);
            });
          }
        });
      });
    },
    removeModelMarkRequest: function removeModelMarkRequest(markingPointId) {
      var _this3 = this;

      return new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a(function (resolve) {
        var data = {
          'modelId': _this3.version,
          'markingPointId': markingPointId
        };
        _this3.$ccbimAxios({
          method: 'post',
          url: _this3.urlIp + '/front/bimfile/markingpointdel',
          data: _this3.$qs.stringify(data)
        }).then(function (res) {
          var data = res.data;

          if (data.success) {
            _this3.delModelMark(markingPointId);
            resolve(data);
          }
        });
      });
    },
    modelMarkListRequest: function modelMarkListRequest() {
      var _this4 = this;

      return new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a(function (resolve) {
        _this4.$ccbimAxios({
          method: 'get',
          url: _this4.urlIp + '/front/bimfile/markingpointlist?modelId=' + _this4.version
        }).then(function (res) {
          var data = res.data;

          resolve(data);
        });
      });
    },
    showPointImage: function showPointImage(item) {
      if (item.photo) {
        this.isShowPointImage = true;
        this.isPointImageSrc = true;
        this.pointImageSrc = item.photo;
        this.pointImageTop = item.top - 160;
        this.pointImageLeft = item.left - 100;
      }
      if (item.text) {
        this.isShowPointImage = true;
        this.isPointTextContent = true;
        this.pointTextContent = item.text;
        this.pointImageTop = item.top - 160;
        this.pointImageLeft = item.left - 100;
      }
    },
    clickPointImg: function clickPointImg(item) {},
    bounceModelMark: function bounceModelMark(id) {
      var _this5 = this;

      var times = 0;
      var interval = setInterval(function () {
        times += 30;
        var rad = 2 * Math.PI / 360 * times;
        _this5.pointListMap.get(id).top -= Math.sin(rad) * 3;
      }, 25);
      this.setNeedUpdate();
      setTimeout(function () {
        clearInterval(interval);
      }, 2100);
    },
    addMouseDWGMark: function addMouseDWGMark(e) {
      if (!this.isPositioning) {
        return;
      }

      this.mouse = e;

      if (this.isShowClick) {
        this.showClick = true;
        this.showRightPopupMenu(this.mouse);
      } else {
        this.showClick = false;
        this.isRightPopupMenu = false;
      }
      this.getDwgInfo(this.getPoint(e));
      this.addClickDwgMark(this.getPoint(e));
    },
    getDwgInfo: function getDwgInfo(point) {
      var cameraPosition = {
        x: window.$CCBIM.camera.position.x / this.scale,
        y: window.$CCBIM.camera.position.y / this.scale,
        z: window.$CCBIM.camera.position.z / this.scale
      };
      var DWGMarkInfo = {
        x: point.x / this.scale,
        y: point.y / this.scale
      };
      var isDWG = false;
      if (this.rendererType === 'DWG') {
        isDWG = true;
      }
      var out = this.getOutWidth();
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'cameraPosition': cameraPosition });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'cameraTarget': this.target });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'outWidth': out });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'zoom': window.$CCBIM.camera.zoom });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'cameraUp': window.$CCBIM.camera.up });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'scale': this.scale });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'DWGMark': DWGMarkInfo });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_assign___default()(this.selectedGEO, { 'isDWG': isDWG });
      this.$emit('selectedGEO', this.selectedGEO);
      this.$emit('selected-geometry', this.selectedGEO);
    },
    addClickDwgMark: function addClickDwgMark(mouse) {
      this.isUpdate = true;
      var Vector = new window.$CCBIM.WebGL.Vector3(mouse.x, mouse.y, 1);
      this.pointSaveListMap.set(-1, { point: Vector, id: -1 });
    },
    getOutWidth: function getOutWidth() {
      var dx = (window.$CCBIM.camera.right - window.$CCBIM.camera.left) / (2 * window.$CCBIM.camera.zoom);
      var dy = (window.$CCBIM.camera.top - window.$CCBIM.camera.bottom) / (2 * window.$CCBIM.camera.zoom);
      var cx = (window.$CCBIM.camera.right + window.$CCBIM.camera.left) / 2;
      var cy = (window.$CCBIM.camera.top + window.$CCBIM.camera.bottom) / 2;
      var right = cx + dx;
      var top = cy + dy;
      return {
        width: top * 2.5,
        height: right * 2.5
      };
    },
    addDwgMark: function addDwgMark(option) {
      this.isUpdate = true;
      if (option.handle) {
        var handle = option.handle.split(',');
        var Vector = new window.$CCBIM.WebGL.Vector3(handle[0], handle[1], 1);
        this.pointSaveListMap.set(option.id, {
          id: option.id,
          point: Vector,
          iconText: option.iconText,
          iconImg: option.iconImg,
          color: option.color,
          photo: option.photo,
          contentText: option.contentText
        });
      }
      this.setNeedUpdate();
    },
    delDwgMark: function delDwgMark(key) {
      this.needUpdate = true;
      this.pointSaveListMap.delete(key);
      this.pointListMap.delete(key);
      this.setNeedUpdate();
    },
    computePointPosition: function computePointPosition() {
      var _rect = this.rect,
          wHalf = _rect.wHalf,
          hHalf = _rect.hHalf;

      this.pointMap.clear();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.pointSaveListMap.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var x = _step.value;

          var center = x.point.clone();
          var scenePoint = center.project(window.$CCBIM.camera);
          scenePoint.x = scenePoint.x * wHalf + wHalf;
          scenePoint.y = -(scenePoint.y * hHalf) + hHalf;
          var floorShow = true;
          this.pointListMap.set(x.id, {
            id: x.id,
            left: scenePoint.x - 15,
            top: scenePoint.y - 40,
            iconText: x.iconText,
            iconImg: x.iconImg ? x.iconImg : window.$CCBIM.render.baseImg.modelMarkImg,
            color: x.color,
            photo: x.photo,
            contentText: x.contentText,
            show: floorShow,
            floorId: x.floorId
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.pointList = [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(this.pointListMap.values()));
    }
  }
});

/***/ }),
/* 466 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      projectFile: [],

      projectMate: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a(),

      projectMap: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a(),

      maxClipPoint: {
        x: -999999999,
        y: -999999999,
        z: -999999999
      },
      minClipPoint: {
        x: 999999999,
        y: 999999999,
        z: 999999999
      }
    };
  },

  methods: {
    getDistance: function getDistance(ext) {
      return [(ext[0] + ext[3]) / 2, (ext[1] + ext[4]) / 2, (ext[2] + ext[5]) / 2];
    },
    initCADInfo: function initCADInfo(info) {
      for (var index = 0; index < info.fileList.length; index++) {
        var element = info.fileList[index];
        this.projectFile.push({
          'id': element.uuid,
          'name': element.Path,
          'filesize': element.filesize
        });
      }
      for (var _index = 0; _index < info.LayerOut.length; _index++) {
        var LayerOut = info.LayerOut[_index];
        for (var i = 0; i < LayerOut.layer.length; i++) {
          var Layer = LayerOut.layer[i];
          this.projectLayerList.add(Layer);
        }
      }
      this.initCommon(info);
    },
    initCommon: function initCommon(info) {
      var _this = this;

      if (info.materials) {
        info.materials.forEach(function (element) {
          _this.projectMate.set(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int___default()(element.uuid), element.color);
        });
        delete info.materials;
      }

      if (this.isDebug) {
        this.initTest();
      }

      this.animate();
      this.initWorker();
    }
  }
});

/***/ }),
/* 467 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      addRefDebounce: null,
      sortRefDebounce: null,
      haveNeedUpdate: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.addRefDebounce = this.debounce(this.addRefGeometr, 500);
    this.sortRefDebounce = this.debounce(this.sortRefGeometr, 500);
    this.haveNeedUpdate = this.debounce(function () {
      _this.needUpdate = false;
    }, 500);
    this.haveOnAfterUpdate = this.debounce(function () {
      window.$CCBIM.controller.onAfterUpdateRefShow();
      _this.haveNeedUpdate();
    }, 50);
  },

  methods: {
    onBeforeUpdate: function onBeforeUpdate() {
      if (window.$CCBIM.controller.onBeforeUpdateRefShow) {
        window.$CCBIM.controller.onBeforeUpdateRefShow();
      }
      this.needUpdate = true;
    },
    onAfterUpdate: function onAfterUpdate() {
      this.haveOnAfterUpdate();
    },
    debounce: function debounce(fn, delay) {
      var timer = void 0;

      return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timer);

        timer = setTimeout(function () {
          fn.apply(context, args);
        }, delay);
      };
    },
    setNeedUpdate: function setNeedUpdate() {
      this.needUpdate = true;
      this.haveNeedUpdate();
    }
  }
});

/***/ }),
/* 468 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_roam_vue__ = __webpack_require__(636);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_roam_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_roam_vue__);


__WEBPACK_IMPORTED_MODULE_0__src_roam_vue___default.a.install = function (Vue) {
  Vue.component(__WEBPACK_IMPORTED_MODULE_0__src_roam_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_0__src_roam_vue___default.a);
};

/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__src_roam_vue___default.a);

/***/ }),
/* 469 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {};
  },
  created: function created() {
    if (!(window.$CCBIM.WebGLRenderer instanceof window.$CCBIM.WebGL.Scene)) {
      this.initScene();
    }
  },

  methods: {
    initScene: function initScene() {
      window.$CCBIM.scene = new window.$CCBIM.WebGL.Scene();

      window.$CCBIM.userModelGroup = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.userModelRefGroup = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.wireframeGroup = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.selectedGroup = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.selectedGEOREFLIST = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.chooseBoxGroup = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.measureGroup = new window.$CCBIM.WebGL.Group();
      window.$CCBIM.pmShadowMap = null;
      window.$CCBIM.scene.add(window.$CCBIM.userModelGroup);
      window.$CCBIM.scene.add(window.$CCBIM.userModelRefGroup);
      window.$CCBIM.scene.add(window.$CCBIM.selectedGroup);
      window.$CCBIM.scene.add(window.$CCBIM.selectedGEOREFLIST);
      window.$CCBIM.scene.add(window.$CCBIM.chooseBoxGroup);
      window.$CCBIM.scene.add(window.$CCBIM.measureGroup);
      this.addLight();
    },
    addLight: function addLight() {
      var al = new window.$CCBIM.WebGL.AmbientLight(0xffffff, 1.0);
      al.name = 'AmbientLight';
      window.$CCBIM.scene.add(al);
      var dl = new window.$CCBIM.WebGL.DirectionalLight(0xffffff, 1);
      dl.name = 'DirectionalLight';
      dl.position.set(1, 1, 1);
      window.$CCBIM.scene.add(dl);
      var dRight = new window.$CCBIM.WebGL.DirectionalLight(0xffffff, 0.5);
      dRight.position.set(-1, -1, 1);
      window.$CCBIM.scene.add(dRight);
    }
  }
});

/***/ }),
/* 470 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      handle: '',
      selectedGEO: {},

      worldCoordinate: [],

      mouse: {},

      target: {
        x: 0,
        y: 0,
        z: 0
      },
      showClick: false,

      showBComInfo: false
    };
  },
  mounted: function mounted() {
    window.$CCBIM.selectedGEOList = [];
  },

  methods: {
    getWorldCoordinate: function getWorldCoordinate(dom, x, y) {
      var rect = dom.getBoundingClientRect();
      return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
    },
    getCADIntersects: function getCADIntersects(e, tolValue) {
      var clientX = 0;
      var clientY = 0;
      if (e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      return this.computeCADIntersects(clientX, clientY, tolValue);
    },
    computeCADIntersects: function computeCADIntersects(clientX, clientY, tolValue) {
      this.worldCoordinate = this.getWorldCoordinate(this.$refs.model, clientX, clientY);
      var Vector = new window.$CCBIM.WebGL.Vector2();
      var mouse = new window.$CCBIM.WebGL.Vector2();
      var raycaster = new window.$CCBIM.WebGL.Raycaster();
      Vector.fromArray(this.worldCoordinate);
      mouse.set(Vector.x * 2 - 1, -(Vector.y * 2) + 1);
      raycaster.far = window.$CCBIM.camera.far;
      raycaster.near = window.$CCBIM.camera.near;
      raycaster.setFromCamera(mouse, window.$CCBIM.camera);
      raycaster.linePrecision = tolValue;
      return {
        rayPt: raycaster.ray.origin,
        intersertArr: raycaster.intersectObjects([].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(window.$CCBIM.userModelGroup.children), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(window.$CCBIM.userModelRefGroup.children)), true)
      };
    },
    updateBComInfo: function updateBComInfo() {
      var cameraData = window.$CCBIM.controller.getCameraData();
      this.selectedGEO.cameraPosition = {
        x: cameraData.cameraPosition.x / this.scale,
        y: cameraData.cameraPosition.y / this.scale,
        z: cameraData.cameraPosition.z / this.scale
      };
      this.selectedGEO.outWidth = this.computedTransverseView() / this.scale;
      for (var key in cameraData.target) {
        this.target[key] = cameraData.target[key] / this.scale;
      }
      this.selectedGEO.cameraTarget = this.target;
    },
    computedTransverseView: function computedTransverseView() {
      var DEG2RAD = Math.PI / 180;
      var far = this.computedCameraVector();
      return far * Math.tan(DEG2RAD * 0.5 * window.$CCBIM.camera.fov) / window.$CCBIM.camera.zoom;
    },
    computedCameraVector: function computedCameraVector() {
      var cameraData = window.$CCBIM.controller.getCameraData();
      var x1 = cameraData.cameraPosition.x;
      var y1 = cameraData.cameraPosition.y;
      var z1 = cameraData.cameraPosition.z;
      var x2 = window.$CCBIM.controller.target ? window.$CCBIM.controller.target.x : 0;
      var y2 = window.$CCBIM.controller.target ? window.$CCBIM.controller.target.y : 0;
      var z2 = window.$CCBIM.controller.target ? window.$CCBIM.controller.target.z : 0;
      this.target.x = x1 + (x2 - x1) * 1.5;
      this.target.y = y1 + (y2 - y1) * 1.5;
      this.target.z = z1 + (z2 - z1) * 1.5;
      return Math.sqrt(Math.pow(x1 - this.target.x, 2) + Math.pow(y1 - this.target.y, 2) + Math.pow(z1 - this.target.z, 2));
    },
    imageToBlod: function imageToBlod() {
      window.$CCBIM.WebGLRenderer.render(window.$CCBIM.scene, window.$CCBIM.camera);
      var data = window.$CCBIM.WebGLRenderer.domElement.toDataURL();
      window.$CCBIM.render.$ccbimBaseImg = window.$CCBIM.WebGLRenderer.domElement.toDataURL('image/png');
      data = data.split(',')[1];
      data = window.atob(data);
      var ia = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++) {
        ia[i] = data.charCodeAt(i);
      }
      return new Blob([ia], { type: 'image/png' });
    },
    canvasToImage: function canvasToImage() {
      window.$CCBIM.WebGLRenderer.render(window.$CCBIM.scene, window.$CCBIM.camera);
      return {
        img: window.$CCBIM.WebGLRenderer.domElement.toDataURL('image/png'),
        width: this.rect.w,
        height: this.rect.h
      };
    }
  }
});

/***/ }),
/* 471 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_useFlatBuffer_js__ = __webpack_require__(101);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      clearColor: '',
      textureType: 2,
      ccbimImage: ''
    };
  },
  mounted: function mounted() {
    this.clearColor = this.ccbimClearColor;
    this.textureType = this.ccbimTextureType;
  },

  props: {
    isPostprocessing: {
      type: Boolean,
      default: false
    },

    antialias: {
      type: Boolean,
      default: true
    },

    perceision: 'highp',

    ccbimClearColor: {
      type: String,
      default: '#fff'
    },

    ccbimTextureType: {
      type: Number,
      default: 2
    },

    isLocalLoad: {
      type: Boolean,
      default: false
    },

    isSimColorMode: {
      type: Boolean,
      default: false
    },

    simColorMode_Color: {
      type: String,
      default: '#fff'
    },

    isModelEdge: {
      type: Boolean,
      default: false
    },

    isAutoRotation: {
      type: Boolean,
      default: false
    },

    isShowClick: {
      type: Boolean,
      default: true
    },

    isShowBCInfo: {
      type: Boolean,
      default: false
    },

    modelEdge_Color: {
      type: String,
      default: '#505050'
    },
    isDebug: {
      type: Boolean,
      default: false
    },
    LocalLoad: {
      type: Boolean,
      default: false
    },
    workerUrl: {
      type: String,
      default: '/static/DataWorker.js?v=1.1.1'
    },
    protoUrl: {
      type: String,
      default: '/static/gemotry.proto?v=1.1.1'
    },

    webGlFontUrl: {
      type: String,
      default: '/static/gentilis_regular.typeface.json?v=1.1.1'
    },

    isNeedUpdate: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    setViewInfoImg: function setViewInfoImg(image) {
      this.ccbimImage = image;
    },
    setCameraView: function setCameraView(up, target, position) {
      var _this = this;

      this.needUpdate = true;
      if (this.rendererType === '3D') {
        if (this.isOpenWalk) {
          this.$refs.roamLocation.style.display = 'block';
          setTimeout(function () {
            _this.$refs.roamLocation.style.display = 'none';
          }, 1500);
        } else {
          this.setCameraModeView(up, target, position);
        }
      } else {
        this.setCameraCADView(up);
      }
      window.$CCBIM.camera.updateProjectionMatrix();
    },
    setCameraModeView: function setCameraModeView(up, target, position) {
      var _this2 = this;

      target = target.map(function (x) {
        return x * _this2.scale;
      });
      position = position.map(function (x) {
        return x * _this2.scale;
      });

      this.setCameraTween(window.$CCBIM.camera.up, up);
      this.setCameraTween(window.$CCBIM.camera.position, position);
      this.setCameraTween(window.$CCBIM.controller.target, target);
      this.setCameraBox();
    },
    setCameraCADView: function setCameraCADView(port) {
      var viewInfo = port.split(',');
      window.$CCBIM.camera.position.x = parseFloat(viewInfo[0]);
      window.$CCBIM.camera.position.y = parseFloat(viewInfo[1]);
      window.$CCBIM.camera.position.z = 90000;
      window.$CCBIM.camera.zoom = window.$CCBIM.camera.right / +viewInfo[3];
      window.$CCBIM.camera.updateProjectionMatrix();
      window.$CCBIM.controller.target.x = parseFloat(viewInfo[0]);
      window.$CCBIM.controller.target.y = parseFloat(viewInfo[1]);
    },
    setGeomery: function setGeomery(floor, handle, floorName) {
      this.clearAllSelectedRef();
      window.$CCBIM.controller.onAfterUpdateRefShow();
      this.highlightGeomery(floor, handle, floorName);
      this.haveNeedUpdate();
    },
    setModelViewInfo: function setModelViewInfo(floor, info, floorName, flatBuffer) {
      var useFlatBuffer = new __WEBPACK_IMPORTED_MODULE_1__flatBuffers_useFlatBuffer_js__["a" /* default */]();
      var viewInfo = useFlatBuffer.getFlatBuffer(useFlatBuffer.DecodeBase64(flatBuffer));
      var floorIds = [];
      var BComTypes = [];
      for (var f = 0; f < viewInfo.floorInfo.length; f++) {
        if (viewInfo.floorInfo[f].state === 1) {
          floorIds.push(viewInfo.floorInfo[f].floorid);
          for (var i = 0; i < this.floorTree[0].children.length; i++) {
            var floor1 = this.floorTree[0].children[i].children;
            for (var j = 0; j < floor1.length; j++) {
              var floor2 = floor1[j].children;
              for (var m = 0; m < floor2.length; m++) {
                if (floor2[m].floorId === viewInfo.floorInfo[f].floorid) {
                  BComTypes = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(BComTypes), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(floor2[m].allComTypeArray));
                }
              }
            }
          }
        } else if (viewInfo.floorInfo[f].state === 2) {
          floorIds.push(viewInfo.floorInfo[f].floorid);
          BComTypes = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(BComTypes), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(viewInfo.floorInfo[f].comtypeArr));
        }
      }
      this.$setBComType(floorIds, BComTypes);
      var up = [viewInfo.cameraUp.x, viewInfo.cameraUp.y, viewInfo.cameraUp.z];
      var target = [viewInfo.cameraTarget.x, viewInfo.cameraTarget.y, viewInfo.cameraTarget.z];
      var position = [viewInfo.cameraPosition.x, viewInfo.cameraPosition.y, viewInfo.cameraPosition.z];
      this.setCameraView(up, target, position);
      var handle = info.split(';')[0];
      this.setGeomery(floor, handle, floorName);
      if (viewInfo.cullPlane && viewInfo.cullPlane.length > 0) {
        var p = viewInfo.cullPlane;
        this.profileHandlePosition(p[0], p[1], p[2], p[3], p[4], p[5]);
      } else {
        this.clippingBox();
        this.clippingPosition();
      }
      useFlatBuffer = null;
    }
  }
});

/***/ }),
/* 472 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_setting_vue__ = __webpack_require__(637);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_setting_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_setting_vue__);


__WEBPACK_IMPORTED_MODULE_0__src_setting_vue___default.a.install = function (Vue) {
  Vue.component(__WEBPACK_IMPORTED_MODULE_0__src_setting_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_0__src_setting_vue___default.a);
};

/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__src_setting_vue___default.a);

/***/ }),
/* 473 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__test_stats_min__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__test_dat_gui_min__ = __webpack_require__(188);


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      stats: null,
      GUI: null
    };
  },

  methods: {
    initTest: function initTest() {
      this.stats = new __WEBPACK_IMPORTED_MODULE_0__test_stats_min__["a" /* default */]();
      this.initGUI();
      this.$refs.model.appendChild(this.stats.dom);
    },
    initGUI: function initGUI() {
      this.GUI = new __WEBPACK_IMPORTED_MODULE_1__test_dat_gui_min__["dat"].GUI();
      var folder = this.GUI.addFolder('');
      folder.add(window.$CCBIM.WebGLRenderer.info.memory, 'geometries');
      folder.add(window.$CCBIM.userModelGroup.children, 'length', 'ThreeJsMesh');
      folder.add(window.$CCBIM.WebGLRenderer.info.memory, 'textures');

      folder.add(window.$CCBIM.WebGLRenderer.info.render, 'triangles');
      folder.add(window.$CCBIM.WebGLRenderer.info.render, 'points');

      var sfolder = this.GUI.addFolder('');
      sfolder.add(window.$CCBIM.WebGLRenderer.info.programs, 'length');
      var osGfolder = this.GUI.addFolder('');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'precision');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'logarithmicDepthBuffer');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxVertexTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxTextureSize');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxCubemapSize');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxAttributes');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxVertexUniforms');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxVaryings');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxFragmentUniforms');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'vertexTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'floatFragmentTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'floatVertexTextures');

      this.setGUICamera();
    },
    setGUILight: function setGUILight() {
      var _this = this;

      var DirectionalLight = window.$CCBIM.scene.getObjectByName('DirectionalLight');
      var AmbientLight = window.$CCBIM.scene.getObjectByName('AmbientLight');

      var folder = this.GUI.addFolder('');
      folder.add(DirectionalLight, 'intensity', 1.0, 10).onChange(function (v) {
        DirectionalLight.intensity = v;
      });

      var dc = { 'light color': DirectionalLight.color.getHex() };
      folder.addColor(dc, 'light color').onChange(function (v) {
        _this.needUpdate = true;
        DirectionalLight.color.setHex(v);
      });

      folder = this.GUI.addFolder('');
      folder.add(AmbientLight, 'intensity', 1.0, 10).onChange(function (v) {
        _this.needUpdate = true;
        AmbientLight.intensity = v;
      });

      dc = { 'light color': AmbientLight.color.getHex() };
      folder.addColor(dc, 'light color').onChange(function (v) {
        _this.needUpdate = true;
        AmbientLight.color.setHex(v);
      });
    },
    setGUICamera: function setGUICamera() {
      var cfolder = this.GUI.addFolder('');
      cfolder.add(window.$CCBIM.camera.position, 'x');
      cfolder.add(window.$CCBIM.camera.position, 'y');
      cfolder.add(window.$CCBIM.camera.position, 'z');
      cfolder.add(window.$CCBIM.camera, 'zoom');
      if (this.rendererType === 'DWG') {
        cfolder.add(window.$CCBIM.camera, 'left');
        cfolder.add(window.$CCBIM.camera, 'right');
        cfolder.add(window.$CCBIM.camera, 'top');
        cfolder.add(window.$CCBIM.camera, 'bottom');
      }
      var ccfolder = this.GUI.addFolder('');
      ccfolder.open();
      ccfolder.add(window.$CCBIM.camera.position, 'x');
      ccfolder.add(window.$CCBIM.camera.position, 'y');
      ccfolder.add(window.$CCBIM.camera.position, 'z');
    }
  }
});

/***/ }),
/* 474 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue__ = __webpack_require__(640);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue__);


__WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue___default.a.install = function (Vue) {
  Vue.component(__WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue___default.a.name, __WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue___default.a);
};

/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__src_FileUpload_vue___default.a);

/***/ }),
/* 475 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_protobufjs__ = __webpack_require__(610);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_protobufjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_protobufjs__);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      progress: 0,
      loaded: 0,
      ccbimAxiosAll: []
    };
  },

  methods: {
    initWorker: function initWorker() {
      var _this = this;

      __WEBPACK_IMPORTED_MODULE_2_protobufjs___default.a.load(this.protoUrl, function (err, root) {
        if (err) throw err;
        _this.loadBufferFile(root);
      });
    },
    loadBufferFile: function loadBufferFile(root) {
      var _this2 = this;

      var promises = null;
      if (this.EVer < 127) {
        promises = this.projectFile.map(function (file) {
          return _this2.loadJSON(file, root);
        });
      }
      __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.all(promises).then(function () {
        _this2.renderFinish();
      });
    },
    loadJSON: function loadJSON(file) {
      var _this3 = this;

      return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve) {
        var CancelToken = _this3.$ccbimAxios.CancelToken;
        var source = CancelToken.source();
        _this3.ccbimAxiosAll.push(source);
        _this3.$ccbimAxios({
          method: 'get',
          cancelToken: source.token,
          url: '' + _this3.cloudUrl + file.name
        }).then(function (res) {
          res.data.Geomery.forEach(function (item) {
            _this3.addGeomery(item);
          });
          _this3.computeProgress(file.filesize);
          resolve();
        }).catch(function (thrown) {
          if (_this3.$ccbimAxios.isCancel(thrown)) {
            console.log('Request canceled', thrown.message);
          } else {}
        });
      });
    },
    computeProgress: function computeProgress(loaded) {
      if (loaded) {
        this.loaded += loaded;
        this.progress = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_number_parse_int___default()(this.loaded / this.size * 100);
      }
    }
  }
});

/***/ }),
/* 476 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);



var CADAreaCtrl = function () {
  function CADAreaCtrl() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, CADAreaCtrl);

    this.type = 'CADAreaCtrl';
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(CADAreaCtrl, [{
    key: 'mousedown',
    value: function mousedown(iconMode) {
      console.log('aaa');
    }
  }, {
    key: 'mousemove',
    value: function mousemove(event, iconMode) {
      console.log('aaa');
    }
  }, {
    key: 'mouseup',
    value: function mouseup(event, iconMode) {
      console.log('aaa');
    }
  }]);

  return CADAreaCtrl;
}();

/* harmony default export */ __webpack_exports__["a"] = (CADAreaCtrl);

/***/ }),
/* 477 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CADControls;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__THREE_math_Quaternion_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CADdistanceCtrl_js__ = __webpack_require__(478);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__CADAreaCtrl_js__ = __webpack_require__(476);









function CADControls(object, domElement, modelrect) {

  var _this = this;
  var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, TOUCH_ZOOM: 5, TOUCH_PAN: 6 };

  this.object = object;
  this.Camera = object;
  this.domElement = domElement !== undefined ? domElement : document;
  this.modelRect = modelrect;

  this.enabled = true;

  this.screen = { left: 0, top: 0, width: 0, height: 0 };

  this.radius = 0;

  this.rotateSpeed = 1.0;
  this.zoomSpeed = 1.2;
  this.panSpeed = 1.0;

  this.noRotate = false;
  this.noZoom = false;
  this.noPan = false;
  this.noRoll = false;

  this.staticMoving = true;
  this.dynamicDampingFactor = 0.2;

  this.OldMouseDownX = 0;
  this.OldMouseDownY = 0;

  this.keys = [65, 83, 68];

  this.target = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]();

  var EPS = 0.000001;

  var _changed = true;

  var _state = STATE.NONE,
      _prevState = STATE.NONE,
      _eye = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */](),
      _rotateStart = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */](),
      _rotateEnd = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */](),
      _zoomStart = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */](),
      _zoomEnd = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */](),
      _touchZoomDistanceStart = 0,
      _touchZoomDistanceEnd = 0,
      _panStart = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */](),
      _panEnd = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */](),
      _curMouseX = 0,
      _curMouseY = 0,
      _enableCalGrip = true;

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.up0 = this.object.up.clone();

  this.left0 = this.object.left;
  this.right0 = this.object.right;
  this.top0 = this.object.top;
  this.bottom0 = this.object.bottom;
  this.zoom0 = this.object.zoom;

  this.DistanceCtrl = null;
  this.AreaCtrl = null;

  var changeEvent = { type: 'change' };
  var startEvent = { type: 'start' };
  var endEvent = { type: 'end' };

  this.drawGripGroup = null;

  this.buildGripGroup = function () {
    if (_this.drawGripGroup !== null) {
      return;
    }

    _this.drawGripGroup = new window.$CCBIM.WebGL.Group();
    var LineBasicMat = new window.$CCBIM.WebGL.LineBasicMaterial({ color: 0xffffff, linewidth: 1, side: window.$CCBIM.WebGL.DoubleSide });

    var simLineVet = [-1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, 1.0, 0.0];
    var simLineGeo = new window.$CCBIM.WebGL.BufferGeometry();
    simLineGeo.addAttribute('position', new window.$CCBIM.WebGL.Float32BufferAttribute(simLineVet, 3));
    var simlineModel = new window.$CCBIM.WebGL.PmLineSegments(simLineGeo, LineBasicMat);
    _this.drawGripGroup.add(simlineModel);

    var multiLineVet = [-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, -1.0, 0.0];
    var multiLineGeo = new window.$CCBIM.WebGL.BufferGeometry();
    multiLineGeo.addAttribute('position', new window.$CCBIM.WebGL.Float32BufferAttribute(multiLineVet, 3));
    var multilineModel = new window.$CCBIM.WebGL.PmLineSegments(multiLineGeo, LineBasicMat);
    _this.drawGripGroup.add(multilineModel);
    window.$CCBIM.scene.add(_this.drawGripGroup);
  };

  this.SetCADCtrlMode = function (ctrlMode) {
    switch (ctrlMode) {
      case 1:
        this.DistanceCtrl = new __WEBPACK_IMPORTED_MODULE_4__CADdistanceCtrl_js__["a" /* default */](this.modelRect);
        this.AreaCtrl = null;
        break;
      case 2:
        this.AreaCtrl = new __WEBPACK_IMPORTED_MODULE_5__CADAreaCtrl_js__["a" /* default */](this.modelRect);
        this.DistanceCtrl = null;
        break;
      default:
        this.AreaCtrl = null;
        this.DistanceCtrl = null;
    }
  };

  this.handleResize = function () {

    if (this.domElement === document) {

      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {

      var box = this.domElement.getBoundingClientRect();

      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }

    this.radius = 0.5 * Math.min(this.screen.width, this.screen.height);

    this.left0 = this.object.left;
    this.right0 = this.object.right;
    this.top0 = this.object.top;
    this.bottom0 = this.object.bottom;
  };

  this.handleEvent = function (event) {

    if (typeof this[event.type] == 'function') {

      this[event.type](event);
    }
  };

  var getMouseOnScreen = function () {

    var vector = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */]();

    return function getMouseOnScreen(pageX, pageY) {

      vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

      return vector;
    };
  }();

  var getMouseProjectionOnBall = function () {

    var vector = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]();
    var objectUp = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]();
    var mouseOnBall = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]();

    return function getMouseProjectionOnBall(pageX, pageY) {

      mouseOnBall.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / _this.radius, (_this.screen.height * 0.5 + _this.screen.top - pageY) / _this.radius, 0.0);

      var length = mouseOnBall.length();

      if (_this.noRoll) {

        if (length < Math.SQRT1_2) {

          mouseOnBall.z = Math.sqrt(1.0 - length * length);
        } else {

          mouseOnBall.z = .5 / length;
        }
      } else if (length > 1.0) {

        mouseOnBall.normalize();
      } else {

        mouseOnBall.z = Math.sqrt(1.0 - length * length);
      }

      _eye.copy(_this.object.position).sub(_this.target);

      vector.copy(_this.object.up).setLength(mouseOnBall.y);
      vector.add(objectUp.copy(_this.object.up).cross(_eye).setLength(mouseOnBall.x));
      vector.add(_eye.setLength(mouseOnBall.z));

      return vector;
    };
  }();

  this.rotateCamera = function () {

    var axis = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */](),
        quaternion = new __WEBPACK_IMPORTED_MODULE_3__THREE_math_Quaternion_js__["a" /* Quaternion */]();

    return function rotateCamera() {

      var angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());

      if (angle) {

        axis.crossVectors(_rotateStart, _rotateEnd).normalize();

        angle *= _this.rotateSpeed;

        quaternion.setFromAxisAngle(axis, -angle);

        _eye.applyQuaternion(quaternion);
        _this.object.up.applyQuaternion(quaternion);

        _rotateEnd.applyQuaternion(quaternion);

        if (_this.staticMoving) {

          _rotateStart.copy(_rotateEnd);
        } else {

          quaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));
          _rotateStart.applyQuaternion(quaternion);
        }

        _changed = true;
      }
    };
  }();

  this.zoomCamera = function () {

    if (_state === STATE.TOUCH_ZOOM) {

      var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
      _touchZoomDistanceStart = _touchZoomDistanceEnd;

      _this.object.zoom *= factor;

      _changed = true;
    } else {

      var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

      if (Math.abs(factor - 1.0) > EPS && factor > 0.0) {

        _this.object.zoom *= factor;

        if (_this.staticMoving) {

          _zoomStart.copy(_zoomEnd);
        } else {

          _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
        }

        _changed = true;
      }
    }
  };

  this.panCamera = function () {

    var mouseChange = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */](),
        objectUp = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */](),
        pan = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]();

    return function panCamera() {

      mouseChange.copy(_panEnd).sub(_panStart);

      if (mouseChange.lengthSq()) {
        var scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;
        var scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;
        mouseChange.x *= scale_x;
        mouseChange.y *= scale_y;

        pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
        pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

        pan.multiplyScalar(this.panSpeed);

        _this.object.position.add(pan);
        _this.target.add(pan);

        if (_this.staticMoving) {

          _panStart.copy(_panEnd);
        } else {

          _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
        }

        _changed = true;
      }
    };
  }();

  this.update = function () {

    _eye.subVectors(_this.object.position, _this.target);

    if (!_this.noRotate) {

      _this.rotateCamera();
    }

    if (!_this.noZoom) {

      var tempPosition = null,
          apreTargetPosition = null;

      if (_this.MouseWheelPoint) {
        tempPosition = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]().copy(_this.MouseWheelPoint);
        tempPosition.setZ(0);
        apreTargetPosition = tempPosition.unproject(_this.object);
      }

      _this.zoomCamera();

      if (_changed) {

        _this.object.updateProjectionMatrix();

        if (_this.MouseWheelPoint) {

          var tempPosition1 = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]().copy(_this.MouseWheelPoint);
          tempPosition1.setZ(0);
          var apreTargetPosition1 = tempPosition1.unproject(_this.object);

          var sub = new __WEBPACK_IMPORTED_MODULE_1__THREE_math_Vector3_js__["a" /* Vector3 */]().subVectors(apreTargetPosition1, apreTargetPosition);
          _this.target.sub(sub);
        }
      }
    }

    if (!_this.noPan) {

      _this.panCamera();
    }

    _this.object.position.addVectors(_this.target, _eye);

    _this.object.lookAt(_this.target);

    if (_changed) {
      _changed = false;
    }
    if (_this.DistanceCtrl) {
      _this.DistanceCtrl.computeLabelPosition();
    }
    if (_this.AreaCtrl) {
      _this.AreaCtrl.computeLabelPosition();
    }
  };

  this.reset = function () {

    _state = STATE.NONE;
    _prevState = STATE.NONE;

    _this.target.copy(_this.target0);
    _this.object.position.copy(_this.position0);
    _this.object.up.copy(_this.up0);

    _eye.subVectors(_this.object.position, _this.target);

    _this.object.left = _this.left0;
    _this.object.right = _this.right0;
    _this.object.top = _this.top0;
    _this.object.bottom = _this.bottom0;

    _this.object.zoom = 1;

    _this.object.lookAt(_this.target);

    _this.object.updateProjectionMatrix();

    _changed = false;
  };

  this.computePoinPosition = function () {
    var widthHalf = app.Size.Width / 2;
    var heightHalf = app.Size.Height / 2;
    var list = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(app.DWGlist.values()));
    if (list) {
      list.forEach(function (x) {
        var center = x.point.clone();
        var scenePoint = center.project(_this.object);
        scenePoint.x = scenePoint.x * widthHalf + widthHalf;
        scenePoint.y = -(scenePoint.y * heightHalf) + heightHalf;
        app.poinPositionCallBack({
          orderId: x.orderId,
          left: scenePoint.x,
          top: scenePoint.y,
          photo: x.photo
        });
      });
    }
  };

  function keydown(event) {

    if (_this.enabled === false) return;

    window.removeEventListener('keydown', keydown);

    _prevState = _state;

    if (_state !== STATE.NONE) {

      return;
    } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {

      _state = STATE.ROTATE;
    } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {

      _state = STATE.ZOOM;
    } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {

      _state = STATE.PAN;
    }
  }

  function keyup(event) {

    if (_this.enabled === false) return;

    _state = _prevState;

    window.addEventListener('keydown', keydown, false);
  }

  function sortCompare(property) {
    return function (a, b) {
      var value1 = a[property];
      var value2 = b[property];
      return value1 - value2;
    };
  }
  function getIconMode(intersects) {

    if (intersects.intersertArr.length === 0) {
      intersects.rayPt.z = 0;
      return { iconMode: -1,
        point: intersects.rayPt
      };
    }
    var iconMode = -1;
    var mousePt = null;

    if (intersects.intersertArr.length === 1) {
      iconMode = 1;
      mousePt = intersects.intersertArr[0].point;
    } else {
      var intersectArray = [];
      for (var i = 0; i < intersects.intersertArr.length; i++) {
        var bHasFind = false;
        for (var j = 0; j < intersectArray.length; j++) {
          if (intersects.intersertArr[i].point.equals(intersectArray[j].point)) {
            intersectArray[j].ptCount++;
            bHasFind = true;
          }
        }
        if (bHasFind === false) {
          var temInfo = {
            point: intersects.intersertArr[i].point,
            ptCount: 1
          };
          intersectArray.push(temInfo);
        }
      }

      intersectArray.sort(sortCompare('ptCount'));
      return { iconMode: 0,
        point: intersectArray[0].point
      };
    }

    return { iconMode: iconMode,
      point: mousePt
    };
  }

  function calMouseGrip(event) {
    _this.buildGripGroup();

    var cameraMaxWidth = Math.max(_this.object.top - _this.object.bottom, _this.object.right - _this.object.left);
    var tolValue = cameraMaxWidth / (_this.object.zoom * 200);

    var intersects = window.$CCBIM.render.$getCADIntersects(event, tolValue);

    return updateIcon(intersects, tolValue);
  }
  function updateIcon(intersects, tolValue) {
    var iconMode = getIconMode(intersects);
    if (iconMode.iconMode === -1) {
      _this.drawGripGroup.visible = false;
    } else {
      _this.drawGripGroup.position.x = iconMode.point.x;
      _this.drawGripGroup.position.y = iconMode.point.y;
      _this.drawGripGroup.position.z = iconMode.point.z;
      _this.drawGripGroup.scale.setLength(tolValue);
      _this.drawGripGroup.updateMatrixWorld(true);

      if (iconMode.iconMode === 1) {
        _this.drawGripGroup.children[0].visible = false;
        _this.drawGripGroup.children[1].visible = true;
      } else {
        _this.drawGripGroup.children[0].visible = true;
        _this.drawGripGroup.children[1].visible = false;
      }
      _this.drawGripGroup.visible = true;
    }
    return iconMode;
  }

  function mousedown(event) {

    window.$CCBIM.render.onBeforeUpdate();
    if (_this.enabled === false) return;

    event.preventDefault();
    event.stopPropagation();

    if (_state === STATE.NONE) {

      if (event.button > 1) _state = event.button;else _state = STATE.PAN;
    }

    if (_state === STATE.ROTATE && !_this.noRotate) {

      _rotateStart.copy(getMouseProjectionOnBall(event.pageX, event.pageY));
      _rotateEnd.copy(_rotateStart);
    } else if (_state === STATE.ZOOM && !_this.noZoom) {

      _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
      _zoomEnd.copy(_zoomStart);
    } else if (_state === STATE.PAN && !_this.noPan) {

      _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
      _panEnd.copy(_panStart);
      _enableCalGrip = false;
    }

    this.OldMouseDownX = event.pageX;
    this.OldMouseDownY = event.pageY;

    if (_this.DistanceCtrl || _this.AreaCtrl) {
      var iconMode = calMouseGrip(event);
      if (_this.DistanceCtrl) {
        _this.DistanceCtrl.mousedown(iconMode);
      } else if (_this.AreaCtrl) {
        _this.AreaCtrl.mousedown(iconMode);
      }
    }
  }

  function mousemove(event) {

    if (_this.enabled === false) return;

    event.preventDefault();
    event.stopPropagation();

    window.$CCBIM.render.setNeedUpdate();

    if (_state === STATE.ROTATE && !_this.noRotate) {

      _rotateEnd.copy(getMouseProjectionOnBall(event.pageX, event.pageY));
    } else if (_state === STATE.ZOOM && !_this.noZoom) {

      _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
    } else if (_state === STATE.PAN && !_this.noPan) {

      _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
    }

    if ((_this.DistanceCtrl || _this.AreaCtrl) && _enableCalGrip) {
      var iconMode = calMouseGrip(event);
      if (_this.DistanceCtrl) {
        _this.DistanceCtrl.mousemove(iconMode);
      } else if (_this.AreaCtrl) {
        _this.AreaCtrl.mousemove(event, iconMode);
      }
    }

    if (event.touches) {
      _curMouseX = event.touches[0].clientX;
      _curMouseY = event.touches[0].clientY;
    } else {
      _curMouseX = event.clientX;
      _curMouseY = event.clientY;
    }
  }

  function mouseup(event) {

    if (_this.enabled === false) return;

    event.preventDefault();
    event.stopPropagation();

    if (_state === STATE.PAN) {
      _enableCalGrip = true;
    }

    _state = STATE.NONE;

    if (event.which !== 1 || _state === STATE.PAN) {
      return;
    }

    var isInPan = false;
    if (Math.abs(this.OldMouseDownX - event.pageX) > 0.01 || Math.abs(this.OldMouseDownY - event.pageY) > 0.01) isInPan = true;

    if (!isInPan && (_this.DistanceCtrl || _this.AreaCtrl)) {
      var iconMode = calMouseGrip(event);
      if (_this.DistanceCtrl) {
        _this.DistanceCtrl.mouseup(iconMode);
      } else if (_this.AreaCtrl) {
        _this.AreaCtrl.mouseup(event, iconMode);
      }
    }
  }

  function mousewheel(event) {

    if (_this.enabled === false) return;

    event.preventDefault();
    event.stopPropagation();

    var Canvas = _this.domElement;
    var x = (event.clientX - Canvas.offsetLeft) / Canvas.width * 2 - 1;
    var y = -((event.clientY - Canvas.offsetTop) / Canvas.height) * 2 + 1;

    _this.MouseWheelPoint = new __WEBPACK_IMPORTED_MODULE_2__THREE_math_Vector2_js__["a" /* Vector2 */](x, y);

    _zoomStart.y += event.deltaY * 0.01;

    window.$CCBIM.render.setNeedUpdate();
  }

  function touchstart(event) {

    if (_this.enabled === false) return;

    switch (event.touches.length) {

      case 2:
        _state = STATE.TOUCH_ZOOM;
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
        _panStart.copy(getMouseOnScreen(x, y));
        _panEnd.copy(_panStart);
        break;
      case 1:
        _state = STATE.TOUCH_PAN;
        var x = event.touches[0].pageX / 2;
        var y = event.touches[0].pageY / 2;
        _panStart.copy(getMouseOnScreen(x, y));
        _panEnd.copy(_panStart);

        if (_this.DistanceCtrl || _this.AreaCtrl) {
          var iconMode = calMouseGrip(event);
          if (_this.DistanceCtrl) {
            _this.DistanceCtrl.touchstart(iconMode);
          } else if (_this.AreaCtrl) {
            _this.AreaCtrl.touchstart(iconMode);
          }
        }
        break;

      default:
        _state = STATE.NONE;

    }
  }

  function touchmove(event) {

    if (_this.enabled === false) return;

    event.preventDefault();
    event.stopPropagation();

    window.$CCBIM.render.setNeedUpdate();

    switch (event.touches.length) {

      case 2:
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
        _panEnd.copy(getMouseOnScreen(x, y));
        break;
      case 1:
        if (_this.DistanceCtrl || _this.AreaCtrl) {
          var iconMode = calMouseGrip(event);
          if (_this.DistanceCtrl) {
            _this.DistanceCtrl.touchmove(iconMode);
          } else if (_this.AreaCtrl) {
            _this.AreaCtrl.touchmove(event, iconMode);
          }
        } else {
          var x = event.touches[0].pageX / 2;
          var y = event.touches[0].pageY / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
        }
        break;

      default:
        _state = STATE.NONE;

    }
  }

  function touchend(event) {

    if (_this.enabled === false) return;

    switch (event.touches.length) {

      case 2:
        _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
        _panEnd.copy(getMouseOnScreen(x, y));
        _panStart.copy(_panEnd);
        break;
      case 1:
        var x = event.touches[0].pageX / 2;
        var y = event.touches[0].pageY / 2;
        _panEnd.copy(getMouseOnScreen(x, y));
        _panStart.copy(_panEnd);
        break;
      default:
        _state = STATE.NONE;

        var isInPan = false;
        if (Math.abs(this.OldMouseDownX - event.pageX) > 0.01 || Math.abs(this.OldMouseDownY - event.pageY) > 0.01) isInPan = true;

        if (!isInPan && (_this.DistanceCtrl || _this.AreaCtrl)) {
          if (_this.DistanceCtrl) {
            _this.DistanceCtrl.touchend();
          } else if (_this.AreaCtrl) {
            _this.AreaCtrl.touchend(event);
          }
        }
    }
  }

  function contextmenu(event) {

    event.preventDefault();
  }

  this.dispose = function () {

    this.domElement.removeEventListener('contextmenu', contextmenu, false);
    this.domElement.removeEventListener('mousedown', mousedown, false);
    this.domElement.removeEventListener('wheel', mousewheel, false);

    this.domElement.removeEventListener('touchstart', touchstart, false);
    this.domElement.removeEventListener('touchend', touchend, false);
    this.domElement.removeEventListener('touchmove', touchmove, false);

    this.domElement.removeEventListener('mousemove', mousemove, false);
    this.domElement.removeEventListener('mouseup', mouseup, false);

    window.removeEventListener('keydown', keydown, false);
    window.removeEventListener('keyup', keyup, false);
  };

  this.domElement.addEventListener('contextmenu', contextmenu, false);
  this.domElement.addEventListener('mousedown', mousedown, false);
  this.domElement.addEventListener('mousemove', mousemove, false);
  this.domElement.addEventListener('mouseup', mouseup, false);
  this.domElement.addEventListener('wheel', mousewheel, false);

  this.domElement.addEventListener('touchstart', touchstart, false);
  this.domElement.addEventListener('touchend', touchend, false);
  this.domElement.addEventListener('touchmove', touchmove, false);

  window.addEventListener('keydown', keydown, false);
  window.addEventListener('keyup', keyup, false);

  this.domElement.addEventListener('mousemove', mousemove, false);
  this.domElement.addEventListener('mouseup', mouseup, false);

  this.handleResize();

  this.update();
};

/***/ }),
/* 478 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__THREE_math_Math__ = __webpack_require__(8);






var CADdistanceCtrl = function () {
  function CADdistanceCtrl(modelRect) {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, CADdistanceCtrl);

    window.$CCBIM.render.onBeforeUpdate();
    this.type = 'CADdistanceCtrl';

    this.distanceLineGroup = new window.$CCBIM.WebGL.Group();
    window.$CCBIM.scene.add(this.distanceLineGroup);
    this.LineBasicMat = new window.$CCBIM.WebGL.LineBasicMaterial({ color: 0xff0000, linewidth: 2, side: window.$CCBIM.WebGL.DoubleSide });

    this.midlineSet = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    this.midlineSet.clear();

    this.midlineList = [];
    this.modelRect = modelRect;

    this.curLabelId = -1;
    this.curDistanceEnt = null;
    this.curLableText = null;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(CADdistanceCtrl, [{
    key: 'computeLabelPosition',
    value: function computeLabelPosition() {
      this.midlineList = [];
      var _modelRect = this.modelRect,
          wHalf = _modelRect.wHalf,
          hHalf = _modelRect.hHalf;

      var cameraLookat = new window.$CCBIM.WebGL.Vector3(0, 0, -1);

      var cameraPosition = window.$CCBIM.camera.position;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.midlineSet.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var x = _step.value;

          var center = x.center.clone();
          var labVer = new window.$CCBIM.WebGL.Vector3();
          labVer.subVectors(center, cameraPosition);
          var isShow = true;
          var dTemAnagle = labVer.angleTo(cameraLookat);
          if (dTemAnagle > Math.PI / 2) {
            isShow = false;
          }
          var scenePoint = center.project(window.$CCBIM.camera);
          scenePoint.x = scenePoint.x * wHalf + wHalf;
          scenePoint.y = -(scenePoint.y * hHalf) + hHalf;
          this.midlineList.push({
            left: scenePoint.x,
            top: scenePoint.y,
            name: x.name,
            show: isShow
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      window.$CCBIM.render.$setCADLabel(this.midlineList);
    }
  }, {
    key: 'addLabel',
    value: function addLabel(UUID, startPt, endPt) {
      var centerPt = new window.$CCBIM.WebGL.Vector3();
      centerPt.x = (endPt.x + startPt.x) / 2;
      centerPt.y = (endPt.y + startPt.y) / 2;
      centerPt.z = (endPt.z + startPt.z) / 2;
      var len = String(Math.round(startPt.distanceTo(endPt) * 100) / 100);
      this.distanceLineGroup.remove(this.curLableText);
      var textGeo = new window.$CCBIM.WebGL.TextGeometry(len, {
        font: window.$CCBIM.render.webGlFont,
        size: 500,
        height: 1,
        curveSegments: 1
      });
      var textMaterial = new window.$CCBIM.WebGL.MeshBasicMaterial({ color: 0xffffff });
      this.curLableText = new window.$CCBIM.WebGL.Mesh(textGeo, textMaterial);
      this.curLableText.position.copy(centerPt);
      this.distanceLineGroup.add(this.curLableText);
    }
  }, {
    key: 'mousedown',
    value: function mousedown(iconMode) {}
  }, {
    key: 'mousemove',
    value: function mousemove(iconMode) {
      if (this.curDistanceEnt) {
        var cmgp = this.curDistanceEnt.geometry.getBufferAttribute('position');
        var beginPt = new window.$CCBIM.WebGL.Vector3();
        beginPt.x = cmgp.array[0];
        beginPt.y = cmgp.array[1];
        beginPt.z = cmgp.array[2];

        cmgp.array[3] = iconMode.point.x;
        cmgp.array[4] = iconMode.point.y;
        cmgp.array[5] = iconMode.point.z;

        this.curDistanceEnt.geometry.updateAttribute('position', 0, cmgp.array);

        this.addLabel(this.curLabelId, beginPt, iconMode.point);
      }
      this.distanceLineGroup.updateMatrixWorld(true);
    }
  }, {
    key: 'mouseup',
    value: function mouseup(iconMode) {
      if (this.curDistanceEnt === null) {
        var simLineVet = [iconMode.point.x, iconMode.point.y, iconMode.point.z, iconMode.point.x, iconMode.point.y, iconMode.point.z];
        var simLineGeo = new window.$CCBIM.WebGL.PMBufferGeometry();
        var positionBuffer = new window.$CCBIM.WebGL.Float32BufferAttribute(simLineVet, 3);
        simLineGeo.addBufferAttribute('position', positionBuffer);

        var indexBuffer = new Float32Array(positionBuffer.array.length / 3);
        for (var i = 0, il = indexBuffer.length; i < il; i++) {
          indexBuffer[i] = i;
        }
        var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.LINES);
        index.setIndex(indexBuffer);
        var indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
        indexRange.setRange(0, indexBuffer.length);
        index.addIndexRange(indexRange);
        simLineGeo.addVertexIndex(index);

        this.curDistanceEnt = new window.$CCBIM.WebGL.PmLineSegments(simLineGeo, this.LineBasicMat);
        this.distanceLineGroup.add(this.curDistanceEnt);
        this.curLabelId = __WEBPACK_IMPORTED_MODULE_4__THREE_math_Math__["a" /* _Math */].generateUUID();
      } else {
        var cmgp = this.curDistanceEnt.geometry.getBufferAttribute('position');
        var beginPt = new window.$CCBIM.WebGL.Vector3();
        beginPt.x = cmgp.array[0];
        beginPt.y = cmgp.array[1];
        beginPt.z = cmgp.array[2];

        cmgp.array[3] = iconMode.point.x;
        cmgp.array[4] = iconMode.point.y;
        cmgp.array[5] = iconMode.point.z;

        this.curDistanceEnt.geometry.updateAttribute('position', 0, cmgp.array);
        this.curDistanceEnt = null;
        this.curLableText = null;

        this.addLabel(this.curLabelId, beginPt, iconMode.point);
      }
      this.distanceLineGroup.updateMatrixWorld(true);
    }
  }, {
    key: 'touchstart',
    value: function touchstart(iconMode) {
      var simLineVet = [iconMode.point.x, iconMode.point.y, iconMode.point.z, iconMode.point.x, iconMode.point.y, iconMode.point.z];
      var simLineGeo = new window.$CCBIM.WebGL.PMBufferGeometry();
      var positionBuffer = new window.$CCBIM.WebGL.Float32BufferAttribute(simLineVet, 3);
      simLineGeo.addBufferAttribute('position', positionBuffer);

      var indexBuffer = new Float32Array(positionBuffer.array.length / 3);
      for (var i = 0, il = indexBuffer.length; i < il; i++) {
        indexBuffer[i] = i;
      }
      var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.LINES);
      index.setIndex(indexBuffer);
      var indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
      indexRange.setRange(0, indexBuffer.length);
      index.addIndexRange(indexRange);
      simLineGeo.addVertexIndex(index);

      this.curDistanceEnt = new window.$CCBIM.WebGL.PmLineSegments(simLineGeo, this.LineBasicMat);
      this.distanceLineGroup.add(this.curDistanceEnt);
      this.curLabelId = __WEBPACK_IMPORTED_MODULE_4__THREE_math_Math__["a" /* _Math */].generateUUID();
      this.distanceLineGroup.updateMatrixWorld(true);
    }
  }, {
    key: 'touchmove',
    value: function touchmove(iconMode) {
      if (this.curDistanceEnt) {
        var cmgp = this.curDistanceEnt.geometry.getBufferAttribute('position');
        var beginPt = new window.$CCBIM.WebGL.Vector3();
        beginPt.x = cmgp.array[0];
        beginPt.y = cmgp.array[1];
        beginPt.z = cmgp.array[2];

        cmgp.array[3] = iconMode.point.x;
        cmgp.array[4] = iconMode.point.y;
        cmgp.array[5] = iconMode.point.z;

        this.curDistanceEnt.geometry.updateAttribute('position', 0, cmgp.array);

        this.addLabel(this.curLabelId, beginPt, iconMode.point);
      }
      this.distanceLineGroup.updateMatrixWorld(true);
    }
  }, {
    key: 'touchend',
    value: function touchend() {
      this.curDistanceEnt = null;
      this.curLableText = null;
    }
  }]);

  return CADdistanceCtrl;
}();

/* harmony default export */ __webpack_exports__["a"] = (CADdistanceCtrl);

/***/ }),
/* 479 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ClippingControls;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create__);



var clipping = void 0;
var clippingNan = void 0;
var chang = void 0;
function ClippingControls() {
  var _mouseDownX = 0;
  var _mouseDownY = 0;
  var _objects = window.$CCBIM.clippingObjects;
  var _camera = window.$CCBIM.webglContext.camera;
  var _domElement = window.$CCBIM.webglContext.renderer.domElement;
  var _clipPlanes = window.$CCBIM.clippingPlane;
  var _plane = new window.$CCBIM.WebGL.Plane();
  var _raycaster = new window.$CCBIM.WebGL.Raycaster();

  var _mouse = new window.$CCBIM.WebGL.Vector2();
  var _offset = new window.$CCBIM.WebGL.Vector3();
  var _intersection = new window.$CCBIM.WebGL.Vector3();
  var help = null;
  var _oldchangePlaneX = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneY = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneZ = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneW = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneXCopy = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneYCopy = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneZCopy = new window.$CCBIM.WebGL.Vector3();
  var _oldchangePlaneWCopy = new window.$CCBIM.WebGL.Vector3();
  var _selectedName = null;
  var indexX = null;
  var indexY = null;
  var indexZ = null;
  var indexW = null;
  var dragX = false;
  var dragY = false;
  var dragZ = false;

  var _selected = null,
      _hovered = null;


  var scope = this;

  function activate() {

    _domElement.addEventListener('mousemove', onDocumentMouseMove, false);
    _domElement.addEventListener('mousedown', onDocumentMouseDown, false);
    _domElement.addEventListener('mouseup', onDocumentMouseUp, false);

    _domElement.addEventListener('touchstart', onTouchStart, false);
    _domElement.addEventListener('touchmove', onTouchMove, false);
    _domElement.addEventListener('touchend', onTouchEnd, false);
  }

  function deactivate() {

    _domElement.removeEventListener('mousemove', onDocumentMouseMove, false);
    _domElement.removeEventListener('mousedown', onDocumentMouseDown, false);
    _domElement.removeEventListener('mouseup', onDocumentMouseUp, false);

    _domElement.removeEventListener('touchstart', onTouchStart, false);
    _domElement.removeEventListener('touchmove', onTouchMove, false);
    _domElement.removeEventListener('touchend', onTouchEnd, false);
  }

  function dispose() {

    deactivate();
  }

  function onDocumentMouseMove(event) {
    event.preventDefault();
    var mouseMoveX = event.pageX;
    var mouseMoveY = event.pageY;
    if (Math.abs(mouseMoveX - _mouseDownX) > 10 || Math.abs(mouseMoveY - _mouseDownY) > 10) {
      clippingMove(event);
    }
  }

  function onDocumentMouseDown(event) {

    event.preventDefault();
    if (event.button !== 0) {
      return false;
    }

    _mouseDownX = event.pageX;
    _mouseDownY = event.pageY;

    help = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');

    _raycaster.setFromCamera(_mouse, _camera);
    var intersects = _raycaster.intersectObjects(_objects);

    if (intersects.length > 0) {

      _selected = intersects[0].object;
      var _geometry = _selected.geometry;

      clippingStart(intersects, _geometry);
    }
  }

  function onDocumentMouseUp(event) {
    event.preventDefault();

    clippingEnd();
  }

  function onTouchStart(event) {

    event.preventDefault();
    event = event.changedTouches[0];

    var rect = _domElement.getBoundingClientRect();
    _mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
    _mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    help = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');

    _raycaster.setFromCamera(_mouse, _camera);
    var intersects = _raycaster.intersectObjects(_objects);

    if (intersects.length > 0) {

      _selected = intersects[0].object;
      var _geometry = _selected.geometry;

      var object = intersects[0].object;
      var center = object.geometry.boundingSphere.center;

      _plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), center);

      clippingStart(intersects, _geometry);
    }
  }

  function onTouchMove(event) {

    event.preventDefault();
    event = event.changedTouches[0];
    clippingMove(event);
  }

  function onTouchEnd(event) {
    event.preventDefault();

    clippingEnd();
  }

  function clippingMove(event) {
    var rect = _domElement.getBoundingClientRect();
    var point = void 0;
    _mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
    _mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    _raycaster.setFromCamera(_mouse, _camera);
    help = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');
    window.$CCBIM.sceneManager.setNeedUpdate(true);
    if (_selected && scope.enabled) {
      if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

        point = _intersection.sub(_offset);
        if (!dragX) {
          point.x = 0;
        }
        if (!dragY) {
          point.y = 0;
        }
        if (!dragZ) {
          point.z = 0;
        }
        if (point.x !== 0) {
          chang = point.x;
        }
        if (point.y !== 0) {
          chang = point.y;
        }
        if (point.z !== 0) {
          chang = point.z;
        }
        var planeX = _oldchangePlaneXCopy.copy(_oldchangePlaneX).add(point);
        var planeY = _oldchangePlaneYCopy.copy(_oldchangePlaneY).add(point);
        var planeZ = _oldchangePlaneZCopy.copy(_oldchangePlaneZ).add(point);
        var planeW = _oldchangePlaneWCopy.copy(_oldchangePlaneW).add(point);
        if (_selectedName === 'x1') {}
        if (_selectedName === 'x2') {
          chang = -point.x;
        }
        if (_selectedName === 'y1') {}
        if (_selectedName === 'y2') {
          chang = -point.y;
        }

        if (_selectedName === 'z1') {}
        if (_selectedName === 'z2') {
          chang = -point.z;
        }
        _selected.geometry.vertices[indexX] = planeX;
        _selected.geometry.vertices[indexY] = planeY;
        _selected.geometry.vertices[indexZ] = planeZ;
        _selected.geometry.vertices[indexW] = planeW;
        _selected.geometry.verticesNeedUpdate = true;
        _selected.geometry.elementsNeedUpdate = true;
        help.update();
        clipping.constant = clippingNan + chang;
      }
      scope.dispatchEvent({ type: 'drag', object: _selected });
      return;
    }

    var intersects = _raycaster.intersectObjects(_objects);
    if (intersects.length > 0) {

      var object = intersects[0].object;

      var center = object.geometry.boundingSphere.center;

      _plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), center);

      if (_hovered !== object) {

        scope.dispatchEvent({ type: 'hoveron', object: object });

        _domElement.style.cursor = 'pointer';
        _hovered = object;
      }
    } else {
      if (_hovered !== null) {

        scope.dispatchEvent({ type: 'hoveroff', object: _hovered });

        _domElement.style.cursor = 'auto';
        _hovered = null;
      }
    }
  }

  function clippingStart(intersects, _geometry) {
    if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

      switch (intersects[0].face.materialIndex) {
        case 0:
          dragX = true;
          dragY = false;
          dragZ = false;
          indexX = 3;
          indexY = 2;
          indexZ = 1;
          indexW = 0;
          _selectedName = 'x1';
          clipping = _clipPlanes[3];
          clippingNan = clipping.constant;
          break;
        case 1:
          dragX = true;
          dragY = false;
          dragZ = false;
          indexX = 7;
          indexY = 6;
          indexZ = 5;
          indexW = 4;
          _selectedName = 'x2';
          clipping = _clipPlanes[2];
          clippingNan = clipping.constant;
          break;
        case 2:
          dragX = false;
          dragY = true;
          dragZ = false;
          indexX = 0;
          indexY = 1;
          indexZ = 4;
          indexW = 5;
          _selectedName = 'y1';
          clipping = _clipPlanes[0];
          clippingNan = clipping.constant;
          break;
        case 3:
          dragX = false;
          dragY = true;
          dragZ = false;
          indexX = 2;
          indexY = 3;
          indexZ = 6;
          indexW = 7;
          _selectedName = 'y2';
          clipping = _clipPlanes[1];
          clippingNan = clipping.constant;
          break;
        case 4:
          dragX = false;
          dragY = false;
          dragZ = true;
          indexX = 7;
          indexY = 5;
          indexZ = 2;
          indexW = 0;
          _selectedName = 'z1';
          clipping = _clipPlanes[4];
          clippingNan = clipping.constant;
          break;
        case 5:
          dragX = false;
          dragY = false;
          dragZ = true;
          indexX = 6;
          indexY = 4;
          indexZ = 3;
          indexW = 1;
          _selectedName = 'z2';
          clipping = _clipPlanes[5];
          clippingNan = clipping.constant;
          break;
      }
      _oldchangePlaneXCopy = new window.$CCBIM.WebGL.Vector3();
      _oldchangePlaneYCopy = new window.$CCBIM.WebGL.Vector3();
      _oldchangePlaneZCopy = new window.$CCBIM.WebGL.Vector3();
      _oldchangePlaneWCopy = new window.$CCBIM.WebGL.Vector3();
      _oldchangePlaneX.copy(_geometry.vertices[indexX]);
      _oldchangePlaneY.copy(_geometry.vertices[indexY]);
      _oldchangePlaneZ.copy(_geometry.vertices[indexZ]);
      _oldchangePlaneW.copy(_geometry.vertices[indexW]);
      _offset.copy(_intersection);
    }

    _domElement.style.cursor = 'move';

    scope.dispatchEvent({ type: 'dragstart', object: _selected });
  }

  function clippingEnd() {

    if (_selected) {

      _selected.geometry.verticesNeedUpdate = false;
      _selected.geometry.elementsNeedUpdate = false;
      scope.dispatchEvent({ type: 'dragend', object: _selected });

      _selected = null;
    }

    _domElement.style.cursor = 'auto';
  }

  activate();

  this.enabled = true;

  this.activate = activate;
  this.deactivate = deactivate;
  this.dispose = dispose;

  this.setObjects = function () {

    console.error('window.$CCBIM.WebGL.ClippingControls: setObjects() has been removed.');
  };

  this.on = function (type, listener) {

    console.warn('window.$CCBIM.WebGL.ClippingControls: on() has been deprecated. Use addEventListener() instead.');
    scope.addEventListener(type, listener);
  };

  this.off = function (type, listener) {

    console.warn('window.$CCBIM.WebGL.ClippingControls: off() has been deprecated. Use removeEventListener() instead.');
    scope.removeEventListener(type, listener);
  };

  this.notify = function (type) {

    console.error('window.$CCBIM.WebGL.ClippingControls: notify() has been deprecated. Use dispatchEvent() instead.');
    scope.dispatchEvent({ type: type });
  };
}
ClippingControls.prototype = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default()(EventDispatcher.prototype);
ClippingControls.prototype.constructor = ClippingControls;

function EventDispatcher() {}

__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(EventDispatcher.prototype, {

  addEventListener: function addEventListener(type, listener) {

    if (this._listeners === undefined) this._listeners = {};

    var listeners = this._listeners;

    if (listeners[type] === undefined) {

      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {

      listeners[type].push(listener);
    }
  },

  hasEventListener: function hasEventListener(type, listener) {

    if (this._listeners === undefined) return false;

    var listeners = this._listeners;

    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },

  removeEventListener: function removeEventListener(type, listener) {

    if (this._listeners === undefined) return;

    var listeners = this._listeners;
    var listenerArray = listeners[type];

    if (listenerArray !== undefined) {

      var index = listenerArray.indexOf(listener);

      if (index !== -1) {

        listenerArray.splice(index, 1);
      }
    }
  },

  dispatchEvent: function dispatchEvent(event) {

    if (this._listeners === undefined) return;

    var listeners = this._listeners;
    var listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {

      event.target = this;

      var array = listenerArray.slice(0);

      for (var i = 0, l = array.length; i < l; i++) {

        array[i].call(this, event);
      }
    }
  }

});

/***/ }),
/* 480 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__controls_PointerLockControls_js__ = __webpack_require__(481);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__THREE_constants__ = __webpack_require__(3);






var PMFirstPersonControls = function () {
  function PMFirstPersonControls(camera, element, cameraPos, viewTarget) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, PMFirstPersonControls);

    this.IsInRotControl = function () {
      return this.MouseControl.isInRot;
    };

    this.Camera = camera;
    this.type = 'first';
    this.element = element !== undefined ? element : document;
    this.target = null;
    this.enabled = true;
    this.moveSpeed = 1;

    this.velocity = new window.$CCBIM.WebGL.Vector3();
    this.oldVelocity = null;
    this.curVelocity = null;
    this.direction = new window.$CCBIM.WebGL.Vector3();
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.moveTop = false;
    this.moveBottom = false;
    this.canJump = false;

    var newCameraPos = new window.$CCBIM.WebGL.Vector3(cameraPos[0], cameraPos[1], cameraPos[2]);
    var footPos = this.getIntersectsFirstEnt(newCameraPos);
    if (!footPos) {
      footPos = new window.$CCBIM.WebGL.Vector3(cameraPos[0], cameraPos[1], viewTarget[2]);
    }

    this.MouseControl = new __WEBPACK_IMPORTED_MODULE_2__controls_PointerLockControls_js__["a" /* default */](this.Camera, [footPos.x, footPos.y, footPos.z], viewTarget, element);

    this.MouseControl.enabled = true;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(PMFirstPersonControls, [{
    key: 'setControlPosition',
    value: function setControlPosition(height, cameraX, cameraY) {
      this.MouseControl.setPosition(height, cameraX, cameraY);
    }
  }, {
    key: 'bindEvent',
    value: function bindEvent() {
      var _this = this;

      document.addEventListener('keydown', function (e) {
        return _this.onKeyDown(e);
      }, false);
      document.addEventListener('keyup', function (e) {
        return _this.onKeyUp(e);
      }, false);
      this.element.addEventListener('wheel', function (e) {
        return _this.onMouseWheel(e);
      }, false);
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      var _this2 = this;

      document.removeEventListener('keydown', function (e) {
        return _this2.onKeyDown(e);
      }, false);
      document.removeEventListener('keyup', function (e) {
        return _this2.onKeyUp(e);
      }, false);
      this.element.removeEventListener('wheel', function (e) {
        return _this2.onMouseWheel(e);
      }, false);

      this.MouseControl.dispose();

      window.$CCBIM.render.onAfterUpdate();
    }
  }, {
    key: 'onMouseWheel',
    value: function onMouseWheel(event) {
      if (event.deltaY > 0) {
        this.moveSpeed -= 5 * (event.deltaY / 100);
        if (this.moveSpeed < 1) {
          this.moveSpeed = 1;
        }
      } else if (event.deltaY < 0) {
        this.moveSpeed += 5 * -(event.deltaY / 100);
      }
    }
  }, {
    key: 'onKeyDown',
    value: function onKeyDown(event) {
      window.$CCBIM.render.onBeforeUpdate();

      if (event.shiftKey) {
        if (event.keyCode === 187) {
          this.moveSpeed += 5;
          if (this.moveSpeed > 100) {
            this.moveSpeed = 100;
          }
        } else if (event.keyCode === 107) {
          this.moveSpeed += 5;
          if (this.moveSpeed > 100) {
            this.moveSpeed = 100;
          }
        } else if (event.keyCode === 189) {
          this.moveSpeed -= 5;
          if (this.moveSpeed < 1) {
            this.moveSpeed = 1;
          }
        } else if (event.keyCode === 109) {
          this.moveSpeed -= 5;
          if (this.moveSpeed < 1) {
            this.moveSpeed = 1;
          }
        }
      }

      switch (event.keyCode) {
        case 38:
        case 87:
          this.moveForward = true;
          break;
        case 37:
        case 65:
          this.moveLeft = true;
          break;
        case 40:
        case 83:
          this.moveBackward = true;
          break;
        case 39:
        case 68:
          this.moveRight = true;
          break;
        case 81:
          this.moveTop = true;
          break;
        case 69:
          this.moveBottom = true;
          break;
      }
    }
  }, {
    key: 'onKeyUp',
    value: function onKeyUp(event) {
      switch (event.keyCode) {
        case 38:
        case 87:
          this.moveForward = false;
          break;
        case 37:
        case 65:
          this.moveLeft = false;
          break;
        case 40:
        case 83:
          this.moveBackward = false;
          break;
        case 39:
        case 68:
          this.moveRight = false;
          break;
        case 81:
          this.moveTop = false;
          break;
        case 69:
          this.moveBottom = false;
          break;
        case 120:
          window.$CCBIM.render.showRoamBox.show = true;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      var delta = 0.016;
      if (!this.enabled) return;

      this.velocity.x -= this.velocity.x * 10.0 * delta;
      this.velocity.z -= this.velocity.z * 10.0 * delta;
      this.velocity.y -= this.velocity.y * 10.0 * delta;

      this.direction.y = Number(this.moveForward) - Number(this.moveBackward);
      this.direction.x = Number(this.moveLeft) - Number(this.moveRight);
      this.direction.z = Number(this.moveTop) - Number(this.moveBottom);

      this.direction.normalize();

      if (this.moveForward || this.moveBackward) this.velocity.y += this.direction.y * 2.0 * this.moveSpeed * delta;
      if (this.moveLeft || this.moveRight) this.velocity.x -= this.direction.x * 2.0 * this.moveSpeed * delta;
      if (this.moveTop || this.moveBottom) {
        this.velocity.z += this.direction.z * 2.0 * this.moveSpeed * delta;
      }

      if (window.$CCBIM.render.isGravity) {
        var oldfootPos = this.MouseControl.getObject().position.clone();
        oldfootPos.z -= 1.5;
        var moveCamraPos = this.MouseControl.getObject().position.clone();
        moveCamraPos.z -= 0.5;
        var footPos = this.getIntersectsFirstEnt(moveCamraPos);
        if (footPos) {
          if (Math.abs(footPos.z - oldfootPos.z) > 0.02) {
            if (footPos.z > oldfootPos.z) {
              this.velocity.z += 1.5 * this.moveSpeed * delta;
            } else if (footPos.z < oldfootPos.z) {
              if (oldfootPos.z - footPos.z > 2.0) this.velocity.z -= 6.0 * this.moveSpeed * delta;else this.velocity.z -= 1.5 * this.moveSpeed * delta;
            }
          } else {
            this.velocity.z = 0;
            this.MouseControl.getObject().position.z = footPos.z + 1.5;
          }
        }
      }

      if (!this.oldVelocity) {
        this.oldVelocity = this.velocity.clone();
        this.curVelocity = this.velocity.clone();
      } else {
        this.curVelocity.x += this.velocity.x;
        this.curVelocity.y += this.velocity.y;
        this.curVelocity.z += this.velocity.z;
        var length = this.oldVelocity.distanceTo(this.curVelocity);
        if (length > 10) {
          window.$CCBIM.render.onAfterUpdate(false);
          this.oldVelocity.copy(this.curVelocity);
          this.MouseControl.getObject().translateX(this.velocity.x * delta);
          this.MouseControl.getObject().translateY(this.velocity.y * delta);
          this.MouseControl.getObject().translateZ(this.velocity.z * delta);
        }
      }
    }
  }, {
    key: 'getCameraData',
    value: function getCameraData() {
      var lookAt = this.MouseControl.getObject().position.clone();
      var lookAtVer = new window.$CCBIM.WebGL.Vector3(0, 0, 0);
      var rotAngle = this.MouseControl.getObject().rotation.z;
      lookAtVer.y = Math.cos(rotAngle);
      lookAtVer.x = -Math.sin(rotAngle);
      lookAt = this.MouseControl.getObject().position.clone();
      lookAt.add(lookAtVer);
      return {
        cameraPosition: this.MouseControl.getObject().position,
        target: lookAt,
        cameraUp: new window.$CCBIM.WebGL.Vector3(0, 0, 1)
      };
    }
  }, {
    key: 'getIntersectsFirstEnt',
    value: function getIntersectsFirstEnt(cameraPos) {
      var raycaster = new window.$CCBIM.WebGL.Raycaster(cameraPos, new window.$CCBIM.WebGL.Vector3(0, 0, -1), 0, 1000);
      var temRenderList = window.$CCBIM.webglContext.getRenderList();
      var interEntArr = raycaster.intersectRenderObjects(temRenderList, true, true);
      if (interEntArr.length === 0) {
        return null;
      }
      return interEntArr[0].point;
    }
  }, {
    key: 'handleResize',
    value: function handleResize() {}
  }]);

  return PMFirstPersonControls;
}();

/* harmony default export */ __webpack_exports__["a"] = (PMFirstPersonControls);

/***/ }),
/* 481 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var PointerLockControls = function PointerLockControls(camera, cameraPos, viewTarget, domElement) {
  var _this = this;

  this.domElement = domElement !== undefined ? domElement : document;
  var mouseDownSiteX = 0;
  var mouseDownSiteY = 0;
  var scope = this;

  camera.rotation.set(0, 0, 0);

  var pitchObject = new window.$CCBIM.WebGL.Object3D();
  pitchObject.add(camera);

  var yawObject = new window.$CCBIM.WebGL.Object3D();

  yawObject.add(pitchObject);
  yawObject.position.x = cameraPos[0];
  yawObject.position.y = cameraPos[1];
  yawObject.position.z = cameraPos[2];

  var vectors = new window.$CCBIM.WebGL.Vector3(0, 0, 0);
  var positionEnd = new window.$CCBIM.WebGL.Vector3(cameraPos[0], cameraPos[1], cameraPos[2]);
  var positionStart = new window.$CCBIM.WebGL.Vector3(viewTarget[0], viewTarget[1], viewTarget[2]);
  vectors.subVectors(positionStart, positionEnd);
  yawObject.rotation.z = new window.$CCBIM.WebGL.Vector3(0, 2, 0).angleTo(vectors);

  var PI_2 = Math.PI / 2;

  var bMoveView = false;
  var isInRot = false;

  this.setPosition = function (height, cameraX, cameraY) {
    yawObject.position.z = height;
    if (cameraX) {
      yawObject.position.x = cameraX;
    }
    if (cameraY) {
      yawObject.position.y = cameraY;
    }
  };

  var onMouseMove = function onMouseMove(event) {

    if (scope.enabled === false) return;
    if (bMoveView === false) return;

    var movementX;
    var movementY;
    if (event.movementX === 0) {
      movementX = event.pageX - mouseDownSiteX;
    } else {
      movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
    }

    if (event.movementY === 0) {
      movementY = event.pageY - mouseDownSiteY;
    } else {
      movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
    }

    yawObject.rotation.z -= movementX * 0.002;
    pitchObject.rotation.x -= movementY * 0.002;
    pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
    isInRot = true;

    mouseDownSiteX = event.pageX;
    mouseDownSiteY = event.pageY;

    window.$CCBIM.render.onBeforeUpdate();
  };

  var onTouchMove = function onTouchMove(event) {
    if (scope.enabled === false) return;
    if (bMoveView === false) return;

    var movementX;
    var movementY;
    window.$CCBIM.render.onBeforeUpdate();

    switch (event.touches.length) {
      case 1:
        movementX = event.touches[0].pageX - mouseDownSiteX;
        movementY = event.touches[0].pageY - mouseDownSiteY;
        mouseDownSiteX = event.touches[0].pageX;
        mouseDownSiteY = event.touches[0].pageY;
        break;
      default:
        movementX = event.touches[1].pageX - mouseDownSiteX;
        movementY = event.touches[1].pageY - mouseDownSiteY;
        mouseDownSiteX = event.touches[1].pageX;
        mouseDownSiteY = event.touches[1].pageY;
        break;
    }
    yawObject.rotation.z -= movementX * 0.008;
    pitchObject.rotation.x -= movementY * 0.008;
    pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
    isInRot = true;
  };

  var onMouseDown = function onMouseDown(event) {
    _this.domElement.addEventListener('mousemove', onMouseMove, true);
    _this.domElement.addEventListener('mouseup', onMouseUp, true);
    if (scope.enabled === false) return;
    bMoveView = true;
    isInRot = false;

    window.$CCBIM.render.onBeforeUpdate();
    mouseDownSiteX = event.pageX;
    mouseDownSiteY = event.pageY;
  };

  var onTouchStart = function onTouchStart(event) {
    _this.domElement.addEventListener('touchmove', onTouchMove, true);
    _this.domElement.addEventListener('touchend', onTouchEnd, true);
    if (scope.enabled === false) return;
    bMoveView = true;
    isInRot = false;

    window.$CCBIM.render.onBeforeUpdate();

    switch (event.touches.length) {
      case 1:
        mouseDownSiteX = event.touches[0].pageX;
        mouseDownSiteY = event.touches[0].pageY;
        break;
      default:
        mouseDownSiteX = event.touches[1].pageX;
        mouseDownSiteY = event.touches[1].pageY;
        break;
    }
  };

  var onMouseUp = function onMouseUp(event) {
    _this.domElement.removeEventListener('mousemove', onMouseMove, false);
    _this.domElement.removeEventListener('mouseup', onMouseUp, false);
    window.$CCBIM.render.onAfterUpdate(false);
    if (scope.enabled === false) return;
    bMoveView = false;
  };

  var onTouchEnd = function onTouchEnd(event) {
    _this.domElement.removeEventListener('touchmove', onTouchMove, false);
    _this.domElement.removeEventListener('touchend', onTouchEnd, false);
    window.$CCBIM.render.onAfterUpdate(false);
    if (scope.enabled === false) return;
    bMoveView = false;
  };

  this.dispose = function () {
    this.domElement.removeEventListener('mousedown', onMouseDown, true);
    this.domElement.removeEventListener('mousemove', onMouseMove, false);
    this.domElement.removeEventListener('mouseup', onMouseUp, false);

    this.domElement.removeEventListener('touchstart', onTouchStart, true);
    this.domElement.removeEventListener('touchmove', onTouchMove, false);
    this.domElement.removeEventListener('touchend', onTouchEnd, false);
  };

  this.domElement.addEventListener('mousedown', onMouseDown, true);
  this.domElement.addEventListener('touchstart', onTouchStart, true);

  this.enabled = false;

  this.getObject = function () {

    return yawObject;
  };

  this.getDirection = function () {

    var direction = new window.$CCBIM.WebGL.Vector3(0, 0, -1);
    var rotation = new window.$CCBIM.WebGL.Euler(0, 0, 0, "YXZ");

    return function (v) {

      v = direction.clone();
      rotation.set(pitchObject.rotation.x, yawObject.rotation.z, 0);

      v.copy(direction).applyEuler(rotation);

      return v;
    };
  }();
};

/* harmony default export */ __webpack_exports__["a"] = (PointerLockControls);

/***/ }),
/* 482 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nipplejs__ = __webpack_require__(609);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nipplejs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_nipplejs__);


function Joystick(options) {
  this.type = 'joystick';
  this.options = options;
  this.manager = null;
}

Joystick.prototype = {
  constructor: Joystick,

  init: function init() {
    this.manager = __WEBPACK_IMPORTED_MODULE_0_nipplejs___default.a.create(this.options);
    this._on();
  },

  _on: function _on() {
    var _this = this;

    this.manager.on('move', function (evt, data) {
      if (data.direction) {
        _this._onMove(data.direction.angle);
      }
    }).on('end', function (evt, data) {
      _this._onEnd();
    });
  },

  _onMove: function _onMove(angle) {
    window.$CCBIM.render.onBeforeUpdate();
    switch (angle) {
      case 'up':
        window.$CCBIM.controller.moveForward = true;
        window.$CCBIM.controller.moveRight = false;
        window.$CCBIM.controller.moveLeft = false;
        window.$CCBIM.controller.moveBackward = false;
        break;
      case 'right':
        window.$CCBIM.controller.moveForward = false;
        window.$CCBIM.controller.moveRight = true;
        window.$CCBIM.controller.moveLeft = false;
        window.$CCBIM.controller.moveBackward = false;
        break;
      case 'left':
        window.$CCBIM.controller.moveForward = false;
        window.$CCBIM.controller.moveRight = false;
        window.$CCBIM.controller.moveLeft = true;
        window.$CCBIM.controller.moveBackward = false;
        break;
      case 'down':
        window.$CCBIM.controller.moveForward = false;
        window.$CCBIM.controller.moveRight = false;
        window.$CCBIM.controller.moveLeft = false;
        window.$CCBIM.controller.moveBackward = true;
        break;
    }
  },

  _onEnd: function _onEnd() {
    window.$CCBIM.controller.moveForward = false;
    window.$CCBIM.controller.moveRight = false;
    window.$CCBIM.controller.moveLeft = false;
    window.$CCBIM.controller.moveBackward = false;
  },

  destroy: function destroy() {
    this.manager.destroy();
  }
};

/* harmony default export */ __webpack_exports__["a"] = (Joystick);

/***/ }),
/* 483 */
/***/ (function(module, exports) {


var PMBIMData = PMBIMData || {};

PMBIMData.EntInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMData.EntInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMData.EntInfo.getRootAsEntInfo = function (bb, obj) {
  return (obj || new PMBIMData.EntInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMData.EntInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.EntInfo.prototype.flootID = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.EntInfo.prototype.comtype = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.EntInfo.prototype.comID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.EntInfo.prototype.handle = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMData.EntInfo.prototype.selectAbility = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBIMData.EntInfo.prototype.stageArray = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMData.EntInfo.prototype.stageArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.EntInfo.prototype.stageArrayArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMData.EntInfo.startEntInfo = function (builder) {
  builder.startObject(7);
};

PMBIMData.EntInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMData.EntInfo.addFlootID = function (builder, flootID) {
  builder.addFieldInt32(1, flootID, 0);
};

PMBIMData.EntInfo.addComtype = function (builder, comtype) {
  builder.addFieldInt32(2, comtype, 0);
};

PMBIMData.EntInfo.addComID = function (builder, comID) {
  builder.addFieldInt32(3, comID, 0);
};

PMBIMData.EntInfo.addHandle = function (builder, handleOffset) {
  builder.addFieldOffset(4, handleOffset, 0);
};

PMBIMData.EntInfo.addSelectAbility = function (builder, selectAbility) {
  builder.addFieldInt8(5, +selectAbility, +false);
};

PMBIMData.EntInfo.addStageArray = function (builder, stageArrayOffset) {
  builder.addFieldOffset(6, stageArrayOffset, 0);
};

PMBIMData.EntInfo.createStageArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMData.EntInfo.startStageArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.EntInfo.endEntInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMData.EntInfoDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMData.EntInfoDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMData.EntInfoDataFile.getRootAsEntInfoDataFile = function (bb, obj) {
  return (obj || new PMBIMData.EntInfoDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMData.EntInfoDataFile.prototype.entInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMBIMData.EntInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMData.EntInfoDataFile.prototype.entInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.EntInfoDataFile.startEntInfoDataFile = function (builder) {
  builder.startObject(1);
};

PMBIMData.EntInfoDataFile.addEntInfoArray = function (builder, entInfoArrayOffset) {
  builder.addFieldOffset(0, entInfoArrayOffset, 0);
};

PMBIMData.EntInfoDataFile.createEntInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMData.EntInfoDataFile.startEntInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.EntInfoDataFile.endEntInfoDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMData.MeshData = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMData.MeshData.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMData.MeshData.getRootAsMeshData = function (bb, obj) {
  return (obj || new PMBIMData.MeshData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMData.MeshData.prototype.entID = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMData.MeshData.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMData.MeshData.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMData.MeshData.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMData.MeshData.prototype.geoID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.vertexOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.vertexCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.vertexParamsOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.vertexParamsCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.trianglesOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.prototype.trianglesCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.MeshData.startMeshData = function (builder) {
  builder.startObject(10);
};

PMBIMData.MeshData.addEntID = function (builder, entID) {
  builder.addFieldInt32(0, entID, 0);
};

PMBIMData.MeshData.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(1, bndBoxMinOffset, 0);
};

PMBIMData.MeshData.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMData.MeshData.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.MeshData.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(2, bndBoxMaxOffset, 0);
};

PMBIMData.MeshData.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMData.MeshData.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.MeshData.addGeoID = function (builder, geoID) {
  builder.addFieldInt32(3, geoID, 0);
};

PMBIMData.MeshData.addVertexOffset = function (builder, vertexOffset) {
  builder.addFieldInt32(4, vertexOffset, 0);
};

PMBIMData.MeshData.addVertexCount = function (builder, vertexCount) {
  builder.addFieldInt32(5, vertexCount, 0);
};

PMBIMData.MeshData.addVertexParamsOffset = function (builder, vertexParamsOffset) {
  builder.addFieldInt32(6, vertexParamsOffset, 0);
};

PMBIMData.MeshData.addVertexParamsCount = function (builder, vertexParamsCount) {
  builder.addFieldInt32(7, vertexParamsCount, 0);
};

PMBIMData.MeshData.addTrianglesOffset = function (builder, trianglesOffset) {
  builder.addFieldInt32(8, trianglesOffset, 0);
};

PMBIMData.MeshData.addTrianglesCount = function (builder, trianglesCount) {
  builder.addFieldInt32(9, trianglesCount, 0);
};

PMBIMData.MeshData.endMeshData = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMData.InstanceMeshData = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMData.InstanceMeshData.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMData.InstanceMeshData.getRootAsInstanceMeshData = function (bb, obj) {
  return (obj || new PMBIMData.InstanceMeshData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMData.InstanceMeshData.prototype.entID = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.InstanceMeshData.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMData.InstanceMeshData.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.InstanceMeshData.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMData.InstanceMeshData.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMData.InstanceMeshData.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.InstanceMeshData.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMData.InstanceMeshData.prototype.geoID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMData.InstanceMeshData.prototype.matrixIndex = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
};

PMBIMData.InstanceMeshData.prototype.instancedRefDefinitionID = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
};

PMBIMData.InstanceMeshData.startInstanceMeshData = function (builder) {
  builder.startObject(6);
};

PMBIMData.InstanceMeshData.addEntID = function (builder, entID) {
  builder.addFieldInt32(0, entID, 0);
};

PMBIMData.InstanceMeshData.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(1, bndBoxMinOffset, 0);
};

PMBIMData.InstanceMeshData.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMData.InstanceMeshData.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.InstanceMeshData.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(2, bndBoxMaxOffset, 0);
};

PMBIMData.InstanceMeshData.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMData.InstanceMeshData.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.InstanceMeshData.addGeoID = function (builder, geoID) {
  builder.addFieldInt32(3, geoID, 0);
};

PMBIMData.InstanceMeshData.addMatrixIndex = function (builder, matrixIndex) {
  builder.addFieldInt32(4, matrixIndex, 0);
};

PMBIMData.InstanceMeshData.addInstancedRefDefinitionID = function (builder, instancedRefDefinitionID) {
  builder.addFieldInt32(5, instancedRefDefinitionID, 0);
};

PMBIMData.InstanceMeshData.endInstanceMeshData = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMData.EntDataDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMData.EntDataDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMData.EntDataDataFile.getRootAsEntDataDataFile = function (bb, obj) {
  return (obj || new PMBIMData.EntDataDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMData.EntDataDataFile.prototype.meshDataArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMBIMData.MeshData()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMData.EntDataDataFile.prototype.meshDataArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.EntDataDataFile.prototype.instanceMeshDataArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMData.InstanceMeshData()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMData.EntDataDataFile.prototype.instanceMeshDataArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMData.EntDataDataFile.startEntDataDataFile = function (builder) {
  builder.startObject(2);
};

PMBIMData.EntDataDataFile.addMeshDataArray = function (builder, meshDataArrayOffset) {
  builder.addFieldOffset(0, meshDataArrayOffset, 0);
};

PMBIMData.EntDataDataFile.createMeshDataArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMData.EntDataDataFile.startMeshDataArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.EntDataDataFile.addInstanceMeshDataArray = function (builder, instanceMeshDataArrayOffset) {
  builder.addFieldOffset(1, instanceMeshDataArrayOffset, 0);
};

PMBIMData.EntDataDataFile.createInstanceMeshDataArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMData.EntDataDataFile.startInstanceMeshDataArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMData.EntDataDataFile.endEntDataDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

this.PMBIMData = PMBIMData;

/***/ }),
/* 484 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BIMData_js__ = __webpack_require__(483);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BIMData_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BIMData_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_classlib_EntInfo__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_classlib_EntData__ = __webpack_require__(102);







function BIMDataInterface() {
  this.type = 'BIMDataInterface';
}
BIMDataInterface.prototype = {
  constructor: BIMDataInterface,

  createEntInfoArray: function createEntInfoArray(bytes, entInfoArray) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var entInfoDataFile = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BIMData_js__["PMBIMData"].EntInfoDataFile.getRootAsEntInfoDataFile(buffer);
    for (var i = 0, len = entInfoDataFile.entInfoArrayLength(); i < len; i++) {
      var obj = entInfoDataFile.entInfoArray(i);
      var entInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_EntInfo__["a" /* EntInfo */]();
      entInfo.setEntInfo(obj.id(), obj.flootID(), obj.comtype(), obj.comID(), obj.handle());
      entInfo.setSelectAbility(obj.selectAbility());
      for (var j = 0, jl = obj.stageArrayLength(); j < jl; j++) {
        entInfo.addStage(obj.stageArray(j));
      }
      entInfoArray.push(entInfo);
    }
  },
  createEntDataArray: function createEntDataArray(bytes, refDefinitionMap, entDataArray) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var entDataDataFile = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BIMData_js__["PMBIMData"].EntDataDataFile.getRootAsEntDataDataFile(buffer);
    for (var i = 0, len = entDataDataFile.meshDataArrayLength(); i < len; i++) {
      var obj = entDataDataFile.meshDataArray(i);
      var meshData = new __WEBPACK_IMPORTED_MODULE_3__model_classlib_EntData__["b" /* MeshData */]();
      meshData.setEntID(obj.entID());
      var bndBoxMin = new window.$CCBIM.WebGL.Vector3(obj.bndBoxMin(0), obj.bndBoxMin(1), obj.bndBoxMin(2));
      var bndBoxMax = new window.$CCBIM.WebGL.Vector3(obj.bndBoxMax(0), obj.bndBoxMax(1), obj.bndBoxMax(2));
      meshData.setBndBox(bndBoxMin, bndBoxMax);
      meshData.setGeoID(obj.geoID());
      meshData.setPosition(obj.vertexOffset(), obj.vertexCount());
      meshData.setTriangle(obj.trianglesOffset(), obj.trianglesCount());
      entDataArray.push(meshData);
    }

    for (var _i = 0, _len = entDataDataFile.instanceMeshDataArrayLength(); _i < _len; _i++) {
      var _obj = entDataDataFile.instanceMeshDataArray(_i);

      var refDefinition = refDefinitionMap.get(_obj.instancedRefDefinitionID());
      if (!refDefinition) {
        continue;
      }
      var refObjectArray = refDefinition.getRefObjectArray();
      for (var j = 0, jl = refObjectArray.length; j < jl; j++) {
        var instanceMeshData = new __WEBPACK_IMPORTED_MODULE_3__model_classlib_EntData__["c" /* InstanceMeshData */]();
        instanceMeshData.setEntID(_obj.entID());
        var _bndBoxMin = new window.$CCBIM.WebGL.Vector3(_obj.bndBoxMin(0), _obj.bndBoxMin(1), _obj.bndBoxMin(2));
        var _bndBoxMax = new window.$CCBIM.WebGL.Vector3(_obj.bndBoxMax(0), _obj.bndBoxMax(1), _obj.bndBoxMax(2));
        instanceMeshData.setBndBox(_bndBoxMin, _bndBoxMax);
        instanceMeshData.setGeoID(refObjectArray[j].geometry.getUUID().toString() + _obj.geoID().toString());
        instanceMeshData.setMatrixIndex(_obj.matrixIndex());
        entDataArray.push(instanceMeshData);
      }
    }
  }
};

/* harmony default export */ __webpack_exports__["a"] = (BIMDataInterface);

/***/ }),
/* 485 */
/***/ (function(module, exports) {


var PMBufferData = PMBufferData || {};

PMBufferData.BufferType = {
  UNKNOWN: 0, 0: 'UNKNOWN',
  INT8: 1, 1: 'INT8',
  UINT8: 2, 2: 'UINT8',
  INT16: 3, 3: 'INT16',
  UINT16: 4, 4: 'UINT16',
  INT32: 5, 5: 'INT32',
  UINT32: 6, 6: 'UINT32',
  FLOAT32: 7, 7: 'FLOAT32'
};

PMBufferData.VertexAttribute = {
  UNKNOWN: 0, 0: 'UNKNOWN',
  INDEX: 1, 1: 'INDEX',
  POSITION: 2, 2: 'POSITION',
  NORMAL: 3, 3: 'NORMAL',
  COLOR: 4, 4: 'COLOR',
  TEXTUREPARAM: 5, 5: 'TEXTUREPARAM',
  INSTANCEMATR1: 6, 6: 'INSTANCEMATR1',
  INSTANCEMATR2: 7, 7: 'INSTANCEMATR2',
  INSTANCEMATR3: 8, 8: 'INSTANCEMATR3',
  INSTANCEMATR4: 9, 9: 'INSTANCEMATR4'
};

PMBufferData.GeometryType = {
  UNKNOWN: 0, 0: 'UNKNOWN',
  POINT: 1, 1: 'POINT',
  LINES: 2, 2: 'LINES',
  LINE_STRIP: 3, 3: 'LINE_STRIP',
  LINE_LOOP: 4, 4: 'LINE_LOOP',
  TRIANGLES: 5, 5: 'TRIANGLES',
  TRIANGLE_STRIP: 6, 6: 'TRIANGLE_STRIP',
  TRIANGLE_FAN: 7, 7: 'TRIANGLE_FAN',
  INSTANCE_MESH: 8, 8: 'INSTANCE_MESH'
};

PMBufferData.BufferData = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.BufferData.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.BufferData.getRootAsBufferData = function (bb, obj) {
  return (obj || new PMBufferData.BufferData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.BufferData.prototype.type = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt8(this.bb_pos + offset) : PMBufferData.BufferType.UNKNOWN;
};

PMBufferData.BufferData.prototype.data = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
};

PMBufferData.BufferData.prototype.dataLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.BufferData.prototype.dataArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBufferData.BufferData.startBufferData = function (builder) {
  builder.startObject(2);
};

PMBufferData.BufferData.addType = function (builder, type) {
  builder.addFieldInt8(0, type, PMBufferData.BufferType.UNKNOWN);
};

PMBufferData.BufferData.addData = function (builder, dataOffset) {
  builder.addFieldOffset(1, dataOffset, 0);
};

PMBufferData.BufferData.createDataVector = function (builder, data) {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

PMBufferData.BufferData.startDataVector = function (builder, numElems) {
  builder.startVector(1, numElems, 1);
};

PMBufferData.BufferData.endBufferData = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.BufferAttribute = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.BufferAttribute.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.BufferAttribute.getRootAsBufferAttribute = function (bb, obj) {
  return (obj || new PMBufferData.BufferAttribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.BufferAttribute.prototype.type = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt8(this.bb_pos + offset) : PMBufferData.VertexAttribute.UNKNOWN;
};

PMBufferData.BufferAttribute.prototype.buffer = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBufferData.BufferData()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBufferData.BufferAttribute.prototype.elementPerVertex = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
};

PMBufferData.BufferAttribute.prototype.instanceAttribute = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBufferData.BufferAttribute.startBufferAttribute = function (builder) {
  builder.startObject(4);
};

PMBufferData.BufferAttribute.addType = function (builder, type) {
  builder.addFieldInt8(0, type, PMBufferData.VertexAttribute.UNKNOWN);
};

PMBufferData.BufferAttribute.addBuffer = function (builder, bufferOffset) {
  builder.addFieldOffset(1, bufferOffset, 0);
};

PMBufferData.BufferAttribute.addElementPerVertex = function (builder, elementPerVertex) {
  builder.addFieldInt8(2, elementPerVertex, 0);
};

PMBufferData.BufferAttribute.addInstanceAttribute = function (builder, instanceAttribute) {
  builder.addFieldInt8(3, +instanceAttribute, +false);
};

PMBufferData.BufferAttribute.endBufferAttribute = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.BufferGeometry = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.BufferGeometry.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.BufferGeometry.getRootAsBufferGeometry = function (bb, obj) {
  return (obj || new PMBufferData.BufferGeometry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.BufferGeometry.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.BufferGeometry.prototype.type = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt8(this.bb_pos + offset) : PMBufferData.GeometryType.UNKNOWN;
};

PMBufferData.BufferGeometry.prototype.vertexAttributeArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMBufferData.BufferAttribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.BufferGeometry.prototype.vertexAttributeArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.BufferGeometry.prototype.materialID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.BufferGeometry.prototype.backMaterialID = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.BufferGeometry.startBufferGeometry = function (builder) {
  builder.startObject(5);
};

PMBufferData.BufferGeometry.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBufferData.BufferGeometry.addType = function (builder, type) {
  builder.addFieldInt8(1, type, PMBufferData.GeometryType.UNKNOWN);
};

PMBufferData.BufferGeometry.addVertexAttributeArray = function (builder, vertexAttributeArrayOffset) {
  builder.addFieldOffset(2, vertexAttributeArrayOffset, 0);
};

PMBufferData.BufferGeometry.createVertexAttributeArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.BufferGeometry.startVertexAttributeArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.BufferGeometry.addMaterialID = function (builder, materialID) {
  builder.addFieldInt32(3, materialID, 0);
};

PMBufferData.BufferGeometry.addBackMaterialID = function (builder, backMaterialID) {
  builder.addFieldInt32(4, backMaterialID, 0);
};

PMBufferData.BufferGeometry.endBufferGeometry = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.RefDefinition = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.RefDefinition.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.RefDefinition.getRootAsRefDefinition = function (bb, obj) {
  return (obj || new PMBufferData.RefDefinition()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.RefDefinition.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.RefDefinition.prototype.bufferGeometryArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBufferData.BufferGeometry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.RefDefinition.prototype.bufferGeometryArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.RefDefinition.startRefDefinition = function (builder) {
  builder.startObject(2);
};

PMBufferData.RefDefinition.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBufferData.RefDefinition.addBufferGeometryArray = function (builder, bufferGeometryArrayOffset) {
  builder.addFieldOffset(1, bufferGeometryArrayOffset, 0);
};

PMBufferData.RefDefinition.createBufferGeometryArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.RefDefinition.startBufferGeometryArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.RefDefinition.endRefDefinition = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.RefDefinitionDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.RefDefinitionDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.RefDefinitionDataFile.getRootAsRefDefinitionDataFile = function (bb, obj) {
  return (obj || new PMBufferData.RefDefinitionDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.RefDefinitionDataFile.prototype.refDefinitionArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMBufferData.RefDefinition()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.RefDefinitionDataFile.prototype.refDefinitionArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.RefDefinitionDataFile.startRefDefinitionDataFile = function (builder) {
  builder.startObject(1);
};

PMBufferData.RefDefinitionDataFile.addRefDefinitionArray = function (builder, refDefinitionArrayOffset) {
  builder.addFieldOffset(0, refDefinitionArrayOffset, 0);
};

PMBufferData.RefDefinitionDataFile.createRefDefinitionArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.RefDefinitionDataFile.startRefDefinitionArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.RefDefinitionDataFile.endRefDefinitionDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.InstanceBufferGeometry = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.InstanceBufferGeometry.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.InstanceBufferGeometry.getRootAsInstanceBufferGeometry = function (bb, obj) {
  return (obj || new PMBufferData.InstanceBufferGeometry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.InstanceBufferGeometry.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.InstanceBufferGeometry.prototype.type = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt8(this.bb_pos + offset) : PMBufferData.GeometryType.UNKNOWN;
};

PMBufferData.InstanceBufferGeometry.prototype.vertexAttributeArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMBufferData.BufferAttribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.InstanceBufferGeometry.prototype.vertexAttributeArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.InstanceBufferGeometry.prototype.refID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.InstanceBufferGeometry.startInstanceBufferGeometry = function (builder) {
  builder.startObject(4);
};

PMBufferData.InstanceBufferGeometry.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBufferData.InstanceBufferGeometry.addType = function (builder, type) {
  builder.addFieldInt8(1, type, PMBufferData.GeometryType.UNKNOWN);
};

PMBufferData.InstanceBufferGeometry.addVertexAttributeArray = function (builder, vertexAttributeArrayOffset) {
  builder.addFieldOffset(2, vertexAttributeArrayOffset, 0);
};

PMBufferData.InstanceBufferGeometry.createVertexAttributeArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.InstanceBufferGeometry.startVertexAttributeArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.InstanceBufferGeometry.addRefID = function (builder, refID) {
  builder.addFieldInt32(3, refID, 0);
};

PMBufferData.InstanceBufferGeometry.endInstanceBufferGeometry = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.BufferGeometryDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.BufferGeometryDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.BufferGeometryDataFile.getRootAsBufferGeometryDataFile = function (bb, obj) {
  return (obj || new PMBufferData.BufferGeometryDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.BufferGeometryDataFile.prototype.bufferGeometryArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMBufferData.BufferGeometry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.BufferGeometryDataFile.prototype.bufferGeometryArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.BufferGeometryDataFile.prototype.instanceBufferGeometryArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBufferData.InstanceBufferGeometry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.BufferGeometryDataFile.prototype.instanceBufferGeometryArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.BufferGeometryDataFile.startBufferGeometryDataFile = function (builder) {
  builder.startObject(2);
};

PMBufferData.BufferGeometryDataFile.addBufferGeometryArray = function (builder, bufferGeometryArrayOffset) {
  builder.addFieldOffset(0, bufferGeometryArrayOffset, 0);
};

PMBufferData.BufferGeometryDataFile.createBufferGeometryArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.BufferGeometryDataFile.startBufferGeometryArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.BufferGeometryDataFile.addInstanceBufferGeometryArray = function (builder, instanceBufferGeometryArrayOffset) {
  builder.addFieldOffset(1, instanceBufferGeometryArrayOffset, 0);
};

PMBufferData.BufferGeometryDataFile.createInstanceBufferGeometryArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.BufferGeometryDataFile.startInstanceBufferGeometryArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.BufferGeometryDataFile.endBufferGeometryDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.Image = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.Image.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.Image.getRootAsImage = function (bb, obj) {
  return (obj || new PMBufferData.Image()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.Image.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.Image.prototype.url = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBufferData.Image.prototype.isUserImage = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBufferData.Image.startImage = function (builder) {
  builder.startObject(3);
};

PMBufferData.Image.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBufferData.Image.addUrl = function (builder, urlOffset) {
  builder.addFieldOffset(1, urlOffset, 0);
};

PMBufferData.Image.addIsUserImage = function (builder, isUserImage) {
  builder.addFieldInt8(2, +isUserImage, +false);
};

PMBufferData.Image.endImage = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.Material = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.Material.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.Material.getRootAsMaterial = function (bb, obj) {
  return (obj || new PMBufferData.Material()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.Material.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.Material.prototype.image = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBufferData.Image()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBufferData.Material.prototype.lightType = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBufferData.Material.prototype.color = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBufferData.Material.prototype.transparency = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMBufferData.Material.prototype.enableTransparent = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBufferData.Material.prototype.depthFunc = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.Material.prototype.polygonOffsetFactor = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.Material.prototype.polygonOffsetUnits = function () {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBufferData.Material.prototype.enablePolygonOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBufferData.Material.prototype.doubleSide = function () {
  var offset = this.bb.__offset(this.bb_pos, 24);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBufferData.Material.startMaterial = function (builder) {
  builder.startObject(11);
};

PMBufferData.Material.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBufferData.Material.addImage = function (builder, imageOffset) {
  builder.addFieldOffset(1, imageOffset, 0);
};

PMBufferData.Material.addLightType = function (builder, lightTypeOffset) {
  builder.addFieldOffset(2, lightTypeOffset, 0);
};

PMBufferData.Material.addColor = function (builder, colorOffset) {
  builder.addFieldOffset(3, colorOffset, 0);
};

PMBufferData.Material.addTransparency = function (builder, transparency) {
  builder.addFieldFloat32(4, transparency, 0.0);
};

PMBufferData.Material.addEnableTransparent = function (builder, enableTransparent) {
  builder.addFieldInt8(5, +enableTransparent, +false);
};

PMBufferData.Material.addDepthFunc = function (builder, depthFunc) {
  builder.addFieldInt32(6, depthFunc, 0);
};

PMBufferData.Material.addPolygonOffsetFactor = function (builder, polygonOffsetFactor) {
  builder.addFieldInt32(7, polygonOffsetFactor, 0);
};

PMBufferData.Material.addPolygonOffsetUnits = function (builder, polygonOffsetUnits) {
  builder.addFieldInt32(8, polygonOffsetUnits, 0);
};

PMBufferData.Material.addEnablePolygonOffset = function (builder, enablePolygonOffset) {
  builder.addFieldInt8(9, +enablePolygonOffset, +false);
};

PMBufferData.Material.addDoubleSide = function (builder, doubleSide) {
  builder.addFieldInt8(10, +doubleSide, +false);
};

PMBufferData.Material.endMaterial = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBufferData.MaterialDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBufferData.MaterialDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBufferData.MaterialDataFile.getRootAsMaterialDataFile = function (bb, obj) {
  return (obj || new PMBufferData.MaterialDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBufferData.MaterialDataFile.prototype.materialArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMBufferData.Material()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBufferData.MaterialDataFile.prototype.materialArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBufferData.MaterialDataFile.startMaterialDataFile = function (builder) {
  builder.startObject(1);
};

PMBufferData.MaterialDataFile.addMaterialArray = function (builder, materialArrayOffset) {
  builder.addFieldOffset(0, materialArrayOffset, 0);
};

PMBufferData.MaterialDataFile.createMaterialArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBufferData.MaterialDataFile.startMaterialArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBufferData.MaterialDataFile.endMaterialDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

this.PMBufferData = PMBufferData;

/***/ }),
/* 486 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__ = __webpack_require__(485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__loaders_TGALoader__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_classlib_RefDefinition__ = __webpack_require__(186);







function BufferDataInterface(fileLoader) {
  var textureType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var isSimColorMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var simColorModeColor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#aaa';

  this.type = 'BufferDataInterface';

  this.fileLoader = fileLoader;

  this.textureType = textureType;
  this.isSimColorMode = isSimColorMode;
  this.simColorModeColor = simColorModeColor;

  this.TGALoader = new __WEBPACK_IMPORTED_MODULE_2__loaders_TGALoader__["a" /* default */]();

  this.textureLoader = new window.$CCBIM.WebGL.TextureLoader();
}

BufferDataInterface.prototype = {
  constructor: BufferDataInterface,

  createBufferData: function createBufferData(bufferData) {
    var offset = 0;
    switch (bufferData.type()) {
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.INT8:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Int8Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset)) : null;
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.UINT8:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Uint8Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset)) : null;
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.INT16:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Int16Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset) / 2) : null;
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.UINT16:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Uint16Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset) / 2) : null;
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.INT32:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Int32Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset) / 4) : null;
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.UINT32:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Uint32Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset) / 4) : null;
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferType.FLOAT32:
        offset = bufferData.bb.__offset(bufferData.bb_pos, 6);
        return offset ? new Float32Array(bufferData.bb.bytes().buffer, bufferData.bb.bytes().byteOffset + bufferData.bb.__vector(bufferData.bb_pos + offset), bufferData.bb.__vector_len(bufferData.bb_pos + offset) / 4) : null;
        break;
    }
    return null;
  },
  createBufferAttribute: function createBufferAttribute(bufferGeometry, vertexAttribute, indexDrawMode) {
    var bufferData = this.createBufferData(vertexAttribute.buffer());
    if (!bufferData) {
      return;
    }
    switch (vertexAttribute.type()) {
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.INDEX:
        var index = new window.$CCBIM.WebGL.VertexIndex(indexDrawMode);
        index.setIndex(bufferData);
        bufferGeometry.addVertexIndex(index);
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.POSITION:
        bufferGeometry.addBufferAttribute('position', new window.$CCBIM.WebGL.Float32BufferAttributeModel(bufferData, vertexAttribute.elementPerVertex()));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.COLOR:
        bufferGeometry.addBufferAttribute('color', new window.$CCBIM.WebGL.Float32BufferAttributeModel(bufferData, vertexAttribute.elementPerVertex()));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.NORMAL:
        bufferGeometry.addBufferAttribute('normal', new window.$CCBIM.WebGL.Float32BufferAttributeModel(bufferData, vertexAttribute.elementPerVertex()));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.TEXTUREPARAM:
        bufferGeometry.addBufferAttribute('uv', new window.$CCBIM.WebGL.Float32BufferAttributeModel(bufferData, vertexAttribute.elementPerVertex()));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.INSTANCEMATR1:
        bufferGeometry.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR1.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(bufferData, vertexAttribute.elementPerVertex(), false, 1));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.INSTANCEMATR2:
        bufferGeometry.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR2.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(bufferData, vertexAttribute.elementPerVertex(), false, 1));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.INSTANCEMATR3:
        bufferGeometry.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR3.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(bufferData, vertexAttribute.elementPerVertex(), false, 1));
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].VertexAttribute.INSTANCEMATR4:
        bufferGeometry.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR4.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(bufferData, vertexAttribute.elementPerVertex(), false, 1));
        break;
    }
  },
  createBufferGeometry: function createBufferGeometry(bufferGeometryData) {
    var attributeCount = bufferGeometryData.vertexAttributeArrayLength();
    if (0 === attributeCount) {
      return null;
    }
    var bufferGeometry = null;
    var indexDrawMode = undefined;
    switch (bufferGeometryData.type()) {
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.POINT:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.UNKNOWN:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.LINES:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.LINE_LOOP:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.LINE_STRIP:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.TRIANGLES:
        {
          bufferGeometry = new window.$CCBIM.WebGL.PMBufferGeometry();
          indexDrawMode = window.$CCBIM.WebGL.DRAWMODE.TRIANGLES;
        }
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.TRIANGLE_STRIP:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.TRIANGLE_FAN:
        break;
      case __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].GeometryType.INSTANCE_MESH:
        {
          bufferGeometry = new window.$CCBIM.WebGL.PMInstanceBufferGeometry();
          indexDrawMode = window.$CCBIM.WebGL.DRAWMODE.TRIANGLES;
        }
        break;
    }

    if (!bufferGeometry) {
      return;
    }

    bufferGeometry.setUUID(bufferGeometryData.uuid());

    for (var i = 0; i < attributeCount; i++) {
      this.createBufferAttribute(bufferGeometry, bufferGeometryData.vertexAttributeArray(i), indexDrawMode);
    }
    if (bufferGeometry.isPMInstanceBufferGeometry) {
      var instanceMatR1 = bufferGeometry.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR1.name);
      if (instanceMatR1) {
        bufferGeometry.setInstancedCount(instanceMatR1.count);
      }
    }

    return bufferGeometry;
  },
  createBufferGeometryDataFile: function createBufferGeometryDataFile(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    return __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].BufferGeometryDataFile.getRootAsBufferGeometryDataFile(buffer);
  },
  createGeometryArray: function createGeometryArray(bufferGeometryDataFile, materialMap, refDefinitionMap, geometryArray) {
    for (var i = 0, length = bufferGeometryDataFile.bufferGeometryArrayLength(); i < length; i++) {
      var bufferGeometryData = bufferGeometryDataFile.bufferGeometryArray(i);
      var bufferGeometry = this.createBufferGeometry(bufferGeometryData);
      if (!bufferGeometry) {
        continue;
      }
      var material = materialMap.get(bufferGeometryData.materialID());
      geometryArray.push(new window.$CCBIM.WebGL.Mesh(bufferGeometry, material));
    }
    for (var _i = 0, _length = bufferGeometryDataFile.instanceBufferGeometryArrayLength(); _i < _length; _i++) {
      var instanceBufferGeometryData = bufferGeometryDataFile.instanceBufferGeometryArray(_i);
      var refDefinition = refDefinitionMap.get(instanceBufferGeometryData.refID());
      if (!refDefinition) {
        continue;
      }
      var refObjectArray = refDefinition.getRefObjectArray();
      for (var j = 0, jl = refObjectArray.length; j < jl; j++) {
        var instanceBufferGeometry = this.createBufferGeometry(instanceBufferGeometryData);
        if (!instanceBufferGeometry) {
          continue;
        }
        var refObject = refObjectArray[j];
        instanceBufferGeometry.setUUID(refObject.geometry.getUUID().toString() + instanceBufferGeometryData.uuid().toString());
        instanceBufferGeometry.setAttributeArray(refObject.geometry.getAttributeArray());
        instanceBufferGeometry.setIndexArray(refObject.geometry.getIndexArray());
        var count = instanceBufferGeometry.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR1.name).count;
        var instanceStateBuffer = new Float32Array(count * window.$CCBIM.WebGL.PMInstanceAttribute.State.itemSize);
        for (var k = 0; k < count; k++) {
          instanceStateBuffer[k * window.$CCBIM.WebGL.PMInstanceAttribute.State.itemSize] = 1.0;
        }
        instanceBufferGeometry.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.State.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(instanceStateBuffer, window.$CCBIM.WebGL.PMInstanceAttribute.State.itemSize, false, 1));

        var colorBuffer = new Float32Array(count * window.$CCBIM.WebGL.PMInstanceAttribute.Color.itemSize);
        instanceBufferGeometry.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.Color.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(colorBuffer, window.$CCBIM.WebGL.PMInstanceAttribute.Color.itemSize, false, 1));
        instanceBufferGeometry.setInstancedCount(count);
        var instanceMesh = new window.$CCBIM.WebGL.InstancedMesh(instanceBufferGeometry, refObject.material);
        geometryArray.push(instanceMesh);
      }
    }
  },
  createEntInfoEntDataArray: function createEntInfoEntDataArray(entInfoDataFile, refDefinitionMap, entInfoArray, entDataArray) {},
  createRefDefinitionMap: function createRefDefinitionMap(bytes, materialMap, refDefinitionMap) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var refDefinitionDataFile = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].RefDefinitionDataFile.getRootAsRefDefinitionDataFile(buffer);
    for (var i = 0, refLength = refDefinitionDataFile.refDefinitionArrayLength(); i < refLength; i++) {
      var refDefinitionObj = refDefinitionDataFile.refDefinitionArray(i);
      var refDefinition = new __WEBPACK_IMPORTED_MODULE_3__model_classlib_RefDefinition__["a" /* RefDefinition */]();
      refDefinition.setUUID(refDefinitionObj.uuid());
      for (var j = 0, geoLength = refDefinitionObj.bufferGeometryArrayLength(); j < geoLength; j++) {
        var bufferGeometryObj = refDefinitionObj.bufferGeometryArray(j);
        var geometry = this.createBufferGeometry(bufferGeometryObj);
        if (!geometry) {
          continue;
        }
        var material = materialMap.get(bufferGeometryObj.materialID());
        refDefinition.addRefObject(new window.$CCBIM.WebGL.Mesh(geometry, material));
      }
      refDefinitionMap.set(refDefinition.getUUID(), refDefinition);
    }
  },
  createMaterialMap: function createMaterialMap(bytes, textureImageMap, materialMap, isInstanceMaterialMap) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var materialDataFile = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_BufferData_js__["PMBufferData"].MaterialDataFile.getRootAsMaterialDataFile(buffer);
    for (var i = 0, length = materialDataFile.materialArrayLength(); i < length; i++) {
      var materialData = materialDataFile.materialArray(i);
      var material = null;

      if (materialData.lightType() === 'MeshLambertMaterial') {
        material = new window.$CCBIM.WebGL.MeshLambertMaterial();
      } else {
        material = new window.$CCBIM.WebGL.MeshPhongMaterial();
      }

      material.map = this.getImageData(materialData.image(), textureImageMap);

      material.transparent = materialData.enableTransparent();
      material.opacity = materialData.transparency();

      if (material.opacity > 0.999999 && !material.map) {
        material.transparent = false;
      }
      if (material.transparent && material.opacity === 1) {
        material.blending = window.$CCBIM.WebGL.NormalBlending;
      }

      if (!material.map) {
        material.color = new window.$CCBIM.WebGL.Color(materialData.color());
      }

      material.colorCopy = new window.$CCBIM.WebGL.Color(materialData.color());

      material.flatShading = false;
      material.depthFunc = materialData.depthFunc() === undefined ? 2 : materialData.depthFunc();
      material.blending = window.$CCBIM.WebGL.NormalBlending;
      material.clippingPlanes = window.$CCBIM.clippingPlane;

      material.polygonOffset = materialData.enablePolygonOffset();
      material.polygonOffsetUnits = materialData.polygonOffsetUnits() / 10;
      material.polygonOffsetFactor = materialData.polygonOffsetFactor() / 10;

      material.vertexOffset = materialData.enablePolygonOffset();
      if (material.vertexOffset) {
        material.vertexOffsetValue = -materialData.polygonOffsetFactor() * window.$CCBIM.sceneManager.sceneData.scale;
      }

      if (this.isPhone) {
        material.side = materialData.doubleSide() === true ? 2 : 0;
      } else {
        material.side = 2;
        material.precision = 'highp';
      }

      if (this.textureType === 1) {
        material.mapCopy = material.map;
        material.map = null;
        material.color = new window.$CCBIM.WebGL.Color(materialData.color());
      }

      if (this.isSimColorMode === true) {
        material.color = new window.$CCBIM.WebGL.Color(this.simColorModeColor);
      }

      material.instanceMaterial = isInstanceMaterialMap;

      materialMap.set(materialData.uuid(), material);
    }
  },
  getImageData: function getImageData(imageData, textureImageMap) {
    if (!imageData) {
      return null;
    }

    var textureImage = textureImageMap.get(imageData.uuid());
    if (textureImage) {
      return textureImage;
    }

    var url = this.fileLoader.getCloudURL() + 'IMG' + imageData.url();
    if (imageData.isUserImage()) {
      var fileIndex = this.fileLoader.getFileIndex(imageData.url());
      if (fileIndex) {
        url = fileIndex.getURL();
      }
    }
    if (url.includes('.tga')) {
      textureImage = this.TGALoader.load(url, function () {
        window.$CCBIM.render.setNeedUpdate();
      }, undefined, function () {
        console.error('An error happened.');
      });
    } else {
      textureImage = this.textureLoader.load(url, function () {
        window.$CCBIM.render.setNeedUpdate();
      }, undefined, function () {
        console.error('An error happened.');
      });
      textureImage.format = window.$CCBIM.WebGL.AlphaFormat;
    }
    textureImage.wrapS = window.$CCBIM.WebGL.RepeatWrapping;
    textureImage.wrapT = window.$CCBIM.WebGL.RepeatWrapping;
    textureImage.anisotropy = window.$CCBIM.webglContext.renderer.capabilities.getMaxAnisotropy();
    textureImageMap.set(imageData.uuid(), textureImage);
    return textureImage;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (BufferDataInterface);

/***/ }),
/* 487 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js__ = __webpack_require__(490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__ = __webpack_require__(185);






function ComponentsDataInterface() {
  this.type = 'ComponentsDataInterface';
}
ComponentsDataInterface.prototype = {
  constructor: ComponentsDataInterface,

  createProjectDataFile: function createProjectDataFile(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    return __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js__["PMComponentsData"].ProjectDataFile.getRootAsProjectDataFile(buffer);
  },
  createStageInfoArray: function createStageInfoArray(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var projectDataFile = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js__["PMComponentsData"].ProjectDataFile.getRootAsProjectDataFile(buffer);
    var stageInfoArray = [];
    for (var i = 0, il = projectDataFile.stageInfoArrayLength(); i < il; i++) {
      var obj = projectDataFile.stageInfoArray(i);
      var stageInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["f" /* StageInfo */](obj.id(), obj.name());
      stageInfoArray.push(stageInfo);
    }
    return stageInfoArray;
  },
  createBuildingInfoArray: function createBuildingInfoArray(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var projectDataFile = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js__["PMComponentsData"].ProjectDataFile.getRootAsProjectDataFile(buffer);
    var buildingInfoArray = [];
    for (var i = 0, il = projectDataFile.buildingInfoArrayLength(); i < il; i++) {
      var buildingInfo = this.createBuildingInfo(projectDataFile.buildingInfoArray(i));
      buildingInfoArray.push(buildingInfo);
    }
    return buildingInfoArray;
  },
  createBuildingInfo: function createBuildingInfo(buildingInfoObj) {
    var buildingInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["a" /* BuildingInfo */](buildingInfoObj.id(), buildingInfoObj.name());
    for (var i = 0, il = buildingInfoObj.floorInfoArrayLength(); i < il; i++) {
      var floorInfo = this.createFloorInfo(buildingInfoObj.floorInfoArray(i));
      buildingInfo.addFloorInfo(floorInfo);
    }
    return buildingInfo;
  },
  createFloorInfo: function createFloorInfo(floorInfoObj) {
    var floorInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["b" /* FloorInfo */](floorInfoObj.id(), floorInfoObj.name());
    for (var i = 0, il = floorInfoObj.baseComtypeArrayLength(); i < il; i++) {
      var baseComtypeInfo = this.createBaseComtypeInfo(floorInfoObj.baseComtypeArray(i));
      floorInfo.addBaseComtypeInfo(baseComtypeInfo);
    }
    return floorInfo;
  },
  createBaseComtypeInfo: function createBaseComtypeInfo(baseComtypeObj) {
    var baseComtypeInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["c" /* BaseComtypeInfo */](baseComtypeObj.id(), baseComtypeObj.name());
    for (var i = 0, il = baseComtypeObj.comtypeArrayLength(); i < il; i++) {
      var comtypeInfo = this.createComtypeInfo(baseComtypeObj.comtypeArray(i));
      baseComtypeInfo.addComtypeInfo(comtypeInfo);
    }
    for (var _i = 0, _il = baseComtypeObj.baseComtypeArrayLength(); _i < _il; _i++) {
      var child = this.createBaseComtypeInfo(baseComtypeObj.baseComtypeArray(_i));
      baseComtypeInfo.addChild(child);
    }
    return baseComtypeInfo;
  },
  createComtypeInfo: function createComtypeInfo(comtypeObj) {
    var comtypeInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["d" /* ComtypeInfo */](comtypeObj.id(), comtypeObj.name());
    for (var i = 0, il = comtypeObj.comidArrayLength(); i < il; i++) {
      var comidInfo = this.createComidInfo(comtypeObj.comidArray(i));
      comtypeInfo.addComidInfo(comidInfo);
    }
    for (var _i2 = 0, _il2 = comtypeObj.comtypeInfoArrayLength(); _i2 < _il2; _i2++) {
      var child = this.createComtypeInfo(comtypeObj.comtypeInfoArray(_i2));
      comtypeInfo.addComtypeInfo(child);
    }
    return comtypeInfo;
  },
  createComidInfo: function createComidInfo(comidObj) {
    var comidInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["e" /* ComidInfo */](comidObj.id(), comidObj.name());
    for (var i = 0, il = comidObj.handleArrayLength(); i < il; i++) {
      comidInfo.addHandle(new String(comidObj.handleArray(i)));
    }
    return comidInfo;
  },

  createFloorCrossLine: function createFloorCrossLine(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var floorCrossLine = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBimData_ComponentsData_js__["PMComponentsData"].FloorAxisInfoDataFile.getRootAsFloorAxisInfoDataFile(buffer);
    var floorCrossLineGroup = [];
    for (var i = 0; i < floorCrossLine.floorAxisInfoArrayLength(); i++) {
      var index = floorCrossLine.floorAxisInfoArray(i);

      var lineGroup = [];
      for (var j = 0; j < index.axisLineArrayLength(); j++) {
        var lineIndex = index.axisLineArray(j);
        var lineObj = {
          textHeight: lineIndex.symbol().textHeight(),
          textRoundRadius: lineIndex.symbol().textRoundRadius(),
          name: lineIndex.symbol().name(),
          textInsert: lineIndex.symbol().positionArray(),
          start: lineIndex.startArray(),
          end: lineIndex.endArray()
        };
        lineGroup.push(lineObj);
      }

      var arcGroup = [];
      for (var m = 0; m < index.axisArcArrayLength(); m++) {
        var arcIndex = index.axisArcArray(m);
        var arcObj = {
          textHeight: arcIndex.symbol().textHeight(),
          textRoundRadius: arcIndex.symbol().textRoundRadius(),
          name: arcIndex.symbol().name(),
          textInsert: arcIndex.symbol().positionArray(),
          center: arcIndex.centerArray(),
          radius: arcIndex.radiu(),
          startAngle: arcIndex.startAngle(),
          endAngle: arcIndex.endAngle(),
          antiClockWise: arcIndex.antiClockWise()
        };
        arcGroup.push(arcObj);
      }

      var crossGroup = [];
      for (var n = 0; n < index.axisLineSegArrayLength(); n++) {
        var crossIndex = index.axisLineSegArray(n);
        var crossObj = {
          start: Array.prototype.slice.call(crossIndex.startArray()),
          end: Array.prototype.slice.call(crossIndex.endArray())
        };
        crossGroup.push(crossObj);
      }

      var obj = {
        floorId: index.id(),
        floorHeight: index.height(),
        floorElevation: index.elevation(),
        floorName: index.name(),
        axisNetLineArray: lineGroup,
        axisNetArcArray: arcGroup,
        crossLines: crossGroup
      };
      floorCrossLineGroup.push(obj);
    }
    return floorCrossLineGroup;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (ComponentsDataInterface);

/***/ }),
/* 488 */
/***/ (function(module, exports) {


var PMSceneData = PMSceneData || {};

PMSceneData.FileIndex = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.FileIndex.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.FileIndex.getRootAsFileIndex = function (bb, obj) {
  return (obj || new PMSceneData.FileIndex()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.FileIndex.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMSceneData.FileIndex.prototype.url = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMSceneData.FileIndex.prototype.fileSize = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
};

PMSceneData.FileIndex.startFileIndex = function (builder) {
  builder.startObject(3);
};

PMSceneData.FileIndex.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMSceneData.FileIndex.addUrl = function (builder, urlOffset) {
  builder.addFieldOffset(1, urlOffset, 0);
};

PMSceneData.FileIndex.addFileSize = function (builder, fileSize) {
  builder.addFieldInt32(2, fileSize, 0);
};

PMSceneData.FileIndex.endFileIndex = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMSceneData.PageData = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.PageData.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.PageData.getRootAsPageData = function (bb, obj) {
  return (obj || new PMSceneData.PageData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.PageData.prototype.dataContentSize = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
};

PMSceneData.PageData.prototype.bufferGeometryDataFileArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.PageData.prototype.bufferGeometryDataFileArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.PageData.prototype.entDataDataFileArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.PageData.prototype.entDataDataFileArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.PageData.startPageData = function (builder) {
  builder.startObject(3);
};

PMSceneData.PageData.addDataContentSize = function (builder, dataContentSize) {
  builder.addFieldInt32(0, dataContentSize, 0);
};

PMSceneData.PageData.addBufferGeometryDataFileArray = function (builder, bufferGeometryDataFileArrayOffset) {
  builder.addFieldOffset(1, bufferGeometryDataFileArrayOffset, 0);
};

PMSceneData.PageData.createBufferGeometryDataFileArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.PageData.startBufferGeometryDataFileArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.PageData.addEntDataDataFileArray = function (builder, entDataDataFileArrayOffset) {
  builder.addFieldOffset(2, entDataDataFileArrayOffset, 0);
};

PMSceneData.PageData.createEntDataDataFileArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.PageData.startEntDataDataFileArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.PageData.endPageData = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMSceneData.PageLOD = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.PageLOD.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.PageLOD.getRootAsPageLOD = function (bb, obj) {
  return (obj || new PMSceneData.PageLOD()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.PageLOD.prototype.level = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMSceneData.PageLOD.prototype.minLoadDistance = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMSceneData.PageLOD.prototype.maxLoadDistance = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMSceneData.PageLOD.prototype.pageData = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMSceneData.PageData()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMSceneData.PageLOD.startPageLOD = function (builder) {
  builder.startObject(4);
};

PMSceneData.PageLOD.addLevel = function (builder, level) {
  builder.addFieldInt32(0, level, 0);
};

PMSceneData.PageLOD.addMinLoadDistance = function (builder, minLoadDistance) {
  builder.addFieldFloat32(1, minLoadDistance, 0.0);
};

PMSceneData.PageLOD.addMaxLoadDistance = function (builder, maxLoadDistance) {
  builder.addFieldFloat32(2, maxLoadDistance, 0.0);
};

PMSceneData.PageLOD.addPageData = function (builder, pageDataOffset) {
  builder.addFieldOffset(3, pageDataOffset, 0);
};

PMSceneData.PageLOD.endPageLOD = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMSceneData.SceneNode = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.SceneNode.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.SceneNode.getRootAsSceneNode = function (bb, obj) {
  return (obj || new PMSceneData.SceneNode()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.SceneNode.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMSceneData.SceneNode.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.SceneNode.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMSceneData.SceneNode.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMSceneData.SceneNode.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.SceneNode.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMSceneData.SceneNode.prototype.nodeData = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMSceneData.PageData()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMSceneData.SceneNode.prototype.lodData = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMSceneData.PageLOD()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.SceneNode.prototype.lodDataLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.SceneNode.prototype.entInfoDataFileArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.SceneNode.prototype.entInfoDataFileArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.SceneNode.prototype.childNodeArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new PMSceneData.SceneNode()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.SceneNode.prototype.childNodeArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.SceneNode.startSceneNode = function (builder) {
  builder.startObject(6);
};

PMSceneData.SceneNode.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(0, bndBoxMinOffset, 0);
};

PMSceneData.SceneNode.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMSceneData.SceneNode.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.SceneNode.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(1, bndBoxMaxOffset, 0);
};

PMSceneData.SceneNode.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMSceneData.SceneNode.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.SceneNode.addNodeData = function (builder, nodeDataOffset) {
  builder.addFieldOffset(2, nodeDataOffset, 0);
};

PMSceneData.SceneNode.addLodData = function (builder, lodDataOffset) {
  builder.addFieldOffset(3, lodDataOffset, 0);
};

PMSceneData.SceneNode.createLodDataVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.SceneNode.startLodDataVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.SceneNode.addEntInfoDataFileArray = function (builder, entInfoDataFileArrayOffset) {
  builder.addFieldOffset(4, entInfoDataFileArrayOffset, 0);
};

PMSceneData.SceneNode.createEntInfoDataFileArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.SceneNode.startEntInfoDataFileArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.SceneNode.addChildNodeArray = function (builder, childNodeArrayOffset) {
  builder.addFieldOffset(5, childNodeArrayOffset, 0);
};

PMSceneData.SceneNode.createChildNodeArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.SceneNode.startChildNodeArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.SceneNode.endSceneNode = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMSceneData.Camera = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.Camera.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.Camera.getRootAsCamera = function (bb, obj) {
  return (obj || new PMSceneData.Camera()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.Camera.prototype.position = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMSceneData.Camera.prototype.positionLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.Camera.prototype.positionArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMSceneData.Camera.prototype.target = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMSceneData.Camera.prototype.targetLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.Camera.prototype.targetArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMSceneData.Camera.prototype.upvec = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMSceneData.Camera.prototype.upvecLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.Camera.prototype.upvecArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMSceneData.Camera.startCamera = function (builder) {
  builder.startObject(3);
};

PMSceneData.Camera.addPosition = function (builder, positionOffset) {
  builder.addFieldOffset(0, positionOffset, 0);
};

PMSceneData.Camera.createPositionVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMSceneData.Camera.startPositionVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.Camera.addTarget = function (builder, targetOffset) {
  builder.addFieldOffset(1, targetOffset, 0);
};

PMSceneData.Camera.createTargetVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMSceneData.Camera.startTargetVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.Camera.addUpvec = function (builder, upvecOffset) {
  builder.addFieldOffset(2, upvecOffset, 0);
};

PMSceneData.Camera.createUpvecVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMSceneData.Camera.startUpvecVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.Camera.endCamera = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMSceneData.SceneDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.SceneDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.SceneDataFile.getRootAsSceneDataFile = function (bb, obj) {
  return (obj || new PMSceneData.SceneDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.SceneDataFile.prototype.version = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMSceneData.SceneDataFile.prototype.rootNode = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMSceneData.SceneNode()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMSceneData.SceneDataFile.prototype.defaultCamera = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMSceneData.Camera()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMSceneData.SceneDataFile.prototype.scale = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMSceneData.SceneDataFile.startSceneDataFile = function (builder) {
  builder.startObject(4);
};

PMSceneData.SceneDataFile.addVersion = function (builder, version) {
  builder.addFieldInt32(0, version, 0);
};

PMSceneData.SceneDataFile.addRootNode = function (builder, rootNodeOffset) {
  builder.addFieldOffset(1, rootNodeOffset, 0);
};

PMSceneData.SceneDataFile.addDefaultCamera = function (builder, defaultCameraOffset) {
  builder.addFieldOffset(2, defaultCameraOffset, 0);
};

PMSceneData.SceneDataFile.addScale = function (builder, scale) {
  builder.addFieldFloat32(3, scale, 0.0);
};

PMSceneData.SceneDataFile.endSceneDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMSceneData.HeadDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMSceneData.HeadDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMSceneData.HeadDataFile.getRootAsHeadDataFile = function (bb, obj) {
  return (obj || new PMSceneData.HeadDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMSceneData.HeadDataFile.prototype.version = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMSceneData.HeadDataFile.prototype.sceneDataFile = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMSceneData.HeadDataFile.prototype.materialDataFileArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.HeadDataFile.prototype.materialDataFileArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.HeadDataFile.prototype.refDefinitionDataFileArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.HeadDataFile.prototype.refDefinitionDataFileArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.HeadDataFile.prototype.projectFileIndex = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMSceneData.HeadDataFile.prototype.floorAxisFileArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new PMSceneData.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMSceneData.HeadDataFile.prototype.floorAxisFileArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMSceneData.HeadDataFile.startHeadDataFile = function (builder) {
  builder.startObject(6);
};

PMSceneData.HeadDataFile.addVersion = function (builder, version) {
  builder.addFieldInt32(0, version, 0);
};

PMSceneData.HeadDataFile.addSceneDataFile = function (builder, sceneDataFileOffset) {
  builder.addFieldOffset(1, sceneDataFileOffset, 0);
};

PMSceneData.HeadDataFile.addMaterialDataFileArray = function (builder, materialDataFileArrayOffset) {
  builder.addFieldOffset(2, materialDataFileArrayOffset, 0);
};

PMSceneData.HeadDataFile.createMaterialDataFileArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.HeadDataFile.startMaterialDataFileArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.HeadDataFile.addRefDefinitionDataFileArray = function (builder, refDefinitionDataFileArrayOffset) {
  builder.addFieldOffset(3, refDefinitionDataFileArrayOffset, 0);
};

PMSceneData.HeadDataFile.createRefDefinitionDataFileArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.HeadDataFile.startRefDefinitionDataFileArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.HeadDataFile.addProjectFileIndex = function (builder, projectFileIndexOffset) {
  builder.addFieldOffset(4, projectFileIndexOffset, 0);
};

PMSceneData.HeadDataFile.addFloorAxisFileArray = function (builder, floorAxisFileArrayOffset) {
  builder.addFieldOffset(5, floorAxisFileArrayOffset, 0);
};

PMSceneData.HeadDataFile.createFloorAxisFileArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMSceneData.HeadDataFile.startFloorAxisFileArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMSceneData.HeadDataFile.endHeadDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

this.PMSceneData = PMSceneData;

/***/ }),
/* 489 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_SceneData_js__ = __webpack_require__(488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_SceneData_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_SceneData_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_classlib_PageData__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__model_classlib_PageLOD__ = __webpack_require__(500);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__model_classlib_FileIndex__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__model_classlib_SceneNode__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__THREE_math_Vector3__ = __webpack_require__(2);











function SceneDataInterface(fileLoader) {
  this.type = 'SceneDataInterface';

  this.fileLoader = fileLoader;
}
SceneDataInterface.prototype = {
  constructor: SceneDataInterface,

  createHeadDataFile: function createHeadDataFile(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_1__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    return __WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_SceneData_js__["PMSceneData"].HeadDataFile.getRootAsHeadDataFile(buffer);
  },

  getHeadFileVersion: function getHeadFileVersion(headDataFile) {
    if (!headDataFile) {
      return -1;
    }
    return headDataFile.version();
  },

  getBasicFileTotal: function getBasicFileTotal(headDataFile) {
    var materialDataFileSize = headDataFile.materialDataFileArrayLength();
    var refDefinitionDataFileSize = headDataFile.refDefinitionDataFileArrayLength();
    var componentsFileSize = headDataFile.floorAxisFileArrayLength();
    var fileSizeTotal = materialDataFileSize + refDefinitionDataFileSize + componentsFileSize;
    return fileSizeTotal;
  },

  getSceneDataFile: function getSceneDataFile(headDataFile) {
    var _this = this;

    var fileIndex = this.fileLoader.getFileIndex(this.createFileIndex(headDataFile.sceneDataFile()).getURL());
    return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve) {
      _this.fileLoader.loadFile(fileIndex).then(function (res) {
        var buffer = new __WEBPACK_IMPORTED_MODULE_1__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(res.data));
        resolve(__WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_SceneData_js__["PMSceneData"].SceneDataFile.getRootAsSceneDataFile(buffer));
      });
    });
  },

  getMaterialDataFileIndexArray: function getMaterialDataFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var indexArray = [];
    for (var i = 0, length = headDataFile.materialDataFileArrayLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.materialDataFileArray(i));
      if (!index) {
        continue;
      }
      indexArray.push(index);
    }

    return indexArray;
  },

  getRefDefinitionDataFileIndexArray: function getRefDefinitionDataFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var indexArray = [];
    for (var i = 0, length = headDataFile.refDefinitionDataFileArrayLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.refDefinitionDataFileArray(i));
      if (!index) {
        continue;
      }
      indexArray.push(index);
    }

    return indexArray;
  },

  getProjectFileIndex: function getProjectFileIndex(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    return this.createFileIndex(headDataFile.projectFileIndex());
  },

  getFloorAxisFileIndexArray: function getFloorAxisFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }
    var indexArray = [];
    for (var i = 0, length = headDataFile.floorAxisFileArrayLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.floorAxisFileArray(i));
      if (!index) {
        continue;
      }
      indexArray.push(index);
    }
    return indexArray;
  },

  getTerrainFileIndexArray: function getTerrainFileIndexArray() {
    return null;
  },

  getDefaultCamera: function getDefaultCamera(sceneDataFile) {
    var defCamera = sceneDataFile.defaultCamera();
    return {
      position: defCamera.positionArray(),
      target: defCamera.targetArray(),
      up: defCamera.upvecArray() };
  },

  getSceneTreeBndBox: function getSceneTreeBndBox(sceneDataFile) {
    var rootNode = sceneDataFile.rootNode();
    return {
      bndBoxMin: rootNode.bndBoxMinArray(),
      bndBoxMax: rootNode.bndBoxMaxArray()
    };
  },

  getRootNode: function getRootNode(sceneDataFile) {
    return sceneDataFile.rootNode();
  },

  getSceneScale: function getSceneScale(sceneDataFile) {
    return sceneDataFile.scale();
  },

  createSceneTree: function createSceneTree(nodeData, group) {
    if (!nodeData || !group) {
      return;
    }

    var newGroup = new window.$CCBIM.WebGL.Group();
    group.add(newGroup);

    var sceneNode = new __WEBPACK_IMPORTED_MODULE_6__model_classlib_SceneNode__["a" /* default */]();
    newGroup.userData.sceneNode = sceneNode;

    var bndBoxMinArray = nodeData.bndBoxMinArray();
    var bndBoxMaxArray = nodeData.bndBoxMaxArray();
    var bndBoxMin = new window.$CCBIM.WebGL.Vector3(bndBoxMinArray[0], bndBoxMinArray[1], bndBoxMinArray[2]);
    var bndBoxMax = new window.$CCBIM.WebGL.Vector3(bndBoxMaxArray[0], bndBoxMaxArray[1], bndBoxMaxArray[2]);
    sceneNode.setBndBox(new window.$CCBIM.WebGL.Box3(bndBoxMin, bndBoxMax));

    var fixPageData = this.createPageData(nodeData.nodeData());
    if (fixPageData) {
      fixPageData.setUsage(-1);
      sceneNode.setPageData(fixPageData);
    }

    for (var i = 0, length = nodeData.lodDataLength(); i < length; i++) {
      var lodData = nodeData.lodData(i);
      if (!lodData) {
        continue;
      }
      var pageData = this.createPageData(lodData.pageData());
      if (!pageData) {
        continue;
      }

      pageData.setUsage(lodData.level());

      var pageLOD = new __WEBPACK_IMPORTED_MODULE_4__model_classlib_PageLOD__["a" /* default */]();
      pageLOD.setLoadRange(lodData.minLoadDistance(), lodData.maxLoadDistance());
      pageLOD.setPageData(pageData);
      sceneNode.addPageLOD(pageLOD);
    }

    for (var _i = 0, _length = nodeData.entInfoDataFileArrayLength(); _i < _length; _i++) {
      var fileIndex = this.createFileIndex(nodeData.entInfoDataFileArray(_i));
      if (!fileIndex) {
        continue;
      }
      sceneNode.addEntInfoFileList(fileIndex);
    }

    for (var _i2 = 0, _length2 = nodeData.childNodeArrayLength(); _i2 < _length2; _i2++) {
      this.createSceneTree(nodeData.childNodeArray(_i2), newGroup);
    }
  },

  createPageData: function createPageData(data) {
    if (!data) {
      return null;
    }

    var pageData = new __WEBPACK_IMPORTED_MODULE_3__model_classlib_PageData__["a" /* default */]();
    pageData.setContentSize(data.dataContentSize());
    for (var j = 0, fileLength = data.bufferGeometryDataFileArrayLength(); j < fileLength; j++) {
      var fileIndex = this.createFileIndex(data.bufferGeometryDataFileArray(j));
      if (!fileIndex) {
        continue;
      }
      pageData.addBufferGeometryFile(fileIndex);
    }
    for (var _j = 0, _fileLength = data.entDataDataFileArrayLength(); _j < _fileLength; _j++) {
      var _fileIndex = this.createFileIndex(data.entDataDataFileArray(_j));
      if (!_fileIndex) {
        continue;
      }
      pageData.addEntDataFileList(_fileIndex);
    }
    return pageData;
  },

  createFileIndex: function createFileIndex(data) {
    if (!data) {
      return null;
    }

    var fileIndex = new __WEBPACK_IMPORTED_MODULE_5__model_classlib_FileIndex__["a" /* default */]();
    fileIndex.setID(data.id());
    fileIndex.setURL(data.url());
    fileIndex.setFileSize(data.fileSize());
    return fileIndex;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (SceneDataInterface);

/***/ }),
/* 490 */
/***/ (function(module, exports) {


var PMComponentsData = PMComponentsData || {};

PMComponentsData.AxisSymbol = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.AxisSymbol.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.AxisSymbol.getRootAsAxisSymbol = function (bb, obj) {
  return (obj || new PMComponentsData.AxisSymbol()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.AxisSymbol.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.AxisSymbol.prototype.position = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMComponentsData.AxisSymbol.prototype.positionLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.AxisSymbol.prototype.positionArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMComponentsData.AxisSymbol.prototype.textHeight = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.AxisSymbol.prototype.textRoundRadius = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.AxisSymbol.startAxisSymbol = function (builder) {
  builder.startObject(4);
};

PMComponentsData.AxisSymbol.addName = function (builder, nameOffset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

PMComponentsData.AxisSymbol.addPosition = function (builder, positionOffset) {
  builder.addFieldOffset(1, positionOffset, 0);
};

PMComponentsData.AxisSymbol.createPositionVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.AxisSymbol.startPositionVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.AxisSymbol.addTextHeight = function (builder, textHeight) {
  builder.addFieldFloat32(2, textHeight, 0.0);
};

PMComponentsData.AxisSymbol.addTextRoundRadius = function (builder, textRoundRadius) {
  builder.addFieldFloat32(3, textRoundRadius, 0.0);
};

PMComponentsData.AxisSymbol.endAxisSymbol = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.AxisLine = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.AxisLine.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.AxisLine.getRootAsAxisLine = function (bb, obj) {
  return (obj || new PMComponentsData.AxisLine()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.AxisLine.prototype.symbol = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMComponentsData.AxisSymbol()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMComponentsData.AxisLine.prototype.start = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMComponentsData.AxisLine.prototype.startLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.AxisLine.prototype.startArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMComponentsData.AxisLine.prototype.end = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMComponentsData.AxisLine.prototype.endLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.AxisLine.prototype.endArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMComponentsData.AxisLine.startAxisLine = function (builder) {
  builder.startObject(3);
};

PMComponentsData.AxisLine.addSymbol = function (builder, symbolOffset) {
  builder.addFieldOffset(0, symbolOffset, 0);
};

PMComponentsData.AxisLine.addStart = function (builder, startOffset) {
  builder.addFieldOffset(1, startOffset, 0);
};

PMComponentsData.AxisLine.createStartVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.AxisLine.startStartVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.AxisLine.addEnd = function (builder, endOffset) {
  builder.addFieldOffset(2, endOffset, 0);
};

PMComponentsData.AxisLine.createEndVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.AxisLine.startEndVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.AxisLine.endAxisLine = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.AxisArc = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.AxisArc.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.AxisArc.getRootAsAxisArc = function (bb, obj) {
  return (obj || new PMComponentsData.AxisArc()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.AxisArc.prototype.symbol = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMComponentsData.AxisSymbol()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMComponentsData.AxisArc.prototype.center = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMComponentsData.AxisArc.prototype.centerLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.AxisArc.prototype.centerArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMComponentsData.AxisArc.prototype.radiu = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.AxisArc.prototype.startAngle = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.AxisArc.prototype.endAngle = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.AxisArc.prototype.antiClockWise = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.AxisArc.startAxisArc = function (builder) {
  builder.startObject(6);
};

PMComponentsData.AxisArc.addSymbol = function (builder, symbolOffset) {
  builder.addFieldOffset(0, symbolOffset, 0);
};

PMComponentsData.AxisArc.addCenter = function (builder, centerOffset) {
  builder.addFieldOffset(1, centerOffset, 0);
};

PMComponentsData.AxisArc.createCenterVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.AxisArc.startCenterVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.AxisArc.addRadiu = function (builder, radiu) {
  builder.addFieldFloat32(2, radiu, 0.0);
};

PMComponentsData.AxisArc.addStartAngle = function (builder, startAngle) {
  builder.addFieldFloat32(3, startAngle, 0.0);
};

PMComponentsData.AxisArc.addEndAngle = function (builder, endAngle) {
  builder.addFieldFloat32(4, endAngle, 0.0);
};

PMComponentsData.AxisArc.addAntiClockWise = function (builder, antiClockWiseOffset) {
  builder.addFieldOffset(5, antiClockWiseOffset, 0);
};

PMComponentsData.AxisArc.endAxisArc = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.AxisLineSeg = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.AxisLineSeg.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.AxisLineSeg.getRootAsAxisLineSeg = function (bb, obj) {
  return (obj || new PMComponentsData.AxisLineSeg()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.AxisLineSeg.prototype.start = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMComponentsData.AxisLineSeg.prototype.startLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.AxisLineSeg.prototype.startArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMComponentsData.AxisLineSeg.prototype.end = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMComponentsData.AxisLineSeg.prototype.endLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.AxisLineSeg.prototype.endArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMComponentsData.AxisLineSeg.startAxisLineSeg = function (builder) {
  builder.startObject(2);
};

PMComponentsData.AxisLineSeg.addStart = function (builder, startOffset) {
  builder.addFieldOffset(0, startOffset, 0);
};

PMComponentsData.AxisLineSeg.createStartVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.AxisLineSeg.startStartVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.AxisLineSeg.addEnd = function (builder, endOffset) {
  builder.addFieldOffset(1, endOffset, 0);
};

PMComponentsData.AxisLineSeg.createEndVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.AxisLineSeg.startEndVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.AxisLineSeg.endAxisLineSeg = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.FloorAxisInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.FloorAxisInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.FloorAxisInfo.getRootAsFloorAxisInfo = function (bb, obj) {
  return (obj || new PMComponentsData.FloorAxisInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.FloorAxisInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorAxisInfo.prototype.height = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.FloorAxisInfo.prototype.elevation = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMComponentsData.FloorAxisInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.FloorAxisInfo.prototype.axisLineArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new PMComponentsData.AxisLine()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.FloorAxisInfo.prototype.axisLineArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorAxisInfo.prototype.axisArcArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new PMComponentsData.AxisArc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.FloorAxisInfo.prototype.axisArcArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorAxisInfo.prototype.axisLineSegArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? (obj || new PMComponentsData.AxisLineSeg()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.FloorAxisInfo.prototype.axisLineSegArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorAxisInfo.startFloorAxisInfo = function (builder) {
  builder.startObject(7);
};

PMComponentsData.FloorAxisInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.FloorAxisInfo.addHeight = function (builder, height) {
  builder.addFieldFloat32(1, height, 0.0);
};

PMComponentsData.FloorAxisInfo.addElevation = function (builder, elevation) {
  builder.addFieldFloat32(2, elevation, 0.0);
};

PMComponentsData.FloorAxisInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(3, nameOffset, 0);
};

PMComponentsData.FloorAxisInfo.addAxisLineArray = function (builder, axisLineArrayOffset) {
  builder.addFieldOffset(4, axisLineArrayOffset, 0);
};

PMComponentsData.FloorAxisInfo.createAxisLineArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.FloorAxisInfo.startAxisLineArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.FloorAxisInfo.addAxisArcArray = function (builder, axisArcArrayOffset) {
  builder.addFieldOffset(5, axisArcArrayOffset, 0);
};

PMComponentsData.FloorAxisInfo.createAxisArcArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.FloorAxisInfo.startAxisArcArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.FloorAxisInfo.addAxisLineSegArray = function (builder, axisLineSegArrayOffset) {
  builder.addFieldOffset(6, axisLineSegArrayOffset, 0);
};

PMComponentsData.FloorAxisInfo.createAxisLineSegArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.FloorAxisInfo.startAxisLineSegArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.FloorAxisInfo.endFloorAxisInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.FloorAxisInfoDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.FloorAxisInfoDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.FloorAxisInfoDataFile.getRootAsFloorAxisInfoDataFile = function (bb, obj) {
  return (obj || new PMComponentsData.FloorAxisInfoDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.FloorAxisInfoDataFile.prototype.floorAxisInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMComponentsData.FloorAxisInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.FloorAxisInfoDataFile.prototype.floorAxisInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorAxisInfoDataFile.startFloorAxisInfoDataFile = function (builder) {
  builder.startObject(1);
};

PMComponentsData.FloorAxisInfoDataFile.addFloorAxisInfoArray = function (builder, floorAxisInfoArrayOffset) {
  builder.addFieldOffset(0, floorAxisInfoArrayOffset, 0);
};

PMComponentsData.FloorAxisInfoDataFile.createFloorAxisInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.FloorAxisInfoDataFile.startFloorAxisInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.FloorAxisInfoDataFile.endFloorAxisInfoDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.ParamInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.ParamInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.ParamInfo.getRootAsParamInfo = function (bb, obj) {
  return (obj || new PMComponentsData.ParamInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.ParamInfo.prototype.type = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.ParamInfo.prototype.nameID = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.ParamInfo.prototype.valueID = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.ParamInfo.startParamInfo = function (builder) {
  builder.startObject(3);
};

PMComponentsData.ParamInfo.addType = function (builder, type) {
  builder.addFieldInt32(0, type, 0);
};

PMComponentsData.ParamInfo.addNameID = function (builder, nameID) {
  builder.addFieldInt32(1, nameID, 0);
};

PMComponentsData.ParamInfo.addValueID = function (builder, valueID) {
  builder.addFieldInt32(2, valueID, 0);
};

PMComponentsData.ParamInfo.endParamInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.ComidInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.ComidInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.ComidInfo.getRootAsComidInfo = function (bb, obj) {
  return (obj || new PMComponentsData.ComidInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.ComidInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.ComidInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.ComidInfo.prototype.handleArray = function (index, optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

PMComponentsData.ComidInfo.prototype.handleArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ComidInfo.startComidInfo = function (builder) {
  builder.startObject(3);
};

PMComponentsData.ComidInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.ComidInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

PMComponentsData.ComidInfo.addHandleArray = function (builder, handleArrayOffset) {
  builder.addFieldOffset(2, handleArrayOffset, 0);
};

PMComponentsData.ComidInfo.createHandleArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ComidInfo.startHandleArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ComidInfo.endComidInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.ComtypeInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.ComtypeInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.ComtypeInfo.getRootAsComtypeInfo = function (bb, obj) {
  return (obj || new PMComponentsData.ComtypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.ComtypeInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.ComtypeInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.ComtypeInfo.prototype.comidArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMComponentsData.ComidInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.ComtypeInfo.prototype.comidArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ComtypeInfo.prototype.comtypeInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMComponentsData.ComtypeInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.ComtypeInfo.prototype.comtypeInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ComtypeInfo.startComtypeInfo = function (builder) {
  builder.startObject(4);
};

PMComponentsData.ComtypeInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.ComtypeInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

PMComponentsData.ComtypeInfo.addComidArray = function (builder, comidArrayOffset) {
  builder.addFieldOffset(2, comidArrayOffset, 0);
};

PMComponentsData.ComtypeInfo.createComidArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ComtypeInfo.startComidArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ComtypeInfo.addComtypeInfoArray = function (builder, comtypeInfoArrayOffset) {
  builder.addFieldOffset(3, comtypeInfoArrayOffset, 0);
};

PMComponentsData.ComtypeInfo.createComtypeInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ComtypeInfo.startComtypeInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ComtypeInfo.endComtypeInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.BaseComtypeInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.BaseComtypeInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.BaseComtypeInfo.getRootAsBaseComtypeInfo = function (bb, obj) {
  return (obj || new PMComponentsData.BaseComtypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.BaseComtypeInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.BaseComtypeInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.BaseComtypeInfo.prototype.comtypeArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMComponentsData.ComtypeInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.BaseComtypeInfo.prototype.comtypeArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.BaseComtypeInfo.prototype.baseComtypeArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMComponentsData.BaseComtypeInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.BaseComtypeInfo.prototype.baseComtypeArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.BaseComtypeInfo.startBaseComtypeInfo = function (builder) {
  builder.startObject(4);
};

PMComponentsData.BaseComtypeInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.BaseComtypeInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

PMComponentsData.BaseComtypeInfo.addComtypeArray = function (builder, comtypeArrayOffset) {
  builder.addFieldOffset(2, comtypeArrayOffset, 0);
};

PMComponentsData.BaseComtypeInfo.createComtypeArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.BaseComtypeInfo.startComtypeArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.BaseComtypeInfo.addBaseComtypeArray = function (builder, baseComtypeArrayOffset) {
  builder.addFieldOffset(3, baseComtypeArrayOffset, 0);
};

PMComponentsData.BaseComtypeInfo.createBaseComtypeArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.BaseComtypeInfo.startBaseComtypeArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.BaseComtypeInfo.endBaseComtypeInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.FloorInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.FloorInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.FloorInfo.getRootAsFloorInfo = function (bb, obj) {
  return (obj || new PMComponentsData.FloorInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.FloorInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.FloorInfo.prototype.showid = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorInfo.prototype.baseComtypeArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMComponentsData.BaseComtypeInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.FloorInfo.prototype.baseComtypeArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.FloorInfo.startFloorInfo = function (builder) {
  builder.startObject(4);
};

PMComponentsData.FloorInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.FloorInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

PMComponentsData.FloorInfo.addShowid = function (builder, showid) {
  builder.addFieldInt32(2, showid, 0);
};

PMComponentsData.FloorInfo.addBaseComtypeArray = function (builder, baseComtypeArrayOffset) {
  builder.addFieldOffset(3, baseComtypeArrayOffset, 0);
};

PMComponentsData.FloorInfo.createBaseComtypeArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.FloorInfo.startBaseComtypeArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.FloorInfo.endFloorInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.StageInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.StageInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.StageInfo.getRootAsStageInfo = function (bb, obj) {
  return (obj || new PMComponentsData.StageInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.StageInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.StageInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.StageInfo.startStageInfo = function (builder) {
  builder.startObject(2);
};

PMComponentsData.StageInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.StageInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

PMComponentsData.StageInfo.endStageInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.BuildingInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.BuildingInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.BuildingInfo.getRootAsBuildingInfo = function (bb, obj) {
  return (obj || new PMComponentsData.BuildingInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.BuildingInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.BuildingInfo.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.BuildingInfo.prototype.floorInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMComponentsData.FloorInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.BuildingInfo.prototype.floorInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.BuildingInfo.startBuildingInfo = function (builder) {
  builder.startObject(3);
};

PMComponentsData.BuildingInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMComponentsData.BuildingInfo.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

PMComponentsData.BuildingInfo.addFloorInfoArray = function (builder, floorInfoArrayOffset) {
  builder.addFieldOffset(2, floorInfoArrayOffset, 0);
};

PMComponentsData.BuildingInfo.createFloorInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.BuildingInfo.startFloorInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.BuildingInfo.endBuildingInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.HandleInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.HandleInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.HandleInfo.getRootAsHandleInfo = function (bb, obj) {
  return (obj || new PMComponentsData.HandleInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.HandleInfo.prototype.floorid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMComponentsData.HandleInfo.prototype.handle = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMComponentsData.HandleInfo.prototype.parmInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMComponentsData.ParamInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.HandleInfo.prototype.parmInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.HandleInfo.startHandleInfo = function (builder) {
  builder.startObject(3);
};

PMComponentsData.HandleInfo.addFloorid = function (builder, floorid) {
  builder.addFieldInt32(0, floorid, 0);
};

PMComponentsData.HandleInfo.addHandle = function (builder, handleOffset) {
  builder.addFieldOffset(1, handleOffset, 0);
};

PMComponentsData.HandleInfo.addParmInfoArray = function (builder, parmInfoArrayOffset) {
  builder.addFieldOffset(2, parmInfoArrayOffset, 0);
};

PMComponentsData.HandleInfo.createParmInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.HandleInfo.startParmInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.HandleInfo.endHandleInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.ProjectDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.ProjectDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.ProjectDataFile.getRootAsProjectDataFile = function (bb, obj) {
  return (obj || new PMComponentsData.ProjectDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.ProjectDataFile.prototype.buildingInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMComponentsData.BuildingInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.ProjectDataFile.prototype.buildingInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ProjectDataFile.prototype.stageInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMComponentsData.StageInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.ProjectDataFile.prototype.stageInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ProjectDataFile.startProjectDataFile = function (builder) {
  builder.startObject(2);
};

PMComponentsData.ProjectDataFile.addBuildingInfoArray = function (builder, buildingInfoArrayOffset) {
  builder.addFieldOffset(0, buildingInfoArrayOffset, 0);
};

PMComponentsData.ProjectDataFile.createBuildingInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ProjectDataFile.startBuildingInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ProjectDataFile.addStageInfoArray = function (builder, stageInfoArrayOffset) {
  builder.addFieldOffset(1, stageInfoArrayOffset, 0);
};

PMComponentsData.ProjectDataFile.createStageInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ProjectDataFile.startStageInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ProjectDataFile.endProjectDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMComponentsData.ComponentsDataFile = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMComponentsData.ComponentsDataFile.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMComponentsData.ComponentsDataFile.getRootAsComponentsDataFile = function (bb, obj) {
  return (obj || new PMComponentsData.ComponentsDataFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMComponentsData.ComponentsDataFile.prototype.paramTextArray = function (index, optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

PMComponentsData.ComponentsDataFile.prototype.paramTextArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ComponentsDataFile.prototype.handleInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMComponentsData.HandleInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMComponentsData.ComponentsDataFile.prototype.handleInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMComponentsData.ComponentsDataFile.startComponentsDataFile = function (builder) {
  builder.startObject(2);
};

PMComponentsData.ComponentsDataFile.addParamTextArray = function (builder, paramTextArrayOffset) {
  builder.addFieldOffset(0, paramTextArrayOffset, 0);
};

PMComponentsData.ComponentsDataFile.createParamTextArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ComponentsDataFile.startParamTextArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ComponentsDataFile.addHandleInfoArray = function (builder, handleInfoArrayOffset) {
  builder.addFieldOffset(1, handleInfoArrayOffset, 0);
};

PMComponentsData.ComponentsDataFile.createHandleInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMComponentsData.ComponentsDataFile.startHandleInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMComponentsData.ComponentsDataFile.endComponentsDataFile = function (builder) {
  var offset = builder.endObject();
  return offset;
};

this.PMComponentsData = PMComponentsData;

/***/ }),
/* 491 */
/***/ (function(module, exports) {


var ViewInfoSpace = ViewInfoSpace || {};

ViewInfoSpace.Showtype = {
  AllHide: 0,
  AllShow: 1,
  Custom: 2
};

ViewInfoSpace.Vec3 = function () {
  this.bb = null;

  this.bb_pos = 0;
};

ViewInfoSpace.Vec3.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

ViewInfoSpace.Vec3.prototype.x = function () {
  return this.bb.readFloat32(this.bb_pos);
};

ViewInfoSpace.Vec3.prototype.y = function () {
  return this.bb.readFloat32(this.bb_pos + 4);
};

ViewInfoSpace.Vec3.prototype.z = function () {
  return this.bb.readFloat32(this.bb_pos + 8);
};

ViewInfoSpace.Vec3.createVec3 = function (builder, x, y, z) {
  builder.prep(4, 12);
  builder.writeFloat32(z);
  builder.writeFloat32(y);
  builder.writeFloat32(x);
  return builder.offset();
};

ViewInfoSpace.ViewInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

ViewInfoSpace.ViewInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

ViewInfoSpace.ViewInfo.getRootAsViewInfo = function (bb, obj) {
  return (obj || new ViewInfoSpace.ViewInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

ViewInfoSpace.ViewInfo.prototype.cameraInfo = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new ViewInfoSpace.CameraInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

ViewInfoSpace.ViewInfo.prototype.floorInfoArr = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new ViewInfoSpace.FloorInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

ViewInfoSpace.ViewInfo.prototype.floorInfoArrLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

ViewInfoSpace.ViewInfo.prototype.cullPlaneArr = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new ViewInfoSpace.CullPlane()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

ViewInfoSpace.ViewInfo.prototype.cullPlaneArrLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

ViewInfoSpace.ViewInfo.prototype.stageId = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

ViewInfoSpace.ViewInfo.startViewInfo = function (builder) {
  builder.startObject(4);
};

ViewInfoSpace.ViewInfo.addCameraInfo = function (builder, cameraInfoOffset) {
  builder.addFieldOffset(0, cameraInfoOffset, 0);
};

ViewInfoSpace.ViewInfo.addFloorInfoArr = function (builder, floorInfoArrOffset) {
  builder.addFieldOffset(1, floorInfoArrOffset, 0);
};

ViewInfoSpace.ViewInfo.createFloorInfoArrVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

ViewInfoSpace.ViewInfo.startFloorInfoArrVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

ViewInfoSpace.ViewInfo.addCullPlaneArr = function (builder, cullPlaneArrOffset) {
  builder.addFieldOffset(2, cullPlaneArrOffset, 0);
};

ViewInfoSpace.ViewInfo.createCullPlaneArrVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

ViewInfoSpace.ViewInfo.startCullPlaneArrVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

ViewInfoSpace.ViewInfo.addStageId = function (builder, stageId) {
  builder.addFieldInt32(3, stageId, 0);
};

ViewInfoSpace.ViewInfo.endViewInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

ViewInfoSpace.ViewInfo.finishViewInfoBuffer = function (builder, offset) {
  builder.finish(offset);
};

ViewInfoSpace.CameraInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

ViewInfoSpace.CameraInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

ViewInfoSpace.CameraInfo.getRootAsCameraInfo = function (bb, obj) {
  return (obj || new ViewInfoSpace.CameraInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

ViewInfoSpace.CameraInfo.prototype.eyePos = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new ViewInfoSpace.Vec3()).__init(this.bb_pos + offset, this.bb) : null;
};

ViewInfoSpace.CameraInfo.prototype.tarPos = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new ViewInfoSpace.Vec3()).__init(this.bb_pos + offset, this.bb) : null;
};

ViewInfoSpace.CameraInfo.prototype.up = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new ViewInfoSpace.Vec3()).__init(this.bb_pos + offset, this.bb) : null;
};

ViewInfoSpace.CameraInfo.prototype.viewWidth = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

ViewInfoSpace.CameraInfo.prototype.viewHeight = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

ViewInfoSpace.CameraInfo.startCameraInfo = function (builder) {
  builder.startObject(5);
};

ViewInfoSpace.CameraInfo.addEyePos = function (builder, eyePosOffset) {
  builder.addFieldStruct(0, eyePosOffset, 0);
};

ViewInfoSpace.CameraInfo.addTarPos = function (builder, tarPosOffset) {
  builder.addFieldStruct(1, tarPosOffset, 0);
};

ViewInfoSpace.CameraInfo.addUp = function (builder, upOffset) {
  builder.addFieldStruct(2, upOffset, 0);
};

ViewInfoSpace.CameraInfo.addViewWidth = function (builder, viewWidth) {
  builder.addFieldFloat32(3, viewWidth, 0.0);
};

ViewInfoSpace.CameraInfo.addViewHeight = function (builder, viewHeight) {
  builder.addFieldFloat32(4, viewHeight, 0.0);
};

ViewInfoSpace.CameraInfo.endCameraInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

ViewInfoSpace.FloorInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

ViewInfoSpace.FloorInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

ViewInfoSpace.FloorInfo.getRootAsFloorInfo = function (bb, obj) {
  return (obj || new ViewInfoSpace.FloorInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

ViewInfoSpace.FloorInfo.prototype.floorid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

ViewInfoSpace.FloorInfo.prototype.state = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt8(this.bb_pos + offset) : ViewInfoSpace.Showtype.AllHide;
};

ViewInfoSpace.FloorInfo.prototype.comtypeArr = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

ViewInfoSpace.FloorInfo.prototype.comtypeArrLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

ViewInfoSpace.FloorInfo.prototype.comtypeArrArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

ViewInfoSpace.FloorInfo.startFloorInfo = function (builder) {
  builder.startObject(3);
};

ViewInfoSpace.FloorInfo.addFloorid = function (builder, floorid) {
  builder.addFieldInt32(0, floorid, 0);
};

ViewInfoSpace.FloorInfo.addState = function (builder, state) {
  builder.addFieldInt8(1, state, ViewInfoSpace.Showtype.AllHide);
};

ViewInfoSpace.FloorInfo.addComtypeArr = function (builder, comtypeArrOffset) {
  builder.addFieldOffset(2, comtypeArrOffset, 0);
};

ViewInfoSpace.FloorInfo.createComtypeArrVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

ViewInfoSpace.FloorInfo.startComtypeArrVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

ViewInfoSpace.FloorInfo.endFloorInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

ViewInfoSpace.CullPlane = function () {
  this.bb = null;

  this.bb_pos = 0;
};

ViewInfoSpace.CullPlane.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

ViewInfoSpace.CullPlane.getRootAsCullPlane = function (bb, obj) {
  return (obj || new ViewInfoSpace.CullPlane()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

ViewInfoSpace.CullPlane.prototype.A = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

ViewInfoSpace.CullPlane.prototype.B = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

ViewInfoSpace.CullPlane.prototype.C = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

ViewInfoSpace.CullPlane.prototype.D = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

ViewInfoSpace.CullPlane.startCullPlane = function (builder) {
  builder.startObject(4);
};

ViewInfoSpace.CullPlane.addA = function (builder, A) {
  builder.addFieldFloat32(0, A, 0.0);
};

ViewInfoSpace.CullPlane.addB = function (builder, B) {
  builder.addFieldFloat32(1, B, 0.0);
};

ViewInfoSpace.CullPlane.addC = function (builder, C) {
  builder.addFieldFloat32(2, C, 0.0);
};

ViewInfoSpace.CullPlane.addD = function (builder, D) {
  builder.addFieldFloat32(3, D, 0.0);
};

ViewInfoSpace.CullPlane.endCullPlane = function (builder) {
  var offset = builder.endObject();
  return offset;
};

this.ViewInfoSpace = ViewInfoSpace;

/***/ }),
/* 492 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__ = __webpack_require__(493);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__model_classlib_FileIndex__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__model_classlib_SceneNode__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__model_classlib_PageData__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__model_classlib_EntData__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__model_classlib_EntInfo__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__model_classlib_RefDefinition__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__loaders_TGALoader__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__model_classlib_gridBuilder__ = __webpack_require__(503);















function BIMDataFBInterface(fileLoader) {
  var textureType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var isSimColorMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var simColorModeColor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#aaa';

  this.type = 'BIMDataFBInterface';

  this.fileLoader = fileLoader;

  this.textureType = textureType;
  this.isSimColorMode = isSimColorMode;
  this.simColorModeColor = simColorModeColor;

  this.textureLoader = new window.$CCBIM.WebGL.TextureLoader();

  this.TGALoader = new __WEBPACK_IMPORTED_MODULE_12__loaders_TGALoader__["a" /* default */]();

  this.gridMeshGeoMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();
  this.gridMeshEntMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();
  this.gridMeshInfoMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();
}
BIMDataFBInterface.prototype = {
  constructor: BIMDataFBInterface,

  createHeadDataFile: function createHeadDataFile(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    return __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__["PMBIMDataOld"].Head.getRootAsHead(buffer);
  },

  getHeadFileVersion: function getHeadFileVersion() {
    return -1;
  },

  getBasicFileTotal: function getBasicFileTotal(headDataFile) {
    var materialDataFileSize = headDataFile.materialFileListLength();
    var refDefinitionDataFileSize = headDataFile.refSourceFileListLength();
    var componentsFileSize = headDataFile.componentsFileListLength();
    var fileSizeTotal = materialDataFileSize + refDefinitionDataFileSize + componentsFileSize;
    return fileSizeTotal;
  },

  getMaterialDataFileIndexArray: function getMaterialDataFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var indexArray = [];
    for (var i = 0, length = headDataFile.materialFileListLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.materialFileList(i));
      if (!index) {
        continue;
      }
      indexArray.push(index);
    }

    return indexArray;
  },

  getRefDefinitionDataFileIndexArray: function getRefDefinitionDataFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var indexArray = [];
    for (var i = 0, length = headDataFile.refSourceFileListLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.refSourceFileList(i));
      if (!index) {
        continue;
      }
      indexArray.push(index);
    }

    return indexArray;
  },

  createSceneTree: function createSceneTree(nodeData, group) {
    if (!nodeData || !group) {
      return;
    }
    this.groupUserData(nodeData, group);
    this.perOrderKDNode(nodeData, group);
  },

  groupUserData: function groupUserData(node, group) {
    var newGroup = new window.$CCBIM.WebGL.Group();
    group.add(newGroup);

    var sceneNode = new __WEBPACK_IMPORTED_MODULE_7__model_classlib_SceneNode__["a" /* default */]();
    newGroup.name = 'sceneNode';
    newGroup.userData.sceneNode = sceneNode;

    var bndBoxMinArray = node.bndBoxMinArray();
    var bndBoxMaxArray = node.bndBoxMaxArray();
    var bndBoxMin = new window.$CCBIM.WebGL.Vector3(bndBoxMinArray[0], bndBoxMinArray[1], bndBoxMinArray[2]);
    var bndBoxMax = new window.$CCBIM.WebGL.Vector3(bndBoxMaxArray[0], bndBoxMaxArray[1], bndBoxMaxArray[2]);
    sceneNode.setBndBox(new window.$CCBIM.WebGL.Box3(bndBoxMin, bndBoxMax));

    var fixPageData = this.createPageData(node);
    if (fixPageData) {
      fixPageData.setUsage(-1);
      sceneNode.setPageData(fixPageData);
    }
  },

  perOrderKDNode: function perOrderKDNode(node, group) {
    if (node === null) {
      return false;
    }

    if (node.firstChildNode()) {
      this.groupUserData(node.firstChildNode(), group);
      this.perOrderKDNode(node.firstChildNode(), group);
    }

    if (node.secondChildNode()) {
      this.groupUserData(node.secondChildNode(), group);
      this.perOrderKDNode(node.secondChildNode(), group);
    }
    return true;
  },

  createPageData: function createPageData(data) {
    if (!data) {
      return null;
    }

    var pageData = new __WEBPACK_IMPORTED_MODULE_8__model_classlib_PageData__["a" /* default */]();
    for (var j = 0, fileLength = data.urlLength(); j < fileLength; j++) {
      var fileIndex = this.createSceneFileIndex(data.url(j));
      if (!fileIndex) {
        continue;
      }
      pageData.addBufferGeometryFile(fileIndex);
    }
    return pageData;
  },

  createFileIndex: function createFileIndex(data) {
    if (!data) {
      return null;
    }

    var fileIndex = new __WEBPACK_IMPORTED_MODULE_6__model_classlib_FileIndex__["a" /* default */]();
    fileIndex.setID(data.id());
    fileIndex.setURL(data.url());
    fileIndex.setFileSize(data.fileSize());
    return fileIndex;
  },

  createSceneFileIndex: function createSceneFileIndex(data) {
    if (!data) {
      return null;
    }

    var fileIndex = new __WEBPACK_IMPORTED_MODULE_6__model_classlib_FileIndex__["a" /* default */]();

    fileIndex.setURL(data);
    return fileIndex;
  },

  getSceneDataFile: function getSceneDataFile(headDataFile) {
    return new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      if (headDataFile) {
        resolve(headDataFile.sceneTree());
      } else {
        reject();
      }
    });
  },

  getDefaultCamera: function getDefaultCamera(sceneDataFile) {
    var defCamera = sceneDataFile.ProjectViewInfo();
    return {
      position: defCamera.mPositionArray(),
      target: defCamera.mTargetArray(),
      up: defCamera.mUpArray()
    };
  },

  getSceneTreeBndBox: function getSceneTreeBndBox(sceneDataFile) {
    return {
      bndBoxMin: sceneDataFile.bndBoxMinArray(),
      bndBoxMax: sceneDataFile.bndBoxMaxArray()
    };
  },

  getRootNode: function getRootNode(sceneDataFile) {
    return sceneDataFile.root();
  },

  getSceneScale: function getSceneScale(sceneDataFile) {
    return sceneDataFile.scale();
  },

  createMaterialMap: function createMaterialMap(bytes, textureImageMap, materialMap, isInstanceMaterialMap) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var materialDataFile = __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__["PMBIMDataOld"].FileData_Material.getRootAsFileData_Material(buffer);
    for (var i = 0, length = materialDataFile.materialArrayLength(); i < length; i++) {
      var materialData = materialDataFile.materialArray(i);
      var material = null;

      if (materialData.lightType() === 'MeshLambertMaterial') {
        material = new window.$CCBIM.WebGL.MeshLambertMaterial();
      } else {
        material = new window.$CCBIM.WebGL.MeshPhongMaterial();
      }

      material.map = this.getImageData(materialData.image(), textureImageMap);

      material.transparent = materialData.enableTransparent();
      material.opacity = materialData.transparency();

      if (material.opacity > 0.999999 && !material.map) {
        material.transparent = false;
      }
      if (material.transparent && material.opacity === 1) {
        material.blending = window.$CCBIM.WebGL.NormalBlending;
      }

      if (!material.map) {
        material.color = new window.$CCBIM.WebGL.Color(materialData.color());
      }

      material.colorCopy = new window.$CCBIM.WebGL.Color(materialData.color());

      material.flatShading = false;
      material.depthFunc = materialData.depthFunc() === undefined ? 2 : materialData.depthFunc();
      material.blending = window.$CCBIM.WebGL.NormalBlending;
      material.clippingPlanes = window.$CCBIM.clippingPlane;

      material.polygonOffset = materialData.enablePolygonOffset();
      material.polygonOffsetUnits = materialData.polygonOffsetUnits() / 10;
      material.polygonOffsetFactor = materialData.polygonOffsetFactor() / 10;

      material.vertexOffset = materialData.enablePolygonOffset();
      if (material.vertexOffset) {
        material.vertexOffsetValue = -materialData.polygonOffsetFactor() * window.$CCBIM.sceneManager.sceneData.scale;
      }

      if (this.isPhone) {
        material.side = materialData.doubleSide() === true ? 2 : 0;
      } else {
        material.side = 2;
        material.precision = 'highp';
      }

      material.userData.uuid = materialData.uuid();
      if (isInstanceMaterialMap) {
        material.instanceMaterial = true;
        material.userData.uuid = -materialData.uuid();
      }

      if (this.textureType === 1) {
        material.mapCopy = material.map;
        material.map = null;
        material.color = new window.$CCBIM.WebGL.Color(materialData.color());
      }

      if (this.isSimColorMode === true) {
        material.color = new window.$CCBIM.WebGL.Color(this.simColorModeColor);
      }

      materialMap.set(materialData.uuid(), material);
    }
  },

  getImageData: function getImageData(imageData, textureImageMap) {
    if (!imageData) {
      return null;
    }

    var textureImage = textureImageMap.get(imageData.uuid());
    if (textureImage) {
      return textureImage;
    }

    var url = this.fileLoader.getCloudURL() + 'IMG' + imageData.url();
    if (imageData.isUserImage()) {
      var fileIndex = this.fileLoader.getFileIndex(imageData.url());
      if (fileIndex) {
        url = fileIndex.getURL();
      }
    }
    if (url.includes('.tga')) {
      textureImage = this.TGALoader.load(url, function () {
        window.$CCBIM.render.setNeedUpdate();
      }, undefined, function () {
        console.error('An error happened.');
      });
    } else {
      textureImage = this.textureLoader.load(url, function () {
        window.$CCBIM.render.setNeedUpdate();
      }, undefined, function () {
        console.error('An error happened.');
      });
      textureImage.format = window.$CCBIM.WebGL.AlphaFormat;
    }
    textureImage.wrapS = window.$CCBIM.WebGL.RepeatWrapping;
    textureImage.wrapT = window.$CCBIM.WebGL.RepeatWrapping;
    textureImage.anisotropy = window.$CCBIM.webglContext.renderer.capabilities.getMaxAnisotropy();
    textureImageMap.set(imageData.uuid(), textureImage);
    return textureImage;
  },

  createRefDefinitionMap: function createRefDefinitionMap(bytes, materialMap, refDefinitionMap) {

    var buffer = new __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var refDefinitionDataFile = __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__["PMBIMDataOld"].FileData_RefSource.getRootAsFileData_RefSource(buffer);
    var geoMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();
    for (var r = 0, len = refDefinitionDataFile.faceArrayLength(); r < len; r++) {
      var index = refDefinitionDataFile.faceArray(r);
      var geometry = this.addGeometry(index);

      if (!geometry) {
        continue;
      }
      var material = materialMap.get(index.material());
      geoMap.set(geometry.getUUID(), new window.$CCBIM.WebGL.Mesh(geometry, material));
    }

    for (var _r = 0, _len = refDefinitionDataFile.groupArrayLength(); _r < _len; _r++) {
      var groupIndex = refDefinitionDataFile.groupArray(_r);
      var refDefinition = new __WEBPACK_IMPORTED_MODULE_11__model_classlib_RefDefinition__["a" /* RefDefinition */]();
      refDefinition.setUUID(groupIndex.uuid());
      for (var i = 0, il = groupIndex.geoDataArrayLength(); i < il; i++) {
        var geo = geoMap.get(groupIndex.geoDataArray(i));
        if (geo) {
          refDefinition.addRefObject(geo);
        }
      }
      if (refDefinition.getRefObjectArray().length > 0) {
        refDefinitionMap.set(refDefinition.getUUID(), refDefinition);
      }
    }
  },

  addGeometry: function addGeometry(data) {
    var bufferGeometry = new window.$CCBIM.WebGL.PMBufferGeometry();

    var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
    index.setIndex(data.trianglesArray());
    bufferGeometry.addVertexIndex(index);

    bufferGeometry.addBufferAttribute('position', new window.$CCBIM.WebGL.Float32BufferAttributeModel(data.vertexsArray(), 3));
    bufferGeometry.addBufferAttribute('normal', new window.$CCBIM.WebGL.Float32BufferAttributeModel(data.normalsArray(), 3));

    var vertexParams = data.vertexParamsArray();
    if (vertexParams && vertexParams.length > 0) {
      bufferGeometry.addBufferAttribute('uv', new window.$CCBIM.WebGL.Float32BufferAttributeModel(vertexParams, 2));
    }
    bufferGeometry.setUUID(data.uuid());
    return bufferGeometry;
  },

  createBufferGeometryDataFile: function createBufferGeometryDataFile(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    return __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__["PMBIMDataOld"].FileData_EntInfo.getRootAsFileData_EntInfo(buffer);
  },
  createGeometryArray: function createGeometryArray(bufferGeometryDataFile, materialMap, refDefinitionMap, geometryArray) {
    for (var r = 0, len = bufferGeometryDataFile.faceArrayLength(); r < len; r++) {
      var faceData = bufferGeometryDataFile.faceArray(r);
      var bufferGeometry = this.addGeometry(faceData);
      if (!bufferGeometry) {
        continue;
      }
      var material = materialMap.get(faceData.material());
      geometryArray.push(new window.$CCBIM.WebGL.Mesh(bufferGeometry, material));
    }

    var refAttributeMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();
    for (var i = 0, refLen = bufferGeometryDataFile.entReferenceArrayLength(); i < refLen; i++) {
      var entRefIndex = bufferGeometryDataFile.entReferenceArray(i);
      var refDefinition = refDefinitionMap.get(entRefIndex.groupID());
      if (!refDefinition) {
        continue;
      }
      var refObjectArray = refDefinition.getRefObjectArray();
      for (var j = 0, jl = refObjectArray.length; j < jl; j++) {
        var refObject = refObjectArray[j];
        var key = refObject.geometry.getUUID();
        var refAttribute = refAttributeMap.get(key);
        if (!refAttribute) {
          refAttribute = new RefAttributeBuffer();
          refAttribute.refObject = refObject;
          refAttribute.refInstanceID = key.toString() + entRefIndex.uuid().toString();
          refAttributeMap.set(key, refAttribute);
        }
        refAttribute.pushMatrix(entRefIndex.matrixArray());
      }
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(refAttributeMap), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _ref = _step.value;

        var _ref2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref, 2);

        var _key = _ref2[0];
        var refBuffer = _ref2[1];

        var instanceBufferGeo = new window.$CCBIM.WebGL.PMInstanceBufferGeometry();
        instanceBufferGeo.setAttributeArray(refBuffer.refObject.geometry.getAttributeArray());
        instanceBufferGeo.setIndexArray(refBuffer.refObject.geometry.getIndexArray());

        var instanceMatR1 = new window.$CCBIM.WebGL.InstancedBufferAttribute(refBuffer.getInstanceMatR1(), 4, false, 1);
        instanceBufferGeo.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR1.name, instanceMatR1);
        var instanceMatR2 = new window.$CCBIM.WebGL.InstancedBufferAttribute(refBuffer.getInstanceMatR2(), 4, false, 1);
        instanceBufferGeo.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR2.name, instanceMatR2);
        var instanceMatR3 = new window.$CCBIM.WebGL.InstancedBufferAttribute(refBuffer.getInstanceMatR3(), 4, false, 1);
        instanceBufferGeo.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR3.name, instanceMatR3);
        var instanceMatR4 = new window.$CCBIM.WebGL.InstancedBufferAttribute(refBuffer.getInstanceMatR4(), 4, false, 1);
        instanceBufferGeo.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR4.name, instanceMatR4);

        var count = instanceBufferGeo.getInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.MatrixR1.name).count;
        var instanceStateBuffer = new Float32Array(count * window.$CCBIM.WebGL.PMInstanceAttribute.State.itemSize);
        for (var k = 0; k < count; k++) {
          instanceStateBuffer[k * window.$CCBIM.WebGL.PMInstanceAttribute.State.itemSize] = 1.0;
        }
        instanceBufferGeo.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.State.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(instanceStateBuffer, window.$CCBIM.WebGL.PMInstanceAttribute.State.itemSize, false, 1));

        var colorBuffer = new Float32Array(count * window.$CCBIM.WebGL.PMInstanceAttribute.Color.itemSize);
        instanceBufferGeo.addInstanceBufferAttribute(window.$CCBIM.WebGL.PMInstanceAttribute.Color.name, new window.$CCBIM.WebGL.InstancedBufferAttribute(colorBuffer, window.$CCBIM.WebGL.PMInstanceAttribute.Color.itemSize, false, 1));
        instanceBufferGeo.setInstancedCount(count);
        instanceBufferGeo.setUUID(refBuffer.refInstanceID);
        var instanceMesh = new window.$CCBIM.WebGL.InstancedMesh(instanceBufferGeo, refBuffer.refObject.material);
        geometryArray.push(instanceMesh);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  },

  createEntInfoEntDataArray: function createEntInfoEntDataArray(entInfoDataFile, refDefinitionMap, entInfoArray, entDataArray) {
    var findEntInfoMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();

    for (var i = 0, il = entInfoDataFile.entInfoArrayLength(); i < il; i++) {
      var obj = entInfoDataFile.entInfoArray(i);
      var entInfo = new __WEBPACK_IMPORTED_MODULE_10__model_classlib_EntInfo__["a" /* EntInfo */]();
      entInfo.setEntInfo(obj.id(), obj.flootID(), obj.comtype(), obj.comID(), obj.handle());
      entInfo.setSelectAbility(obj.selectAbility());
      for (var j = 0, jl = obj.stageArrayLength(); j < jl; j++) {
        entInfo.addStage(obj.stageArray(j));
      }
      for (var _j = 0, _jl = obj.entDataArrayLength(); _j < _jl; _j++) {
        findEntInfoMap.set(obj.entDataArray(_j), entInfo.getID());
      }
      entInfoArray.push(entInfo);
    }

    for (var _i = 0, _il = entInfoDataFile.entTriangleArrayLength(); _i < _il; _i++) {
      var _obj = entInfoDataFile.entTriangleArray(_i);
      var meshData = new __WEBPACK_IMPORTED_MODULE_9__model_classlib_EntData__["b" /* MeshData */]();
      var entID = findEntInfoMap.get(_obj.uuid());
      if (entID) {
        meshData.setEntID(entID);
      }
      var bndBoxMin = new window.$CCBIM.WebGL.Vector3(_obj.bndBoxMin(0), _obj.bndBoxMin(1), _obj.bndBoxMin(2));
      var bndBoxMax = new window.$CCBIM.WebGL.Vector3(_obj.bndBoxMax(0), _obj.bndBoxMax(1), _obj.bndBoxMax(2));
      meshData.setBndBox(bndBoxMin, bndBoxMax);
      meshData.setGeoID(_obj.faceID());
      meshData.setPosition(_obj.vertexOffset(), _obj.vertexCount());
      meshData.setTriangle(_obj.trianglesOffset(), _obj.trianglesCount());
      entDataArray.push(meshData);
    }

    var refAttributeMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();
    var tempMatrix = new window.$CCBIM.WebGL.Matrix4();
    for (var _i2 = 0, _il2 = entInfoDataFile.entReferenceArrayLength(); _i2 < _il2; _i2++) {
      var entRefIndex = entInfoDataFile.entReferenceArray(_i2);
      var refDefinition = refDefinitionMap.get(entRefIndex.groupID());
      if (!refDefinition || !refDefinition.getBndBox()) {
        continue;
      }
      var matrixArray = entRefIndex.matrixArray();
      tempMatrix.set(matrixArray[0], matrixArray[4], matrixArray[8], matrixArray[12], matrixArray[1], matrixArray[5], matrixArray[9], matrixArray[13], matrixArray[2], matrixArray[6], matrixArray[10], matrixArray[14], matrixArray[3], matrixArray[7], matrixArray[11], matrixArray[15]);
      var bndBox = refDefinition.getBndBox().clone();
      bndBox.applyMatrix4(tempMatrix);
      var _entID = findEntInfoMap.get(entRefIndex.uuid());
      var refObjectArray = refDefinition.getRefObjectArray();
      for (var _j2 = 0, _jl2 = refObjectArray.length; _j2 < _jl2; _j2++) {
        var refObject = refObjectArray[_j2];
        var key = refObject.geometry.getUUID();
        var refAttribute = refAttributeMap.get(key);
        if (!refAttribute) {
          refAttribute = new RefAttributeBuffer();
          refAttribute.refInstanceID = key.toString() + entRefIndex.uuid().toString();
          refAttributeMap.set(key, refAttribute);
        }

        var instanceMeshData = new __WEBPACK_IMPORTED_MODULE_9__model_classlib_EntData__["c" /* InstanceMeshData */]();
        instanceMeshData.setEntID(_entID);
        var _bndBoxMin = new window.$CCBIM.WebGL.Vector3(entRefIndex.bndBoxMin(0), entRefIndex.bndBoxMin(1), entRefIndex.bndBoxMin(2));
        var _bndBoxMax = new window.$CCBIM.WebGL.Vector3(entRefIndex.bndBoxMax(0), entRefIndex.bndBoxMax(1), entRefIndex.bndBoxMax(2));

        instanceMeshData.bndBox = bndBox.clone();
        instanceMeshData.setGeoID(refAttribute.refInstanceID);
        instanceMeshData.setMatrixIndex(refAttribute.curMatrixIndex);
        entDataArray.push(instanceMeshData);

        refAttribute.curMatrixIndex++;
      }
    }

    findEntInfoMap = null;
  },

  getProjectFileIndex: function getProjectFileIndex(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var projectFile = null;
    for (var i = 0, length = headDataFile.componentsFileListLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.componentsFileList(i));
      if (!index) {
        continue;
      }
      if (index.url === 'Components.bin') {
        projectFile = index;
      }
    }

    return projectFile;
  },

  getFloorAxisFileIndexArray: function getFloorAxisFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var indexArray = [];
    for (var i = 0, length = headDataFile.componentsFileListLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.componentsFileList(i));
      if (!index) {
        continue;
      }
      if (index.url === 'floorCrossLine.bin') {
        indexArray.push(index);
      }
    }

    return indexArray;
  },

  getTerrainFileIndexArray: function getTerrainFileIndexArray(headDataFile) {
    if (!headDataFile) {
      return null;
    }

    var indexArray = [];
    for (var i = 0, length = headDataFile.meshFileListLength(); i < length; i++) {
      var index = this.createFileIndex(headDataFile.meshFileList(i));
      if (!index) {
        continue;
      }
      indexArray.push(index);
    }

    return indexArray;
  },

  addTerrainGeometry: function addTerrainGeometry(meshGeoArray, ent) {
    var grid = new __WEBPACK_IMPORTED_MODULE_13__model_classlib_gridBuilder__["a" /* default */](meshGeoArray, ent);
    var attribute = grid.getAttribute();

    var bufferGeometry = new window.$CCBIM.WebGL.PMBufferGeometry();

    var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
    index.setIndex(attribute.index);
    bufferGeometry.addVertexIndex(index);

    bufferGeometry.addBufferAttribute('position', new window.$CCBIM.WebGL.Float32BufferAttribute(attribute.position, 3));
    bufferGeometry.addBufferAttribute('uv', new window.$CCBIM.WebGL.Float32BufferAttribute(attribute.uv, 2));
    bufferGeometry.computeVertexNormals();
    bufferGeometry.setUUID(ent.meshID);
    return bufferGeometry;
  },
  addTerrainOtherGeometry: function addTerrainOtherGeometry(faceIndex) {
    var bufferGeometry = new window.$CCBIM.WebGL.PMBufferGeometry();

    var index = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
    index.setIndex(faceIndex.triangles);
    bufferGeometry.addVertexIndex(index);

    bufferGeometry.addBufferAttribute('position', new window.$CCBIM.WebGL.Float32BufferAttributeModel(faceIndex.vertexs, 3));
    bufferGeometry.addBufferAttribute('normal', new window.$CCBIM.WebGL.Float32BufferAttributeModel(faceIndex.normals, 3));

    var vertexParams = faceIndex.vertexParams;
    if (vertexParams && vertexParams.length > 0) {
      bufferGeometry.addBufferAttribute('uv', new window.$CCBIM.WebGL.Float32BufferAttributeModel(vertexParams, 2));
    }

    bufferGeometry.setUUID(faceIndex.uuid);
    return bufferGeometry;
  },
  createTerrainDataFile: function createTerrainDataFile(bytes) {
    this.gridMeshGeoMap.clear();
    this.gridMeshEntMap.clear();
    this.gridMeshInfoMap.clear();
    var buffer = new __WEBPACK_IMPORTED_MODULE_4__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    return __WEBPACK_IMPORTED_MODULE_5__flatBuffers_sceneGraph_BIMData_generated_js__["PMBIMDataOld"].FileData_MeshInfo.getRootAsFileData_MeshInfo(buffer);
  },
  setTerrainDataMap: function setTerrainDataMap(bufferDataFile) {
    var meshGeoArray = [];
    for (var i = 0, len = bufferDataFile.meshGeoArrayLength(); i < len; i++) {
      var index = bufferDataFile.meshGeoArray(i);

      var otherFaceArray = [];
      for (var f = 0, otherFaceLen = index.otherFaceLength(); f < otherFaceLen; f++) {
        var otherIndex = index.otherFace(f);

        var otherFace = {
          uuid: otherIndex.uuid(),
          vertexs: otherIndex.vertexsArray(),
          triangles: otherIndex.trianglesArray(),
          normals: otherIndex.normalsArray(),
          vertexParams: otherIndex.vertexParamsArray(),
          material: otherIndex.material()
        };
        otherFaceArray.push(otherFace);
      }
      var obj = {
        uuid: index.uuid(),
        origin: index.originArray(),
        columnCount: index.columnCount(),
        rowCount: index.rowCount(),
        gridSize: index.gridSize(),
        material: index.material(),
        otherFace: otherFaceArray
      };
      meshGeoArray.push(obj);
    }
    for (var m = 0; m < meshGeoArray.length; m++) {
      this.gridMeshGeoMap.set(meshGeoArray[m].uuid, meshGeoArray[m]);
    }

    var meshEntArray = [];
    for (var _i3 = 0, _len2 = bufferDataFile.meshEntArrLength(); _i3 < _len2; _i3++) {
      var _index = bufferDataFile.meshEntArr(_i3);

      var _obj2 = {
        uuid: _index.uuid(),
        bndBoxMin: _index.bndBoxMinArray(),
        bndBoxMax: _index.bndBoxMaxArray(),
        meshID: _index.meshID(),
        columnOffset: _index.columnOffset(),
        columnCount: _index.columnCount(),
        rowOffset: _index.rowOffset(),
        rowCount: _index.rowCount(),
        vertexColPos: _index.vertexColPosArray(),
        vertexRowPos: _index.vertexRowPosArray(),
        vertexHeight: _index.vertexHeightArray()
      };
      meshEntArray.push(_obj2);
    }
    for (var e = 0; e < meshEntArray.length; e++) {
      this.gridMeshEntMap.set(meshEntArray[e].uuid, meshEntArray[e]);
    }

    var entInfoArray = [];
    for (var _i4 = 0, _len3 = bufferDataFile.entInfoArrayLength(); _i4 < _len3; _i4++) {
      var _index2 = bufferDataFile.entInfoArray(_i4);

      var _obj3 = {
        id: _index2.id(),
        floorId: _index2.flootID(),
        comtype: _index2.comtype(),
        comID: _index2.comID(),
        handle: _index2.handle(),
        selectAbility: _index2.selectAbility(),
        stageArray: Array.prototype.slice.call(_index2.stageArrayArray()),
        entDataArray: Array.prototype.slice.call(_index2.entDataArrayArray())
      };
      entInfoArray.push(_obj3);
    }
    for (var _f = 0; _f < entInfoArray.length; _f++) {
      var _index3 = entInfoArray[_f];
      for (var ed = 0, entDataLen = _index3.entDataArray.length; ed < entDataLen; ed++) {
        this.gridMeshInfoMap.set(_index3.entDataArray[ed], _index3);
      }
    }
  },
  getGridMeshEntMap: function getGridMeshEntMap() {
    return this.gridMeshEntMap;
  },
  getGridMeshInfoMap: function getGridMeshInfoMap() {
    return this.gridMeshInfoMap;
  },
  getGridMeshGeoMap: function getGridMeshGeoMap() {
    return this.gridMeshGeoMap;
  },

  createGridEntInfoEntDataArray: function createGridEntInfoEntDataArray(entInfoArrayList, meshTriangleList, faceTriangleList, entInfoArray, entDataArray) {
    var findEntInfoMap = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_map___default.a();

    for (var i = 0, il = entInfoArrayList.length; i < il; i++) {
      var obj = entInfoArrayList[i];
      var entInfo = new __WEBPACK_IMPORTED_MODULE_10__model_classlib_EntInfo__["a" /* EntInfo */]();
      entInfo.setEntInfo(obj.id, obj.floorId, obj.comtype, obj.comID, obj.handle);
      entInfo.setSelectAbility(obj.selectAbility);
      for (var j = 0, jl = obj.stageArray.length; j < jl; j++) {
        entInfo.addStage(obj.stageArray[j]);
      }
      for (var _j3 = 0, _jl3 = obj.entDataArray.length; _j3 < _jl3; _j3++) {
        findEntInfoMap.set(obj.entDataArray[_j3], entInfo.getID());
      }
      entInfoArray.push(entInfo);
    }

    var bndBoxMin = void 0;
    var bndBoxMax = void 0;

    for (var _i5 = 0, _il3 = meshTriangleList.length; _i5 < _il3; _i5++) {
      var _obj4 = meshTriangleList[_i5];
      var gridMeshGeoMap = this.getGridMeshGeoMap();
      var meshGeoArray = gridMeshGeoMap.get(_obj4.meshID);
      var grid = new __WEBPACK_IMPORTED_MODULE_13__model_classlib_gridBuilder__["a" /* default */](meshGeoArray, _obj4);
      var attribute = grid.getAttribute();

      var meshData = new __WEBPACK_IMPORTED_MODULE_9__model_classlib_EntData__["b" /* MeshData */]();
      var entID = findEntInfoMap.get(_obj4.uuid);
      if (entID) {
        meshData.setEntID(entID);
      }
      if (!bndBoxMin) {
        bndBoxMin = new window.$CCBIM.WebGL.Vector3(_obj4.bndBoxMin[0], _obj4.bndBoxMin[1], _obj4.bndBoxMin[2]);
        bndBoxMax = new window.$CCBIM.WebGL.Vector3(_obj4.bndBoxMax[0], _obj4.bndBoxMax[1], _obj4.bndBoxMax[2]);
      }
      meshData.setBndBox(bndBoxMin, bndBoxMax);
      meshData.setGeoID(_obj4.meshID);
      meshData.setPosition(0, attribute.position.length);
      meshData.setTriangle(0, attribute.index.length / 3);
      entDataArray.push(meshData);
    }

    for (var _i6 = 0, _il4 = faceTriangleList.length; _i6 < _il4; _i6++) {
      for (var _j4 = 0, _jl4 = faceTriangleList[_i6].otherFace.length; _j4 < _jl4; _j4++) {
        var face = faceTriangleList[_i6].otherFace[_j4];

        var bufferGeometry = new window.$CCBIM.WebGL.PMBufferGeometry();

        var _meshData = new __WEBPACK_IMPORTED_MODULE_9__model_classlib_EntData__["b" /* MeshData */]();
        _meshData.setBndBox(bndBoxMin, bndBoxMax);
        _meshData.setGeoID(face.uuid);
        _meshData.setPosition(0, face.vertexs.length / 3);
        _meshData.setTriangle(0, face.triangles.length / 3);
        entDataArray.push(_meshData);
      }
    }
  }
};

function RefAttributeBuffer() {
  this.instanceMatR1 = [];
  this.instanceMatR2 = [];
  this.instanceMatR3 = [];
  this.instanceMatR4 = [];

  this.refObject = null;
  this.refInstanceID = '';
  this.curMatrixIndex = 0;
}
RefAttributeBuffer.prototype = {
  constructor: RefAttributeBuffer,
  getInstanceMatR1: function getInstanceMatR1() {
    return this.getFloat32Array(this.instanceMatR1);
  },
  getInstanceMatR2: function getInstanceMatR2() {
    return this.getFloat32Array(this.instanceMatR2);
  },
  getInstanceMatR3: function getInstanceMatR3() {
    return this.getFloat32Array(this.instanceMatR3);
  },
  getInstanceMatR4: function getInstanceMatR4() {
    return this.getFloat32Array(this.instanceMatR4);
  },
  getInstanceColorKey: function getInstanceColorKey() {
    return this.instanceColorKey;
  },
  getFloat32Array: function getFloat32Array(array) {
    var size = array.length;
    var buffer = new Float32Array(size);
    for (var i = 0; i < size; i++) {
      buffer[i] = array[i];
    }
    return buffer;
  },
  clearInstanceMat: function clearInstanceMat() {
    this.instanceMatR1 = null;
    this.instanceMatR2 = null;
    this.instanceMatR3 = null;
    this.instanceMatR4 = null;
  },

  pushMatrix: function pushMatrix(matrix) {
    this.instanceMatR1.push(matrix[0]);
    this.instanceMatR1.push(matrix[1]);
    this.instanceMatR1.push(matrix[2]);
    this.instanceMatR1.push(matrix[3]);
    this.instanceMatR2.push(matrix[4]);
    this.instanceMatR2.push(matrix[5]);
    this.instanceMatR2.push(matrix[6]);
    this.instanceMatR2.push(matrix[7]);
    this.instanceMatR3.push(matrix[8]);
    this.instanceMatR3.push(matrix[9]);
    this.instanceMatR3.push(matrix[10]);
    this.instanceMatR3.push(matrix[11]);
    this.instanceMatR4.push(matrix[12]);
    this.instanceMatR4.push(matrix[13]);
    this.instanceMatR4.push(matrix[14]);
    this.instanceMatR4.push(matrix[15]);
  }
};

/* harmony default export */ __webpack_exports__["a"] = (BIMDataFBInterface);

/***/ }),
/* 493 */
/***/ (function(module, exports) {


var PMBIMDataOld = PMBIMDataOld || {};

PMBIMDataOld.Image = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.Image.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.Image.getRootAsImage = function (bb, obj) {
  return (obj || new PMBIMDataOld.Image()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.Image.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Image.prototype.url = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.Image.prototype.isUserImage = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBIMDataOld.Image.startImage = function (builder) {
  builder.startObject(3);
};

PMBIMDataOld.Image.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.Image.addUrl = function (builder, urlOffset) {
  builder.addFieldOffset(1, urlOffset, 0);
};

PMBIMDataOld.Image.addIsUserImage = function (builder, isUserImage) {
  builder.addFieldInt8(2, +isUserImage, +false);
};

PMBIMDataOld.Image.endImage = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.Material = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.Material.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.Material.getRootAsMaterial = function (bb, obj) {
  return (obj || new PMBIMDataOld.Material()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.Material.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Material.prototype.image = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.Image()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBIMDataOld.Material.prototype.lightType = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.Material.prototype.color = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.Material.prototype.transparency = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMBIMDataOld.Material.prototype.enableTransparent = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBIMDataOld.Material.prototype.depthFunc = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Material.prototype.polygonOffsetFactor = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Material.prototype.polygonOffsetUnits = function () {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Material.prototype.enablePolygonOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBIMDataOld.Material.prototype.doubleSide = function () {
  var offset = this.bb.__offset(this.bb_pos, 24);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBIMDataOld.Material.startMaterial = function (builder) {
  builder.startObject(11);
};

PMBIMDataOld.Material.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.Material.addImage = function (builder, imageOffset) {
  builder.addFieldOffset(1, imageOffset, 0);
};

PMBIMDataOld.Material.addLightType = function (builder, lightTypeOffset) {
  builder.addFieldOffset(2, lightTypeOffset, 0);
};

PMBIMDataOld.Material.addColor = function (builder, colorOffset) {
  builder.addFieldOffset(3, colorOffset, 0);
};

PMBIMDataOld.Material.addTransparency = function (builder, transparency) {
  builder.addFieldFloat32(4, transparency, 0.0);
};

PMBIMDataOld.Material.addEnableTransparent = function (builder, enableTransparent) {
  builder.addFieldInt8(5, +enableTransparent, +false);
};

PMBIMDataOld.Material.addDepthFunc = function (builder, depthFunc) {
  builder.addFieldInt32(6, depthFunc, 0);
};

PMBIMDataOld.Material.addPolygonOffsetFactor = function (builder, polygonOffsetFactor) {
  builder.addFieldInt32(7, polygonOffsetFactor, 0);
};

PMBIMDataOld.Material.addPolygonOffsetUnits = function (builder, polygonOffsetUnits) {
  builder.addFieldInt32(8, polygonOffsetUnits, 0);
};

PMBIMDataOld.Material.addEnablePolygonOffset = function (builder, enablePolygonOffset) {
  builder.addFieldInt8(9, +enablePolygonOffset, +false);
};

PMBIMDataOld.Material.addDoubleSide = function (builder, doubleSide) {
  builder.addFieldInt8(10, +doubleSide, +false);
};

PMBIMDataOld.Material.endMaterial = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.FileData_Material = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.FileData_Material.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.FileData_Material.getRootAsFileData_Material = function (bb, obj) {
  return (obj || new PMBIMDataOld.FileData_Material()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.FileData_Material.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_Material.prototype.materialArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.Material()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_Material.prototype.materialArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_Material.startFileData_Material = function (builder) {
  builder.startObject(2);
};

PMBIMDataOld.FileData_Material.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.FileData_Material.addMaterialArray = function (builder, materialArrayOffset) {
  builder.addFieldOffset(1, materialArrayOffset, 0);
};

PMBIMDataOld.FileData_Material.createMaterialArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_Material.startMaterialArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_Material.endFileData_Material = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.GeoData_Line = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.GeoData_Line.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.GeoData_Line.getRootAsGeoData_Line = function (bb, obj) {
  return (obj || new PMBIMDataOld.GeoData_Line()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.GeoData_Line.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Line.prototype.vertexs = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Line.prototype.vertexsLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Line.prototype.vertexsArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Line.prototype.width = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMBIMDataOld.GeoData_Line.prototype.color = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.GeoData_Line.startGeoData_Line = function (builder) {
  builder.startObject(4);
};

PMBIMDataOld.GeoData_Line.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.GeoData_Line.addVertexs = function (builder, vertexsOffset) {
  builder.addFieldOffset(1, vertexsOffset, 0);
};

PMBIMDataOld.GeoData_Line.createVertexsVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Line.startVertexsVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Line.addWidth = function (builder, width) {
  builder.addFieldFloat32(2, width, 0.0);
};

PMBIMDataOld.GeoData_Line.addColor = function (builder, colorOffset) {
  builder.addFieldOffset(3, colorOffset, 0);
};

PMBIMDataOld.GeoData_Line.endGeoData_Line = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.GeoData_Face = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.GeoData_Face.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.GeoData_Face.getRootAsGeoData_Face = function (bb, obj) {
  return (obj || new PMBIMDataOld.GeoData_Face()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.GeoData_Face.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.vertexs = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.vertexsLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.vertexsArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Face.prototype.triangles = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.trianglesLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.trianglesArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Face.prototype.normals = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.normalsLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.normalsArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Face.prototype.vertexParams = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.vertexParamsLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Face.prototype.vertexParamsArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Face.prototype.material = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Face.startGeoData_Face = function (builder) {
  builder.startObject(6);
};

PMBIMDataOld.GeoData_Face.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.GeoData_Face.addVertexs = function (builder, vertexsOffset) {
  builder.addFieldOffset(1, vertexsOffset, 0);
};

PMBIMDataOld.GeoData_Face.createVertexsVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Face.startVertexsVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Face.addTriangles = function (builder, trianglesOffset) {
  builder.addFieldOffset(2, trianglesOffset, 0);
};

PMBIMDataOld.GeoData_Face.createTrianglesVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Face.startTrianglesVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Face.addNormals = function (builder, normalsOffset) {
  builder.addFieldOffset(3, normalsOffset, 0);
};

PMBIMDataOld.GeoData_Face.createNormalsVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Face.startNormalsVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Face.addVertexParams = function (builder, vertexParamsOffset) {
  builder.addFieldOffset(4, vertexParamsOffset, 0);
};

PMBIMDataOld.GeoData_Face.createVertexParamsVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Face.startVertexParamsVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Face.addMaterial = function (builder, material) {
  builder.addFieldInt32(5, material, 0);
};

PMBIMDataOld.GeoData_Face.endGeoData_Face = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.GeoData_Mesh = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.GeoData_Mesh.getRootAsGeoData_Mesh = function (bb, obj) {
  return (obj || new PMBIMDataOld.GeoData_Mesh()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.GeoData_Mesh.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.origin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.originLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.originArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Mesh.prototype.columnCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.rowCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.gridSize = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMBIMDataOld.GeoData_Mesh.prototype.material = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Mesh.prototype.otherFace = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? (obj || new PMBIMDataOld.GeoData_Face()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.GeoData_Mesh.prototype.otherFaceLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Mesh.startGeoData_Mesh = function (builder) {
  builder.startObject(7);
};

PMBIMDataOld.GeoData_Mesh.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.GeoData_Mesh.addOrigin = function (builder, originOffset) {
  builder.addFieldOffset(1, originOffset, 0);
};

PMBIMDataOld.GeoData_Mesh.createOriginVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Mesh.startOriginVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Mesh.addColumnCount = function (builder, columnCount) {
  builder.addFieldInt16(2, columnCount, 0);
};

PMBIMDataOld.GeoData_Mesh.addRowCount = function (builder, rowCount) {
  builder.addFieldInt16(3, rowCount, 0);
};

PMBIMDataOld.GeoData_Mesh.addGridSize = function (builder, gridSize) {
  builder.addFieldFloat32(4, gridSize, 0.0);
};

PMBIMDataOld.GeoData_Mesh.addMaterial = function (builder, material) {
  builder.addFieldInt32(5, material, 0);
};

PMBIMDataOld.GeoData_Mesh.addOtherFace = function (builder, otherFaceOffset) {
  builder.addFieldOffset(6, otherFaceOffset, 0);
};

PMBIMDataOld.GeoData_Mesh.createOtherFaceVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Mesh.startOtherFaceVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Mesh.endGeoData_Mesh = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.GeoData_Group = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.GeoData_Group.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.GeoData_Group.getRootAsGeoData_Group = function (bb, obj) {
  return (obj || new PMBIMDataOld.GeoData_Group()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.GeoData_Group.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Group.prototype.geoDataArray = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.GeoData_Group.prototype.geoDataArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.GeoData_Group.prototype.geoDataArrayArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.GeoData_Group.startGeoData_Group = function (builder) {
  builder.startObject(2);
};

PMBIMDataOld.GeoData_Group.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.GeoData_Group.addGeoDataArray = function (builder, geoDataArrayOffset) {
  builder.addFieldOffset(1, geoDataArrayOffset, 0);
};

PMBIMDataOld.GeoData_Group.createGeoDataArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.GeoData_Group.startGeoDataArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.GeoData_Group.endGeoData_Group = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.FileData_RefSource = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.FileData_RefSource.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.FileData_RefSource.getRootAsFileData_RefSource = function (bb, obj) {
  return (obj || new PMBIMDataOld.FileData_RefSource()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.FileData_RefSource.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_RefSource.prototype.lineArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.GeoData_Line()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_RefSource.prototype.lineArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_RefSource.prototype.faceArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMBIMDataOld.GeoData_Face()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_RefSource.prototype.faceArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_RefSource.prototype.groupArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMBIMDataOld.GeoData_Group()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_RefSource.prototype.groupArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_RefSource.startFileData_RefSource = function (builder) {
  builder.startObject(4);
};

PMBIMDataOld.FileData_RefSource.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.FileData_RefSource.addLineArray = function (builder, lineArrayOffset) {
  builder.addFieldOffset(1, lineArrayOffset, 0);
};

PMBIMDataOld.FileData_RefSource.createLineArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_RefSource.startLineArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_RefSource.addFaceArray = function (builder, faceArrayOffset) {
  builder.addFieldOffset(2, faceArrayOffset, 0);
};

PMBIMDataOld.FileData_RefSource.createFaceArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_RefSource.startFaceArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_RefSource.addGroupArray = function (builder, groupArrayOffset) {
  builder.addFieldOffset(3, groupArrayOffset, 0);
};

PMBIMDataOld.FileData_RefSource.createGroupArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_RefSource.startGroupArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_RefSource.endFileData_RefSource = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.EntData_Triangle = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.EntData_Triangle.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.EntData_Triangle.getRootAsEntData_Triangle = function (bb, obj) {
  return (obj || new PMBIMDataOld.EntData_Triangle()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.EntData_Triangle.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Triangle.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Triangle.prototype.faceID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.vertexOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.vertexCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.vertexParamsOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.vertexParamsCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.trianglesOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.prototype.trianglesCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Triangle.startEntData_Triangle = function (builder) {
  builder.startObject(10);
};

PMBIMDataOld.EntData_Triangle.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.EntData_Triangle.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(1, bndBoxMinOffset, 0);
};

PMBIMDataOld.EntData_Triangle.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Triangle.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Triangle.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(2, bndBoxMaxOffset, 0);
};

PMBIMDataOld.EntData_Triangle.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Triangle.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Triangle.addFaceID = function (builder, faceID) {
  builder.addFieldInt32(3, faceID, 0);
};

PMBIMDataOld.EntData_Triangle.addVertexOffset = function (builder, vertexOffset) {
  builder.addFieldInt32(4, vertexOffset, 0);
};

PMBIMDataOld.EntData_Triangle.addVertexCount = function (builder, vertexCount) {
  builder.addFieldInt32(5, vertexCount, 0);
};

PMBIMDataOld.EntData_Triangle.addVertexParamsOffset = function (builder, vertexParamsOffset) {
  builder.addFieldInt32(6, vertexParamsOffset, 0);
};

PMBIMDataOld.EntData_Triangle.addVertexParamsCount = function (builder, vertexParamsCount) {
  builder.addFieldInt32(7, vertexParamsCount, 0);
};

PMBIMDataOld.EntData_Triangle.addTrianglesOffset = function (builder, trianglesOffset) {
  builder.addFieldInt32(8, trianglesOffset, 0);
};

PMBIMDataOld.EntData_Triangle.addTrianglesCount = function (builder, trianglesCount) {
  builder.addFieldInt32(9, trianglesCount, 0);
};

PMBIMDataOld.EntData_Triangle.endEntData_Triangle = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.EntData_Reference = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.EntData_Reference.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.EntData_Reference.getRootAsEntData_Reference = function (bb, obj) {
  return (obj || new PMBIMDataOld.EntData_Reference()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.EntData_Reference.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Reference.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Reference.prototype.groupID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.matrix = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.matrixLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Reference.prototype.matrixArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Reference.startEntData_Reference = function (builder) {
  builder.startObject(5);
};

PMBIMDataOld.EntData_Reference.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.EntData_Reference.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(1, bndBoxMinOffset, 0);
};

PMBIMDataOld.EntData_Reference.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Reference.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Reference.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(2, bndBoxMaxOffset, 0);
};

PMBIMDataOld.EntData_Reference.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Reference.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Reference.addGroupID = function (builder, groupID) {
  builder.addFieldInt32(3, groupID, 0);
};

PMBIMDataOld.EntData_Reference.addMatrix = function (builder, matrixOffset) {
  builder.addFieldOffset(4, matrixOffset, 0);
};

PMBIMDataOld.EntData_Reference.createMatrixVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Reference.startMatrixVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Reference.endEntData_Reference = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.EntData_Mesh = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.EntData_Mesh.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.EntData_Mesh.getRootAsEntData_Mesh = function (bb, obj) {
  return (obj || new PMBIMDataOld.EntData_Mesh()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.EntData_Mesh.prototype.uuid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Mesh.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Mesh.prototype.meshID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.columnOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.columnCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.rowOffset = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.rowCount = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexColPos = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexColPosLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexColPosArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexRowPos = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? this.bb.readUint16(this.bb.__vector(this.bb_pos + offset) + index * 2) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexRowPosLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexRowPosArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 22);
  return offset ? new Uint16Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexHeight = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 24);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexHeightLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 24);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntData_Mesh.prototype.vertexHeightArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 24);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntData_Mesh.startEntData_Mesh = function (builder) {
  builder.startObject(11);
};

PMBIMDataOld.EntData_Mesh.addUuid = function (builder, uuid) {
  builder.addFieldInt32(0, uuid, 0);
};

PMBIMDataOld.EntData_Mesh.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(1, bndBoxMinOffset, 0);
};

PMBIMDataOld.EntData_Mesh.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Mesh.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Mesh.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(2, bndBoxMaxOffset, 0);
};

PMBIMDataOld.EntData_Mesh.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Mesh.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Mesh.addMeshID = function (builder, meshID) {
  builder.addFieldInt32(3, meshID, 0);
};

PMBIMDataOld.EntData_Mesh.addColumnOffset = function (builder, columnOffset) {
  builder.addFieldInt16(4, columnOffset, 0);
};

PMBIMDataOld.EntData_Mesh.addColumnCount = function (builder, columnCount) {
  builder.addFieldInt16(5, columnCount, 0);
};

PMBIMDataOld.EntData_Mesh.addRowOffset = function (builder, rowOffset) {
  builder.addFieldInt16(6, rowOffset, 0);
};

PMBIMDataOld.EntData_Mesh.addRowCount = function (builder, rowCount) {
  builder.addFieldInt16(7, rowCount, 0);
};

PMBIMDataOld.EntData_Mesh.addVertexColPos = function (builder, vertexColPosOffset) {
  builder.addFieldOffset(8, vertexColPosOffset, 0);
};

PMBIMDataOld.EntData_Mesh.createVertexColPosVector = function (builder, data) {
  builder.startVector(2, data.length, 2);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt16(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Mesh.startVertexColPosVector = function (builder, numElems) {
  builder.startVector(2, numElems, 2);
};

PMBIMDataOld.EntData_Mesh.addVertexRowPos = function (builder, vertexRowPosOffset) {
  builder.addFieldOffset(9, vertexRowPosOffset, 0);
};

PMBIMDataOld.EntData_Mesh.createVertexRowPosVector = function (builder, data) {
  builder.startVector(2, data.length, 2);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt16(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Mesh.startVertexRowPosVector = function (builder, numElems) {
  builder.startVector(2, numElems, 2);
};

PMBIMDataOld.EntData_Mesh.addVertexHeight = function (builder, vertexHeightOffset) {
  builder.addFieldOffset(10, vertexHeightOffset, 0);
};

PMBIMDataOld.EntData_Mesh.createVertexHeightVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntData_Mesh.startVertexHeightVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntData_Mesh.endEntData_Mesh = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.FileData_MeshInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.FileData_MeshInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.FileData_MeshInfo.getRootAsFileData_MeshInfo = function (bb, obj) {
  return (obj || new PMBIMDataOld.FileData_MeshInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.FileData_MeshInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_MeshInfo.prototype.meshGeoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.GeoData_Mesh()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_MeshInfo.prototype.meshGeoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_MeshInfo.prototype.meshEntArr = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMBIMDataOld.EntData_Mesh()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_MeshInfo.prototype.meshEntArrLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_MeshInfo.prototype.entInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMBIMDataOld.EntInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_MeshInfo.prototype.entInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_MeshInfo.startFileData_MeshInfo = function (builder) {
  builder.startObject(4);
};

PMBIMDataOld.FileData_MeshInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.FileData_MeshInfo.addMeshGeoArray = function (builder, meshGeoArrayOffset) {
  builder.addFieldOffset(1, meshGeoArrayOffset, 0);
};

PMBIMDataOld.FileData_MeshInfo.createMeshGeoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_MeshInfo.startMeshGeoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_MeshInfo.addMeshEntArr = function (builder, meshEntArrOffset) {
  builder.addFieldOffset(2, meshEntArrOffset, 0);
};

PMBIMDataOld.FileData_MeshInfo.createMeshEntArrVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_MeshInfo.startMeshEntArrVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_MeshInfo.addEntInfoArray = function (builder, entInfoArrayOffset) {
  builder.addFieldOffset(3, entInfoArrayOffset, 0);
};

PMBIMDataOld.FileData_MeshInfo.createEntInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_MeshInfo.startEntInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_MeshInfo.endFileData_MeshInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.EntInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.EntInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.EntInfo.getRootAsEntInfo = function (bb, obj) {
  return (obj || new PMBIMDataOld.EntInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.EntInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntInfo.prototype.flootID = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntInfo.prototype.comtype = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntInfo.prototype.comID = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntInfo.prototype.handle = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.EntInfo.prototype.selectAbility = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
};

PMBIMDataOld.EntInfo.prototype.stageArray = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntInfo.prototype.stageArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntInfo.prototype.stageArrayArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntInfo.prototype.entDataArray = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.EntInfo.prototype.entDataArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.EntInfo.prototype.entDataArrayArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.EntInfo.startEntInfo = function (builder) {
  builder.startObject(8);
};

PMBIMDataOld.EntInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.EntInfo.addFlootID = function (builder, flootID) {
  builder.addFieldInt32(1, flootID, 0);
};

PMBIMDataOld.EntInfo.addComtype = function (builder, comtype) {
  builder.addFieldInt32(2, comtype, 0);
};

PMBIMDataOld.EntInfo.addComID = function (builder, comID) {
  builder.addFieldInt32(3, comID, 0);
};

PMBIMDataOld.EntInfo.addHandle = function (builder, handleOffset) {
  builder.addFieldOffset(4, handleOffset, 0);
};

PMBIMDataOld.EntInfo.addSelectAbility = function (builder, selectAbility) {
  builder.addFieldInt8(5, +selectAbility, +false);
};

PMBIMDataOld.EntInfo.addStageArray = function (builder, stageArrayOffset) {
  builder.addFieldOffset(6, stageArrayOffset, 0);
};

PMBIMDataOld.EntInfo.createStageArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntInfo.startStageArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntInfo.addEntDataArray = function (builder, entDataArrayOffset) {
  builder.addFieldOffset(7, entDataArrayOffset, 0);
};

PMBIMDataOld.EntInfo.createEntDataArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.EntInfo.startEntDataArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.EntInfo.endEntInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.FileData_EntInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.FileData_EntInfo.getRootAsFileData_EntInfo = function (bb, obj) {
  return (obj || new PMBIMDataOld.FileData_EntInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.FileData_EntInfo.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.lineArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.GeoData_Line()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_EntInfo.prototype.lineArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.faceArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMBIMDataOld.GeoData_Face()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_EntInfo.prototype.faceArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.entTriangleArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMBIMDataOld.EntData_Triangle()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_EntInfo.prototype.entTriangleArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.entReferenceArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new PMBIMDataOld.EntData_Reference()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_EntInfo.prototype.entReferenceArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.entInfoArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new PMBIMDataOld.EntInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.FileData_EntInfo.prototype.entInfoArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.level = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.levelLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileData_EntInfo.prototype.levelArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.FileData_EntInfo.startFileData_EntInfo = function (builder) {
  builder.startObject(7);
};

PMBIMDataOld.FileData_EntInfo.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.FileData_EntInfo.addLineArray = function (builder, lineArrayOffset) {
  builder.addFieldOffset(1, lineArrayOffset, 0);
};

PMBIMDataOld.FileData_EntInfo.createLineArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_EntInfo.startLineArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_EntInfo.addFaceArray = function (builder, faceArrayOffset) {
  builder.addFieldOffset(2, faceArrayOffset, 0);
};

PMBIMDataOld.FileData_EntInfo.createFaceArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_EntInfo.startFaceArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_EntInfo.addEntTriangleArray = function (builder, entTriangleArrayOffset) {
  builder.addFieldOffset(3, entTriangleArrayOffset, 0);
};

PMBIMDataOld.FileData_EntInfo.createEntTriangleArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_EntInfo.startEntTriangleArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_EntInfo.addEntReferenceArray = function (builder, entReferenceArrayOffset) {
  builder.addFieldOffset(4, entReferenceArrayOffset, 0);
};

PMBIMDataOld.FileData_EntInfo.createEntReferenceArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_EntInfo.startEntReferenceArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_EntInfo.addEntInfoArray = function (builder, entInfoArrayOffset) {
  builder.addFieldOffset(5, entInfoArrayOffset, 0);
};

PMBIMDataOld.FileData_EntInfo.createEntInfoArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_EntInfo.startEntInfoArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_EntInfo.addLevel = function (builder, levelOffset) {
  builder.addFieldOffset(6, levelOffset, 0);
};

PMBIMDataOld.FileData_EntInfo.createLevelVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.FileData_EntInfo.startLevelVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.FileData_EntInfo.endFileData_EntInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.FileIndex = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.FileIndex.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.FileIndex.getRootAsFileIndex = function (bb, obj) {
  return (obj || new PMBIMDataOld.FileIndex()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.FileIndex.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileIndex.prototype.url = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.FileIndex.prototype.fileSize = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FileIndex.startFileIndex = function (builder) {
  builder.startObject(3);
};

PMBIMDataOld.FileIndex.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.FileIndex.addUrl = function (builder, urlOffset) {
  builder.addFieldOffset(1, urlOffset, 0);
};

PMBIMDataOld.FileIndex.addFileSize = function (builder, fileSize) {
  builder.addFieldInt32(2, fileSize, 0);
};

PMBIMDataOld.FileIndex.endFileIndex = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.ViewInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.ViewInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.ViewInfo.getRootAsViewInfo = function (bb, obj) {
  return (obj || new PMBIMDataOld.ViewInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.ViewInfo.prototype.mPosition = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.ViewInfo.prototype.mPositionLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.ViewInfo.prototype.mPositionArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.ViewInfo.prototype.mTarget = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.ViewInfo.prototype.mTargetLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.ViewInfo.prototype.mTargetArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.ViewInfo.prototype.mUp = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.ViewInfo.prototype.mUpLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.ViewInfo.prototype.mUpArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.ViewInfo.startViewInfo = function (builder) {
  builder.startObject(3);
};

PMBIMDataOld.ViewInfo.addMPosition = function (builder, mPositionOffset) {
  builder.addFieldOffset(0, mPositionOffset, 0);
};

PMBIMDataOld.ViewInfo.createMPositionVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.ViewInfo.startMPositionVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.ViewInfo.addMTarget = function (builder, mTargetOffset) {
  builder.addFieldOffset(1, mTargetOffset, 0);
};

PMBIMDataOld.ViewInfo.createMTargetVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.ViewInfo.startMTargetVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.ViewInfo.addMUp = function (builder, mUpOffset) {
  builder.addFieldOffset(2, mUpOffset, 0);
};

PMBIMDataOld.ViewInfo.createMUpVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.ViewInfo.startMUpVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.ViewInfo.endViewInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.KDNode = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.KDNode.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.KDNode.getRootAsKDNode = function (bb, obj) {
  return (obj || new PMBIMDataOld.KDNode()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.KDNode.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.KDNode.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.KDNode.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.KDNode.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.KDNode.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.KDNode.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.KDNode.prototype.fileID = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.KDNode.prototype.fileIDLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.KDNode.prototype.fileIDArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.KDNode.prototype.url = function (index, optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

PMBIMDataOld.KDNode.prototype.urlLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.KDNode.prototype.firstChildNode = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new PMBIMDataOld.KDNode()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBIMDataOld.KDNode.prototype.secondChildNode = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new PMBIMDataOld.KDNode()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBIMDataOld.KDNode.startKDNode = function (builder) {
  builder.startObject(6);
};

PMBIMDataOld.KDNode.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(0, bndBoxMinOffset, 0);
};

PMBIMDataOld.KDNode.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.KDNode.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.KDNode.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(1, bndBoxMaxOffset, 0);
};

PMBIMDataOld.KDNode.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.KDNode.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.KDNode.addFileID = function (builder, fileIDOffset) {
  builder.addFieldOffset(2, fileIDOffset, 0);
};

PMBIMDataOld.KDNode.createFileIDVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.KDNode.startFileIDVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.KDNode.addUrl = function (builder, urlOffset) {
  builder.addFieldOffset(3, urlOffset, 0);
};

PMBIMDataOld.KDNode.createUrlVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.KDNode.startUrlVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.KDNode.addFirstChildNode = function (builder, firstChildNodeOffset) {
  builder.addFieldOffset(4, firstChildNodeOffset, 0);
};

PMBIMDataOld.KDNode.addSecondChildNode = function (builder, secondChildNodeOffset) {
  builder.addFieldOffset(5, secondChildNodeOffset, 0);
};

PMBIMDataOld.KDNode.endKDNode = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.FloorInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.FloorInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.FloorInfo.getRootAsFloorInfo = function (bb, obj) {
  return (obj || new PMBIMDataOld.FloorInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.FloorInfo.prototype.floorid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.FloorInfo.prototype.floorName = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.FloorInfo.startFloorInfo = function (builder) {
  builder.startObject(2);
};

PMBIMDataOld.FloorInfo.addFloorid = function (builder, floorid) {
  builder.addFieldInt32(0, floorid, 0);
};

PMBIMDataOld.FloorInfo.addFloorName = function (builder, floorNameOffset) {
  builder.addFieldOffset(1, floorNameOffset, 0);
};

PMBIMDataOld.FloorInfo.endFloorInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.SceneTree = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.SceneTree.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.SceneTree.getRootAsSceneTree = function (bb, obj) {
  return (obj || new PMBIMDataOld.SceneTree()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.SceneTree.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

PMBIMDataOld.SceneTree.prototype.root = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.KDNode()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBIMDataOld.SceneTree.prototype.projectName = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

PMBIMDataOld.SceneTree.prototype.ProjectViewInfo = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMBIMDataOld.ViewInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBIMDataOld.SceneTree.prototype.bndBoxMin = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.SceneTree.prototype.bndBoxMinLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.SceneTree.prototype.bndBoxMinArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.SceneTree.prototype.bndBoxMax = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

PMBIMDataOld.SceneTree.prototype.bndBoxMaxLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.SceneTree.prototype.bndBoxMaxArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

PMBIMDataOld.SceneTree.prototype.scale = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

PMBIMDataOld.SceneTree.prototype.floorList = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? (obj || new PMBIMDataOld.FloorInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.SceneTree.prototype.floorListLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.SceneTree.startSceneTree = function (builder) {
  builder.startObject(8);
};

PMBIMDataOld.SceneTree.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

PMBIMDataOld.SceneTree.addRoot = function (builder, rootOffset) {
  builder.addFieldOffset(1, rootOffset, 0);
};

PMBIMDataOld.SceneTree.addProjectName = function (builder, projectNameOffset) {
  builder.addFieldOffset(2, projectNameOffset, 0);
};

PMBIMDataOld.SceneTree.addProjectViewInfo = function (builder, ProjectViewInfoOffset) {
  builder.addFieldOffset(3, ProjectViewInfoOffset, 0);
};

PMBIMDataOld.SceneTree.addBndBoxMin = function (builder, bndBoxMinOffset) {
  builder.addFieldOffset(4, bndBoxMinOffset, 0);
};

PMBIMDataOld.SceneTree.createBndBoxMinVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.SceneTree.startBndBoxMinVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.SceneTree.addBndBoxMax = function (builder, bndBoxMaxOffset) {
  builder.addFieldOffset(5, bndBoxMaxOffset, 0);
};

PMBIMDataOld.SceneTree.createBndBoxMaxVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.SceneTree.startBndBoxMaxVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.SceneTree.addScale = function (builder, scale) {
  builder.addFieldFloat32(6, scale, 0.0);
};

PMBIMDataOld.SceneTree.addFloorList = function (builder, floorListOffset) {
  builder.addFieldOffset(7, floorListOffset, 0);
};

PMBIMDataOld.SceneTree.createFloorListVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.SceneTree.startFloorListVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.SceneTree.endSceneTree = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.Head = function () {
  this.bb = null;

  this.bb_pos = 0;
};

PMBIMDataOld.Head.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

PMBIMDataOld.Head.getRootAsHead = function (bb, obj) {
  return (obj || new PMBIMDataOld.Head()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

PMBIMDataOld.Head.prototype.materialFileList = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new PMBIMDataOld.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.Head.prototype.materialFileListLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Head.prototype.refSourceFileList = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new PMBIMDataOld.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.Head.prototype.refSourceFileListLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Head.prototype.entFileList = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new PMBIMDataOld.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.Head.prototype.entFileListLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Head.prototype.componentsFileList = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new PMBIMDataOld.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.Head.prototype.componentsFileListLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Head.prototype.meshFileList = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new PMBIMDataOld.FileIndex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

PMBIMDataOld.Head.prototype.meshFileListLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

PMBIMDataOld.Head.prototype.sceneTree = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new PMBIMDataOld.SceneTree()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

PMBIMDataOld.Head.startHead = function (builder) {
  builder.startObject(6);
};

PMBIMDataOld.Head.addMaterialFileList = function (builder, materialFileListOffset) {
  builder.addFieldOffset(0, materialFileListOffset, 0);
};

PMBIMDataOld.Head.createMaterialFileListVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.Head.startMaterialFileListVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.Head.addRefSourceFileList = function (builder, refSourceFileListOffset) {
  builder.addFieldOffset(1, refSourceFileListOffset, 0);
};

PMBIMDataOld.Head.createRefSourceFileListVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.Head.startRefSourceFileListVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.Head.addEntFileList = function (builder, entFileListOffset) {
  builder.addFieldOffset(2, entFileListOffset, 0);
};

PMBIMDataOld.Head.createEntFileListVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.Head.startEntFileListVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.Head.addComponentsFileList = function (builder, componentsFileListOffset) {
  builder.addFieldOffset(3, componentsFileListOffset, 0);
};

PMBIMDataOld.Head.createComponentsFileListVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.Head.startComponentsFileListVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.Head.addMeshFileList = function (builder, meshFileListOffset) {
  builder.addFieldOffset(4, meshFileListOffset, 0);
};

PMBIMDataOld.Head.createMeshFileListVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

PMBIMDataOld.Head.startMeshFileListVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

PMBIMDataOld.Head.addSceneTree = function (builder, sceneTreeOffset) {
  builder.addFieldOffset(5, sceneTreeOffset, 0);
};

PMBIMDataOld.Head.endHead = function (builder) {
  var offset = builder.endObject();
  return offset;
};

PMBIMDataOld.Head.finishHeadBuffer = function (builder, offset) {
  builder.finish(offset);
};

this.PMBIMDataOld = PMBIMDataOld;

/***/ }),
/* 494 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_sceneGraph_component_generated_js__ = __webpack_require__(495);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_sceneGraph_component_generated_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__flatBuffers_sceneGraph_component_generated_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__ = __webpack_require__(185);




function ComponentFBInterface() {
  this.type = 'ComponentFBInterface';
}

ComponentFBInterface.prototype = {
  constructor: ComponentFBInterface,

  createBuildingInfoArray: function createBuildingInfoArray(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var buildInfo = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_sceneGraph_component_generated_js__["FlatSceneGraph"].CComponentsInfoAddBuildinfo.getRootAsCComponentsInfoAddBuildinfo(buffer);
    var buildProject = buildInfo.mPBuildproject();

    var buildingInfoArray = [];
    for (var i = 0, buildsLength = buildProject.buildsLength(); i < buildsLength; i++) {
      var buildingInfo = this.createBuildingInfo(buildProject.builds(i));
      if (buildingInfo.floorInfoArray.length > 0) {
        buildingInfoArray.push(buildingInfo);
      }
    }
    return buildingInfoArray;
  },

  createBuildingInfo: function createBuildingInfo(buildingInfoObj) {
    var buildingInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["a" /* BuildingInfo */](buildingInfoObj.buildid(), buildingInfoObj.buildname());
    for (var i = 0, il = buildingInfoObj.floorsLength(); i < il; i++) {
      var floorInfo = this.createFloorInfo(buildingInfoObj.floors(i));
      if (floorInfo.baseComtypeInfoArray.length > 0) {
        buildingInfo.addFloorInfo(floorInfo);
      }
    }
    return buildingInfo;
  },

  createFloorInfo: function createFloorInfo(floorInfoObj) {
    var floorInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["b" /* FloorInfo */](floorInfoObj.floorid(), floorInfoObj.floorname());
    for (var i = 0, il = floorInfoObj.comtypeGroupInfoLength(); i < il; i++) {
      var baseComtypeInfo = this.createBaseComtypeInfo(floorInfoObj.comtypeGroupInfo(i));
      floorInfo.addBaseComtypeInfo(baseComtypeInfo);
    }
    return floorInfo;
  },

  createBaseComtypeInfo: function createBaseComtypeInfo(baseComtypeObj) {
    var baseComtypeInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["c" /* BaseComtypeInfo */](baseComtypeObj.bId(), baseComtypeObj.bName());
    for (var i = 0, il = baseComtypeObj.subcomtypeInfoLength(); i < il; i++) {
      var comtypeInfo = this.createComtypeInfo(baseComtypeObj.subcomtypeInfo(i));
      baseComtypeInfo.addComtypeInfo(comtypeInfo);
    }
    return baseComtypeInfo;
  },

  createComtypeInfo: function createComtypeInfo(comtypeObj) {
    var comtypeInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["d" /* ComtypeInfo */](comtypeObj.id(), comtypeObj.name());
    for (var i = 0, il = comtypeObj.gjInfoLength(); i < il; i++) {
      var comidInfo = this.createComidInfo(comtypeObj.gjInfo(i));
      comtypeInfo.addComidInfo(comidInfo);
    }
    for (var _i = 0, _il = comtypeObj.subcomtypeInfoLength(); _i < _il; _i++) {
      var child = this.createComtypeInfo(comtypeObj.subcomtypeInfo(_i));
      comtypeInfo.addComtypeInfo(child);
    }
    return comtypeInfo;
  },
  createComidInfo: function createComidInfo(comidObj) {
    var comidInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["e" /* ComidInfo */](comidObj.id(), comidObj.name());
    for (var i = 0, il = comidObj.handleInfoLength(); i < il; i++) {
      comidInfo.addHandle(comidObj.handleInfo(i));
    }
    return comidInfo;
  },

  createStageInfoArray: function createStageInfoArray(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var buildInfo = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_sceneGraph_component_generated_js__["FlatSceneGraph"].CComponentsInfoAddBuildinfo.getRootAsCComponentsInfoAddBuildinfo(buffer);
    var buildProject = buildInfo.mPBuildproject();
    var stageInfoArray = [];
    for (var s = 0, stagesLength = buildProject.stagesLength(); s < stagesLength; s++) {
      var stagesIndex = buildProject.stages(s);
      var stageInfo = new __WEBPACK_IMPORTED_MODULE_2__model_classlib_ProjectData__["f" /* StageInfo */](stagesIndex.stageid(), stagesIndex.stagename());
      stageInfoArray.push(stageInfo);
    }
    return stageInfoArray;
  },

  createFloorCrossLine: function createFloorCrossLine(bytes) {
    var buffer = new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_flatbuffers_js__["flatbuffers"].ByteBuffer(new Uint8Array(bytes));
    var floorCrossLine = __WEBPACK_IMPORTED_MODULE_1__flatBuffers_sceneGraph_component_generated_js__["FlatSceneGraph"].FloorCrossLineGroup.getRootAsFloorCrossLineGroup(buffer);
    var floorCrossLineGroup = [];
    for (var i = 0; i < floorCrossLine.floorPlanGraphLength(); i++) {
      var index = floorCrossLine.floorPlanGraph(i);

      var lineGroup = [];
      for (var j = 0; j < index.axisNetLineArrayLength(); j++) {
        var lineIndex = index.axisNetLineArray(j);
        var lineObj = {
          textHeight: lineIndex.textHeight(),
          textRoundRadius: lineIndex.textRoundRadius(),
          name: lineIndex.name(),
          textInsert: lineIndex.textInsertArray(),
          start: lineIndex.startArray(),
          end: lineIndex.endArray()
        };
        lineGroup.push(lineObj);
      }

      var arcGroup = [];
      for (var m = 0; m < index.axisNetArcArrayLength(); m++) {
        var arcIndex = index.axisNetArcArray(m);
        var arcObj = {
          textHeight: arcIndex.textHeight(),
          textRoundRadius: arcIndex.textRoundRadius(),
          name: arcIndex.name(),
          textInsert: arcIndex.textInsertArray(),
          center: arcIndex.centerArray(),
          radius: arcIndex.radius(),
          startAngle: arcIndex.startAngle(),
          endAngle: arcIndex.endAngle(),
          antiClockWise: arcIndex.antiClockWise()
        };
        arcGroup.push(arcObj);
      }

      var crossGroup = [];
      for (var n = 0; n < index.crossLinesLength(); n++) {
        var crossIndex = index.crossLines(n);
        var crossObj = {
          start: Array.prototype.slice.call(crossIndex.startArray()),
          end: Array.prototype.slice.call(crossIndex.endArray())
        };
        crossGroup.push(crossObj);
      }

      var obj = {
        floorId: index.floorId(),
        floorHeight: index.floorHeight(),
        floorElevation: index.floorElevation(),
        floorName: index.floorName(),
        axisNetLineArray: lineGroup,
        axisNetArcArray: arcGroup,
        crossLines: crossGroup
      };
      floorCrossLineGroup.push(obj);
    }
    return floorCrossLineGroup;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (ComponentFBInterface);

/***/ }),
/* 495 */
/***/ (function(module, exports) {


var FlatSceneGraph = FlatSceneGraph || {};

FlatSceneGraph.AxisNetLine = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.AxisNetLine.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.AxisNetLine.getRootAsAxisNetLine = function (bb, obj) {
  return (obj || new FlatSceneGraph.AxisNetLine()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.AxisNetLine.prototype.textHeight = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetLine.prototype.textRoundRadius = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetLine.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.AxisNetLine.prototype.textInsert = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.AxisNetLine.prototype.textInsertLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.AxisNetLine.prototype.textInsertArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.AxisNetLine.prototype.start = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.AxisNetLine.prototype.startLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.AxisNetLine.prototype.startArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.AxisNetLine.prototype.end = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.AxisNetLine.prototype.endLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.AxisNetLine.prototype.endArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.AxisNetLine.startAxisNetLine = function (builder) {
  builder.startObject(6);
};

FlatSceneGraph.AxisNetLine.addTextHeight = function (builder, textHeight) {
  builder.addFieldFloat32(0, textHeight, 0.0);
};

FlatSceneGraph.AxisNetLine.addTextRoundRadius = function (builder, textRoundRadius) {
  builder.addFieldFloat32(1, textRoundRadius, 0.0);
};

FlatSceneGraph.AxisNetLine.addName = function (builder, nameOffset) {
  builder.addFieldOffset(2, nameOffset, 0);
};

FlatSceneGraph.AxisNetLine.addTextInsert = function (builder, textInsertOffset) {
  builder.addFieldOffset(3, textInsertOffset, 0);
};

FlatSceneGraph.AxisNetLine.createTextInsertVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.AxisNetLine.startTextInsertVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.AxisNetLine.addStart = function (builder, startOffset) {
  builder.addFieldOffset(4, startOffset, 0);
};

FlatSceneGraph.AxisNetLine.createStartVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.AxisNetLine.startStartVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.AxisNetLine.addEnd = function (builder, endOffset) {
  builder.addFieldOffset(5, endOffset, 0);
};

FlatSceneGraph.AxisNetLine.createEndVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.AxisNetLine.startEndVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.AxisNetLine.endAxisNetLine = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.AxisNetArc = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.AxisNetArc.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.AxisNetArc.getRootAsAxisNetArc = function (bb, obj) {
  return (obj || new FlatSceneGraph.AxisNetArc()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.AxisNetArc.prototype.textHeight = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetArc.prototype.textRoundRadius = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetArc.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.AxisNetArc.prototype.textInsert = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.AxisNetArc.prototype.textInsertLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.AxisNetArc.prototype.textInsertArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.AxisNetArc.prototype.center = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.AxisNetArc.prototype.centerLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.AxisNetArc.prototype.centerArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.AxisNetArc.prototype.radius = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetArc.prototype.startAngle = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetArc.prototype.endAngle = function () {
  var offset = this.bb.__offset(this.bb_pos, 18);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.AxisNetArc.prototype.antiClockWise = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 20);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.AxisNetArc.startAxisNetArc = function (builder) {
  builder.startObject(9);
};

FlatSceneGraph.AxisNetArc.addTextHeight = function (builder, textHeight) {
  builder.addFieldFloat32(0, textHeight, 0.0);
};

FlatSceneGraph.AxisNetArc.addTextRoundRadius = function (builder, textRoundRadius) {
  builder.addFieldFloat32(1, textRoundRadius, 0.0);
};

FlatSceneGraph.AxisNetArc.addName = function (builder, nameOffset) {
  builder.addFieldOffset(2, nameOffset, 0);
};

FlatSceneGraph.AxisNetArc.addTextInsert = function (builder, textInsertOffset) {
  builder.addFieldOffset(3, textInsertOffset, 0);
};

FlatSceneGraph.AxisNetArc.createTextInsertVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.AxisNetArc.startTextInsertVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.AxisNetArc.addCenter = function (builder, centerOffset) {
  builder.addFieldOffset(4, centerOffset, 0);
};

FlatSceneGraph.AxisNetArc.createCenterVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.AxisNetArc.startCenterVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.AxisNetArc.addRadius = function (builder, radius) {
  builder.addFieldFloat32(5, radius, 0.0);
};

FlatSceneGraph.AxisNetArc.addStartAngle = function (builder, startAngle) {
  builder.addFieldFloat32(6, startAngle, 0.0);
};

FlatSceneGraph.AxisNetArc.addEndAngle = function (builder, endAngle) {
  builder.addFieldFloat32(7, endAngle, 0.0);
};

FlatSceneGraph.AxisNetArc.addAntiClockWise = function (builder, antiClockWiseOffset) {
  builder.addFieldOffset(8, antiClockWiseOffset, 0);
};

FlatSceneGraph.AxisNetArc.endAxisNetArc = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.line = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.line.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.line.getRootAsline = function (bb, obj) {
  return (obj || new FlatSceneGraph.line()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.line.prototype.start = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.line.prototype.startLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.line.prototype.startArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.line.prototype.end = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.line.prototype.endLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.line.prototype.endArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.line.startline = function (builder) {
  builder.startObject(2);
};

FlatSceneGraph.line.addStart = function (builder, startOffset) {
  builder.addFieldOffset(0, startOffset, 0);
};

FlatSceneGraph.line.createStartVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.line.startStartVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.line.addEnd = function (builder, endOffset) {
  builder.addFieldOffset(1, endOffset, 0);
};

FlatSceneGraph.line.createEndVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.line.startEndVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.line.endline = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.OneFloorCrossLineInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.OneFloorCrossLineInfo.getRootAsOneFloorCrossLineInfo = function (bb, obj) {
  return (obj || new FlatSceneGraph.OneFloorCrossLineInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.floorId = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.floorHeight = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.floorElevation = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.floorName = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.axisNetLineArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new FlatSceneGraph.AxisNetLine()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.axisNetLineArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.axisNetArcArray = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new FlatSceneGraph.AxisNetArc()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.axisNetArcArrayLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.crossLines = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? (obj || new FlatSceneGraph.line()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.OneFloorCrossLineInfo.prototype.crossLinesLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 16);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.OneFloorCrossLineInfo.startOneFloorCrossLineInfo = function (builder) {
  builder.startObject(7);
};

FlatSceneGraph.OneFloorCrossLineInfo.addFloorId = function (builder, floorId) {
  builder.addFieldInt32(0, floorId, 0);
};

FlatSceneGraph.OneFloorCrossLineInfo.addFloorHeight = function (builder, floorHeight) {
  builder.addFieldFloat32(1, floorHeight, 0.0);
};

FlatSceneGraph.OneFloorCrossLineInfo.addFloorElevation = function (builder, floorElevation) {
  builder.addFieldFloat32(2, floorElevation, 0.0);
};

FlatSceneGraph.OneFloorCrossLineInfo.addFloorName = function (builder, floorNameOffset) {
  builder.addFieldOffset(3, floorNameOffset, 0);
};

FlatSceneGraph.OneFloorCrossLineInfo.addAxisNetLineArray = function (builder, axisNetLineArrayOffset) {
  builder.addFieldOffset(4, axisNetLineArrayOffset, 0);
};

FlatSceneGraph.OneFloorCrossLineInfo.createAxisNetLineArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.OneFloorCrossLineInfo.startAxisNetLineArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.OneFloorCrossLineInfo.addAxisNetArcArray = function (builder, axisNetArcArrayOffset) {
  builder.addFieldOffset(5, axisNetArcArrayOffset, 0);
};

FlatSceneGraph.OneFloorCrossLineInfo.createAxisNetArcArrayVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.OneFloorCrossLineInfo.startAxisNetArcArrayVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.OneFloorCrossLineInfo.addCrossLines = function (builder, crossLinesOffset) {
  builder.addFieldOffset(6, crossLinesOffset, 0);
};

FlatSceneGraph.OneFloorCrossLineInfo.createCrossLinesVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.OneFloorCrossLineInfo.startCrossLinesVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.OneFloorCrossLineInfo.endOneFloorCrossLineInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.FloorCrossLineGroup = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.FloorCrossLineGroup.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.FloorCrossLineGroup.getRootAsFloorCrossLineGroup = function (bb, obj) {
  return (obj || new FlatSceneGraph.FloorCrossLineGroup()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.FloorCrossLineGroup.prototype.floorPlanGraph = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new FlatSceneGraph.OneFloorCrossLineInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.FloorCrossLineGroup.prototype.floorPlanGraphLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.FloorCrossLineGroup.startFloorCrossLineGroup = function (builder) {
  builder.startObject(1);
};

FlatSceneGraph.FloorCrossLineGroup.addFloorPlanGraph = function (builder, floorPlanGraphOffset) {
  builder.addFieldOffset(0, floorPlanGraphOffset, 0);
};

FlatSceneGraph.FloorCrossLineGroup.createFloorPlanGraphVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.FloorCrossLineGroup.startFloorPlanGraphVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.FloorCrossLineGroup.endFloorCrossLineGroup = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.GjInfo_index = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.GjInfo_index.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.GjInfo_index.getRootAsGjInfo_index = function (bb, obj) {
  return (obj || new FlatSceneGraph.GjInfo_index()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.GjInfo_index.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.GjInfo_index.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.GjInfo_index.prototype.handleInfo = function (index, optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

FlatSceneGraph.GjInfo_index.prototype.handleInfoLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.GjInfo_index.startGjInfo_index = function (builder) {
  builder.startObject(3);
};

FlatSceneGraph.GjInfo_index.addName = function (builder, nameOffset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

FlatSceneGraph.GjInfo_index.addId = function (builder, id) {
  builder.addFieldInt32(1, id, 0);
};

FlatSceneGraph.GjInfo_index.addHandleInfo = function (builder, handleInfoOffset) {
  builder.addFieldOffset(2, handleInfoOffset, 0);
};

FlatSceneGraph.GjInfo_index.createHandleInfoVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.GjInfo_index.startHandleInfoVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.GjInfo_index.endGjInfo_index = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.getRootAsComtypeInfo_gjinfoindex = function (bb, obj) {
  return (obj || new FlatSceneGraph.ComtypeInfo_gjinfoindex()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.uuid = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.bId = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.bName = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.gjInfo = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? (obj || new FlatSceneGraph.GjInfo_index()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.prototype.gjInfoLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 14);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.startComtypeInfo_gjinfoindex = function (builder) {
  builder.startObject(6);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.addUuid = function (builder, uuidOffset) {
  builder.addFieldOffset(0, uuidOffset, 0);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.addId = function (builder, id) {
  builder.addFieldInt32(1, id, 0);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.addName = function (builder, nameOffset) {
  builder.addFieldOffset(2, nameOffset, 0);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.addBId = function (builder, bId) {
  builder.addFieldInt32(3, bId, 0);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.addBName = function (builder, bNameOffset) {
  builder.addFieldOffset(4, bNameOffset, 0);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.addGjInfo = function (builder, gjInfoOffset) {
  builder.addFieldOffset(5, gjInfoOffset, 0);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.createGjInfoVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.startGjInfoVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.ComtypeInfo_gjinfoindex.endComtypeInfo_gjinfoindex = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.getRootAsSubComtypeInfo_gjinfoindex = function (bb, obj) {
  return (obj || new FlatSceneGraph.SubComtypeInfo_gjinfoindex()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.id = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.name = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.uuid = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.gjInfo = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new FlatSceneGraph.GjInfo_index()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.gjInfoLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.subcomtypeInfo = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? (obj || new FlatSceneGraph.SubComtypeInfo_gjinfoindex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.prototype.subcomtypeInfoLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 12);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.startSubComtypeInfo_gjinfoindex = function (builder) {
  builder.startObject(5);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.addId = function (builder, id) {
  builder.addFieldInt32(0, id, 0);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.addName = function (builder, nameOffset) {
  builder.addFieldOffset(1, nameOffset, 0);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.addUuid = function (builder, uuidOffset) {
  builder.addFieldOffset(2, uuidOffset, 0);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.addGjInfo = function (builder, gjInfoOffset) {
  builder.addFieldOffset(3, gjInfoOffset, 0);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.createGjInfoVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.startGjInfoVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.addSubcomtypeInfo = function (builder, subcomtypeInfoOffset) {
  builder.addFieldOffset(4, subcomtypeInfoOffset, 0);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.createSubcomtypeInfoVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.startSubcomtypeInfoVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.SubComtypeInfo_gjinfoindex.endSubComtypeInfo_gjinfoindex = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.getRootAsComtypeGroupInfo_gjinfoindex = function (bb, obj) {
  return (obj || new FlatSceneGraph.ComtypeGroupInfo_gjinfoindex()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.prototype.bId = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.prototype.bName = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.prototype.subcomtypeInfo = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new FlatSceneGraph.SubComtypeInfo_gjinfoindex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.prototype.subcomtypeInfoLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.startComtypeGroupInfo_gjinfoindex = function (builder) {
  builder.startObject(3);
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.addBId = function (builder, bId) {
  builder.addFieldInt32(0, bId, 0);
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.addBName = function (builder, bNameOffset) {
  builder.addFieldOffset(1, bNameOffset, 0);
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.addSubcomtypeInfo = function (builder, subcomtypeInfoOffset) {
  builder.addFieldOffset(2, subcomtypeInfoOffset, 0);
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.createSubcomtypeInfoVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.startSubcomtypeInfoVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.ComtypeGroupInfo_gjinfoindex.endComtypeGroupInfo_gjinfoindex = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.getRootAsSimFloorInfoAddCAxisNet = function (bb, obj) {
  return (obj || new FlatSceneGraph.SimFloorInfoAddCAxisNet()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.prototype.floorid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.prototype.floorname = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.prototype.showid = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.prototype.comtypeGroupInfo = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? (obj || new FlatSceneGraph.ComtypeGroupInfo_gjinfoindex()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.prototype.comtypeGroupInfoLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.startSimFloorInfoAddCAxisNet = function (builder) {
  builder.startObject(4);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.addFloorid = function (builder, floorid) {
  builder.addFieldInt32(0, floorid, 0);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.addFloorname = function (builder, floornameOffset) {
  builder.addFieldOffset(1, floornameOffset, 0);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.addShowid = function (builder, showid) {
  builder.addFieldInt32(2, showid, 0);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.addComtypeGroupInfo = function (builder, comtypeGroupInfoOffset) {
  builder.addFieldOffset(3, comtypeGroupInfoOffset, 0);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.createComtypeGroupInfoVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.startComtypeGroupInfoVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.SimFloorInfoAddCAxisNet.endSimFloorInfoAddCAxisNet = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.CBuildStageInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.CBuildStageInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.CBuildStageInfo.getRootAsCBuildStageInfo = function (bb, obj) {
  return (obj || new FlatSceneGraph.CBuildStageInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.CBuildStageInfo.prototype.stageid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CBuildStageInfo.prototype.stagename = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.CBuildStageInfo.startCBuildStageInfo = function (builder) {
  builder.startObject(2);
};

FlatSceneGraph.CBuildStageInfo.addStageid = function (builder, stageid) {
  builder.addFieldInt32(0, stageid, 0);
};

FlatSceneGraph.CBuildStageInfo.addStagename = function (builder, stagenameOffset) {
  builder.addFieldOffset(1, stagenameOffset, 0);
};

FlatSceneGraph.CBuildStageInfo.endCBuildStageInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.CSimBuildInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.CSimBuildInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.CSimBuildInfo.getRootAsCSimBuildInfo = function (bb, obj) {
  return (obj || new FlatSceneGraph.CSimBuildInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.CSimBuildInfo.prototype.buildid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CSimBuildInfo.prototype.buildname = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.CSimBuildInfo.prototype.floors = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new FlatSceneGraph.SimFloorInfoAddCAxisNet()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.CSimBuildInfo.prototype.floorsLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CSimBuildInfo.startCSimBuildInfo = function (builder) {
  builder.startObject(3);
};

FlatSceneGraph.CSimBuildInfo.addBuildid = function (builder, buildid) {
  builder.addFieldInt32(0, buildid, 0);
};

FlatSceneGraph.CSimBuildInfo.addBuildname = function (builder, buildnameOffset) {
  builder.addFieldOffset(1, buildnameOffset, 0);
};

FlatSceneGraph.CSimBuildInfo.addFloors = function (builder, floorsOffset) {
  builder.addFieldOffset(2, floorsOffset, 0);
};

FlatSceneGraph.CSimBuildInfo.createFloorsVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.CSimBuildInfo.startFloorsVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.CSimBuildInfo.endCSimBuildInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.UserDataInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.UserDataInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.UserDataInfo.getRootAsUserDataInfo = function (bb, obj) {
  return (obj || new FlatSceneGraph.UserDataInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.UserDataInfo.prototype.strName = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.UserDataInfo.prototype.strValue = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.UserDataInfo.startUserDataInfo = function (builder) {
  builder.startObject(2);
};

FlatSceneGraph.UserDataInfo.addStrName = function (builder, strNameOffset) {
  builder.addFieldOffset(0, strNameOffset, 0);
};

FlatSceneGraph.UserDataInfo.addStrValue = function (builder, strValueOffset) {
  builder.addFieldOffset(1, strValueOffset, 0);
};

FlatSceneGraph.UserDataInfo.endUserDataInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.HandleInfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.HandleInfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.HandleInfo.getRootAsHandleInfo = function (bb, obj) {
  return (obj || new FlatSceneGraph.HandleInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.HandleInfo.prototype.floorid = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
};

FlatSceneGraph.HandleInfo.prototype.id = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

FlatSceneGraph.HandleInfo.prototype.userData = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? (obj || new FlatSceneGraph.UserDataInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.HandleInfo.prototype.userDataLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.HandleInfo.prototype.parmtextindex = function (index) {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
};

FlatSceneGraph.HandleInfo.prototype.parmtextindexLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.HandleInfo.prototype.parmtextindexArray = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
};

FlatSceneGraph.HandleInfo.startHandleInfo = function (builder) {
  builder.startObject(4);
};

FlatSceneGraph.HandleInfo.addFloorid = function (builder, floorid) {
  builder.addFieldInt32(0, floorid, 0);
};

FlatSceneGraph.HandleInfo.addId = function (builder, idOffset) {
  builder.addFieldOffset(1, idOffset, 0);
};

FlatSceneGraph.HandleInfo.addUserData = function (builder, userDataOffset) {
  builder.addFieldOffset(2, userDataOffset, 0);
};

FlatSceneGraph.HandleInfo.createUserDataVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.HandleInfo.startUserDataVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.HandleInfo.addParmtextindex = function (builder, parmtextindexOffset) {
  builder.addFieldOffset(3, parmtextindexOffset, 0);
};

FlatSceneGraph.HandleInfo.createParmtextindexVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.HandleInfo.startParmtextindexVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.HandleInfo.endHandleInfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.CBuildProject = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.CBuildProject.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.CBuildProject.getRootAsCBuildProject = function (bb, obj) {
  return (obj || new FlatSceneGraph.CBuildProject()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.CBuildProject.prototype.builds = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new FlatSceneGraph.CSimBuildInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.CBuildProject.prototype.buildsLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CBuildProject.prototype.stages = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? (obj || new FlatSceneGraph.CBuildStageInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.CBuildProject.prototype.stagesLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CBuildProject.startCBuildProject = function (builder) {
  builder.startObject(2);
};

FlatSceneGraph.CBuildProject.addBuilds = function (builder, buildsOffset) {
  builder.addFieldOffset(0, buildsOffset, 0);
};

FlatSceneGraph.CBuildProject.createBuildsVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.CBuildProject.startBuildsVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.CBuildProject.addStages = function (builder, stagesOffset) {
  builder.addFieldOffset(1, stagesOffset, 0);
};

FlatSceneGraph.CBuildProject.createStagesVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.CBuildProject.startStagesVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.CBuildProject.endCBuildProject = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.CBuildProject_map = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.CBuildProject_map.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.CBuildProject_map.getRootAsCBuildProject_map = function (bb, obj) {
  return (obj || new FlatSceneGraph.CBuildProject_map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.CBuildProject_map.prototype.handleinfos = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new FlatSceneGraph.HandleInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

FlatSceneGraph.CBuildProject_map.prototype.handleinfosLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CBuildProject_map.prototype.parmtextlist = function (index, optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

FlatSceneGraph.CBuildProject_map.prototype.parmtextlistLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

FlatSceneGraph.CBuildProject_map.startCBuildProject_map = function (builder) {
  builder.startObject(2);
};

FlatSceneGraph.CBuildProject_map.addHandleinfos = function (builder, handleinfosOffset) {
  builder.addFieldOffset(0, handleinfosOffset, 0);
};

FlatSceneGraph.CBuildProject_map.createHandleinfosVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.CBuildProject_map.startHandleinfosVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.CBuildProject_map.addParmtextlist = function (builder, parmtextlistOffset) {
  builder.addFieldOffset(1, parmtextlistOffset, 0);
};

FlatSceneGraph.CBuildProject_map.createParmtextlistVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

FlatSceneGraph.CBuildProject_map.startParmtextlistVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

FlatSceneGraph.CBuildProject_map.endCBuildProject_map = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.CComponentsInfoAddBuildinfo = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.getRootAsCComponentsInfoAddBuildinfo = function (bb, obj) {
  return (obj || new FlatSceneGraph.CComponentsInfoAddBuildinfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.prototype.mPBuildproject = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new FlatSceneGraph.CBuildProject()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.startCComponentsInfoAddBuildinfo = function (builder) {
  builder.startObject(1);
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.addMPBuildproject = function (builder, mPBuildprojectOffset) {
  builder.addFieldOffset(0, mPBuildprojectOffset, 0);
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.endCComponentsInfoAddBuildinfo = function (builder) {
  var offset = builder.endObject();
  return offset;
};

FlatSceneGraph.CComponentsInfoAddBuildinfo.finishCComponentsInfoAddBuildinfoBuffer = function (builder, offset) {
  builder.finish(offset);
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap = function () {
  this.bb = null;

  this.bb_pos = 0;
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap.getRootAsCComponentsInfoAddBuildinfoMap = function (bb, obj) {
  return (obj || new FlatSceneGraph.CComponentsInfoAddBuildinfoMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap.prototype.mPBuildprojectMap = function (obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new FlatSceneGraph.CBuildProject_map()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap.startCComponentsInfoAddBuildinfoMap = function (builder) {
  builder.startObject(1);
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap.addMPBuildprojectMap = function (builder, mPBuildprojectMapOffset) {
  builder.addFieldOffset(0, mPBuildprojectMapOffset, 0);
};

FlatSceneGraph.CComponentsInfoAddBuildinfoMap.endCComponentsInfoAddBuildinfoMap = function (builder) {
  var offset = builder.endObject();
  return offset;
};

this.FlatSceneGraph = FlatSceneGraph;

/***/ }),
/* 496 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);


/* harmony default export */ __webpack_exports__["a"] = ({
  methods: {
    setCamera: function setCamera(view) {
      this.setCameraUp(view.up);
      this.setCameraPosition(view.position);
    },
    setCameraUp: function setCameraUp(items) {
      var _items = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(items, 3);

      window.$CCBIM.webglContext.camera.up.x = _items[0];
      window.$CCBIM.webglContext.camera.up.y = _items[1];
      window.$CCBIM.webglContext.camera.up.z = _items[2];
    },
    setCameraPosition: function setCameraPosition(items) {
      var _items2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(items, 3);

      window.$CCBIM.webglContext.camera.position.x = _items2[0];
      window.$CCBIM.webglContext.camera.position.y = _items2[1];
      window.$CCBIM.webglContext.camera.position.z = _items2[2];
    }
  }
});

/***/ }),
/* 497 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__flatBuffers_useFlatBuffer__ = __webpack_require__(101);





function ActionManager(dom) {
  this.actionManager = 'type';

  this.dom = dom;

  this.isMouseDown = false;
  this.isMouseMove = false;
  this.mouseDownX = 0;
  this.mouseDownY = 0;

  this.selectColor = new window.$CCBIM.WebGL.Color(0 / 255, 251 / 255, 191 / 255);

  this.useFlatBuffer = new __WEBPACK_IMPORTED_MODULE_3__flatBuffers_useFlatBuffer__["a" /* default */]();
}

ActionManager.prototype = {
  constructor: ActionManager,

  onModelMouseMove: function onModelMouseMove(event) {
    event.preventDefault();
    if (this.isMouseDown) {
      var mouseMoveX = void 0;
      var mouseMoveY = void 0;
      if (event.type === 'touchmove') {
        mouseMoveX = event.changedTouches[0].clientX;
        mouseMoveY = event.changedTouches[0].clientY;
      } else {
        mouseMoveX = event.clientX;
        mouseMoveY = event.clientY;
      }
      if (Math.abs(mouseMoveX - this.mouseDownX) > 20 || Math.abs(mouseMoveY - this.mouseDownY) > 20) {
        this.isMouseMove = true;
      }
    }
  },
  onModelMouseDown: function onModelMouseDown(event) {
    event.preventDefault();
    if (window.$CCBIM.sceneManager) {
      window.$CCBIM.sceneManager.setNeedUpdate(true);
    }
    this.isMouseDown = true;
    this.isMouseMove = false;

    if (event.type === 'touchstart') {
      this.mouseDownX = event.changedTouches[0].clientX;
      this.mouseDownY = event.changedTouches[0].clientY;
    } else {
      this.mouseDownX = event.clientX;
      this.mouseDownY = event.clientY;
    }
  },
  onModelMouseUp: function onModelMouseUp(event) {
    var _this = this;

    var actionObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      event.preventDefault();
      if (window.$CCBIM.sceneManager) {
        window.$CCBIM.sceneManager.setNeedUpdate(true);
      }
      _this.isMouseDown = false;

      if (actionObj.isChoose && !_this.isMouseMove) {
        _this.selectGeometry(event).then(function (success) {
          resolve(success);
        }, function (error) {
          reject(error);
        });
      } else {
        reject('/');
      }
    });
  },
  selectGeometry: function selectGeometry(event) {
    var _this2 = this;

    return new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      window.$CCBIM.sceneManager.clearHighlight();
      var worldCoordinate = void 0;
      if (event.type === 'touchend') {
        worldCoordinate = _this2.getWorldCoordinate(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
      } else {
        worldCoordinate = _this2.getWorldCoordinate(event.clientX, event.clientY);
      }
      var selectArray = window.$CCBIM.sceneManager.selectEnt(worldCoordinate);
      if (selectArray.length) {
        var selectArrayFirstObj = selectArray[0];

        var _loop = function _loop(s) {
          var selectArrayFirst = selectArray[s];
          if (selectArrayFirst.distance === selectArrayFirstObj.distance) {
            var clippingBoxHelp = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');
            if (clippingBoxHelp) {
              clippingBoxHelp.geometry.computeBoundingBox();
              var clippingBox = clippingBoxHelp.geometry.boundingBox;
              if (selectArrayFirst.point.x < clippingBox.min.x || selectArrayFirst.point.y < clippingBox.min.y || selectArrayFirst.point.z < clippingBox.min.z) {
                reject('');
                return {
                  v: false
                };
              }
              if (selectArrayFirst.point.x > clippingBox.max.x || selectArrayFirst.point.y > clippingBox.max.y || selectArrayFirst.point.z > clippingBox.max.z) {
                reject('');
                return {
                  v: false
                };
              }
            }
            var opacity = 1;
            window.$CCBIM.sceneManager.highlightEnt(selectArrayFirst.entInfo, _this2.selectColor, opacity).then(function (suc) {
              _this2.getSelectGeometryPositionInfo(selectArrayFirst.entInfo, selectArrayFirst.point);
              resolve(suc);
            }, function (err) {
              reject(err);
            });
          }
        };

        for (var s = 0; s < selectArray.length; s++) {
          var _ret = _loop(s);

          if ((typeof _ret === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(_ret)) === "object") return _ret.v;
        }
      } else {
        reject('()');
      }
    });
  },
  getWorldCoordinate: function getWorldCoordinate(x, y) {
    var rect = this.dom.getBoundingClientRect();
    var worldCoordinate = new window.$CCBIM.WebGL.Vector2();
    worldCoordinate.set((x - rect.left) / rect.width * 2 - 1, -((y - rect.top) / rect.height * 2) + 1);
    return worldCoordinate;
  },
  getSelectGeometryPositionInfo: function getSelectGeometryPositionInfo(selectedGEO, clickPointPosition) {
    var geometryData = {};
    var sceneData = window.$CCBIM.sceneManager.getSceneData();
    var cameraData = window.$CCBIM.controller.getCameraData();
    var cameraPosition = {
      x: cameraData.cameraPosition.x / sceneData.scale,
      y: cameraData.cameraPosition.y / sceneData.scale,
      z: cameraData.cameraPosition.z / sceneData.scale
    };
    var clickPosition = {
      x: clickPointPosition.x / sceneData.scale,
      y: clickPointPosition.y / sceneData.scale,
      z: clickPointPosition.z / sceneData.scale
    };
    var target = {
      x: cameraData.target.x / sceneData.scale,
      y: cameraData.target.y / sceneData.scale,
      z: cameraData.target.z / sceneData.scale
    };

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'cameraPosition': cameraPosition });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'cameraUp': cameraData.cameraUp });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'cameraTarget': target });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'clickPointPosition': clickPosition });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'comid': selectedGEO.comid });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'comtype': selectedGEO.comtype });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'floorID': selectedGEO.floorID });
    var floorName = window.$CCBIM.projectManager.floorIdNameMap.get(selectedGEO.floorID);
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'floorName': floorName });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'handle': selectedGEO.handle });

    var cullPlaneArr = [];
    if (window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp')) {
      for (var m = 0; m < window.$CCBIM.clippingPlane.length; m++) {
        cullPlaneArr.push({
          x: window.$CCBIM.clippingPlane[m].normal.x,
          y: window.$CCBIM.clippingPlane[m].normal.y,
          z: window.$CCBIM.clippingPlane[m].normal.z,
          constant: window.$CCBIM.clippingPlane[m].constant / sceneData.scale
        });
      }
    }

    var TransverseView = this.computedTransverseView() / sceneData.scale;
    var currentStage = window.$CCBIM.projectManager.getCurrentStage();
    var flatBuffer = this.useFlatBuffer.setFlatBuffer(cameraPosition, target, cameraData.cameraUp, TransverseView, TransverseView, window.$CCBIM.render.$ccbimFloorInfoArr, cullPlaneArr, currentStage.id);
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'flatBuffer': flatBuffer });

    var modelMinPt = new window.$CCBIM.WebGL.Vector3(Infinity, Infinity, Infinity);
    var modelMaxPt = new window.$CCBIM.WebGL.Vector3(-Infinity, -Infinity, -Infinity);
    var entDataArray = selectedGEO.getEntDataArray();
    for (var i = 0, il = entDataArray.length; i < il; i++) {
      var bndBox = entDataArray[i].bndBox;
      if (bndBox.min.x < modelMinPt.x || bndBox.min.y < modelMinPt.y || bndBox.min.z < modelMinPt.z) {
        modelMinPt = bndBox.min;
      }
      if (bndBox.max.x > modelMaxPt.x || bndBox.max.y > modelMaxPt.y || bndBox.max.z > modelMaxPt.z) {
        modelMaxPt = bndBox.max;
      }
    }
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'modelMinPt': modelMinPt });
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_assign___default()(geometryData, { 'modelMaxPt': modelMaxPt });

    window.$CCBIM.sceneManager.setSelectGeometry(geometryData);
  },
  computedTransverseView: function computedTransverseView() {
    var DEG2RAD = Math.PI / 180;
    var far = this.computedCameraVector();
    return far * Math.tan(DEG2RAD * 0.5 * window.$CCBIM.webglContext.camera.fov) / window.$CCBIM.webglContext.camera.zoom;
  },
  computedCameraVector: function computedCameraVector() {
    var cameraData = window.$CCBIM.controller.getCameraData();
    var x1 = cameraData.cameraPosition.x;
    var y1 = cameraData.cameraPosition.y;
    var z1 = cameraData.cameraPosition.z;
    var x2 = window.$CCBIM.controller.target ? window.$CCBIM.controller.target.x : 0;
    var y2 = window.$CCBIM.controller.target ? window.$CCBIM.controller.target.y : 0;
    var z2 = window.$CCBIM.controller.target ? window.$CCBIM.controller.target.z : 0;
    var target = {
      x: x1 + (x2 - x1) * 1.5,
      y: y1 + (y2 - y1) * 1.5,
      z: z1 + (z2 - z1) * 1.5
    };
    return Math.sqrt(Math.pow(x1 - target.x, 2) + Math.pow(y1 - target.y, 2) + Math.pow(z1 - target.z, 2));
  },
  getSelectGeometryBox: function getSelectGeometryBox() {
    var modelMinPt = new window.$CCBIM.WebGL.Vector3(Infinity, Infinity, Infinity);
    var modelMaxPt = new window.$CCBIM.WebGL.Vector3(-Infinity, -Infinity, -Infinity);
    if (window.$CCBIM.sceneManager.getSelectGeometry()) {
      var selectedGeometry = window.$CCBIM.sceneManager.getSelectGeometry();
      modelMinPt = selectedGeometry.modelMinPt;
      modelMaxPt = selectedGeometry.modelMaxPt;
    }
    return {
      modelMinPt: modelMinPt,
      modelMaxPt: modelMaxPt
    };
  },
  getSelectGeometryBoxCenterPt: function getSelectGeometryBoxCenterPt() {
    var selGeo = this.getSelectGeometryBox();

    var modelCenterPt = new window.$CCBIM.WebGL.Vector3((selGeo.modelMaxPt.x + selGeo.modelMinPt.x) / 2, (selGeo.modelMaxPt.y + selGeo.modelMinPt.y) / 2, (selGeo.modelMaxPt.z + selGeo.modelMinPt.z) / 2);
    return modelCenterPt;
  },
  getIntersectsFirstEnt: function getIntersectsFirstEnt(event) {
    var result = this.getIntersectsObjectsArray(event);
    if (result) {
      return result[0];
    }
    return null;
  },
  getIntersectsObjectsArray: function getIntersectsObjectsArray(event, ignoreLine) {
    var camera = window.$CCBIM.webglContext.getCamera();
    var windowPos = void 0;
    if (event.type === 'touchend' || event.type === 'touchstart') {
      windowPos = this.getWorldCoordinate(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
    } else {
      windowPos = this.getWorldCoordinate(event.clientX, event.clientY);
    }
    var ray = new window.$CCBIM.WebGL.Raycaster();
    ray.far = camera.far;
    ray.near = camera.near;
    ray.setFromCamera(windowPos, camera);

    var temRenderList = window.$CCBIM.webglContext.getRenderList();
    return ray.intersectRenderObjects(temRenderList, true, false, ignoreLine);
  }
};

/* harmony default export */ __webpack_exports__["a"] = (ActionManager);

/***/ }),
/* 498 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

function Detector() {
  this.canvas = !!window.CanvasRenderingContext2D;
  this.workers = !!window.Worker;
  this.fileapi = window.File && window.FileReader && window.FileList && window.Blob;
}

Detector.prototype = {
  constructor: Detector,

  webgl: function () {
    try {
      var canvas = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
      return false;
    }
  }(),

  webgl2: function () {
    try {
      var canvas = document.createElement('canvas');
      return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));
    } catch (e) {
      return false;
    }
  }(),

  isIe: function isIe() {
    if (navigator.userAgent.includes('Trident')) {
      return true;
    } else {
      return false;
    }
  }
};

/* harmony default export */ __webpack_exports__["a"] = (Detector);

/***/ }),
/* 499 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatBuffers_PBIMData_BufferDataInterface__ = __webpack_require__(486);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_SceneDataInterface__ = __webpack_require__(489);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_BIMDataInterface__ = __webpack_require__(484);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__flatBuffers_PBIMData_ComponentsDataInterface__ = __webpack_require__(487);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__FileLoader_js__ = __webpack_require__(183);








function FileLoadContext() {
  var textureType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
  var isSimColorMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var simColorModeColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#aaa';

  this.type = 'FileLoadContext';

  this.fileLoader = null;

  this.textureType = textureType;
  this.isSimColorMode = isSimColorMode;
  this.simColorModeColor = simColorModeColor;

  this.bufferDataInterface = null;
  this.sceneDataInterface = null;
  this.bimDataInterface = null;
}

FileLoadContext.prototype = {
  initialize: function initialize(params) {
    this.fileLoader = params.fileLoader ? params.fileLoader : new __WEBPACK_IMPORTED_MODULE_4__FileLoader_js__["a" /* default */](params.axios);

    this.bufferDataInterface = params.bufferDataInterface ? params.bufferDataInterface : new __WEBPACK_IMPORTED_MODULE_0__flatBuffers_PBIMData_BufferDataInterface__["a" /* default */](this.fileLoader, this.textureType, this.isSimColorMode, this.simColorModeColor);
    this.sceneDataInterface = params.sceneDataInterface ? params.sceneDataInterface : new __WEBPACK_IMPORTED_MODULE_1__flatBuffers_PBIMData_SceneDataInterface__["a" /* default */](this.fileLoader);
    this.bimDataInterface = params.bimDataInterface ? params.bimDataInterface : new __WEBPACK_IMPORTED_MODULE_2__flatBuffers_PBIMData_BIMDataInterface__["a" /* default */]();
    this.componentsDataInterface = params.componentsDataInterface ? params.componentsDataInterface : new __WEBPACK_IMPORTED_MODULE_3__flatBuffers_PBIMData_ComponentsDataInterface__["a" /* default */]();
  },

  getFileLoader: function getFileLoader() {
    return this.fileLoader;
  },

  getBufferDataInterface: function getBufferDataInterface() {
    return this.bufferDataInterface;
  },

  getSceneDataInterface: function getSceneDataInterface() {
    return this.sceneDataInterface;
  },

  getBIMDataInterface: function getBIMDataInterface() {
    return this.bimDataInterface;
  },

  getComponentDataInterface: function getComponentDataInterface() {
    return this.componentsDataInterface;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (FileLoadContext);

/***/ }),
/* 500 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


function PageLOD() {
  this.type = 'PageLOD';

  this.minLoadDistance = 0;

  this.maxLoadDistance = -1;

  this.pageData = null;
}

PageLOD.prototype = {
  constructor: PageLOD,

  setLoadRange: function setLoadRange(minDistance, maxDistance) {
    this.minLoadDistance = minDistance;
    this.maxLoadDistance = maxDistance;
  },

  getMinLoadDistance: function getMinLoadDistance() {
    return this.minLoadDistance;
  },

  getMaxLoadDistance: function getMaxLoadDistance() {
    return this.maxLoadDistance;
  },

  setPageData: function setPageData(pageData) {
    this.pageData = pageData;
  },

  getPageData: function getPageData() {
    return this.pageData;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (PageLOD);

/***/ }),
/* 501 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);



function ProjectManager() {
  this.type = 'projectManager';

  this.fileLoadContext = null;

  this.stageInfoArray = [];

  this.setStageInfoArray = [];
  this.currentStage = null;

  this.floorCrossLine = [];
  this.floorCrossLineBufferData = null;

  this.floorIdNameMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

  this.floorNameIdMap = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

  this.opacityColor = new window.$CCBIM.WebGL.Color(0, 0, 0);

  this.pmShadowMap = null;
}

ProjectManager.prototype = {
  constructor: ProjectManager,

  initialize: function initialize(params) {
    this.fileLoadContext = params.fileLoadContext;
  },

  loadProject: function loadProject(bytes) {},

  setFloorCrossLineBufferData: function setFloorCrossLineBufferData(dataArray) {
    this.floorCrossLineBufferData = dataArray;
  },

  getFloorCrossLineBufferData: function getFloorCrossLineBufferData() {
    return this.floorCrossLineBufferData;
  },

  setFloorCrossLine: function setFloorCrossLine(dataArray) {
    this.floorCrossLine = dataArray;
  },

  getFloorCrossLine: function getFloorCrossLine() {
    return this.floorCrossLine;
  },

  setStageInfo: function setStageInfo(dataArray) {
    this.setStageInfoArray = dataArray;
    this.currentStage = dataArray[0];
  },

  getStageInfo: function getStageInfo() {
    return this.setStageInfoArray;
  },

  setCurrentStage: function setCurrentStage(currentStage) {
    this.currentStage = currentStage;
  },

  getCurrentStage: function getCurrentStage() {
    return this.currentStage;
  },

  setBuildingInfoBufferData: function setBuildingInfoBufferData(dataArray) {
    this.buildingInfoArrayBufferData = dataArray;
  },

  getBuildingInfoBufferData: function getBuildingInfoBufferData() {
    return this.buildingInfoArrayBufferData;
  },

  getBuildingInfo: function getBuildingInfo() {
    var bufferData = this.getBuildingInfoBufferData();
    var buildingInfoArray = window.$CCBIM.sceneManager.loadFloorTreeData(bufferData);
    var buildingInfoUIArray = [];
    for (var i = 0, il = buildingInfoArray.length; i < il; i++) {
      var buildIndex = buildingInfoArray[i];
      var floorGroup = [];
      for (var j = 0, jl = buildIndex.getFloorInfoArray().length; j < jl; j++) {
        var floorIndex = buildIndex.getFloorInfoArray()[j];
        if (floorIndex.getBaseComtypeInfoArray().length === 0) {
          continue;
        }
        var baseComtypeGroup = [];
        for (var f = 0, fl = floorIndex.getBaseComtypeInfoArray().length; f < fl; f++) {
          var baseComtypeIndex = floorIndex.getBaseComtypeInfoArray()[f];
          var comtypeGroup = [];
          this.recurveBaseComtype(baseComtypeIndex, comtypeGroup, floorIndex.getID());
          if (comtypeGroup.length === 0) {
            var comtype = {
              comtype: baseComtypeIndex.getID(),
              floorId: floorIndex.getID(),
              text: baseComtypeIndex.getName()
            };
            baseComtypeGroup.push(comtype);
          } else {
            var baseComtype = {
              baseComtypeId: baseComtypeIndex.getID(),
              text: baseComtypeIndex.getName(),
              children: comtypeGroup
            };
            baseComtypeGroup.push(baseComtype);
          }
        }
        var floor = {
          floorId: floorIndex.getID(),
          text: floorIndex.getName(),
          children: baseComtypeGroup
        };
        this.floorNameIdMap.set(floorIndex.getName(), floorIndex.getID());
        this.floorIdNameMap.set(floorIndex.getID(), floorIndex.getName());
        floorGroup.push(floor);
      }
      var build = {
        buildId: buildIndex.getID(),
        text: buildIndex.getName(),
        children: floorGroup
      };
      buildingInfoUIArray.push(build);
    }
    return buildingInfoUIArray;
  },

  recurveBaseComtype: function recurveBaseComtype(baseComtype, comtypeGroup, floorId) {
    if (baseComtype.getChildArray().length > 0) {
      for (var r = 0, rl = baseComtype.getChildArray().length; r < rl; r++) {
        var comtypeIndex = baseComtype.getChildArray()[r];

        this.recurveBaseComtype(comtypeIndex, comtypeGroup, floorId);
      }
    } else {
      for (var _r = 0, _rl = baseComtype.getComtypeInfoArray().length; _r < _rl; _r++) {
        var _comtypeIndex = baseComtype.getComtypeInfoArray()[_r];

        var comtype = {
          comtype: _comtypeIndex.getID(),
          floorId: floorId,
          text: _comtypeIndex.getName()
        };
        comtypeGroup.push(comtype);
      }
    }
  },

  recurveComtype: function recurveComtype(comtype) {
    if (comtype.getComtypeInfoArray().length > 0) {
      for (var r = 0, rl = comtype.getComtypeInfoArray().length; r < rl; r++) {
        this.recurveComtype(comtype.getComtypeInfoArray()[r]);
      }
    } else {
      for (var _r2 = 0, _rl2 = comtype.getComidInfoArray().length; _r2 < _rl2; _r2++) {}
    }
  },

  setEntInfoVisible: function setEntInfoVisible(floorIdComtypeArray, stage, visible) {
    window.$CCBIM.sceneManager.setNeedUpdate(true);

    var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();

    for (var i = 0, il = sceneNodeArray.length; i < il; i++) {
      sceneNodeArray[i].entInfoMap.forEach(function (entInfo) {
        for (var s = 0, sl = entInfo.stageArray.length; s < sl; s++) {
          if (stage === -Infinity || entInfo.stageArray[s] === stage || entInfo.stageArray[s] === -1) {
            for (var j = 0, jl = floorIdComtypeArray.length; j < jl; j++) {
              if (entInfo.floorID === floorIdComtypeArray[j].floorId && entInfo.comtype === floorIdComtypeArray[j].comtype) {
                window.$CCBIM.sceneManager.setEntVisible(entInfo, visible);
              }
            }
          }
        }
      });
    }
  },

  setInstanceMeshEntInfoVisible: function setInstanceMeshEntInfoVisible(visible) {
    window.$CCBIM.sceneManager.setNeedUpdate(true);

    window.$CCBIM.sceneManager.refDefinitionMap.forEach(function (refDefinition) {
      var refObjectArray = refDefinition.getRefObjectArray();
      for (var i = 0, il = refObjectArray.length; i < il; i++) {
        var geometry = refObjectArray[i].geometry;
        var vertexIndex = geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
        if (vertexIndex) {
          var indexRange = vertexIndex.getIndexRangeArray()[0];
          indexRange.setVisible(visible);
        }
      }
    });
  },

  setEntInfoVisibleFromStage: function setEntInfoVisibleFromStage(stage) {
    window.$CCBIM.sceneManager.setNeedUpdate(true);

    var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();

    for (var i = 0, il = sceneNodeArray.length; i < il; i++) {
      sceneNodeArray[i].entInfoMap.forEach(function (entInfo) {
        var haveStage = false;
        for (var s = 0, sl = entInfo.stageArray.length; s < sl; s++) {
          if (entInfo.stageArray[s] === stage || entInfo.stageArray[s] === -1) {
            haveStage = true;
          }
        }
        if (haveStage) {
          window.$CCBIM.sceneManager.setEntVisible(entInfo, true);
        } else {
          window.$CCBIM.sceneManager.setEntVisible(entInfo, false);
        }
      });
    }
  },

  setEntInfoOpacity: function setEntInfoOpacity(floorIdComtypeArray) {
    var _this = this;

    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    window.$CCBIM.sceneManager.setNeedUpdate(true);

    window.$CCBIM.sceneManager.clearHighlight();
    window.$CCBIM.sceneManager.clearOpaCity();

    var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();

    for (var s = 0, sl = sceneNodeArray.length; s < sl; s++) {
      sceneNodeArray[s].entInfoMap.forEach(function (entInfo) {
        if (direction) {
          var isOpcity = true;
          for (var f = 0, fl = floorIdComtypeArray.length; f < fl; f++) {
            if (entInfo.floorID === floorIdComtypeArray[f].floorId && entInfo.comtype === floorIdComtypeArray[f].comtype) {
              isOpcity = false;
            }
          }
          if (isOpcity) {
            window.$CCBIM.sceneManager.opactiyEnt(entInfo, _this.opacityColor, 0.1);
          }
        } else {
          for (var _f = 0, _fl = floorIdComtypeArray.length; _f < _fl; _f++) {
            if (entInfo.floorID === floorIdComtypeArray[_f].floorId && entInfo.comtype === floorIdComtypeArray[_f].comtype) {
              window.$CCBIM.sceneManager.opactiyEnt(entInfo, _this.opacityColor, 0.1);
            }
          }
        }
      });
    }
  },

  setEntMapMode: function setEntMapMode() {
    var renderList = window.$CCBIM.webglContext.getRenderList().opaque;
    for (var i = 0, itemLen = renderList.length; i < itemLen; i++) {
      var index = renderList[i];
      if (index.material.mapCopy) {
        index.material.map = index.material.mapCopy;
      }
      if (index.material.map) {
        index.material.color = new window.$CCBIM.WebGL.Color();
      }
      index.material.mapCopy = null;
      index.material.needsUpdate = true;
    }

    window.$CCBIM.sceneManager.setNeedUpdate(true);
  },

  setEntColorMode: function setEntColorMode() {
    var renderList = window.$CCBIM.webglContext.getRenderList().opaque;
    for (var i = 0, itemLen = renderList.length; i < itemLen; i++) {
      var index = renderList[i];
      if (index.material.map) {
        index.material.mapCopy = index.material.map;
        index.material.map = null;
      }
      index.material.color = index.material.colorCopy;
      index.material.needsUpdate = true;
    }

    window.$CCBIM.sceneManager.setNeedUpdate(true);
  },

  setEntLineMode: function setEntLineMode() {
    window.$CCBIM.sceneManager.switchGeometryWire = true;

    window.$CCBIM.sceneManager.showGeometryWire();

    window.$CCBIM.sceneManager.setNeedUpdate(true);
  },

  removeEntLineMode: function removeEntLineMode() {
    window.$CCBIM.sceneManager.switchGeometryWire = false;
    window.$CCBIM.sceneManager.hideGeometryWire();

    window.$CCBIM.sceneManager.setNeedUpdate(true);
  },

  setBottomShadow: function setBottomShadow() {
    var sceneData = window.$CCBIM.sceneManager.getSceneData();
    var maxPt = new window.$CCBIM.WebGL.Vector3(sceneData.bndBoxMax[0], sceneData.bndBoxMax[1], sceneData.bndBoxMax[2]);
    var minPt = new window.$CCBIM.WebGL.Vector3(sceneData.bndBoxMin[0], sceneData.bndBoxMin[1], sceneData.bndBoxMin[2]);

    var canvasWidth = maxPt.x - minPt.x;
    var canvasHeight = maxPt.y - minPt.y;

    var canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    var ctx = canvas.getContext('2d');

    var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();

    var bottomShadowArray = [];
    this.recurveGetBndBox(sceneNodeArray, minPt, maxPt, bottomShadowArray);

    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.fillStyle = '#AAAAAA';
    bottomShadowArray.forEach(function (item) {
      ctx.fillRect(item[0], item[1], item[2], item[3]);
    });
    this.addBottomShadow(canvas.toDataURL('image/png'));
    canvas.width = canvas.height = 0;
  },
  recurveGetBndBox: function recurveGetBndBox(sceneNodeArray, minPt, maxPt, bottomShadowArray) {
    for (var i = 0, il = sceneNodeArray.length; i < il; i++) {
      sceneNodeArray[i].entInfoMap.forEach(function (entInfo) {
        for (var b = 0, bl = entInfo.entDataArray.length; b < bl; b++) {
          var entIndex = entInfo.entDataArray[b];
          var max = entIndex.bndBox.max;
          var min = entIndex.bndBox.min;
          var startX = min.x - minPt.x;
          var startY = maxPt.y - max.y;
          var width = max.x - min.x;
          var height = max.y - min.y;
          bottomShadowArray.push([startX, startY, width, height]);
        }
      });
    }
  },
  addBottomShadow: function addBottomShadow(mapImg) {
    if (this.pmShadowMap) {
      return null;
    }
    var sceneData = window.$CCBIM.sceneManager.getSceneData();
    var maxPt = new window.$CCBIM.WebGL.Vector3(sceneData.bndBoxMax[0], sceneData.bndBoxMax[1], sceneData.bndBoxMax[2]);
    var minPt = new window.$CCBIM.WebGL.Vector3(sceneData.bndBoxMin[0], sceneData.bndBoxMin[1], sceneData.bndBoxMin[2]);
    var bottomPlan = new window.$CCBIM.WebGL.PlaneGeometry(maxPt.x - minPt.x, maxPt.y - minPt.y);
    var texture = new window.$CCBIM.WebGL.TextureLoader().load(mapImg);
    var material = new window.$CCBIM.WebGL.MeshBasicMaterial({ map: texture, transparent: true });

    this.pmShadowMap = new window.$CCBIM.WebGL.Mesh(bottomPlan, material);
    this.pmShadowMap.name = 'bottomShadow';
    this.pmShadowMap.position.x = (maxPt.x + minPt.x) / 2;
    this.pmShadowMap.position.y = (maxPt.y + minPt.y) / 2;
    this.pmShadowMap.position.z = minPt.z - window.$CCBIM.sceneManager.sceneData.scale * 5000;
    window.$CCBIM.webglContext.scene.add(this.pmShadowMap);

    window.$CCBIM.sceneManager.setNeedUpdate(true);
  },
  removeBottomShadow: function removeBottomShadow() {
    if (this.pmShadowMap) {
      window.$CCBIM.webglContext.scene.remove(this.pmShadowMap);
      window.$CCBIM.sceneManager.setNeedUpdate(true);
      this.pmShadowMap = null;
    }
  },


  getEntInfoBndCenterFromFloorIdHandle: function getEntInfoBndCenterFromFloorIdHandle(floorIdHandle) {
    var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();

    var entInfoData = null;

    for (var i = 0, il = sceneNodeArray.length; i < il; i++) {
      sceneNodeArray[i].entInfoMap.forEach(function (entInfo) {
        if (entInfo.floorID === floorIdHandle.floorId && entInfo.handle === floorIdHandle.handle) {
          entInfoData = entInfo;
        }
      });
    }
    if (entInfoData) {
      var modelMinPt = new window.$CCBIM.WebGL.Vector3(Infinity, Infinity, Infinity);
      var modelMaxPt = new window.$CCBIM.WebGL.Vector3(-Infinity, -Infinity, -Infinity);
      for (var e = 0, el = entInfoData.entDataArray.length; e < el; e++) {
        var bndBox = entInfoData.entDataArray[e].bndBox;
        if (bndBox.min.x < modelMinPt.x || bndBox.min.y < modelMinPt.y || bndBox.min.z < modelMinPt.z) {
          modelMinPt = bndBox.min;
        }
        if (bndBox.max.x > modelMaxPt.x || bndBox.max.y > modelMaxPt.y || bndBox.max.z > modelMaxPt.z) {
          modelMaxPt = bndBox.max;
        }
      }
      var bndBoxCenter = new window.$CCBIM.WebGL.Vector3((modelMaxPt.x + modelMinPt.x) / 2, (modelMaxPt.y + modelMinPt.y) / 2, (modelMaxPt.z + modelMinPt.z) / 2);
      return bndBoxCenter;
    }
  },

  getEntInfoFromFloorIdHandle: function getEntInfoFromFloorIdHandle(floorIdHandle) {
    var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();

    var entInfoData = null;

    for (var i = 0, il = sceneNodeArray.length; i < il; i++) {
      sceneNodeArray[i].entInfoMap.forEach(function (entInfo) {
        if (entInfo.floorID === floorIdHandle.floorId && entInfo.handle === floorIdHandle.handle) {
          entInfoData = entInfo;
        }
      });
    }
    return entInfoData;
  },

  canvasToImageBlod: function canvasToImageBlod() {
    window.$CCBIM.webglContext.renderer.render(window.$CCBIM.webglContext.scene, window.$CCBIM.webglContext.camera);
    var data = window.$CCBIM.webglContext.renderer.domElement.toDataURL();
    data = data.split(',')[1];
    data = window.atob(data);
    var ia = new Uint8Array(data.length);
    for (var i = 0; i < data.length; i++) {
      ia[i] = data.charCodeAt(i);
    }
    return new Blob([ia], { type: 'image/png' });
  },
  canvasToImage: function canvasToImage() {
    var rect = window.$CCBIM.device.getDevicesWidthHeight();
    window.$CCBIM.webglContext.renderer.render(window.$CCBIM.webglContext.scene, window.$CCBIM.webglContext.camera);
    return {
      img: window.$CCBIM.webglContext.renderer.domElement.toDataURL('image/png'),
      width: rect.w,
      height: rect.h
    };
  }
};

/* harmony default export */ __webpack_exports__["a"] = (ProjectManager);

/***/ }),
/* 502 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__WebGLContext__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__THREE_constants__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__SceneNode__ = __webpack_require__(104);










function SceneManager(WireColor) {
  this.type = 'SceneManager';

  this.materialMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.textureImageMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.refMaterialMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.refDefinitionMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.highlightMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.opactiyEntMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.selectedGeometry = null;

  this.sceneData = {
    bndBoxMin: [0, 0, 0],
    bndBoxMax: [0, 0, 0],
    scale: 0.001,
    viewPosition: [0, 0, 1],
    viewTarget: [0, 0, 0],
    viewUp: [0, 1, 0],
    maxBoundingValue: 0
  };

  this.autoFitCameraFutstum = false;

  this.webglContext = new __WEBPACK_IMPORTED_MODULE_5__WebGLContext__["a" /* default */]();

  this.fileLoadContext = null;

  this.sceneNodeMemorySize = 400 * 1024;

  this.MAX_MEMORY_LIMIT_MOBILE = 800 * 1024;

  this.MAX_MEMORY_LIMIT_PC = 2400 * 1024;

  this.needUpdate = true;

  this.isLoading = false;
  this.promiseArr = [];
  this.realLoadQueue = [];

  this.computeWireWorker = null;
  this.geometryWireColor = new window.$CCBIM.WebGL.Color(WireColor);
  this.refGeoComputeWireMap = null;
  this.geometryWireMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

  this.switchBottomShadow = null;
  this.switchGeometryWire = null;
}

SceneManager.prototype = {
  constructor: SceneManager,

  initialize: function initialize(params) {
    this.webglContext = params.webglContext;

    this.fileLoadContext = params.fileLoadContext;

    this.computeWireWorker = new Worker('/static/DataWorker.js?v=1.1.1');

    this.switchBottomShadow = params.switchBottomShadow;
    this.switchGeometryWire = params.switchGeometryWire;
  },

  getWebGLContext: function getWebGLContext() {
    return this.webglContext;
  },

  getFileLoadContext: function getFileLoadContext() {
    return this.fileLoadContext;
  },

  getSceneData: function getSceneData() {
    return this.sceneData;
  },

  getGeometryWireColor: function getGeometryWireColor() {
    return this.geometryWireColor;
  },

  getNeedUpdate: function getNeedUpdate() {
    return this.needUpdate;
  },

  setNeedUpdate: function setNeedUpdate(flag) {
    this.needUpdate = flag;
  },

  clearData: function clearData() {
    this.materialMap.clear();

    this.textureImageMap.clear();

    this.refMaterialMap.clear();

    this.refDefinitionMap.clear();

    this.fileLoadContext.getFileLoader().clearData();

    this.computeWireWorker.terminate();
  },

  setAutoFitCameraFtustum: function setAutoFitCameraFtustum(value) {
    this.autoFitCameraFutstum = value;
  },

  fitCameraFtustum: function fitCameraFtustum() {
    if (!this.autoFitCameraFutstum) {
      return;
    }
    var camera = this.webglContext.getCamera();
    if (!camera) {
      return;
    }

    var frustum = this.webglContext.getRenderer().getFrustum();
    var nearClip = frustum.planes[5];

    var bndBoxMin = this.sceneData.bndBoxMin;
    var bndBoxMax = this.sceneData.bndBoxMax;

    var maxSceneValue = this.sceneData.maxBoundingValue;

    var minDistance = Number.MAX_VALUE;
    var maxDistance = Number.MIN_VALUE;

    var temPt = new window.$CCBIM.WebGL.Vector3();
    for (var i = 0; i < 8; i++) {
      temPt.set(i & 1 ? bndBoxMax[0] : bndBoxMin[0], i & 2 ? bndBoxMax[1] : bndBoxMin[1], i & 4 ? bndBoxMax[2] : bndBoxMin[2]);
      var temDist = Math.abs(nearClip.distanceToPoint(temPt));
      if (temDist < minDistance) {
        minDistance = temDist;
      }
      if (temDist > maxDistance) {
        maxDistance = temDist;
      }
    }

    if (camera.position.x < bndBoxMin[0] || camera.position.y < bndBoxMin[1] || camera.position.z < bndBoxMin[2] || camera.position.x > bndBoxMax[0] || camera.position.y > bndBoxMax[1] || camera.position.z > bndBoxMax[2]) {
      minDistance *= 0.9;
    } else {
      minDistance = maxSceneValue / 1000;
    }
    maxDistance *= 2;


    camera.near = minDistance;
    camera.far = maxDistance;
    camera.updateProjectionMatrix();
  },

  loadHead: function loadHead(bytes, func) {
    var _this = this;

    return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {
      var fileLoaderContext, fileLoader, sceneDataInterface, headDataFile, projectFileIndex, floorAxisFileIndexArray, i, length, index, materialFileIndexArray, loadMaterialArray, _i, _length, _index, refDefinitionFileIndexArray, loadRefDefinitionArray, _i2, _length2, _index2, terrainFileIndexArray, loadTerrainFileArray, _i4, _length3, _index3;

      return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              fileLoaderContext = _this.getFileLoadContext();
              fileLoader = fileLoaderContext.getFileLoader();
              sceneDataInterface = fileLoaderContext.getSceneDataInterface();
              headDataFile = sceneDataInterface.createHeadDataFile(bytes);

              fileLoader.setBasicFileTotal(sceneDataInterface.getBasicFileTotal(headDataFile));

              _context.next = 7;
              return sceneDataInterface.getSceneDataFile(headDataFile).then(function (res) {
                fileLoader.setBasicProgress(1);

                func(fileLoader.getBasicProgress());
                _this.loadSceneData(res);
              });

            case 7:
              projectFileIndex = sceneDataInterface.getProjectFileIndex(headDataFile);

              if (!projectFileIndex) {
                _context.next = 11;
                break;
              }

              _context.next = 11;
              return fileLoader.loadFile(fileLoader.getFileIndex(projectFileIndex.getURL())).then(function (res) {
                fileLoader.setBasicProgress(1);

                func(fileLoader.getBasicProgress());

                window.$CCBIM.projectManager.setBuildingInfoBufferData(res.data);
              });

            case 11:
              floorAxisFileIndexArray = sceneDataInterface.getFloorAxisFileIndexArray(headDataFile);

              if (!floorAxisFileIndexArray) {
                _context.next = 23;
                break;
              }

              i = 0, length = floorAxisFileIndexArray.length;

            case 14:
              if (!(i < length)) {
                _context.next = 23;
                break;
              }

              index = fileLoader.getFileIndex(floorAxisFileIndexArray[i].getURL());

              if (index) {
                _context.next = 18;
                break;
              }

              return _context.abrupt('continue', 20);

            case 18:
              _context.next = 20;
              return fileLoader.loadFile(index).then(function (res) {
                fileLoader.setBasicProgress(1);

                func(fileLoader.getBasicProgress());

                window.$CCBIM.projectManager.setFloorCrossLineBufferData(res.data);
              });

            case 20:
              i++;
              _context.next = 14;
              break;

            case 23:
              materialFileIndexArray = sceneDataInterface.getMaterialDataFileIndexArray(headDataFile);
              loadMaterialArray = [];
              _i = 0, _length = materialFileIndexArray.length;

            case 26:
              if (!(_i < _length)) {
                _context.next = 34;
                break;
              }

              _index = fileLoader.getFileIndex(materialFileIndexArray[_i].getURL());

              if (_index) {
                _context.next = 30;
                break;
              }

              return _context.abrupt('continue', 31);

            case 30:
              loadMaterialArray.push(fileLoader.loadFile(_index).then(function (res) {
                fileLoader.setBasicProgress(1);

                func(fileLoader.getBasicProgress());
                _this.loadMaterialData(res.data);
              }));

            case 31:
              _i++;
              _context.next = 26;
              break;

            case 34:
              _context.next = 36;
              return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.all(loadMaterialArray);

            case 36:
              refDefinitionFileIndexArray = sceneDataInterface.getRefDefinitionDataFileIndexArray(headDataFile);
              loadRefDefinitionArray = [];
              _i2 = 0, _length2 = refDefinitionFileIndexArray.length;

            case 39:
              if (!(_i2 < _length2)) {
                _context.next = 47;
                break;
              }

              _index2 = fileLoader.getFileIndex(refDefinitionFileIndexArray[_i2].getURL());

              if (_index2) {
                _context.next = 43;
                break;
              }

              return _context.abrupt('continue', 44);

            case 43:
              loadRefDefinitionArray.push(fileLoader.loadFile(_index2).then(function (res) {
                fileLoader.setBasicProgress(1);

                func(fileLoader.getBasicProgress());
                _this.loadRefDefinitionData(res.data);
              }));

            case 44:
              _i2++;
              _context.next = 39;
              break;

            case 47:
              _context.next = 49;
              return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.all(loadRefDefinitionArray).then(function () {
                _this.refDefinitionMap.forEach(function (refDefinition) {
                  var refObjectArray = refDefinition.getRefObjectArray();
                  for (var _i3 = 0, il = refObjectArray.length; _i3 < il; _i3++) {
                    var geometry = refObjectArray[_i3].geometry;

                    var vertexIndex = geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
                    if (vertexIndex) {
                      var indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
                      indexRange.setRange(0, vertexIndex.getBufferAttribute().array.length);
                      vertexIndex.addIndexRange(indexRange);
                    }
                  }
                });
              });

            case 49:
              terrainFileIndexArray = sceneDataInterface.getTerrainFileIndexArray(headDataFile);

              if (!terrainFileIndexArray) {
                _context.next = 63;
                break;
              }

              loadTerrainFileArray = [];
              _i4 = 0, _length3 = terrainFileIndexArray.length;

            case 53:
              if (!(_i4 < _length3)) {
                _context.next = 61;
                break;
              }

              _index3 = fileLoader.getFileIndex(terrainFileIndexArray[_i4].getURL());

              if (_index3) {
                _context.next = 57;
                break;
              }

              return _context.abrupt('continue', 58);

            case 57:

              loadTerrainFileArray.push(fileLoader.loadFile(_index3).then(function (res) {
                fileLoader.setBasicProgress(1);

                func(fileLoader.getBasicProgress());

                _this.loadTerrainData(res.data);
              }));

            case 58:
              _i4++;
              _context.next = 53;
              break;

            case 61:
              _context.next = 63;
              return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.all(loadTerrainFileArray).then(function () {
                if (loadTerrainFileArray.length > 0) {
                  var gridMeshEntMap = sceneDataInterface.getGridMeshEntMap();
                  var gridMeshInfoMap = sceneDataInterface.getGridMeshInfoMap();
                  var gridMeshGeoMap = sceneDataInterface.getGridMeshGeoMap();
                  var gridGroup = new window.$CCBIM.WebGL.Group();
                  gridGroup.name = 'gridGroup';
                  var sceneNode = new __WEBPACK_IMPORTED_MODULE_7__SceneNode__["a" /* default */]();
                  gridGroup.userData.sceneNode = sceneNode;
                  var bndBoxMin = new window.$CCBIM.WebGL.Vector3(0, 0, 0);
                  var bndBoxMax = new window.$CCBIM.WebGL.Vector3(0, 0, 0);
                  sceneNode.setBndBox(new window.$CCBIM.WebGL.Box3(bndBoxMin, bndBoxMax));
                  window.$CCBIM.webglContext.scene.add(gridGroup);

                  var entInfoArray = [];
                  var entDataArray = [];
                  sceneDataInterface.createGridEntInfoEntDataArray([].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(gridMeshInfoMap.values())), [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(gridMeshEntMap.values())), [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(gridMeshGeoMap.values())), entInfoArray, entDataArray);
                  for (var _i5 = 0, il = entInfoArray.length; _i5 < il; _i5++) {
                    sceneNode.addEntInfo(entInfoArray[_i5]);
                  }
                  for (var _i6 = 0, _il = entDataArray.length; _i6 < _il; _i6++) {
                    var entData = entDataArray[_i6];
                    var entInfoData = sceneNode.getOrCreateEntInfoData(entData.getEntID());
                    entInfoData.addEntData(entData);
                  }

                  gridMeshEntMap.forEach(function (ent) {
                    var meshGeoArray = gridMeshGeoMap.get(ent.meshID);

                    var bufferGeometry = sceneDataInterface.addTerrainGeometry(meshGeoArray, ent);
                    var vertexIndex = bufferGeometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
                    if (vertexIndex) {
                      for (var _i7 = 0, _il2 = entDataArray.length; _i7 < _il2; _i7++) {
                        if (entDataArray[_i7].isMeshData && entDataArray[_i7].getGeoID() === bufferGeometry.getUUID()) {
                          vertexIndex.addIndexRange(entDataArray[_i7].getTriangleDrawRange());
                        }
                      }
                    }
                    var material = _this.materialMap.get(meshGeoArray.material);
                    var model = new window.$CCBIM.WebGL.Mesh(bufferGeometry, material);
                    gridGroup.add(model);

                    for (var d = 0; d < entDataArray.length; d++) {
                      if (ent.meshID === entDataArray[d].geoID) {
                        entDataArray[d].setObject3D(model);
                      }
                    }
                    for (var _i8 = 0, _il3 = entInfoArray.length; _i8 < _il3; _i8++) {
                      sceneNode.getEntInfo(entInfoArray[_i8].id).setEntDataArray(entDataArray);
                    }

                    for (var f = 0; f < meshGeoArray.otherFace.length; f++) {
                      var faceIndex = meshGeoArray.otherFace[f];
                      var otherGEO = sceneDataInterface.addTerrainOtherGeometry(faceIndex);
                      var otherMate = _this.materialMap.get(faceIndex.material);
                      var otherModel = new window.$CCBIM.WebGL.Mesh(otherGEO, otherMate);
                      gridGroup.add(otherModel);
                      var _vertexIndex = otherGEO.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
                      if (_vertexIndex) {
                        for (var _i9 = 0, _il4 = entDataArray.length; _i9 < _il4; _i9++) {
                          if (entDataArray[_i9].isMeshData && entDataArray[_i9].getGeoID() === otherGEO.getUUID()) {
                            entDataArray[_i9].setObject3D(otherModel);
                            _vertexIndex.addIndexRange(entDataArray[_i9].getTriangleDrawRange());
                          }
                        }
                      }
                    }
                  });
                }
              });

            case 63:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }))();
  },


  showGeometryWire: function showGeometryWire() {
    this.setGeometryWireVisible(true);
  },

  hideGeometryWire: function hideGeometryWire() {
    this.setGeometryWireVisible(false);
  },

  setGeometryWireVisible: function setGeometryWireVisible(value) {
    var _this2 = this;

    this.refDefinitionMap.forEach(function (refDefinition) {
      var refObjectArray = refDefinition.getRefObjectArray();
      for (var i = 0, il = refObjectArray.length; i < il; i++) {
        var geometry = refObjectArray[i].geometry;
        var wireIndex = geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.LINES);
        if (wireIndex) {
          var indexRangeArray = wireIndex.getIndexRangeArray();
          for (var j = 0, jl = indexRangeArray.length; j < jl; j++) {
            indexRangeArray[j].setVisible(value);
          }
        } else {
          if (value === true) {
            _this2.geometryWireMap.set(geometry.getUUID(), geometry);
          }
        }
      }
    });

    var groupArray = [];
    groupArray.push(this.webglContext.getScene());
    for (var i = 0; i < groupArray.length; i++) {
      var group = groupArray[i];
      var sceneNode = this.getSceneNode(group);
      if (sceneNode) {
        var objectMap = sceneNode.getObjectMap();
        objectMap.forEach(function (object) {
          var geometry = object.geometry;
          if (geometry && geometry.isPMBufferGeometry && !geometry.isPMInstanceBufferGeometry) {
            var wireIndex = geometry.getVertexIndex(window.$CCBIM.WebGL.DRAWMODE.LINES);
            if (wireIndex) {
              var indexRangeArray = wireIndex.getIndexRangeArray();
              for (var j = 0, jl = indexRangeArray.length; j < jl; j++) {
                indexRangeArray[j].setVisible(value);
              }
            } else {
              if (value === true) {
                _this2.geometryWireMap.set(geometry.getUUID(), geometry);
              }
            }
          }
        });
      }
      for (var j = 0, jl = group.children.length; j < jl; j++) {
        groupArray.push(group.children[j]);
      }
    }

    this.geometryWireMap.forEach(function (geometry) {
      _this2.computeGeometryWire(geometry, function (geoUUID, indices) {
        _this2.createGeoWireFunc(geoUUID, indices);
      });
    });
  },

  createGeoWireFunc: function createGeoWireFunc(geoUUID, indices) {
    if (!this.geometryWireMap) {
      return;
    }
    var geometry = this.geometryWireMap.get(geoUUID);
    if (geometry) {
      var indexBuffer = indices;
      var indexAttribute = new window.$CCBIM.WebGL.VertexIndex(window.$CCBIM.WebGL.DRAWMODE.LINES);
      indexAttribute.setIndex(indexBuffer);
      var indexRange = new window.$CCBIM.WebGL.VertexIndexRange();
      indexRange.setRange(0, indexBuffer.length);
      indexRange.setDiffuse(this.geometryWireColor);
      indexRange.setVisible(true);
      indexAttribute.addIndexRange(indexRange);
      geometry.addVertexIndex(indexAttribute);

      this.geometryWireMap.delete(geoUUID);
    }
  },

  loadSceneData: function loadSceneData(sceneDataFile) {
    var wegGLContext = this.webglContext;
    var fileLoaderContext = this.getFileLoadContext();
    var sceneDataInterface = fileLoaderContext.getSceneDataInterface();
    var rootNode = sceneDataInterface.getRootNode(sceneDataFile);
    sceneDataInterface.createSceneTree(rootNode, wegGLContext.scene);

    var sceneData = this.sceneData;

    var sceneTreeBndBox = sceneDataInterface.getSceneTreeBndBox(sceneDataFile);
    var bndBoxMin = sceneTreeBndBox.bndBoxMin;
    var bndBoxMax = sceneTreeBndBox.bndBoxMax;

    sceneData.bndBoxMin[0] = bndBoxMin[0];
    sceneData.bndBoxMin[1] = bndBoxMin[1];
    sceneData.bndBoxMin[2] = bndBoxMin[2];

    sceneData.bndBoxMax[0] = bndBoxMax[0];
    sceneData.bndBoxMax[1] = bndBoxMax[1];
    sceneData.bndBoxMax[2] = bndBoxMax[2];

    sceneData.maxBoundingValue = Math.sqrt(Math.pow(bndBoxMax[0] - bndBoxMin[0], 2) + Math.pow(bndBoxMax[1] - bndBoxMin[1], 2) + Math.pow(bndBoxMax[2] - bndBoxMin[2], 2));

    var defCamera = sceneDataInterface.getDefaultCamera(sceneDataFile);
    if (defCamera) {
      sceneData.viewPosition = defCamera.position;
      sceneData.viewTarget = defCamera.target;
      sceneData.viewUp = defCamera.up;
    } else {
      sceneData.viewTarget = [];
      sceneData.viewTarget[0] = (bndBoxMin[0] + bndBoxMax[0]) / 2;
      sceneData.viewTarget[1] = (bndBoxMin[1] + bndBoxMax[1]) / 2;
      sceneData.viewTarget[2] = (bndBoxMin[2] + bndBoxMax[2]) / 2;
      sceneData.viewUp = [0, 0, 1];
      var dist = Math.sqrt(Math.pow(bndBoxMax[0] - bndBoxMin[0], 2), Math.pow(bndBoxMax[1] - bndBoxMin[1], 2), Math.pow(bndBoxMax[2] - bndBoxMin[2], 2));
      sceneData.viewPosition = [];
      sceneData.viewPosition[0] = sceneData.viewTarget[0] + dist;
      sceneData.viewPosition[1] = sceneData.viewTarget[1] - dist;
      sceneData.viewPosition[2] = sceneData.viewTarget[2] + dist;
    }

    sceneData.scale = sceneDataInterface.getSceneScale(sceneDataFile);
  },

  loadMaterialData: function loadMaterialData(bytes) {
    var fileLoaderContext = this.getFileLoadContext();
    var bufferDataInterface = fileLoaderContext.getBufferDataInterface();
    bufferDataInterface.createMaterialMap(bytes, this.textureImageMap, this.materialMap, false);
    bufferDataInterface.createMaterialMap(bytes, this.textureImageMap, this.refMaterialMap, true);
  },

  loadRefDefinitionData: function loadRefDefinitionData(bytes) {
    var fileLoaderContext = this.getFileLoadContext();
    var bufferDataInterface = fileLoaderContext.getBufferDataInterface();
    bufferDataInterface.createRefDefinitionMap(bytes, this.refMaterialMap, this.refDefinitionMap);
  },

  loadFloorTreeData: function loadFloorTreeData(bytes) {
    var fileLoaderContext = this.getFileLoadContext();
    var componentDataInterface = fileLoaderContext.getComponentDataInterface();
    window.$CCBIM.projectManager.setStageInfo(componentDataInterface.createStageInfoArray(bytes));
    var buildingInfo = componentDataInterface.createBuildingInfoArray(bytes);
    return buildingInfo;
  },

  loadFloorCrossLineData: function loadFloorCrossLineData(bytes) {
    var fileLoaderContext = this.getFileLoadContext();
    var componentDataInterface = fileLoaderContext.getComponentDataInterface();
    window.$CCBIM.projectManager.setFloorCrossLine(componentDataInterface.createFloorCrossLine(bytes));
  },

  loadTerrainData: function loadTerrainData(bytes) {
    var fileLoaderContext = this.getFileLoadContext();
    var bufferDataInterface = fileLoaderContext.getBufferDataInterface();
    var bufferDataFile = bufferDataInterface.createTerrainDataFile(bytes);

    bufferDataInterface.setTerrainDataMap(bufferDataFile);
  },

  getSceneNode: function getSceneNode(group) {
    if (!group) {
      return null;
    }
    return group.userData.sceneNode;
  },

  loadBufferGeometryData: function loadBufferGeometryData(bytes, group) {
    var geoArray = [];
    var fileLoaderContext = this.getFileLoadContext();
    var bufferDataInterface = fileLoaderContext.getBufferDataInterface();
    var bufferDataFile = bufferDataInterface.createBufferGeometryDataFile(bytes);
    bufferDataInterface.createGeometryArray(bufferDataFile, this.materialMap, this.refDefinitionMap, geoArray);
    var sceneNode = this.getSceneNode(group);
    for (var i = 0, length = geoArray.length; i < length; i++) {
      var geometry = geoArray[i];
      var material = geometry.material;
      var materialGroup = sceneNode.getMaterialGroup(material);
      if (!materialGroup) {
        materialGroup = sceneNode.getOrCreateMaterialGroup(material);
        group.add(materialGroup);
      }
      materialGroup.add(geometry);
    }
    sceneNode.setHaveLoad();

    var entInfoArray = [];
    var entDataArray = [];
    bufferDataInterface.createEntInfoEntDataArray(bufferDataFile, this.refDefinitionMap, entInfoArray, entDataArray);
    for (var _i10 = 0, il = entInfoArray.length; _i10 < il; _i10++) {
      sceneNode.addEntInfo(entInfoArray[_i10]);
    }
    for (var _i11 = 0, _il5 = entDataArray.length; _i11 < _il5; _i11++) {
      var entData = entDataArray[_i11];
      var entInfoData = sceneNode.getOrCreateEntInfoData(entData.getEntID());
      entInfoData.addEntData(entData);
    }

    this.setNeedUpdate(true);
  },

  loadBIMEntData: function loadBIMEntData(bytes, sceneNode) {
    var fileLoaderContext = this.getFileLoadContext();
    var bimDataInterface = fileLoaderContext.getBIMDataInterface();
    var entDataArray = [];
    bimDataInterface.createEntDataArray(bytes, this.refDefinitionMap, entDataArray);
    for (var i = 0, il = entDataArray.length; i < il; i++) {
      var entData = entDataArray[i];
      var entInfoData = sceneNode.getOrCreateEntInfoData(entData.getEntID());
      entInfoData.addEntData(entData);
    }
  },

  loadBIMEntInfo: function loadBIMEntInfo(bytes, sceneNode) {
    var fileLoaderContext = this.getFileLoadContext();
    var bimDataInterface = fileLoaderContext.getBIMDataInterface();
    var entInfoArray = [];
    bimDataInterface.createEntInfoArray(bytes, entInfoArray);
    for (var i = 0, il = entInfoArray.length; i < il; i++) {
      sceneNode.addEntInfo(entInfoArray[i]);
    }
  },

  loadGroup: function loadGroup(loadQueue, promiseArray, loadingFunc) {
    var _this3 = this;

    var _loop = function _loop(i, length) {
      var group = loadQueue[i];
      var sceneNode = _this3.getSceneNode(group);
      if (!sceneNode) {
        return 'continue';
      }

      var pageData = sceneNode.getCurPage();
      if (!pageData) {
        return 'continue';
      }

      var fileLoader = _this3.getFileLoadContext().getFileLoader();

      var bufferGeoFileIndexArray = pageData.getBufferGeometryFileList();
      for (var _i12 = 0, _length4 = bufferGeoFileIndexArray.length; _i12 < _length4; _i12++) {
        var index = fileLoader.getFileIndex(bufferGeoFileIndexArray[_i12].getURL());
        if (!index) {
          continue;
        }
        var promise = fileLoader.loadFile(index).then(function (res) {
          _this3.loadBufferGeometryData(res.data, group);

          fileLoader.setEntInfoProgress(1);
          loadingFunc(fileLoader.getEntInfoProgress());
        });

        if (promise) {
          promiseArray.push(promise);
        }
      }

      var entDataFileArray = pageData.getEntDataFileList();
      for (var _i13 = 0, _length5 = entDataFileArray.length; _i13 < _length5; _i13++) {
        var _index4 = fileLoader.getFileIndex(entDataFileArray[_i13].getURL());
        if (!_index4) {
          continue;
        }
        var _promise = fileLoader.loadFile(_index4).then(function (res) {
          _this3.loadBIMEntData(res.data, sceneNode);

          fileLoader.setEntInfoProgress(1);
          loadingFunc(fileLoader.getEntInfoProgress());
        });

        if (_promise) {
          promiseArray.push(_promise);
        }
      }

      var entInfoFileArray = sceneNode.getEntInfoFileList();
      for (var _i14 = 0, _length6 = entInfoFileArray.length; _i14 < _length6; _i14++) {
        var _index5 = fileLoader.getFileIndex(entInfoFileArray[_i14].getURL());
        if (!_index5) {
          continue;
        }
        var _promise2 = fileLoader.loadFile(_index5).then(function (res) {
          _this3.loadBIMEntInfo(res.data, sceneNode);

          fileLoader.setEntInfoProgress(1);
          loadingFunc(fileLoader.getEntInfoProgress());
        });

        if (_promise2) {
          promiseArray.push(_promise2);
        }
      }
    };

    for (var i = 0, length = loadQueue.length; i < length; i++) {
      var _ret = _loop(i, length);

      if (_ret === 'continue') continue;
    }
  },

  realTimeLoading: function realTimeLoading(loadingFunc, finishFunc) {
    var _this4 = this;

    if (this.isLoading) {
      return;
    }
    this.isLoading = true;
    var webglContext = this.webglContext;
    var frustum = webglContext.getRenderer().getFrustum();

    this.initLoadQueue(webglContext.getScene(), frustum, webglContext.getCamera().position, this.realLoadQueue);

    var loadQueue = this.geometryGroupSort(this.realLoadQueue, webglContext.getCamera().position);

    var fileLoader = this.getFileLoadContext().getFileLoader();
    fileLoader.setEntInfoFileTotal(this.getEntInfoFileTotalSize(loadQueue));

    this.loadGroup(loadQueue, this.promiseArr, loadingFunc);

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.all(this.promiseArr).then(function () {
      for (var i = 0, length = loadQueue.length; i < length; i++) {
        var _sceneNode = _this4.getSceneNode(loadQueue[i]);
        if (!_sceneNode) {
          continue;
        }
        _sceneNode.finish();
      }
      if (_this4.promiseArr.length > 0) {
        window.$CCBIM.sceneManager.setNeedUpdate(true);

        window.$CCBIM.projectManager.removeBottomShadow();
        if (_this4.switchBottomShadow) {
          window.$CCBIM.projectManager.setBottomShadow();
        }

        if (_this4.switchGeometryWire) {
          _this4.showGeometryWire();
        }

        finishFunc();
      }
      _this4.realLoadQueue = [];
      for (var _i15 = 0, _length7 = _this4.promiseArr.length; _i15 < _length7; _i15++) {
        _this4.promiseArr[_i15] = null;
      }
      _this4.promiseArr = [];
      _this4.isLoading = false;
    });
  },

  getEntInfoFileTotalSize: function getEntInfoFileTotalSize(loadQueue) {
    var fileTotalSize = 0;
    for (var f = 0; f < loadQueue.length; f++) {
      var groupIndex = loadQueue[f];
      var _sceneNode2 = this.getSceneNode(groupIndex);
      if (!_sceneNode2) {
        continue;
      }

      var pageData = _sceneNode2.getCurPage();
      if (!pageData) {
        continue;
      }

      var _bufferGeoFileIndexArray = pageData.getBufferGeometryFileList();
      for (var i = 0, length = _bufferGeoFileIndexArray.length; i < length; i++) {
        fileTotalSize++;
      }

      var _entDataFileArray = pageData.getEntDataFileList();
      for (var _i16 = 0, _length8 = _entDataFileArray.length; _i16 < _length8; _i16++) {
        fileTotalSize++;
      }

      var _entInfoFileArray = _sceneNode2.getEntInfoFileList();
      for (var _i17 = 0, _length9 = _entInfoFileArray.length; _i17 < _length9; _i17++) {
        fileTotalSize++;
      }
    }
    return fileTotalSize;
  },


  initLoadQueue: function initLoadQueue(group, frustum, cameraPosition, realLoadQueue) {
    if (group.name === 'gridGroup') {
      return;
    }
    var sceneNode = this.getSceneNode(group);
    if (sceneNode) {
      var bndBox = sceneNode.getBndBox();

      var pageData = null;
      if (frustum.intersectsBox(bndBox)) {
        pageData = sceneNode.getPageData();
        if (!pageData) {
          var center = new window.$CCBIM.WebGL.Vector3((bndBox.max.x + bndBox.min.x) / 2, (bndBox.max.y + bndBox.min.y) / 2, (bndBox.max.z + bndBox.min.z) / 2);

          var dist = cameraPosition.distanceTo(center);

          var pageLODArray = sceneNode.getPageLODArray();
          for (var i = 0, length = pageLODArray.length; i < length; i++) {
            var pageLOD = pageLODArray[i];
            if (dist < pageLOD.getMaxLoadDistance()) {
              pageData = pageLOD.getPageData();
              break;
            }
          }
        }
      }

      sceneNode.setNextPage(pageData);

      realLoadQueue.push(group);
    }

    for (var _i18 = 0, _length10 = group.children.length; _i18 < _length10; _i18++) {
      this.initLoadQueue(group.children[_i18], frustum, cameraPosition, realLoadQueue);
    }
  },

  ascSort: function ascSort(a, b) {
    return a.distance - b.distance;
  },

  geometryGroupSort: function geometryGroupSort(groupArray, cameraPosition) {
    var maxMemoryLimit = 0;
    if (window.$CCBIM.render.propertyPer <= 0.2) {
      window.$CCBIM.render.propertyPer = 0.2;
    }
    if (this.isPhone) {
      maxMemoryLimit = this.MAX_MEMORY_LIMIT_MOBILE * window.$CCBIM.render.propertyPer;
      if (maxMemoryLimit < 500 * 1024) {
        maxMemoryLimit = 500 * 1204;
      }
    } else {
      maxMemoryLimit = this.MAX_MEMORY_LIMIT_PC * window.$CCBIM.render.propertyPer;
    }
    if (window.$CCBIM.render.propertyPer >= 0.9) {
      maxMemoryLimit = Infinity;
    }

    var distanceArray = [];
    for (var g = 0, len = groupArray.length; g < len; g++) {
      var itemIndex = groupArray[g];
      var bndBoxMax = itemIndex.userData.sceneNode.bndBox.max;
      var bndBoxMin = itemIndex.userData.sceneNode.bndBox.min;

      var bndBoxCenter = new window.$CCBIM.WebGL.Vector3((bndBoxMax.x + bndBoxMin.x) / 2, (bndBoxMax.y + bndBoxMin.y) / 2, (bndBoxMax.z + bndBoxMin.z) / 2);
      var distance = Math.sqrt(Math.pow(bndBoxCenter.x - cameraPosition.x, 2) + Math.pow(bndBoxCenter.y - cameraPosition.y, 2) + Math.pow(bndBoxCenter.z - cameraPosition.z, 2));
      var obj = {
        distance: distance,
        group: itemIndex
      };
      distanceArray.push(obj);
    }

    for (var d = 0, distanceArrayLen = distanceArray.length - 1; d < distanceArrayLen; d++) {
      for (var x = 0, distanceArrayBubbleLen = distanceArrayLen - d; x < distanceArrayBubbleLen; x++) {
        if (distanceArray[x].distance > distanceArray[x + 1].distance) {
          var a = distanceArray[x];
          distanceArray[x] = distanceArray[x + 1];
          distanceArray[x + 1] = a;
        }
      }
    }

    var usedList = [];
    for (var r = 0, removeLen = distanceArray.length; r < removeLen; r++) {
      var groupIndex = distanceArray[r].group;
      var _sceneNode3 = this.getSceneNode(groupIndex);
      if (!_sceneNode3.getHaveLoad()) {
        if (this.sceneNodeMemorySize * (r + 1) < maxMemoryLimit) {
          _sceneNode3.setCurPage(_sceneNode3.getNextPage());
          usedList.push(groupIndex);
        }
      } else {
        if (this.sceneNodeMemorySize * (r + 1) > maxMemoryLimit) {
          groupIndex.removeAll();
          _sceneNode3.clearData();
          _sceneNode3.clearNextPage();
          _sceneNode3.clearCurPage();
          _sceneNode3.removeHaveLoad();
        }
      }
    }

    return usedList;
  },
  getSceneNodeArray: function getSceneNodeArray() {
    var sceneNodeArray = [];
    var groupArray = [];
    groupArray.push(this.webglContext.getScene());
    for (var i = 0; i < groupArray.length; i++) {
      var _group = groupArray[i];
      var _sceneNode4 = this.getSceneNode(_group);
      if (_sceneNode4) {
        sceneNodeArray.push(_sceneNode4);
      }
      for (var j = 0, jl = _group.children.length; j < jl; j++) {
        groupArray.push(_group.children[j]);
      }
    }
    return sceneNodeArray;
  },

  selectEnt: function selectEnt(worldCoordinate) {
    var _this5 = this;

    var webglContext = this.webglContext;
    var camera = webglContext.getCamera();
    var ray = new window.$CCBIM.WebGL.Raycaster();
    ray.far = camera.far;
    ray.near = camera.near;
    ray.setFromCamera(worldCoordinate, camera);
    var sceneNodeArray = [];

    var groupArray = [];
    groupArray.push(webglContext.getScene());
    for (var i = 0; i < groupArray.length; i++) {
      var _group2 = groupArray[i];
      var _sceneNode5 = this.getSceneNode(_group2);
      if (_sceneNode5 && ray.ray.intersectsBox(_sceneNode5.getBndBox())) {
        sceneNodeArray.push(_sceneNode5);
      }
      for (var j = 0, jl = _group2.children.length; j < jl; j++) {
        groupArray.push(_group2.children[j]);
      }
    }

    var testResultArray = [];
    for (var _i19 = 0, il = sceneNodeArray.length; _i19 < il; _i19++) {
      sceneNodeArray[_i19].entInfoMap.forEach(function (entInfo) {
        if (!entInfo.getVisible()) {
          return true;
        }
        var entDataArray = entInfo.getEntDataArray();
        var testObjectMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();
        var testObjectQueue = [];

        for (var _j = 0, _jl = entDataArray.length; _j < _jl; _j++) {
          var entData = entDataArray[_j];
          if (!ray.ray.intersectsBox(entData.getBndBox())) {
            continue;
          }

          var object = entData.getObject3D();
          if (!object) {
            continue;
          }
          var geometry = object.geometry;
          if (geometry.isPMBufferGeometry || geometry.isPMInstanceBufferGeometry) {
            if (!testObjectMap.get(geometry.getUUID())) {
              testObjectMap.set(geometry.getUUID(), object);
              testObjectQueue.push(object);
              _this5.resetGeometryPick(geometry);
            }
            entData.setPick();
          }
        }

        var result = ray.intersectObjects(testObjectQueue, true);
        if (result.length > 0) {
          testResultArray.push({ distance: result[0].distance, point: result[0].point, entInfo: entInfo });
        }

        for (var _j2 = 0, _jl2 = testObjectQueue.length; _j2 < _jl2; _j2++) {
          _this5.resetGeometryPick(testObjectQueue[_j2].geometry);
        }

        testObjectMap = null;
      });
    }

    testResultArray.sort(this.ascSort);
    var result = [];
    for (var _i20 = 0, _il6 = testResultArray.length; _i20 < _il6; _i20++) {
      result.push(testResultArray[_i20]);
    }
    return result;
  },

  resetGeometryPick: function resetGeometryPick(geometry) {
    if (!geometry) {
      return;
    }
    if (geometry.isPMInstanceBufferGeometry) {
      geometry.clearPickMatrixIndex();
    } else {
      var index = geometry.getVertexIndex(__WEBPACK_IMPORTED_MODULE_6__THREE_constants__["e" /* DRAWMODE */].TRIANGLES);
      if (index) {
        index.clearPickRangeArray();
      }
    }
  },

  highlightEnt: function highlightEnt(entInfo, color, opacity) {
    var _this6 = this;

    return new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      if (!entInfo || _this6.highlightMap.get(entInfo.getID()) || _this6.opactiyEntMap.get(entInfo.getID())) {
        reject('');
        return;
      }

      var entDataArray = entInfo.getEntDataArray();
      for (var i = 0, il = entDataArray.length; i < il; i++) {
        entDataArray[i].setHighlight(color, opacity);
        _this6.highlightMap.set(entInfo.getID(), entInfo);
      }
      resolve('');
    });
  },

  clearHighlight: function clearHighlight() {
    this.highlightMap.forEach(function (entInfo) {
      var entDataArray = entInfo.getEntDataArray();
      for (var i = 0, il = entDataArray.length; i < il; i++) {
        entDataArray[i].clearHighlight();
      }
    });
    this.highlightMap.clear();
    this.selectedGeometry = null;
  },

  opactiyEnt: function opactiyEnt(entInfo, color, opacity) {
    var _this7 = this;

    return new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      if (!entInfo) {
        reject();
        return;
      }

      var entDataArray = entInfo.getEntDataArray();
      for (var i = 0, il = entDataArray.length; i < il; i++) {
        entDataArray[i].setHighlight(color, opacity);
        _this7.opactiyEntMap.set(entInfo.getID(), entInfo);
      }
      resolve();
    });
  },

  clearOpaCity: function clearOpaCity() {
    this.opactiyEntMap.forEach(function (entInfo) {
      var entDataArray = entInfo.getEntDataArray();
      for (var i = 0, il = entDataArray.length; i < il; i++) {
        entDataArray[i].clearHighlight();
      }
    });
    this.opactiyEntMap.clear();
  },

  setEntVisible: function setEntVisible(entInfo, visible) {
    if (!entInfo) {
      return;
    }

    entInfo.setVisible(visible);
  },

  setSelectGeometry: function setSelectGeometry(selectedGeometry) {
    this.selectedGeometry = selectedGeometry;
  },
  getSelectGeometry: function getSelectGeometry() {
    return this.selectedGeometry;
  },

  computeGeometryWire: function computeGeometryWire(geometry, callback) {
    if (!geometry || !geometry.isPMBufferGeometry) {
      return;
    }

    var positionAttribute = geometry.getBufferAttribute('position');
    var indexAttribute = geometry.getIndex(window.$CCBIM.WebGL.DRAWMODE.TRIANGLES);
    if (!positionAttribute || !indexAttribute) {
      return;
    }

    this.computeWireWorker.postMessage({
      positions: positionAttribute.array,
      face: indexAttribute.array,
      geoUUID: geometry.getUUID()
    });
    this.computeWireWorker.onmessage = function (msg) {
      if (callback) {
        callback(msg.data.geoUUID, msg.data.indices);
      }
    };
  }
};

/* harmony default export */ __webpack_exports__["a"] = (SceneManager);

/***/ }),
/* 503 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function GridBuilder(originPosition, offset) {
  this.type = 'gridBuilder';

  this.origin = originPosition.origin;
  this.gridSize = originPosition.gridSize;
  this.material = originPosition.material;

  this.offset = {
    bndBoxMin: offset.bndBoxMin,
    bndBoxMax: offset.bndBoxMax,
    columnOffset: offset.columnOffset,
    columnCount: offset.columnCount,
    rowOffset: offset.rowOffset,
    rowCount: offset.rowCount,
    vertexColPos: offset.vertexColPos,
    vertexRowPos: offset.vertexRowPos,
    vertexHeight: offset.vertexHeight
  };
}

GridBuilder.prototype = {
  constructor: GridBuilder,

  getAttribute: function getAttribute() {
    var originZ = this.origin[2];
    var offsetStartX = this.origin[0] + this.offset.columnOffset * this.gridSize;
    var offsetStartY = this.origin[1] + this.offset.rowOffset * this.gridSize;

    var positionArray = [];
    for (var r = 0, rowLen = this.offset.rowCount; r < rowLen; r++) {
      for (var c = 0, columnLen = this.offset.columnCount; c < columnLen; c++) {
        positionArray.push(offsetStartX + this.gridSize * c, offsetStartY + this.gridSize * r, originZ);
      }
    }

    var indexArray = [];
    for (var i = 0, len = this.offset.rowCount * this.offset.columnCount; i < len; i++) {
      if (i >= this.offset.rowCount * this.offset.columnCount - this.offset.columnCount) {
        continue;
      }
      if (i % this.offset.columnCount === this.offset.columnCount - 1) {
        continue;
      }
      indexArray.push(i, i + 1, i + 1 + this.offset.columnCount);
      indexArray.push(i, i + 1 + this.offset.columnCount, i + this.offset.columnCount);
    }

    for (var v = 0, vLen = this.offset.vertexColPos.length; v < vLen; v++) {
      var vertexIndex = this.offset.vertexColPos[v] + this.offset.columnCount * this.offset.vertexRowPos[v];
      positionArray[vertexIndex * 3 + 2] = this.offset.vertexHeight[v];
    }

    var uvArray = [];
    var curU = 0.0;
    var curV = 0.0;
    for (var _r = 0, _rowLen = this.offset.rowCount; _r < _rowLen; _r++) {
      curU = _r / 50;
      for (var _c = 0, _columnLen = this.offset.columnCount; _c < _columnLen; _c++) {
        curV = _c / 50;
        uvArray.push(curU, curV);
      }
    }
    return {
      position: positionArray,
      index: indexArray,
      uv: uvArray
    };
  }
};

/* harmony default export */ __webpack_exports__["a"] = (GridBuilder);

/***/ }),
/* 504 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__controls_ClippingControls_js__ = __webpack_require__(479);


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showClipping: false,
      showClippingHelp: true,
      assignmentLine: '',

      dragControls: null,

      clippingMax: null,

      clippingMin: null,

      basedComponentCut: false,
      showComponentCut: false
    };
  },
  created: function created() {
    window.$CCBIM.clippingGroup = new window.$CCBIM.WebGL.Group();
    window.$CCBIM.clippingPlane = [];
    window.$CCBIM.clippingObjects = [];
    this.initClippingPlane();
  },

  methods: {
    initClippingPlane: function initClippingPlane() {
      var plane1 = new window.$CCBIM.WebGL.Plane(new window.$CCBIM.WebGL.Vector3(0, -1, 0), 0);
      plane1.name = 'y1';
      var plane2 = new window.$CCBIM.WebGL.Plane(new window.$CCBIM.WebGL.Vector3(0, 1, 0), 0);
      plane2.name = 'y2';
      var plane3 = new window.$CCBIM.WebGL.Plane(new window.$CCBIM.WebGL.Vector3(1, 0, 0), 0);
      plane3.name = 'x1';
      var plane4 = new window.$CCBIM.WebGL.Plane(new window.$CCBIM.WebGL.Vector3(-1, 0, 0), 0);
      plane4.name = 'x2';
      var plane5 = new window.$CCBIM.WebGL.Plane(new window.$CCBIM.WebGL.Vector3(0, 0, -1), 0);
      plane5.name = 'z1';
      var plane6 = new window.$CCBIM.WebGL.Plane(new window.$CCBIM.WebGL.Vector3(0, 0, 1), 0);
      plane6.name = 'z2';
      window.$CCBIM.clippingPlane.push(plane1, plane2, plane3, plane4, plane5, plane6);
    },
    clippingBox: function clippingBox(maxClipPoint, minClipPoint) {
      this.clippingMax = new window.$CCBIM.WebGL.Vector3(maxClipPoint.x, maxClipPoint.y, maxClipPoint.z);
      this.clippingMin = new window.$CCBIM.WebGL.Vector3(minClipPoint.x, minClipPoint.y, minClipPoint.z);
    },
    clippingPosition: function clippingPosition(py1, py2, px1, px2, pz1, pz2) {
      var _this = this;

      var sceneData = window.$CCBIM.sceneManager.getSceneData();
      window.$CCBIM.clippingPlane.forEach(function (x) {
        switch (x.name) {
          case 'y1':
            if (py1) {
              x.constant = py1 * sceneData.scale;
            } else {
              x.constant = _this.clippingMax.y + sceneData.scale * 10;
            }
            break;
          case 'y2':
            if (py2) {
              x.constant = py2 * sceneData.scale;
            } else {
              x.constant = -_this.clippingMin.y + sceneData.scale * 10;
            }
            break;
          case 'x1':
            if (px1) {
              x.constant = px1 * sceneData.scale;
            } else {
              x.constant = -_this.clippingMin.x + sceneData.scale * 10;
            }
            break;
          case 'x2':
            if (px2) {
              x.constant = px2 * sceneData.scale;
            } else {
              x.constant = _this.clippingMax.x + sceneData.scale * 10;
            }
            break;
          case 'z1':
            if (pz1) {
              x.constant = pz1 * sceneData.scale;
            } else {
              x.constant = _this.clippingMax.z + sceneData.scale * 10;
            }
            break;
          case 'z2':
            if (pz2) {
              x.constant = pz2 * sceneData.scale;
            } else {
              x.constant = -_this.clippingMin.z + sceneData.scale * 10;
            }
            break;
        }
      });
    },
    clippingGeometry: function clippingGeometry() {
      var max = this.clippingMax;
      var min = this.clippingMin;
      var maxX = Math.abs(min.x) + Math.abs(max.x);
      var maxY = Math.abs(min.y) + Math.abs(max.y);
      var maxZ = Math.abs(min.z) + Math.abs(max.z);

      var boxGeometry = new window.$CCBIM.WebGL.BoxGeometry(maxX, maxY, maxZ);

      var material = new window.$CCBIM.WebGL.MeshBasicMaterial({ color: 0x00ff00 });

      var boxMesh = new window.$CCBIM.WebGL.Mesh(boxGeometry, material);

      var boxHelper = new window.$CCBIM.WebGL.BoxHelper(boxMesh, '#00b589');
      boxHelper.name = 'clippingBoxHelp';
      window.$CCBIM.clippingGroup.add(boxHelper);

      var bufferGeometry = boxHelper.geometry;
      var positionAttribute = bufferGeometry.getAttribute('position');
      var positionArray = positionAttribute.array;
      positionArray[0] = max.x;
      positionArray[1] = max.y;
      positionArray[2] = max.z;

      positionArray[3] = min.x;
      positionArray[4] = max.y;
      positionArray[5] = max.z;

      positionArray[6] = min.x;
      positionArray[7] = min.y;
      positionArray[8] = max.z;

      positionArray[9] = max.x;
      positionArray[10] = min.y;
      positionArray[11] = max.z;

      positionArray[12] = max.x;
      positionArray[13] = max.y;
      positionArray[14] = min.z;

      positionArray[15] = min.x;
      positionArray[16] = max.y;
      positionArray[17] = min.z;

      positionArray[18] = min.x;
      positionArray[19] = min.y;
      positionArray[20] = min.z;

      positionArray[21] = max.x;
      positionArray[22] = min.y;
      positionArray[23] = min.z;

      positionAttribute.needsUpdate = true;

      boxGeometry.vertices = [];
      boxGeometry.vertices.push(new window.$CCBIM.WebGL.Vector3(max.x, max.y, max.z), new window.$CCBIM.WebGL.Vector3(max.x, max.y, min.z), new window.$CCBIM.WebGL.Vector3(max.x, min.y, max.z), new window.$CCBIM.WebGL.Vector3(max.x, min.y, min.z), new window.$CCBIM.WebGL.Vector3(min.x, max.y, min.z), new window.$CCBIM.WebGL.Vector3(min.x, max.y, max.z), new window.$CCBIM.WebGL.Vector3(min.x, min.y, min.z), new window.$CCBIM.WebGL.Vector3(min.x, min.y, max.z));
      boxGeometry.verticesNeedUpdate = true;

      window.$CCBIM.clippingObjects = [];
      window.$CCBIM.clippingObjects.push(boxMesh);
      window.$CCBIM.clippingGroup.name = 'clipping';
      window.$CCBIM.webglContext.scene.add(window.$CCBIM.clippingGroup);
    },
    clippingDrag: function clippingDrag() {
      this.dragControls = new __WEBPACK_IMPORTED_MODULE_0__controls_ClippingControls_js__["a" /* default */]();
      this.dragControls.addEventListener('dragstart', function () {
        window.$CCBIM.controller.enabled = false;
        window.$CCBIM.viewBox.controllerBox.enabled = false;
      });
      this.dragControls.addEventListener('dragend', function () {
        window.$CCBIM.controller.enabled = true;
        window.$CCBIM.viewBox.controllerBox.enabled = true;
      });
    },
    profileHandle: function profileHandle() {
      window.$CCBIM.sceneManager.setNeedUpdate(true);

      this.showClippingHelp = true;
      window.$CCBIM.clippingGroup.removeAll();
      window.$CCBIM.webglContext.scene.remove(window.$CCBIM.clippingGroup);

      var sceneData = window.$CCBIM.sceneManager.getSceneData();
      var projectMinPt = sceneData.bndBoxMin;
      var projectMaxPt = sceneData.bndBoxMax;
      var maxClipPoint = new window.$CCBIM.WebGL.Vector3(projectMaxPt[0], projectMaxPt[1], projectMaxPt[2]);
      var minClipPoint = new window.$CCBIM.WebGL.Vector3(projectMinPt[0], projectMinPt[1], projectMinPt[2]);

      if (window.$CCBIM.sceneManager.getSelectGeometry() && this.basedComponentCut) {
        var selectGeo = window.$CCBIM.actionManager.getSelectGeometryBox();
        maxClipPoint = new window.$CCBIM.WebGL.Vector3(selectGeo.modelMaxPt.x + sceneData.scale * 500, selectGeo.modelMaxPt.y + sceneData.scale * 500, selectGeo.modelMaxPt.z + sceneData.scale * 500);
        minClipPoint = new window.$CCBIM.WebGL.Vector3(selectGeo.modelMinPt.x - sceneData.scale * 500, selectGeo.modelMinPt.y - sceneData.scale * 500, selectGeo.modelMinPt.z - sceneData.scale * 500);

        var modelCenterPt = new window.$CCBIM.WebGL.Vector3((selectGeo.modelMaxPt.x + selectGeo.modelMinPt.x) / 2, (selectGeo.modelMaxPt.y + selectGeo.modelMinPt.y) / 2, (selectGeo.modelMaxPt.z + selectGeo.modelMinPt.z) / 2);
        this.setCameraTween(window.$CCBIM.controller.target, [modelCenterPt.x, modelCenterPt.y, modelCenterPt.z]);

        var cameraData = window.$CCBIM.controller.getCameraData();

        var targetVec = new window.$CCBIM.WebGL.Vector3();
        targetVec.subVectors(modelCenterPt, cameraData.target);
        var positionVec = new window.$CCBIM.WebGL.Vector3();
        positionVec.addVectors(cameraData.cameraPosition, targetVec);
        this.setCameraTween(window.$CCBIM.webglContext.camera.position, [positionVec.x, positionVec.y, positionVec.z]);

        var positionTargetVec = new window.$CCBIM.WebGL.Vector3();
        positionTargetVec.subVectors(positionVec, modelCenterPt);
        var distance = positionVec.distanceTo(modelCenterPt);
        var diameter = maxClipPoint.distanceTo(minClipPoint);
        var normalize = positionTargetVec.normalize();
        if (diameter < distance) {
          for (var key in normalize) {
            if (normalize.hasOwnProperty(key)) {
              normalize[key] = normalize[key] * (distance * (1 - diameter / distance));
            }
          }
          var positionDistanceVec = new window.$CCBIM.WebGL.Vector3();
          positionDistanceVec.subVectors(positionVec, normalize);
          this.setCameraTween(window.$CCBIM.webglContext.camera.position, [positionDistanceVec.x, positionDistanceVec.y, positionDistanceVec.z]);
        }
        this.setCameraBox();
      }

      this.clippingBox(maxClipPoint, minClipPoint);
      this.clippingPosition();
      this.clippingGeometry();
      this.clippingDrag();
      this.dragControls.activate();
      window.$CCBIM.webglContext.renderer.localClippingEnabled = true;
      if (this.showClippingHelp) {
        this.assignmentLine = '';
      } else {
        this.assignmentLine = '';
      }
      this.showClipping = true;

      this.showBComInfo = false;

      window.$CCBIM.sceneManager.clearHighlight();
    },
    closeClipping: function closeClipping() {
      this.handleList.forEach(function (x) {
        if (x.type === 'profile') {
          x.hover = false;
          x.action.forEach(function (list) {
            list.hover = false;
          });
        }
      });

      if (this.dragControls) {
        this.dragControls.dispose();
      }
      window.$CCBIM.clippingGroup.removeAll();
      window.$CCBIM.webglContext.scene.remove(window.$CCBIM.clippingGroup);
      window.$CCBIM.clippingObjects = [];

      window.$CCBIM.webglContext.renderer.localClippingEnabled = false;
      window.$CCBIM.sceneManager.setNeedUpdate(true);
      this.basedComponentCut = false;
      this.showClipping = false;
    },
    clippingHelpHandle: function clippingHelpHandle() {
      window.$CCBIM.sceneManager.setNeedUpdate(true);
      this.showClippingHelp = !this.showClippingHelp;
      if (this.showClippingHelp) {
        this.assignmentLine = '';
      } else {
        this.assignmentLine = '';
      }
      var boxHelper = window.$CCBIM.clippingGroup.getObjectByName('clippingBoxHelp');
      boxHelper.visible = this.showClippingHelp;
    },
    resetClipping: function resetClipping() {
      var _this2 = this;

      if (this.dragControls) {
        this.dragControls.dispose();
        this.dragControls = null;
      }
      this.showClippingHelp = true;
      window.$CCBIM.clippingGroup.removeAll();
      window.$CCBIM.webglContext.scene.remove(window.$CCBIM.clippingGroup);
      this.profileHandle();

      this.handleList.forEach(function (x) {
        if (x.type === 'profile') {
          x.action.forEach(function (list) {
            if (list.type === 'component' && list.hover) {
              _this2.basedComponentCut = true;
            } else {
              _this2.basedComponentCut = false;
            }
          });
        }
      });
    },
    profileHandlePosition: function profileHandlePosition(py1, py2, px1, px2, pz1, pz2) {
      this.clippingPosition(py1, py2, px1, px2, pz1, pz2);
      window.$CCBIM.webglContext.renderer.localClippingEnabled = true;
      window.$CCBIM.sceneManager.setNeedUpdate(true);
    }
  }
});

/***/ }),
/* 505 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controls_TrackballControls_js__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__controls_PMFirstPersonControls_js__ = __webpack_require__(480);




/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      controller: null
    };
  },

  methods: {
    setTrackballControls: function setTrackballControls() {
      if (window.$CCBIM.controller) {
        window.$CCBIM.controller.dispose();
      }
      window.$CCBIM.controller = new __WEBPACK_IMPORTED_MODULE_1__controls_TrackballControls_js__["a" /* default */](window.$CCBIM.webglContext.camera, this.$refs.model, true);
      window.$CCBIM.controller.bindEvent();
      window.$CCBIM.controller.scene = window.$CCBIM.webglContext.scene;
      window.$CCBIM.controller.modelCenter.x = this.view.target[0];
      window.$CCBIM.controller.modelCenter.y = this.view.target[1];
      window.$CCBIM.controller.modelCenter.z = this.view.target[2];
      window.$CCBIM.controller.zoomSpeed = 1.3;
      window.$CCBIM.controller.rotateSpeed = 2.5;
      this.setControlsTarget(this.view.target);
    },
    setFirstPersonControl: function setFirstPersonControl() {
      var cameraPosition = window.$CCBIM.webglContext.camera.position;
      window.$CCBIM.webglContext.camera = window.$CCBIM.webglContext.setPerspectiveCamera();
      window.$CCBIM.controller.dispose();
      window.$CCBIM.controller = new __WEBPACK_IMPORTED_MODULE_2__controls_PMFirstPersonControls_js__["a" /* default */](window.$CCBIM.webglContext.camera, this.$refs.model, [cameraPosition.x, cameraPosition.y, cameraPosition.z], this.view.target);
      window.$CCBIM.controller.bindEvent();
      window.$CCBIM.controller.enabled = true;
      if (window.$CCBIM.render.moveSpeed) {
        window.$CCBIM.controller.moveSpeed = window.$CCBIM.render.moveSpeed;
      } else {
        window.$CCBIM.controller.moveSpeed = 20;
      }
      window.$CCBIM.webglContext.scene.add(window.$CCBIM.controller.MouseControl.getObject());
      window.$CCBIM.webglContext.camera.rotateX(Math.PI / 2);
    },
    setControlsTarget: function setControlsTarget(target) {
      if (window.$CCBIM.controller.target) {
        var _target = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(target, 3);

        window.$CCBIM.controller.target.x = _target[0];
        window.$CCBIM.controller.target.y = _target[1];
        window.$CCBIM.controller.target.z = _target[2];
      }
    }
  }
});

/***/ }),
/* 506 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var timerEvent = null;

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showBComInfoTop: 0,
      showBComInfoLeft: 0,

      isRightPopupMenu: false
    };
  },

  methods: {
    onDblclick: function onDblclick(e) {
      var _this = this;

      clearTimeout(timerEvent);
      if (this.isDblClick) {
        window.$CCBIM.actionManager.onModelMouseUp(e, {
          isChoose: true
        }).then(function (success) {
          var selectedGeometry = window.$CCBIM.sceneManager.getSelectGeometry();
          if (selectedGeometry) {
            _this.$emit('selected-geometry', selectedGeometry);
            _this.$emit('selectedGEO', selectedGeometry);
          }
          console.log(success);
        }, function (error) {
          _this.$emit('selected-geometry', {});
          _this.$emit('selectedGEO', {});
          console.log(error);
        });
      }
    },
    onModelMouseMove: function onModelMouseMove(e) {
      e.stopPropagation();
      window.$CCBIM.actionManager.onModelMouseMove(e);
    },
    onModelMouseUp: function onModelMouseUp(e) {
      var _this2 = this;

      e.stopPropagation();
      clearTimeout(timerEvent);
      if (e.detail === 2) {
        return;
      }

      if (this.isChoose) {
        timerEvent = setTimeout(function () {
          _this2.showBComInfo = false;
          _this2.isRightPopupMenu = false;
          window.$CCBIM.actionManager.onModelMouseUp(e, {
            isChoose: _this2.isChoose
          }).then(function (success) {
            var selectedGeometry = window.$CCBIM.sceneManager.getSelectGeometry();
            if (selectedGeometry) {
              if (_this2.basedComponentCut) {
                _this2.showComponentCut = true;
              } else {
                _this2.showRightPopupMenu(e);
              }

              _this2.$emit('selected-geometry', selectedGeometry);
              _this2.$emit('selectedGEO', selectedGeometry);
            }
            console.log(success);
          }, function (error) {
            _this2.$emit('selected-geometry', {});
            _this2.$emit('selectedGEO', {});
            console.log(error);
          });
        }, 300);
      }
    },
    onModelMouseDown: function onModelMouseDown(e) {
      e.stopPropagation();
      window.$CCBIM.actionManager.onModelMouseDown(e);
    },
    onTouchMove: function onTouchMove(e) {
      e.stopPropagation();
      window.$CCBIM.actionManager.onModelMouseMove(e);
    },
    onTouchEnd: function onTouchEnd(e) {
      var _this3 = this;

      e.stopPropagation();
      this.showBComInfo = false;
      this.isRightPopupMenu = false;
      window.$CCBIM.actionManager.onModelMouseUp(e, {
        isChoose: this.isChoose
      }).then(function (result) {
        if (_this3.basedComponentCut) {
          _this3.showComponentCut = true;
        } else {
          _this3.showRightPopupMenu(event);
        }

        _this3.$emit('selected-geometry', result);
        _this3.$emit('selectedGEO', result);
      }, function (error) {
        console.log(error);
      });
    },
    onTouchStart: function onTouchStart(e) {
      e.stopPropagation();
      window.$CCBIM.actionManager.onModelMouseDown(e);
    },
    showRightPopupMenu: function showRightPopupMenu(e) {
      var _this4 = this;

      if (this.isShowContextMenu) {
        this.isRightPopupMenu = true;
        this.$nextTick(function () {
          _this4.showBComInfoTop = _this4.getOffsetY(e) + 20;
          _this4.showBComInfoLeft = _this4.getOffsetX(e);
          var menu = _this4.$refs.rightPopupMenu;
          if (menu) {
            var rect = window.$CCBIM.device.getDevicesWidthHeight();
            if (rect.w - _this4.getOffsetX(e) < menu.clientWidth) {
              _this4.showBComInfoLeft = _this4.getOffsetX(e) - menu.clientWidth;
            }
            if (rect.h - _this4.getOffsetY(e) < menu.clientHeight + 70) {
              _this4.showBComInfoTop = _this4.getOffsetY(e) - (menu.clientHeight + 70);
            }
          }
        });
      }
    },
    getHandleInfo: function getHandleInfo() {
      var _this5 = this;

      var selectedGEO = window.$CCBIM.sceneManager.getSelectGeometry();
      var data = {
        'version': this.version,
        'floorid': selectedGEO.floorID,
        'handle': selectedGEO.handle
      };
      this.$ccbimAxios({
        method: 'post',
        url: this.urlIp + '/front/bimfile/handleInfo.htm',
        data: this.$qs.stringify(data)
      }).then(function (res) {
        if (res.data.errorMsg) {
          _this5.$message.error(res.data.errorMsg);
        } else {
          _this5.$set(_this5.selectedGEO, 'userData', res.data);
          _this5.showBComInfo = true;
        }
      }, function (err) {
        _this5.$message.error(err);
      });
    },
    getOffsetX: function getOffsetX(e) {
      var event = e || window.event;
      var srcObj = event.target || event.srcElement;
      if (event.offsetX) {
        return event.offsetX;
      } else {
        var rect = srcObj.getBoundingClientRect();
        var clientX = void 0;
        if (event.type === 'touchend' || event.type === 'touchstart') {
          clientX = event.changedTouches[0].clientX;
        } else {
          clientX = event.clientX;
        }
        return clientX - rect.left;
      }
    },
    getOffsetY: function getOffsetY(e) {
      var event = e || window.event;
      var srcObj = event.target || event.srcElement;
      if (event.offsetY) {
        return event.offsetY;
      } else {
        var rect = srcObj.getBoundingClientRect();
        var clientY = void 0;
        if (event.type === 'touchend' || event.type === 'touchstart') {
          clientY = event.changedTouches[0].clientY;
        } else {
          clientY = event.clientY;
        }
        return clientY - rect.top;
      }
    }
  }
});

/***/ }),
/* 507 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showStagesAll: false,

      stageSelectOn: {
        stageid: -1
      },

      stagesAll: [],

      showFloorDiv: false,

      floorTree: [],

      searchText: '',

      showFloorsData: [],

      showBComTypesData: [],

      isShowAllComType: false
    };
  },

  methods: {
    initFloorTree: function initFloorTree() {
      var _this = this;

      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {
        var floorTree, floorTreeUI;
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                floorTree = window.$CCBIM.projectManager.getBuildingInfo();
                floorTreeUI = _this.setFloorTreeUIData(floorTree);

                _this.floorTree = [{
                  text: '',
                  opened: true,
                  selected: true,
                  tier: '0',
                  children: floorTreeUI
                }];

                _this.stagesAll = window.$CCBIM.projectManager.getStageInfo();
                if (_this.stagesAll.length > 0) {
                  _this.stageSelectOn = _this.stagesAll[0];
                }

                _this.setModelPinListData(_this.floorTree);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }))();
    },
    setFloorTreeUIData: function setFloorTreeUIData(floorTree) {
      for (var i = 0, il = floorTree.length; i < il; i++) {
        var itemIndex = floorTree[i];
        itemIndex.opened = false;
        itemIndex.selected = true;
        if (itemIndex.children) {
          this.setFloorTreeUIData(floorTree[i].children);
        }
      }
      return floorTree;
    },
    setModelPinListData: function setModelPinListData(sceneTree) {
      var _this2 = this;

      window.$CCBIM.render.$ccbimFloorDisplay = [];
      window.$CCBIM.render.$ccbimFloorNameDisplay = [];
      window.$CCBIM.render.$ccbimFloorInfoArr = [];
      for (var a = 0; a < sceneTree.length; a++) {
        var build = sceneTree[a].children;

        for (var b = 0; b < build.length; b++) {
          var floor = build[b].children;

          for (var f = 0; f < floor.length; f++) {
            var obj = {};
            obj.floorid = floor[f].floorId;
            obj.state = 1;
            window.$CCBIM.render.$ccbimFloorInfoArr.push(obj);
            window.$CCBIM.render.$ccbimFloorDisplay.push(floor[f].floorId);
            window.$CCBIM.render.$ccbimFloorNameDisplay.push(floor[f].text);
          }
        }
      }
      setTimeout(function () {
        _this2.emitFloor();
      }, 500);
    },
    inputSearch: function inputSearch() {
      var _this3 = this;

      var text = this.searchText;
      var patt = new RegExp(text);

      this.$refs.treeStrong.handleRecursionNodeChildren(this.floorTree[0], function (node) {
        if (text !== '' && node !== undefined) {
          var str = node.text;
          node.opened = false;
          if (patt.test(str)) {
            node.opened = true;
            _this3.$refs.treeStrong.handleParentNodeOpen(node);
          }
        }
      });

      this.$nextTick(function () {
        _this3.$refs.treeStrong.handleRecursionNodeDom(_this3.$refs.treeStrong, function (node) {
          if (text !== '' && node.model !== undefined) {
            var str = node.model.text;
            if (patt.test(str)) {
              node.$el.querySelector('.tree-anchor').style.color = '#00b589';
            } else {
              node.$el.querySelector('.tree-anchor').style.color = '#fff';
            }
          } else {
            node.$el.querySelector('.tree-anchor').style.color = '#fff';
          }
        });
      });
    },
    itemCheckedClick: function itemCheckedClick(item) {
      var floorComtypeArray = [];
      this.recursionTreeGetFloorComType(item, floorComtypeArray);
      var stageSelectOn = window.$CCBIM.projectManager.getCurrentStage();
      window.$CCBIM.projectManager.setEntInfoVisible(floorComtypeArray, stageSelectOn.id, item.selected);
      this.getFlatBufferFloorInfo();
      this.setNeedUpdate();
    },
    recursionTreeGetFloorComType: function recursionTreeGetFloorComType(treeSource, floorComtypeArray) {
      if (treeSource.children) {
        for (var i = 0, len = treeSource.children.length; i < len; i++) {
          this.recursionTreeGetFloorComType(treeSource.children[i], floorComtypeArray);
        }
      } else {
        floorComtypeArray.push({
          floorId: treeSource.floorId,
          comtype: treeSource.comtype
        });
      }
    },
    recursionTreeVisibleGetFloorComType: function recursionTreeVisibleGetFloorComType(treeSource, floorComtypeArray) {
      if (treeSource.children) {
        for (var i = 0, len = treeSource.children.length; i < len; i++) {
          this.recursionTreeVisibleGetFloorComType(treeSource.children[i], floorComtypeArray);
        }
      } else {
        if (treeSource.selected) {
          floorComtypeArray.push({
            floorId: treeSource.floorId,
            comtype: treeSource.comtype
          });
        }
      }
    },
    itemTextClick: function itemTextClick(item, that) {
      this.$refs.treeStrong.handleRecursionNodeDom(this.$refs.treeStrong, function (node) {
        node.$el.style.backgroundColor = '';
      });
      that.$el.style.backgroundColor = 'black';

      var floorComtypeArray = [];
      this.recursionTreeGetFloorComType(item, floorComtypeArray);

      window.$CCBIM.projectManager.setEntInfoOpacity(floorComtypeArray);

      this.showBComInfo = false;
      this.isShowAllComType = true;

      this.setNeedUpdate();
    },
    getFlatBufferFloorInfo: function getFlatBufferFloorInfo() {
      var _this4 = this;

      window.$CCBIM.render.$ccbimFloorInfoArr = [];
      window.$CCBIM.render.$ccbimFloorDisplay = [];
      window.$CCBIM.render.$ccbimFloorNameDisplay = [];
      this.$refs.treeStrong.handleRecursionNodeChildren(this.floorTree[0], function (node) {
        if (node && node.floorId && !node.comtype) {
          var obj = {};
          obj.floorid = node.floorId;
          if (node.selected) {
            obj.state = 1;
            window.$CCBIM.render.$ccbimFloorDisplay.push(node.floorId);
            window.$CCBIM.render.$ccbimFloorNameDisplay.push(node.text);
          } else {
            var comTypeArr = [];
            _this4.recursionFloorGetComtype(node.children, comTypeArr);
            if (comTypeArr.length > 0) {
              obj.state = 2;
              obj.comtypeArr = comTypeArr;
            } else {
              obj.state = 0;
            }
          }
          window.$CCBIM.render.$ccbimFloorInfoArr.push(obj);
        }
      });
    },
    recursionFloorGetComtype: function recursionFloorGetComtype(source, comtypeArray) {
      for (var f = 0, fl = source.length; f < fl; f++) {
        var itemIndex = source[f];
        if (itemIndex.children && itemIndex.children.length > 0) {
          this.recursionFloorGetComtype(itemIndex.children, comtypeArray);
        } else {
          if (itemIndex.selected) {
            comtypeArray.push(itemIndex.comtype);
          }
        }
      }
    },
    emitFloor: function emitFloor() {
      this.$emit('floors');
    },
    setEntVisibleFromFloorComtype: function setEntVisibleFromFloorComtype(floorComtypeArray) {
      console.log(this.floorTree[0]);

      this.recursionTreeSetTreeChecked(this.floorTree[0], floorComtypeArray);

      var floorComtypeAllArray = [];
      this.recursionTreeGetFloorComType(this.floorTree[0], floorComtypeAllArray);
      var stageSelectOn = window.$CCBIM.projectManager.getCurrentStage();
      window.$CCBIM.projectManager.setEntInfoVisible(floorComtypeAllArray, stageSelectOn.id, false);

      window.$CCBIM.projectManager.setEntInfoVisible(floorComtypeArray, stageSelectOn.id, true);
      console.log(this.floorTree[0]);
    },
    recursionTreeSetTreeChecked: function recursionTreeSetTreeChecked(treeSource, floorComtypeArray) {
      if (treeSource.children) {
        for (var i = 0, len = treeSource.children.length; i < len; i++) {
          treeSource.children[i].parent = treeSource;
          this.recursionTreeSetTreeChecked(treeSource.children[i], floorComtypeArray);
        }
      } else {
        treeSource.selected = false;
        for (var f = 0, fl = floorComtypeArray.length; f < fl; f++) {
          if (floorComtypeArray[f].floorId === treeSource.floorId && floorComtypeArray[f].comtype === treeSource.comtype) {
            treeSource.selected = true;
          }
        }
      }

      if (treeSource.parent) {
        treeSource.parent.selected = true;
        for (var p = 0, pl = treeSource.parent.children.length; p < pl; p++) {
          if (!treeSource.parent.children[p].selected) {
            treeSource.parent.selected = false;
          }
        }
      }
    },
    controlStages: function controlStages(stage) {
      this.showStagesAll = false;
      this.stageSelectOn = stage;
      window.$CCBIM.projectManager.setCurrentStage(stage);
      this.setStagesVisible();
    },
    getStagesFromStageId: function getStagesFromStageId(id) {
      for (var i = 0, il = this.stagesAll.length; i < il; i++) {
        var itemIndex = this.stagesAll[i];
        if (itemIndex.id === id) {
          return itemIndex;
        }
      }
      return null;
    },
    setStagesVisible: function setStagesVisible() {
      var stageSelectOn = window.$CCBIM.projectManager.getCurrentStage();

      var floorComtypeAllArray = [];
      this.recursionTreeGetFloorComType(this.floorTree[0], floorComtypeAllArray);
      window.$CCBIM.projectManager.setEntInfoVisible(floorComtypeAllArray, -Infinity, false);

      var floorComtypeArray = [];
      this.recursionTreeVisibleGetFloorComType(this.floorTree[0], floorComtypeArray);
      window.$CCBIM.projectManager.setEntInfoVisible(floorComtypeArray, stageSelectOn.id, true);

      window.$CCBIM.sceneManager.setNeedUpdate(true);
    },
    showAllOpacityComType: function showAllOpacityComType() {
      window.$CCBIM.sceneManager.clearOpaCity();

      this.$refs.treeStrong.handleRecursionNodeDom(this.$refs.treeStrong, function (node) {
        node.$el.style.backgroundColor = '';
      });

      this.isShowAllComType = false;

      this.isRightPopupMenu = false;
      this.setNeedUpdate();
    },
    popupMenuFilterComponent: function popupMenuFilterComponent(direction) {
      var selectedGEO = window.$CCBIM.sceneManager.getSelectGeometry();
      var floorComtypeArray = [];
      this.recurveFloorTreeGetSameType(this.floorTree, selectedGEO.floorID, selectedGEO.comtype, floorComtypeArray);
      window.$CCBIM.projectManager.setEntInfoOpacity(floorComtypeArray, direction);
      this.isShowAllComType = true;
      console.log(floorComtypeArray);
    },
    recurveFloorTreeGetSameType: function recurveFloorTreeGetSameType(floorTree, floorId, comtype, floorComtypeArray) {
      for (var i = 0, il = floorTree.length; i < il; i++) {
        var itemIndex = floorTree[i];
        if (itemIndex.children) {
          this.recurveFloorTreeGetSameType(floorTree[i].children, floorId, comtype, floorComtypeArray);
        } else {
          if (itemIndex.floorId === floorId && itemIndex.comtype === comtype) {
            for (var f = 0, fl = floorTree.length; f < fl; f++) {
              floorComtypeArray.push({
                floorId: floorTree[f].floorId,
                comtype: floorTree[f].comtype
              });
            }
            return false;
          }
        }
      }
    }
  }
});

/***/ }),
/* 508 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);

var floorCrossLine = [];
/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      isActive: false,

      miniMapScale: 0,

      mapCanvasWidth: 280,
      mapCanvasHeight: 265,

      scaleBig: true,
      ctx: null,

      crossData: [],

      mapRoomInfoData: [],

      rectangleData: {},

      locationPoint: {
        x: 0,
        y: 0
      },

      deg: 0,

      selected: 0,

      selectFloorPlanGraph: [],

      crossLineBin: null,

      axisTextLength: 0,
      haveInitMap: false
    };
  },

  methods: {
    initMap: function initMap() {
      if (!this.haveInitMap) {
        var bufferData = window.$CCBIM.projectManager.getFloorCrossLineBufferData();
        window.$CCBIM.sceneManager.loadFloorCrossLineData(bufferData);

        floorCrossLine = window.$CCBIM.projectManager.getFloorCrossLine();

        for (var i = 0; i < floorCrossLine.length; i++) {
          var obj = {};
          obj.floorElevation = floorCrossLine[i].floorElevation;
          obj.floorHeight = floorCrossLine[i].floorHeight;
          obj.floorId = floorCrossLine[i].floorId;
          obj.floorName = floorCrossLine[i].floorName;
          this.selectFloorPlanGraph.push(obj);
        }
        if (this.$refs.mapCanvas) {
          this.ctx = this.$refs.mapCanvas.getContext('2d');
          this.getMapData(this.selected);
          this.drawUpload(this.mapCanvasWidth, this.mapCanvasHeight);
        }
        this.haveInitMap = true;
      }
    },
    drawUpload: function drawUpload(width, height) {
      this.ctx.clearRect(0, 0, width, height);
      this.drawCross();
      this.drawFloor();
    },
    getMapData: function getMapData(number) {
      this.crossData = [];
      this.mapRoomInfoData = [];
      if (floorCrossLine.length <= 0) {
        return;
      }
      if (floorCrossLine[number].axisNetLineArray.length <= 0 && floorCrossLine[number].crossLines.length <= 0) {
        return;
      }
      for (var i = 0; i < floorCrossLine[number].axisNetLineArray.length; i++) {
        var axisNetLineIndex = floorCrossLine[number].axisNetLineArray[i];

        if (axisNetLineIndex.name.length > this.axisTextLength) {
          this.axisTextLength = axisNetLineIndex.name.length;
        }
        this.crossData[i] = {
          name: axisNetLineIndex.name,
          start: [axisNetLineIndex.start[0], axisNetLineIndex.start[1] * -1],
          end: [axisNetLineIndex.end[0], axisNetLineIndex.end[1] * -1],
          selectOn: false
        };
      }
      for (var j = 0; j < floorCrossLine[number].crossLines.length; j++) {
        var crossLinesIndex = floorCrossLine[number].crossLines[j];
        this.mapRoomInfoData[j] = {
          start: [crossLinesIndex.start[0], crossLinesIndex.start[1] * -1],
          end: [crossLinesIndex.end[0], crossLinesIndex.end[1] * -1]
        };
      }
      var rectangle = this.rectangulareEnvelope(this.crossData, this.mapRoomInfoData);
      this.rectangleData.height = rectangle.maxY - rectangle.minY + 26;
      this.rectangleData.width = rectangle.maxX - rectangle.minX + 26;
      this.rectangleData.centerPoint = [(rectangle.maxX + rectangle.minX) / 2, (rectangle.maxY + rectangle.minY) / 2];

      this.miniMapScale = Math.min(this.mapCanvasWidth / this.rectangleData.width, this.mapCanvasHeight / this.rectangleData.height);
      this.translateOrigin();
    },
    getCamera2dPosition: function getCamera2dPosition() {
      var cameraData = window.$CCBIM.controller.getCameraData();
      var target = cameraData.target;
      var position = cameraData.cameraPosition;
      var subVer = new window.$CCBIM.WebGL.Vector3(0, 1, 0);
      if (target) {
        subVer = target.clone();
      }
      subVer.sub(position);
      subVer.z = 0;
      var defVer = new window.$CCBIM.WebGL.Vector3(0, 1, 0);
      var temAnagle = subVer.angleTo(defVer) * 180 / Math.PI;

      if (subVer.x < 0) {
        temAnagle = 360 - temAnagle;
      }
      if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(this.rectangleData).length === 0) {
        this.$refs.circleLocation.style.display = 'none';
        return;
      }
      this.$refs.circleLocation.style.display = 'block';
      this.locationPoint.x = (position.x - this.rectangleData.centerPoint[0]) * this.miniMapScale + this.mapCanvasWidth / 2;
      this.locationPoint.y = (position.y * -1 - this.rectangleData.centerPoint[1]) * this.miniMapScale + this.mapCanvasHeight / 2;
      this.drawLocation(this.locationPoint.x, this.locationPoint.y, temAnagle);
    },
    canvasDoubleClick: function canvasDoubleClick(event) {
      var canvas = this.$refs.mapCanvas;
      var rect = canvas.getBoundingClientRect();
      var x = event.clientX - rect.left * (canvas.width / rect.width);
      var y = event.clientY - rect.top * (canvas.height / rect.height);
      var cameraX = (x - this.mapCanvasWidth / 2) / this.miniMapScale + this.rectangleData.centerPoint[0];
      var cameraY = ((y - this.mapCanvasHeight / 2) / this.miniMapScale + this.rectangleData.centerPoint[1]) * -1;
      var height = floorCrossLine[this.selected].floorElevation + floorCrossLine[this.selected].floorHeight / 2;
      window.$CCBIM.controller.setControlPosition(height, cameraX, cameraY);
      this.setCameraUp([0, 0, 1]);
      this.setNeedUpdate();
    },
    rectangulareEnvelope: function rectangulareEnvelope(crossDataList, mapRoomInfoDataList) {
      if (crossDataList.length <= 0 && mapRoomInfoDataList.length <= 0) {
        return;
      }
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;

      for (var i = 0; i < crossDataList.length; i++) {
        if (crossDataList[i].start[0] < minX) {
          minX = crossDataList[i].start[0];
        } else if (crossDataList[i].start[0] > maxX) {
          maxX = crossDataList[i].start[0];
        }

        if (crossDataList[i].end[0] < minX) {
          minX = crossDataList[i].end[0];
        } else if (crossDataList[i].end[0] > maxX) {
          maxX = crossDataList[i].end[0];
        }

        if (crossDataList[i].start[1] < minY) {
          minY = crossDataList[i].start[1];
        } else if (crossDataList[i].start[1] > maxY) {
          maxY = crossDataList[i].start[1];
        }

        if (crossDataList[i].end[1] < minY) {
          minY = crossDataList[i].end[1];
        } else if (crossDataList[i].end[1] > maxY) {
          maxY = crossDataList[i].end[1];
        }
      }
      for (var _i = 0; _i < mapRoomInfoDataList.length; _i++) {
        if (mapRoomInfoDataList[_i].start[0] < minX) {
          minX = mapRoomInfoDataList[_i].start[0];
        } else if (mapRoomInfoDataList[_i].start[0] > maxX) {
          maxX = mapRoomInfoDataList[_i].start[0];
        }

        if (mapRoomInfoDataList[_i].end[0] < minX) {
          minX = mapRoomInfoDataList[_i].end[0];
        } else if (mapRoomInfoDataList[_i].end[0] > maxX) {
          maxX = mapRoomInfoDataList[_i].end[0];
        }

        if (mapRoomInfoDataList[_i].start[1] < minY) {
          minY = mapRoomInfoDataList[_i].start[1];
        } else if (mapRoomInfoDataList[_i].start[1] > maxY) {
          maxY = mapRoomInfoDataList[_i].start[1];
        }

        if (mapRoomInfoDataList[_i].end[1] < minY) {
          minY = mapRoomInfoDataList[_i].end[1];
        } else if (mapRoomInfoDataList[_i].end[1] > maxY) {
          maxY = mapRoomInfoDataList[_i].end[1];
        }
      }
      return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
      };
    },
    translateOrigin: function translateOrigin() {
      if (this.crossData.length <= 0 && this.mapRoomInfoData.length <= 0) {
        return;
      }

      for (var i = 0; i < this.crossData.length; i++) {
        this.crossData[i].start[0] = (this.crossData[i].start[0] - this.rectangleData.centerPoint[0]) * this.miniMapScale + this.mapCanvasWidth / 2;
        this.crossData[i].start[1] = (this.crossData[i].start[1] - this.rectangleData.centerPoint[1]) * this.miniMapScale + this.mapCanvasHeight / 2;
        this.crossData[i].end[0] = (this.crossData[i].end[0] - this.rectangleData.centerPoint[0]) * this.miniMapScale + this.mapCanvasWidth / 2;
        this.crossData[i].end[1] = (this.crossData[i].end[1] - this.rectangleData.centerPoint[1]) * this.miniMapScale + this.mapCanvasHeight / 2;
      }
      for (var j = 0; j < this.mapRoomInfoData.length; j++) {
        this.mapRoomInfoData[j].start[0] = (this.mapRoomInfoData[j].start[0] - this.rectangleData.centerPoint[0]) * this.miniMapScale + this.mapCanvasWidth / 2;
        this.mapRoomInfoData[j].start[1] = (this.mapRoomInfoData[j].start[1] - this.rectangleData.centerPoint[1]) * this.miniMapScale + this.mapCanvasHeight / 2;
        this.mapRoomInfoData[j].end[0] = (this.mapRoomInfoData[j].end[0] - this.rectangleData.centerPoint[0]) * this.miniMapScale + this.mapCanvasWidth / 2;
        this.mapRoomInfoData[j].end[1] = (this.mapRoomInfoData[j].end[1] - this.rectangleData.centerPoint[1]) * this.miniMapScale + this.mapCanvasHeight / 2;
      }
    },
    crossText: function crossText(text, x1, y1, x2, y2, radius) {
      var vectorStart = new window.$CCBIM.WebGL.Vector2(x1, y1);
      var vectorEnd = new window.$CCBIM.WebGL.Vector2(x2, y2);
      var vectorLine = new window.$CCBIM.WebGL.Vector2();
      vectorLine.subVectors(vectorStart, vectorEnd);
      var normalize = vectorLine.normalize();

      x1 = x1 + radius * normalize.x;
      x2 = x2 - radius * normalize.x;
      y1 = y1 + radius * normalize.y;
      y2 = y2 - radius * normalize.y;

      this.ctx.fillStyle = '#fff';
      this.ctx.fillText(text, x1, y1);
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
      this.ctx.beginPath();
      this.ctx.strokeStyle = '#fff';
      this.ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
      this.ctx.closePath();
      this.ctx.stroke();

      this.ctx.fillStyle = '#fff';
      this.ctx.fillText(text, x2, y2);
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
      this.ctx.beginPath();
      this.ctx.strokeStyle = '#fff';
      this.ctx.arc(x2, y2, radius, 0, 2 * Math.PI);
      this.ctx.closePath();
      this.ctx.stroke();
    },
    drawCross: function drawCross() {
      if (this.crossData.length <= 0) {
        return;
      }
      var fontSize = 0;
      if (this.axisTextLength === 1) {
        fontSize = 16;
      } else if (this.axisTextLength === 2) {
        fontSize = 12;
      } else if (this.axisTextLength === 3) {
        fontSize = 10;
      } else if (this.axisTextLength === 4) {
        fontSize = 9;
      } else if (this.axisTextLength >= 5) {
        fontSize = 8;
      }
      this.ctx.font = fontSize + 'px Arial';

      for (var i = 0; i < this.crossData.length; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(this.crossData[i].start[0], this.crossData[i].start[1]);
        this.ctx.lineTo(this.crossData[i].end[0], this.crossData[i].end[1]);
        this.ctx.closePath();
        if (this.crossData[i].selectOn) {
          this.ctx.strokeStyle = '#ff0000';
        } else {
          this.ctx.strokeStyle = '#ffffff';
        }
        this.ctx.stroke();
        if (i % 3 === 0) {
          if (this.isActive) {
            this.crossText(this.crossData[i].name, this.crossData[i].start[0], this.crossData[i].start[1], this.crossData[i].end[0], this.crossData[i].end[1], 12);
          }
        }
      }
    },
    drawFloor: function drawFloor() {
      if (this.mapRoomInfoData.length <= 0) {
        return;
      }
      for (var i = 0; i < this.mapRoomInfoData.length; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(this.mapRoomInfoData[i].start[0], this.mapRoomInfoData[i].start[1]);
        this.ctx.lineTo(this.mapRoomInfoData[i].end[0], this.mapRoomInfoData[i].end[1]);
        this.ctx.strokeStyle = '#00ffff';
        this.ctx.closePath();
        this.ctx.stroke();
      }
    },
    drawLocation: function drawLocation(x, y, angle) {
      this.$refs.circleLocation.style.transform = 'translate(' + x + 'px,' + y + 'px) rotate(' + angle + 'deg)';
    },
    canvasMove: function canvasMove(e) {
      this.getCrossPoint(e.offsetX, e.offsetY);
    },
    getCrossPoint: function getCrossPoint(x, y) {
      for (var i = 0; i < this.crossData.length; i++) {
        if (x - this.crossData[i].start[0] > -2 && x - this.crossData[i].start[0] < 2 || y - this.crossData[i].start[1] > -2 && y - this.crossData[i].start[1] < 2) {
          this.crossData[i].selectOn = true;
          this.drawUpload(this.mapCanvasWidth, this.mapCanvasHeight);
          return;
        } else {
          if (this.crossData[i].selectOn) {
            this.crossData[i].selectOn = false;
            this.drawUpload(this.mapCanvasWidth, this.mapCanvasHeight);
          }
        }
      }
    },
    selectFloor: function selectFloor() {
      this.getMapData(this.selected);
      this.drawUpload(this.mapCanvasWidth, this.mapCanvasHeight);
      var height = floorCrossLine[this.selected].floorElevation + floorCrossLine[this.selected].floorHeight / 2;
      var temCenterPt = new window.$CCBIM.WebGL.Vector3(0, 0, height);
      if (window.$CCBIM.controller.SetModelCenterPt) {
        window.$CCBIM.controller.SetModelCenterPt(temCenterPt, false);
      }
      window.$CCBIM.controller.setControlPosition(height);
      this.setNeedUpdate();
    },
    zoomMap: function zoomMap() {
      var _this = this;

      this.isActive = true;
      this.scaleBig = false;
      this.mapCanvasWidth = 600;
      this.mapCanvasHeight = 450;
      this.$nextTick(function () {
        _this.getMapData(_this.selected);
        _this.drawUpload(_this.mapCanvasWidth, _this.mapCanvasHeight);
      });
    },
    shrinkMap: function shrinkMap() {
      var _this2 = this;

      this.isActive = false;
      this.scaleBig = true;
      this.mapCanvasWidth = 280;
      this.mapCanvasHeight = 265;
      this.$nextTick(function () {
        _this2.getMapData(_this2.selected);
        _this2.drawUpload(_this2.mapCanvasWidth, _this2.mapCanvasHeight);
      });
    }
  }
});

/***/ }),
/* 509 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controls_joystick__ = __webpack_require__(482);




/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showHandle: false,

      isChoose: false,

      isBoxChoose: false,

      isMeasureHeight: false,

      clearHeightDisControl: null,

      isOpenWalk: false,

      showMap: false,
      handleList: [{ href: '#icon-floor', name: '/', type: 'floor', show: true, hover: false }, { href: '#icon-close', name: '', type: 'hideMark', show: true, hover: false }, { href: '#icon-open', name: '', type: 'showMark', show: false, hover: true }],
      handle3DList: [{ href: '#icon-choose', name: '', type: 'choose', show: true, hover: false }, { href: '#icon-full', name: '', type: 'boxChoose', show: false, hover: false }, { href: '#icon-poumian', name: '', type: 'profile', show: true, hover: false, action: [{ name: '', type: 'global', show: true, hover: false }, { name: '', type: 'component', show: true, hover: false, disable: false }] }, { href: '#icon-zu', name: '', type: 'walk', show: true, hover: false }, { href: '#icon-celiang', name: '', type: 'clearHeight', show: true, hover: false }, { href: '#icon-xiaoditu', name: '', type: 'modelMap', show: true, hover: false }],

      isUseWebGlFont: false,
      phoneJoystick: null
    };
  },

  props: {
    isHandle: {
      type: Boolean,
      default: true
    },

    isMark: {
      type: Boolean,
      default: true
    },

    isFloor: {
      type: Boolean,
      default: true
    },

    isChooseButton: {
      type: Boolean,
      default: true
    },

    isBoxChooseButton: {
      type: Boolean,
      default: true
    },

    isProfile: {
      type: Boolean,
      default: true
    },
    componentProfileDisable: {
      type: Boolean,
      default: false
    },

    isWalk: {
      type: Boolean,
      default: true
    },

    isClearHeight: {
      type: Boolean,
      default: true
    },

    isModelMap: {
      type: Boolean,
      default: true
    },

    definedChooseButton: {
      type: Boolean,
      default: false
    },

    definedProfileButton: {
      type: Boolean,
      default: false
    },

    definedWalkButton: {
      type: Boolean,
      default: false
    },

    definedMeasureHeightButton: {
      type: Boolean,
      default: false
    },

    definedShowMapButton: {
      type: Boolean,
      default: false
    },

    definedShowFloorButton: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    definedChooseButton: function definedChooseButton(status) {
      this.isChoose = status;
    },
    definedProfileButton: function definedProfileButton(status) {
      this.showClipping = status;
    },
    definedWalkButton: function definedWalkButton(status) {
      this.isOpenWalk = status;
    },
    definedMeasureHeightButton: function definedMeasureHeightButton(status) {
      this.isMeasureHeight = status;
    },
    definedShowMapButton: function definedShowMapButton(status) {
      this.showMap = status;
    },
    definedShowFloorButton: function definedShowFloorButton(status) {
      this.showFloorDiv = status;
    }
  },
  mounted: function mounted() {
    window.$CCBIM.handle.profileHandle = this.profileHandle;

    window.$CCBIM.handle.closeClipping = this.closeClipping;

    window.$CCBIM.handle.openWalk = this.setFirstPersonControl;

    window.$CCBIM.handle.closeWalk = this.closeWalk;

    window.$CCBIM.handle.openMeasureHeight = this.setModelHeightColor;

    window.$CCBIM.render.webGlFont = null;
  },

  methods: {
    setHandle: function setHandle() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.handleList), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          if (!this.isMark && item.type === 'hideMark' || !this.isFloor && item.type === 'floor') {
            item.show = false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.handle3DList), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _item = _step2.value;

          if (!this.isChooseButton && _item.type === 'choose' || !this.isBoxChooseButton && _item.type === 'boxChoose' || !this.isProfile && _item.type === 'profile' || !this.isWalk && _item.type === 'walk' || !this.isClearHeight && _item.type === 'clearHeight' || !this.isModelMap && _item.type === 'modelMap') {
            _item.show = false;
          }

          if (this.componentProfileDisable && _item.type === 'profile') {
            _item.action[1].disable = true;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    },
    handleClick: function handleClick(item) {
      var _this = this;

      this.needUpdate = true;
      item.hover = !item.hover;
      switch (item.type) {
        case 'floor':
          this.showFloorDiv = !this.showFloorDiv;
          if (this.isChoose) {
            this.closeChoose();
          }
          this.closeClipping();
          if (this.isMeasureHeight) {
            this.setModelHeightColor(false, this.$refs.model);
            this.isMeasureHeight = !this.isMeasureHeight;
            this.handle3DList.forEach(function (x) {
              if (x.type === 'clearHeight') {
                x.hover = false;
              }
            });
          }
          if (!item.hover) {
            this.closeFloorDiv();
          }
          this.closeMap();
          break;

        case 'profile':
          item.hover = false;
          item.action.forEach(function (list) {
            if (list.hover) {
              item.hover = true;
            }
          });
          this.closeFloorDiv();
          if (this.isOpenWalk) {
            this.isOpenWalk = false;
            this.closeWalk();
          }
          if (this.isMeasureHeight) {
            this.setModelHeightColor(false, this.$refs.model);
            this.isMeasureHeight = false;
            this.handle3DList.forEach(function (x) {
              if (x.type === 'clearHeight') {
                x.hover = false;
              }
            });
          }
          this.closeMap();
          break;

        case 'comments':
          break;

        case 'choose':
          if (this.basedComponentCut) {
            item.hover = true;
            return;
          }
          this.isChoose = !this.isChoose;
          if (!item.hover) {
            this.closeChoose();
          }
          if (this.isMeasureHeight) {
            this.setModelHeightColor(false, this.$refs.model);
            this.isMeasureHeight = false;
            this.handle3DList.forEach(function (x) {
              if (x.type === 'clearHeight') {
                x.hover = false;
              }
            });
          }
          this.closeFloorDiv();
          this.closeMap();
          break;

        case 'boxChoose':
          this.isBoxChoose = !this.isBoxChoose;
          break;

        case 'hideMark':
          this.handleList.forEach(function (x) {
            if (x.type === 'showMark') {
              x.show = true;
            }
          });
          item.show = false;
          item.hover = false;
          this.showMark = false;
          break;

        case 'showMark':
          this.handleList.forEach(function (x) {
            if (x.type === 'hideMark') {
              x.show = true;
            }
          });
          item.show = false;
          item.hover = true;
          this.showMark = true;
          break;

        case 'walk':
          this.isOpenWalk = !this.isOpenWalk;
          this.$emit('openWalk');
          if (item.hover) {
            this.$refs.roamBox.haveRoamBox();
            this.setFirstPersonControl();
            this.isRightPopupMenu = false;

            if (this.isPhone) {
              this.launchFullscreen();
              this.showHandle = false;
              this.$nextTick(function () {
                _this.phoneJoystick = new __WEBPACK_IMPORTED_MODULE_1__controls_joystick__["a" /* default */]({
                  zone: document.getElementById('phone_joystick'),
                  position: { left: '50%', top: '50%' },
                  color: 'black',
                  size: 120,
                  mode: 'static'
                });
                _this.phoneJoystick.init();
              });
            }
          } else {
            this.closeWalk();
          }
          this.closeClipping();
          break;

        case 'clearHeight':
          if (this.isUseWebGlFont) {
            this.isMeasureHeight = !this.isMeasureHeight;
            this.setModelHeightColor(item.hover, this.$refs.model);
            this.closeClipping();
            this.closeChoose();
            this.closeFloorDiv();
            this.closeMap();
          } else {
            alert('webGL');
          }
          break;

        case 'modelMap':
          if (this.isPhone) {
            item.hover = false;
            return;
          }
          if (!item.hover) {
            this.showMap = false;
          } else {
            this.showMap = true;
          }
          if (!this.haveInitMap) {
            this.initMap();
          }
          if (this.isMeasureHeight) {
            this.setModelHeightColor(false, this.$refs.model);
            this.isMeasureHeight = !this.isMeasureHeight;
            this.handle3DList.forEach(function (x) {
              if (x.type === 'clearHeight') {
                x.hover = false;
              }
            });
          }
          this.closeClipping();
          this.closeChoose();
          this.closeFloorDiv();
          break;
      }
    },
    clickProfile: function clickProfile(item, parent) {
      if (item.disable) {
        return;
      }
      item.hover = !item.hover;
      parent.action.forEach(function (x) {
        if (x.name !== item.name) {
          if (x.hover) {
            x.hover = false;
          }
        }
      });
      if (item.type === 'component') {
        this.handleList.forEach(function (x) {
          if (x.type === 'choose') {
            x.hover = item.hover;
          }
        });
        if (item.hover) {
          this.basedComponentCut = true;
          this.isChoose = true;
        } else {
          this.closeClipping();
          this.closeChoose();
          this.showComponentCut = false;
        }
      } else {
        this.basedComponentCut = false;
        if (item.hover) {
          this.profileHandle();
        } else {
          this.closeClipping();
        }
      }
    },
    performComponentCut: function performComponentCut() {
      this.profileHandle();
      this.showComponentCut = false;
      this.basedComponentCut = false;
    },
    closeChoose: function closeChoose() {
      this.handleList.forEach(function (x) {
        if (x.type === 'choose') {
          x.hover = false;
        }
      });
      this.isChoose = false;
      this.showClick = false;
      this.isRightPopupMenu = false;
      window.$CCBIM.sceneManager.clearHighlight();

      this.$emit('selected-geometry', {});
      this.$emit('selectedGEO', {});
      this.closeBComInfoDiv();
    },
    openFloorDiv: function openFloorDiv() {},
    closeFloorDiv: function closeFloorDiv() {
      this.handleList.forEach(function (x) {
        if (x.type === 'floor') {
          x.hover = false;
        }
      });
      this.showFloorDiv = false;
    },
    closeBComInfoDiv: function closeBComInfoDiv() {
      this.showBComInfo = false;
    },
    closeWalk: function closeWalk() {
      var _this2 = this;

      this.handleList.forEach(function (x) {
        if (x.type === 'walk') {
          x.hover = false;
        }
      });
      document.removeEventListener('keydown', function (e) {
        return _this2.onModelkeydown(e);
      }, false);
      this.showHandle = true;
      this.isOpenWalk = false;

      if (this.isPhone) {
        this.phoneJoystick.destroy();
      }
      setTimeout(function () {
        _this2.setCameraBox();
      }, 100);

      window.$CCBIM.webglContext.camera = window.$CCBIM.webglContext.setPerspectiveCamera();
      this.setCameraUp(this.view.up);
      this.setCameraPosition(this.view.position);

      this.setTrackballControls();

      this.$refs.roamBox.showRoamImg = false;
      this.$refs.roamBox.showRoamBox.show = false;
    },
    closeMap: function closeMap() {
      this.showMap = false;
      this.handleList.forEach(function (x) {
        if (x.type === 'modelMap') {
          x.hover = false;
        }
      });
    },
    phoneOpenTree: function phoneOpenTree() {
      this.showFloorDiv = !this.showFloorDiv;
      if (this.floorTree.length === 0) {
        this.floorTree = window.$CCBIM.render.scene.floorTree.tree;
      }
    }
  }
});

/***/ }),
/* 510 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__static_sockjs_min_js__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__static_sockjs_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__static_sockjs_min_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__static_stomp_js__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__static_stomp_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__static_stomp_js__);







/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      isShowPointImage: false,
      showMark: true,
      pointImageSrc: '',
      isPointImageSrc: false,
      pointImageTop: 0,
      pointImageLeft: 0,
      pointTextContent: '',
      isPointTextContent: false,
      pointList: [],
      pointSaveListMap: new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a(),
      pointListMap: new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a(),
      pointMap: new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a(),
      stompClient: null };
  },

  props: {
    modelMark: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  watch: {
    modelMark: function modelMark(items) {
      for (var i = 0; i < items.length; i++) {
        if (window.$CCBIM.render.rendererType === '3D') {
          this.addModelMark(items[i]);
        }
      }
    }
  },
  methods: {
    connectWebSocket: function connectWebSocket() {
      var _this = this;

      var socket = new window.SockJS(this.urlIp + '/websocket/');
      this.stompClient = window.Stomp.over(socket);
      this.stompClient.connect({}, function () {
        _this.stompClient.subscribe('/model/' + _this.version + '/msg', function (response) {
          var info = JSON.parse(response.body);
          console.log(info);

          _this.socketCallback(info);
        });
      });
    },
    socketCallback: function socketCallback(info) {
      if (window.$CCBIM.render.rendererType === 'DWG') {} else if (window.$CCBIM.render.rendererType === '3D') {
        if (info.type === 'MARKPOINT') {
          if (info.data.opt === 1) {
            this.$emit('socketAddMark', info);
          } else if (info.data.opt === 2) {} else if (info.data.opt === 3) {}
        }
      }
    },
    addModelMarkRequest: function addModelMarkRequest(extInfo) {
      var _this2 = this;

      return new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        var selectedGEO = window.$CCBIM.sceneManager.getSelectGeometry();
        console.log(selectedGEO);
        if (!selectedGEO) {
          return false;
        }
        _this2.$ccbimAxios({
          method: 'post',
          url: _this2.urlIp + '/front/bimfile/apply4Id'
        }).then(function (pointId) {
          if (pointId.data.success) {
            var handelPoint = selectedGEO.handle + ';' + selectedGEO.clickPointPosition.x + ',' + selectedGEO.clickPointPosition.y + ',' + selectedGEO.clickPointPosition.z;

            var data = {
              'opt': 1,
              'modelId': _this2.version,
              'markingPointId': pointId.data.result,
              'pointInfo': __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()({
                'floorId': selectedGEO.floorID,
                'componentId': selectedGEO.comid,
                'handle': handelPoint,
                'viewInformation': selectedGEO.flatBuffer
              }),
              'extInfo': extInfo !== undefined || extInfo !== null ? __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(extInfo) : null
            };
            _this2.$ccbimAxios({
              method: 'post',
              url: _this2.urlIp + '/front/bimfile/markingpointadd',
              data: _this2.$qs.stringify(data)
            }).then(function (res) {
              var data = res.data;

              resolve(data);
            }).catch(function () {
              reject();
            });
          }
        });
      });
    },
    removeModelMarkRequest: function removeModelMarkRequest(markingPointId) {
      var _this3 = this;

      return new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        var data = {
          'modelId': _this3.version,
          'markingPointId': markingPointId
        };
        _this3.$ccbimAxios({
          method: 'post',
          url: _this3.urlIp + '/front/bimfile/markingpointdel',
          data: _this3.$qs.stringify(data)
        }).then(function (res) {
          var data = res.data;

          if (data.success) {
            _this3.delModelMark(markingPointId);
            resolve(data);
          }
        }).catch(function () {
          reject();
        });
      });
    },
    modelMarkListRequest: function modelMarkListRequest() {
      var _this4 = this;

      return new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this4.$ccbimAxios({
          method: 'get',
          url: _this4.urlIp + '/front/bimfile/markingpointlist?modelId=' + _this4.version
        }).then(function (res) {
          var data = res.data;

          resolve(data);
        }).catch(function () {
          reject();
        });
      });
    },
    showPointImage: function showPointImage(item) {
      if (item.photo) {
        this.isShowPointImage = true;
        this.isPointImageSrc = true;
        this.pointImageSrc = item.photo;
        this.pointImageTop = item.top - 160;
        this.pointImageLeft = item.left - 100;
      }
      if (item.text) {
        this.isShowPointImage = true;
        this.isPointTextContent = true;
        this.pointTextContent = item.text;
        this.pointImageTop = item.top - 160;
        this.pointImageLeft = item.left - 100;
      }
    },
    clickPointImg: function clickPointImg(item) {
      this.$emit('click-model-mark', item);
    },
    bounceModelMark: function bounceModelMark(id) {
      var _this5 = this;

      window.$CCBIM.sceneManager.setNeedUpdate(false);
      var times = 0;
      var interval = setInterval(function () {
        times += 30;
        var rad = 2 * Math.PI / 360 * times;
        _this5.pointListMap.get(id).top -= Math.sin(rad) * 3;
      }, 25);
      setTimeout(function () {
        clearInterval(interval);
      }, 1500);
    },
    addModelMark: function addModelMark() {
      var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(option) === '{}') {
        console.log('');
        return false;
      }
      if (this.pointSaveListMap.has(option.id)) {
        var point = this.pointSaveListMap.get(option.id);
        point.labelText = option.labelText;
        point.selfDefiningData = option.selfDefiningData;
        return;
      }
      var sceneData = window.$CCBIM.sceneManager.getSceneData();
      var scale = sceneData.scale;
      var floorId = option.floorId;
      if (option.floorId && option.floorId >= 0) {
        floorId = option.floorId;
      } else {
        floorId = window.$CCBIM.projectManager.floorNameIdMap.get(option.floorName);
      }
      if (option.handle.indexOf(';') > -1) {
        var position = option.handle.split(';')[1].split(',');
        var uuid = position[0] + position[1] + position[2];
        var Vector = new window.$CCBIM.WebGL.Vector3(position[0] * scale, position[1] * scale, position[2] * scale);
        this.pointSaveListMap.set(option.id, {
          uuid: uuid,
          id: option.id,
          point: Vector,
          iconText: option.iconText,
          labelText: option.labelText,
          selfDefiningData: option.selfDefiningData,
          warning: option.warning,
          iconImg: option.iconImg,
          color: option.color,
          photo: option.photo,
          contentText: option.contentText,
          floorId: floorId
        });
      } else {
        var bndBoxCenter = window.$CCBIM.projectManager.getEntInfoBndCenterFromFloorIdHandle({
          floorId: floorId,
          handle: option.handle
        });
        var _uuid = bndBoxCenter.x + bndBoxCenter.y + bndBoxCenter.z;
        this.pointSaveListMap.set(option.id, {
          uuid: _uuid,
          id: option.id,
          point: bndBoxCenter,
          iconText: option.iconText,
          iconImg: option.iconImg,
          color: option.color,
          photo: option.photo,
          contentText: option.contentText,
          floorId: floorId
        });
      }
      this.setNeedUpdate();
    },
    delModelMark: function delModelMark(id) {
      this.needUpdate = true;
      this.pointSaveListMap.delete(id);
      this.pointListMap.delete(id);
      this.setNeedUpdate();
      if (this.pointListMap.size === 0) {
        this.pointList = [];
      }
    },
    computePointPosition: function computePointPosition() {
      if (this.pointSaveListMap.size === 0) {
        return false;
      }

      var _window$$CCBIM$device = window.$CCBIM.device.getDevicesWidthHeight(),
          wHalf = _window$$CCBIM$device.wHalf,
          hHalf = _window$$CCBIM$device.hHalf;

      this.pointMap.clear();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.pointSaveListMap.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var x = _step.value;

          var uuid = x.uuid;
          var center = x.point.clone();
          var scenePoint = center.project(window.$CCBIM.webglContext.camera);
          scenePoint.x = scenePoint.x * wHalf + wHalf;
          scenePoint.y = -(scenePoint.y * hHalf) + hHalf;
          if (window.$CCBIM.render.rendererType === '3D') {
            if (this.pointMap.has(uuid)) {
              var list = this.pointMap.get(uuid);
              list.push(uuid);
              var length = list.length - 1;
              scenePoint.x = scenePoint.x + 30 * length;
            } else {
              this.pointMap.set(uuid, [uuid]);
            }
          }
          var floorShow = void 0;
          if (window.$CCBIM.render.rendererType === 'DWG') {
            floorShow = true;
          } else {
            floorShow = window.$CCBIM.render.$ccbimFloorDisplay.includes(x.floorId);
          }
          this.pointListMap.set(x.id, {
            id: x.id,
            left: scenePoint.x - 15,
            top: scenePoint.y - 30,
            iconText: x.iconText,
            labelText: x.labelText,
            selfDefiningData: x.selfDefiningData,
            warning: x.warning,
            iconImg: x.iconImg ? x.iconImg : window.$CCBIM.render.baseImg.modelMarkImg,
            color: x.color,
            photo: x.photo,
            contentText: x.contentText,
            show: floorShow,
            floorId: x.floorId
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.pointList = [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(this.pointListMap.values()));
    }
  }
});

/***/ }),
/* 511 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

/* harmony default export */ __webpack_exports__["a"] = ({
  mounted: function mounted() {},

  methods: {
    onBeforeUpdate: function onBeforeUpdate() {
      window.$CCBIM.sceneManager.setNeedUpdate(true);
      if (window.$CCBIM.controller.isAutoRotation || !window.$CCBIM.isNeedHide) {
        return;
      }
      this.debounce(function () {
        window.$CCBIM.projectManager.setInstanceMeshEntInfoVisible(false);
      }, 500)();
    },
    onAfterUpdate: function onAfterUpdate() {
      var _this = this;

      var isNeedUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


      this.debounce(function () {
        _this.dispatchLoading();
        window.$CCBIM.sceneManager.setNeedUpdate(true);
      }, 500)();

      if (window.$CCBIM.controller.isAutoRotation) {
        return;
      }
      this.debounce(function () {
        window.$CCBIM.projectManager.setInstanceMeshEntInfoVisible(true);
        if (isNeedUpdate) {
          _this.debounce(function () {
            window.$CCBIM.sceneManager.setNeedUpdate(false);
          }, 500)();
        }
      }, 500)();
    },
    debounce: function debounce(fn, delay) {
      var timer = void 0;

      return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timer);

        timer = setTimeout(function () {
          fn.apply(context, args);
        }, delay);
      };
    },
    setNeedUpdate: function setNeedUpdate() {
      if (window.$CCBIM.sceneManager) {
        window.$CCBIM.sceneManager.setNeedUpdate(true);
        this.debounce(function () {
          window.$CCBIM.sceneManager.setNeedUpdate(false);
        }, 500)();
      }
    }
  }
});

/***/ }),
/* 512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatBuffers_useFlatBuffer__ = __webpack_require__(101);




/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      showSettingBox: false,

      ccbimImage: '',

      externalSelectGeo: null
    };
  },

  props: {
    physicallyCorrectLights: {
      type: Boolean,
      default: true
    },

    ccbimTextureType: {
      type: Number,
      default: 2
    },

    isSimColorMode: {
      type: Boolean,
      default: false
    },

    simColorModeColor: {
      type: String,
      default: '#fff'
    },

    modelEdgeColor: {
      type: String,
      default: '#505050'
    },

    isModelEdge: {
      type: Boolean,
      default: false
    },

    workerUrl: {
      type: String,
      default: '/static/DataWorker.js?v=1.1.1'
    },

    webGlFontUrl: {
      type: String,
      default: '/static/gentilis_regular.typeface.json?v=1.1.1'
    },

    isDebug: {
      type: Boolean,
      default: false
    },

    isNeedUpdate: {
      type: Boolean,
      default: true
    },

    isShowBCInfo: {
      type: Boolean,
      default: false
    },

    isDblClick: {
      type: Boolean,
      default: false
    },

    isAutoRotation: {
      type: Boolean,
      default: false
    },

    isShowContextMenu: {
      type: Boolean,
      default: true
    },

    isShowGanttButton: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    setViewInfoImg: function setViewInfoImg(image) {
      this.ccbimImage = image;
    },
    setShowSettingBox: function setShowSettingBox() {
      window.$CCBIM.render.showSettingBox.show = true;
    },
    setModelViewInfo: function setModelViewInfo(floor, info, floorName, flatBuffer) {
      var useFlatBuffer = new __WEBPACK_IMPORTED_MODULE_1__flatBuffers_useFlatBuffer__["a" /* default */]();
      var viewInfo = useFlatBuffer.getFlatBuffer(useFlatBuffer.DecodeBase64(flatBuffer));

      var floorComtypeArrayList = [];
      for (var f = 0; f < viewInfo.floorInfo.length; f++) {
        if (viewInfo.floorInfo[f].state === 1) {
          for (var i = 0; i < this.floorTree[0].children.length; i++) {
            var _floor = this.floorTree[0].children[i].children;
            for (var j = 0; j < _floor.length; j++) {
              if (_floor[j].floorId === viewInfo.floorInfo[f].floorid) {
                var floorComtypeArray = [];
                this.recursionTreeGetFloorComType(_floor[j], floorComtypeArray);
                floorComtypeArrayList = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(floorComtypeArrayList), floorComtypeArray);
              }
            }
          }
        } else if (viewInfo.floorInfo[f].state === 2) {
          var _floorComtypeArray = [];
          for (var c = 0; c < viewInfo.floorInfo[f].comtypeArr.length; c++) {
            var comtypeIndex = viewInfo.floorInfo[f].comtypeArr[c];
            _floorComtypeArray.push({
              floorId: viewInfo.floorInfo[f].floorid,
              comtype: comtypeIndex
            });
          }
          floorComtypeArrayList = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(floorComtypeArrayList), _floorComtypeArray);
        }
      }
      this.setEntVisibleFromFloorComtype(floorComtypeArrayList);

      var up = [viewInfo.cameraUp.x, viewInfo.cameraUp.y, viewInfo.cameraUp.z];
      var target = [viewInfo.cameraTarget.x, viewInfo.cameraTarget.y, viewInfo.cameraTarget.z];
      var position = [viewInfo.cameraPosition.x, viewInfo.cameraPosition.y, viewInfo.cameraPosition.z];
      this.setCameraView(up, target, position);

      var handle = info.split(';')[0];
      this.externalSelectGeo = {
        floor: floor,
        handle: handle,
        floorName: floorName
      };
      this.setSelectGeometry(this.externalSelectGeo.floor, this.externalSelectGeo.handle, this.externalSelectGeo.floorName);
      var stage = this.getStagesFromStageId(viewInfo.stageId);
      if (stage) {
        this.controlStages(stage);
      }

      this.closeClipping();
      if (viewInfo.cullPlane && viewInfo.cullPlane.length > 0) {
        var p = viewInfo.cullPlane;
        this.profileHandlePosition(p[0], p[1], p[2], p[3], p[4], p[5]);
      }
      useFlatBuffer = null;
    },
    setCameraView: function setCameraView(up, target, position) {
      var _this = this;

      if (this.isOpenWalk) {
        this.$refs.roamLocation.style.display = 'block';
        setTimeout(function () {
          _this.$refs.roamLocation.style.display = 'none';
        }, 1500);
      } else {
        this.setCameraModeView(up, target, position);
      }
    },
    setCameraModeView: function setCameraModeView(up, target, position) {
      window.$CCBIM.sceneManager.setNeedUpdate(true);
      var sceneData = window.$CCBIM.sceneManager.getSceneData();
      target = target.map(function (x) {
        return x * sceneData.scale;
      });
      position = position.map(function (x) {
        return x * sceneData.scale;
      });
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, up);
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, position);
      this.setCameraTween(window.$CCBIM.controller.target, target);
      this.setCameraBox();
    },
    setSelectGeometry: function setSelectGeometry(floor, handle, floorName) {
      window.$CCBIM.sceneManager.clearHighlight();
      this.selectedGeometry = null;
      var entInfo = window.$CCBIM.projectManager.getEntInfoFromFloorIdHandle({
        floorId: floor,
        handle: handle
      });
      this.selectedGeometry = entInfo;
      var opacity = 1;
      window.$CCBIM.sceneManager.highlightEnt(entInfo, window.$CCBIM.actionManager.selectColor, opacity).then(function () {
        console.log('');
      }, function () {
        console.log('');
      });
    }
  }
});

/***/ }),
/* 513 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__test_stats_min__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__test_dat_gui_min__ = __webpack_require__(188);


/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      stats: null,
      GUI: null
    };
  },

  methods: {
    initTest: function initTest() {
      this.stats = new __WEBPACK_IMPORTED_MODULE_0__test_stats_min__["a" /* default */]();
      this.$refs.model.appendChild(this.stats.dom);
      this.initGUI();
    },
    initGUI: function initGUI() {
      this.GUI = new __WEBPACK_IMPORTED_MODULE_1__test_dat_gui_min__["dat"].GUI();
      var folder = this.GUI.addFolder('');
      folder.add(window.$CCBIM.WebGLRenderer.info.memory, 'geometries');

      folder.add(window.$CCBIM.WebGLRenderer.info.memory, 'textures');

      folder.add(window.$CCBIM.WebGLRenderer.info.render, 'triangles');
      folder.add(window.$CCBIM.WebGLRenderer.info.render, 'points');

      var sfolder = this.GUI.addFolder('');
      sfolder.add(window.$CCBIM.WebGLRenderer.info.programs, 'length');
      var osGfolder = this.GUI.addFolder('');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'precision');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'logarithmicDepthBuffer');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxVertexTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxTextureSize');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxCubemapSize');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxAttributes');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxVertexUniforms');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxVaryings');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'maxFragmentUniforms');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'vertexTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'floatFragmentTextures');
      osGfolder.add(window.$CCBIM.WebGLRenderer.capabilities, 'floatVertexTextures');

      this.setGUICamera();
    },
    setGUILight: function setGUILight() {
      var _this = this;

      var DirectionalLight = window.$CCBIM.scene.getObjectByName('DirectionalLight');
      var AmbientLight = window.$CCBIM.scene.getObjectByName('AmbientLight');

      var folder = this.GUI.addFolder('');
      folder.add(DirectionalLight, 'intensity', 1.0, 10).onChange(function (v) {
        DirectionalLight.intensity = v;
      });

      var dc = { 'light color': DirectionalLight.color.getHex() };
      folder.addColor(dc, 'light color').onChange(function (v) {
        _this.needUpdate = true;
        DirectionalLight.color.setHex(v);
      });

      folder = this.GUI.addFolder('');
      folder.add(AmbientLight, 'intensity', 1.0, 10).onChange(function (v) {
        _this.needUpdate = true;
        AmbientLight.intensity = v;
      });

      dc = { 'light color': AmbientLight.color.getHex() };
      folder.addColor(dc, 'light color').onChange(function (v) {
        _this.needUpdate = true;
        AmbientLight.color.setHex(v);
      });
    },
    setGUICamera: function setGUICamera() {
      var cfolder = this.GUI.addFolder('');
      cfolder.add(window.$CCBIM.camera.position, 'x');
      cfolder.add(window.$CCBIM.camera.position, 'y');
      cfolder.add(window.$CCBIM.camera.position, 'z');
      cfolder.add(window.$CCBIM.camera, 'zoom');
      if (this.rendererType === 'DWG') {
        cfolder.add(window.$CCBIM.camera, 'left');
        cfolder.add(window.$CCBIM.camera, 'right');
        cfolder.add(window.$CCBIM.camera, 'top');
        cfolder.add(window.$CCBIM.camera, 'bottom');
      }
      var ccfolder = this.GUI.addFolder('');
      ccfolder.open();
      ccfolder.add(window.$CCBIM.camera.position, 'x');
      ccfolder.add(window.$CCBIM.camera.position, 'y');
      ccfolder.add(window.$CCBIM.camera.position, 'z');
    }
  }
});

/***/ }),
/* 514 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controls_TrackballControls_js__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tool_tween__ = __webpack_require__(105);



/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      startTween: false
    };
  },

  methods: {
    initBox: function initBox() {
      window.$CCBIM.viewBox = {
        rendererBox: null,
        sceneBox: null,
        cameraBox: null,
        controllerBox: null
      };
      window.$CCBIM.viewBox.rendererBox = new window.$CCBIM.WebGL.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      window.$CCBIM.viewBox.rendererBox.setSize(90, 90);
      window.$CCBIM.viewBox.cameraBox = new window.$CCBIM.WebGL.PerspectiveCamera(40, 90 / 90, 1, 3000);
      window.$CCBIM.viewBox.sceneBox = new window.$CCBIM.WebGL.Scene();
      window.$CCBIM.viewBox.controllerBox = new __WEBPACK_IMPORTED_MODULE_1__controls_TrackballControls_js__["a" /* default */](window.$CCBIM.viewBox.cameraBox, this.$refs.model, false);

      window.$CCBIM.viewBox.controllerBox.noZoom = true;
      window.$CCBIM.viewBox.controllerBox.noPan = true;
      window.$CCBIM.viewBox.controllerBox.rotateSpeed = 2.5;
      window.$CCBIM.viewBox.controllerBox.dynamicDampingFactor = 0;
      this.$refs.viewBox.appendChild(window.$CCBIM.viewBox.rendererBox.domElement);
      this.addBoxGeometry();
      this.addBoxLight();
    },
    setCameraBox: function setCameraBox() {
      var cameraData = window.$CCBIM.controller.getCameraData();
      var carmraVer = new window.$CCBIM.WebGL.Vector3();
      carmraVer.subVectors(cameraData.cameraPosition, cameraData.target).normalize();
      carmraVer.setLength(90);

      var cUp = cameraData.cameraUp.clone();

      if (window.$CCBIM.viewBox) {
        window.$CCBIM.viewBox.cameraBox.position.x = carmraVer.x;
        window.$CCBIM.viewBox.cameraBox.position.y = carmraVer.y;
        window.$CCBIM.viewBox.cameraBox.position.z = carmraVer.z;

        window.$CCBIM.viewBox.cameraBox.up.x = cUp.x;
        window.$CCBIM.viewBox.cameraBox.up.y = cUp.y;
        window.$CCBIM.viewBox.cameraBox.up.z = cUp.z;
      }
    },
    setCameraBoxUp: function setCameraBoxUp(items) {
      var _items = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(items, 3);

      window.$CCBIM.viewBox.cameraBox.up.x = _items[0];
      window.$CCBIM.viewBox.cameraBox.up.y = _items[1];
      window.$CCBIM.viewBox.cameraBox.up.z = _items[2];
    },
    setCameraBoxPosition: function setCameraBoxPosition(items) {
      var _items2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(items, 3);

      window.$CCBIM.viewBox.cameraBox.position.x = _items2[0];
      window.$CCBIM.viewBox.cameraBox.position.y = _items2[1];
      window.$CCBIM.viewBox.cameraBox.position.z = _items2[2];
    },
    addBoxGeometry: function addBoxGeometry() {
      var geometry = new window.$CCBIM.WebGL.BoxGeometry(31, 31, 31);
      var loader = new window.$CCBIM.WebGL.TextureLoader();

      var material1 = new window.$CCBIM.WebGL.MeshPhongMaterial({
        map: loader.load(window.$CCBIM.render.baseImg.right)
      });
      var material2 = new window.$CCBIM.WebGL.MeshPhongMaterial({
        map: loader.load(window.$CCBIM.render.baseImg.left)
      });
      var material3 = new window.$CCBIM.WebGL.MeshPhongMaterial({
        map: loader.load(window.$CCBIM.render.baseImg.back)
      });
      var material4 = new window.$CCBIM.WebGL.MeshPhongMaterial({
        map: loader.load(window.$CCBIM.render.baseImg.front)
      });
      var material5 = new window.$CCBIM.WebGL.MeshPhongMaterial({
        map: loader.load(window.$CCBIM.render.baseImg.up)
      });
      var material6 = new window.$CCBIM.WebGL.MeshPhongMaterial({
        map: loader.load(window.$CCBIM.render.baseImg.bottom)
      });
      var materials = [material1, material2, material3, material4, material5, material6];
      var mesh = new window.$CCBIM.WebGL.Mesh(geometry, materials);
      window.$CCBIM.viewBox.sceneBox.add(mesh);
    },
    addBoxLight: function addBoxLight() {
      var dl = new window.$CCBIM.WebGL.DirectionalLight(0xffffff, 2);
      dl.name = 'DirectionalLight';
      dl.position.set(1, 1, 1);
      window.$CCBIM.viewBox.sceneBox.add(dl);
      var dRight = new window.$CCBIM.WebGL.DirectionalLight(0xffffff, 1.6);
      dRight.position.set(-1, -1, -1);
      window.$CCBIM.viewBox.sceneBox.add(dRight);
    },
    getBoxIntersects: function getBoxIntersects(point) {
      var mouse = new window.$CCBIM.WebGL.Vector2();
      mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);
      var raycaster = new window.$CCBIM.WebGL.Raycaster();
      raycaster.far = window.$CCBIM.viewBox.cameraBox.far;
      raycaster.near = window.$CCBIM.viewBox.cameraBox.near;
      raycaster.setFromCamera(mouse, window.$CCBIM.viewBox.cameraBox);
      return raycaster.intersectObjects(window.$CCBIM.viewBox.sceneBox.children);
    },
    getWorldCoordinate: function getWorldCoordinate(dom, x, y) {
      var rect = dom.getBoundingClientRect();
      return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
    },
    boxHandle: function boxHandle(e) {
      var _this = this;

      var boxWorldCoordinate = this.getWorldCoordinate(this.$refs.viewBox, e.clientX, e.clientY);
      var Vector = new window.$CCBIM.WebGL.Vector2();
      Vector.fromArray(boxWorldCoordinate);
      var intersects = this.getBoxIntersects(Vector);
      if (intersects.length > 0 && !this.isOpenWalk) {
        window.$CCBIM.sceneManager.setNeedUpdate(true);
        this.setControlsTarget(this.view.target);
        switch (intersects[0].face.materialIndex) {
          case 0:
            this.toRight();
            break;
          case 1:
            this.toLeft();
            break;
          case 2:
            this.toBack();
            break;
          case 3:
            this.toFront();
            break;
          case 4:
            this.toTop();
            break;
          case 5:
            this.toBottom();
            break;
        }
        setTimeout(function () {
          _this.setCameraBox();
        }, 1000);
      }
    },
    toHome: function toHome() {
      var _this2 = this;

      if (!this.isOpenWalk) {
        window.$CCBIM.sceneManager.setNeedUpdate(true);
        this.setCameraTween(window.$CCBIM.webglContext.camera.up, this.view.up);
        this.setCameraTween(window.$CCBIM.webglContext.camera.position, this.view.position);
        this.setCameraTween(window.$CCBIM.controller.target, this.view.target);
        setTimeout(function () {
          _this2.setCameraBox();
        }, 1000);
      }
    },
    toRight: function toRight() {
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, [0, 0, 2]);
      var _window$$CCBIM$contro = window.$CCBIM.controller.target,
          y = _window$$CCBIM$contro.y,
          z = _window$$CCBIM$contro.z;

      var x = this.view.position[0];
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, [x, y, z]);
    },
    toLeft: function toLeft() {
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, [0, 0, 2]);
      var _window$$CCBIM$contro2 = window.$CCBIM.controller.target,
          y = _window$$CCBIM$contro2.y,
          z = _window$$CCBIM$contro2.z;

      var x = this.view.position[0];
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, [-(x * 3), y, z]);
    },
    toBack: function toBack() {
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, [0, 0, 2]);
      var _window$$CCBIM$contro3 = window.$CCBIM.controller.target,
          x = _window$$CCBIM$contro3.x,
          z = _window$$CCBIM$contro3.z;

      var y = this.view.position[1];
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, [x, -y, z]);
    },
    toFront: function toFront() {
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, [0, 0, 2]);
      var _window$$CCBIM$contro4 = window.$CCBIM.controller.target,
          x = _window$$CCBIM$contro4.x,
          z = _window$$CCBIM$contro4.z;

      var y = this.view.position[1];
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, [x, y, z]);
    },
    toTop: function toTop() {
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, [0, 2, 0]);
      var _window$$CCBIM$contro5 = window.$CCBIM.controller.target,
          x = _window$$CCBIM$contro5.x,
          y = _window$$CCBIM$contro5.y;

      var z = this.view.position[2];
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, [x, y, z]);
    },
    toBottom: function toBottom() {
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, [0, -2, 0]);
      var _window$$CCBIM$contro6 = window.$CCBIM.controller.target,
          x = _window$$CCBIM$contro6.x,
          y = _window$$CCBIM$contro6.y;

      var z = this.view.position[2];
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, [x, y, -z]);
    },
    toPosition: function toPosition(upPosition, cameraPosition) {
      this.setCameraBox();
      this.setCameraTween(window.$CCBIM.webglContext.camera.up, upPosition);
      this.setCameraTween(window.$CCBIM.webglContext.camera.position, cameraPosition);
    },
    setCameraTween: function setCameraTween(source, view) {
      var _this3 = this;

      new __WEBPACK_IMPORTED_MODULE_2__tool_tween__["a" /* default */].Tween(source).to({
        x: view[0],
        y: view[1],
        z: view[2] }, 1000).easing(__WEBPACK_IMPORTED_MODULE_2__tool_tween__["a" /* default */].Easing.Quadratic.Out).onStart(function () {
        _this3.startTween = true;
        _this3.onBeforeUpdate();
      }).onComplete(function () {
        window.$CCBIM.sceneManager.setNeedUpdate(true);
        _this3.startTween = false;

        if (_this3.tweenTimer.length > 0) {
          _this3.tweenTimer.forEach(function (item) {
            clearInterval(item);
          });
          _this3.tweenTimer.length = 0;
        }
      }).start();
    }
  }
});

/***/ }),
/* 515 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var panoramaFile = {
  fileJson: [],

  cloudUrl: ''
};

/* harmony default export */ __webpack_exports__["a"] = ({
  data: function data() {
    return {
      panoramaErrorMsg: ''
    };
  },

  props: {
    version: '',

    panoramaUrlIp: ''
  },
  methods: {
    panoramaConstructInfo: function panoramaConstructInfo() {
      var _this = this;

      var data = {};
      data['versionId'] = this.version;
      this.$ccbimAxios({
        method: 'post',
        url: this.panoramaUrlIp + '/front/bimfile/modelConstructInfoCors.htm',
        data: this.$qs.stringify(data)
      }).then(function (res) {
        var data = res.data;

        if (data.success) {
          if (data.result.jsons.length === 0) {
            _this.panoramaErrorMsg = '';
            return;
          }
          panoramaFile.fileJson = data.result.jsons;
          _this.loadPanoramaInfo();
        } else {
          _this.panoramaErrorMsg = data.errorMsg;
        }
      });
    },
    loadPanoramaInfo: function loadPanoramaInfo() {
      var _this2 = this;

      var ProjectInfo = panoramaFile.fileJson.filter(function (x) {
        return x.FileKey.includes('panorama');
      });
      var url = ProjectInfo[0].URI;
      this.$ccbimAxios({
        method: 'get',
        url: url
      }).then(function (res) {
        if (res.data.var === 2) {
          _this2.isNew = true;
        }
        _this2.handlePanoramaInfo(res.data);
      });
    },
    handlePanoramaInfo: function handlePanoramaInfo(data) {
      var url = panoramaFile.fileJson[0].URI;
      var length = url.lastIndexOf('/');
      panoramaFile.cloudUrl = url.slice(0, length + 1);

      data.panoramaArray.forEach(function (panoramaArray) {
        panoramaFile.fileJson.forEach(function (item) {
          for (var i = 0, len = panoramaArray.panoramaImg.length; i < len; i++) {
            if (item.FileKey.indexOf(panoramaArray.panoramaImg[i].split('|')[1]) > 0) {
              panoramaArray.panoramaImg[i] = panoramaFile.cloudUrl + item.FileKey;
            }
          }
          if (panoramaArray.previewImg && item.FileKey.indexOf(panoramaArray.previewImg.split('|')[1]) > 0) {
            panoramaArray.previewImg = panoramaFile.cloudUrl + item.FileKey;
          }
          panoramaArray.jumpHot.forEach(function (jumpHot) {
            for (var j = 0, iconLen = jumpHot.img.length; j < iconLen; j++) {
              if (jumpHot.targetPic && item.FileKey.indexOf(jumpHot.targetPic.split('|')[1]) > 0) {
                jumpHot.targetPic = panoramaFile.cloudUrl + item.FileKey;
              }
            }
          });
        });
        panoramaArray.jumpHot.forEach(function (jumpHot) {
          for (var j = 0, iconLen = jumpHot.img.length; j < iconLen; j++) {
            jumpHot.img[j] = panoramaFile.cloudUrl + 'Pm720/Icon/' + jumpHot.img[j].split('|')[1];
          }
        });
        panoramaArray.current = false;
      });
      data.panoramaArray[0].current = true;

      this.panoramaInit();
      this.panorama = data;

      this.box = this.panorama.box;
      this.jumpHot = this.panorama.panoramaArray[0].jumpHot;
      this.panoramaImg = this.panorama.panoramaArray[0].panoramaImg;
      this.panoramaId = this.panorama.panoramaArray[0].id;
      this.setCameraTarget(this.panorama.panoramaArray[0].cameraTarget);
    }
  }
});

/***/ }),
/* 516 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  front: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NjQ2RTdGMjIyOTQxMUU4QTFCNDhCNkI1OTVFM0M0NSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NjQ2RTdGMTIyOTQxMUU4QTFCNDhCNkI1OTVFM0M0NSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MUI3QkYzQkM0MjcxMUU3ODBBNkZDMjZFN0M3MzU1QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MUI3QkYzQ0M0MjcxMUU3ODBBNkZDMjZFN0M3MzU1QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB9AAEAAgMBAQAAAAAAAAAAAAAAAwQBBgcFAgEBAAAAAAAAAAAAAAAAAAAAABAAAAUBBQQECgkEAwAAAAAAAAECAwQFEXESFAYhUzQHMUEiE1FhMnKyc5OzNTaBkbFS4jN0VRfhQiMWQ1QVEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDoMOHGOM2ZtkZmQnyUXdEELhWrhOAgyUXdEGSi7ohOACDJRd0QZKLuiE4AIMlF3RBkou6ITgAgyUXdEGSi7ohOACDJRd0QZKLuiE4AIMlF3RBkou6ITgAgyUXdEIJkOMUVwybIjIheFebwrtwDMLhWrhOIIXCtXCcAAAAAAAABmw7LbNnhGAAAGbDsts2H1gMAAAAAAAK83hXbhYFebwrtwDMLhWrhOIIXCtXCcAAAABkunaWwc/1GnmSdalHQVOFS+zlySbJF5Pa8vtdI8vBzg++79ccAquoNSaR1kuRVnlS6ZJ8hsiwtnHt/409S0dfhHT40hiZHalxV95HfSS2nC60n0DkVSofMysJZRVGFSksL7xklmx2VfRZ9QuIZ5utoS22biEJKxKE5ciIi6iIgHTahPiUqE9UJ7hNRmE4lqPr8CS8ZjnOj6zqjUmqZVSZeU1SLbZTCyxNEgtjbTZdS/CZCjOpnNOpxlQ6g2uRHXtU0s45laXQfiMYp9K5pUmImDTW1x4yDM0toNjpPpMzO0zO8B16zxDA5Zg5wffd+uONl0cnWpSJX+1qWbOBOWxm2fat7X5XiAbcAAACvN4V24WBXm8K7cAzC4Vq4TiCFwrVwnAAAAHmairH/AIFHkVbucx3GEu5xYbcR2eVtGifzAn9mP2/4Rs3MT5OqF7fpENf0RqTSlO05HiVWUw1LQtZrQ43iURGey08JgIf5hT+zn7f8IyXOAjMiKjHtMi/P8J2fdGzf7loT/vRfY/hHP+ZFXolXmUpdEeaeQyk0vmyjARKNwjK3YQDsT8hMeIuWsjNDbXfKSnpsw47CHj6a1ZT9VNyHIDLzJRjSSyfIiM8XRhwn4h6FT+Cyf0h+7IaDyf4aree19hgL/MLVNa07NpjFKdbbblNrU8TjaVmZktKSsxdGwxvLSjWy2tXlKQlR3mVo5bze+JUT1TnvEjqMfh2fVo9EgEgAAAK83hXbhYFebwrtwDMLhWrhOIIXCtXCcAAAAavzE+Tqhe36RDWdGaDoNd09Hqc5DxyHFLSo23cKbEnYWywbPzE+Tqhe36RDnuntFahrVJaqFPqaY0Zw1JSybjqTI0nYexGwBvP8WaW3cn239BonMLTNM0zLpjVMS4lMojW73q8e1LhEVngHrfxtq397R7Z8axqvT1V07IhNVWYUxcjtNKJa14SSsiMv8nR9ADt9T+Cyf0h+7IaDyf4aree19hjfqn8Flfoz92Q0Dk8ZHGq1n32vsMBW5vfEqJ6pz3iR1GPw7Pq0eiQ5dze+JUT1TnvEjqMfh2fVo9EgEgAAAK83hXbhYFebwrtwDMLhWrhOIIXCtXCcAAAAavzE+Tqhe36RCPlt8oRPPc9Ie5XKQzXqW/SZDi2Wn8OJxuw1FhO3ZitIfNBorGn6Y1Sozq3mmjUonHLCUeI7duGwgENS1Vp6jyjhVOcmPIJJL7tSVn2VdB2pSZDmHMeu0zUFRpZUd7NJYTgWtKTIjUtwjJKcREZjpNb0bQNQykTao06p9CO7Sppw0FhI7dpEIaboHStKlImxoinH2zxNKfcNwkKL+5KT2WgNkSk8DaDLbgQRkfmlsGtHrrSUd96K7KTEeZUaHUKaNHaSdhl2EnaNmtO23r6Rq07l5pWozH58pl85ElZuOmh5SU4j6bEl0AOf8wK9A1LWKc1R1HIRHT3JOERkS1uLI7EEe3ZYOzNJNDTaFeUlCUneREQ8Gk6J0zRJBS4MQ1SU7W3X1m4aPMxdA2AAAAABXm8K7cLArzeFduAZhcK1cJxBC4Vq4TgAAAAAAAAAAAAAAAAAAAAArzeFduFgV5vCu3AMwuFauE4ow5kUozZG4RGRCbOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwK83hXbgzsXekIJkyMqM4ROEZmQD//2Q==',
  back: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NzE5RDE2OTIyOTMxMUU4OTIzNzlDRDUwRTQ4NTZDOCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NzE5RDE2ODIyOTMxMUU4OTIzNzlDRDUwRTQ4NTZDOCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1MkUyM0JCQUM0NDExMUU3QkMyQkE1QjQ3MUZERUEwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1MkUyM0JCQkM0NDExMUU3QkMyQkE1QjQ3MUZERUEwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB/AAEBAQEBAQEAAAAAAAAAAAAAAwcGBAUBAQEAAAAAAAAAAAAAAAAAAAAAEAABAwEFBQQHAwgLAAAAAAABAAIDBBESFAUGIXJTNAcxURNVQZHRItKUFXGyFoEyUoKTJBc3YaGxQpKiIzNDc4QRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANBo6OlNLETECSNpV8FScJqUXKRbqughgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNUKyjpRSykRAEDYV7lCt5SXdQKLlIt1XUKLlIt1XQEREBERAREQEREBERAREQFCt5SXdV1Ct5SXdQKLlIt1XUKLlIt1XQEREAbSuPyrXEmZ6on04aBsTYXzx4kSlxPgEi25cH51neuxHaFhIySbUOtMxyuCobSySVNU8TPDnAXHuNljCDtQbtYUsKyr+EeZ+eQ/spvjT+EeZ+eQ/spvjQas1pc4N7LSB61xuQa4kzvUNRkTqBsDYPG/eBKXk+C67+YWDt+1c43pDmbnBv1yEWmy3wpvT+uvn9N4DS60npXOvugiqYi8bA4sN29t77EGxr4R1ZlI1I7TLpLtUGAiUkXDMduHt/Tu7f6l68/zZmR5PV5o+wmBlsTT/ekd7rG/wCIrOummSOzTManU+YDxfAkIgc/beqX+8+T9QH1oNXREQFCt5SXdV1Ct5SXdQKLlIt1XUKLlIt1XQEREH6O0LItLfzMrf8AvrfvOWujtCxKT8SZLq3MM3y3LJ5X4mpEbn00r43Nke73hdAt2dm1BtiLK/xz1C8mHyVR8SfjnqF5MPkqj4kGrR/7jN4f2rINB/zAr/8A2ffK9TdddQmkOGTC0G0fuVR8Sh09os1bq6Wvr6KenE0VQ975IZI2X5DesBeO87NqD6vV2tdFlmXUDT7s8z55R3iJtjf8zl1Wj8vblmmMspWixzoRPKey183+oSfyELgurjy/Nsph9Dad+zfkHsWqQMEUEUQ2BjGsA3WgIKIiIChW8pLuq6hW8pLuoFFykW6rqFFykW6roCIiAv287vK5DWNBrWsqKV2lap1PCxjhUhs7IbXki6bH9uxc19E6v+ZSfOxexBql53efWl53efWsr+idX/MpPnYvYn0Tq/5lJ87F7EGqXnd59aFxPaSVlf0Tq/5lJ87F7E+idX/MpPnYvYg8/VQX9R5bHb/wMH2XpVrZ7VgmoKXUtJnFHHqmd1RWkRuie6VsxEV/YLzP6fQt7PagIiIChW8pLuq6hW8pLuoFFykW6rqFFykW6roCIiB27AhFltuyztt2Kc8LKiCSnkLgyVpY4sJa4Bwsta5thBHoWSS9O9ZSzzxYu9T33MZLPUvPiR+h7mi8do7QUGtyVFPEA6WaNgOwFz2gW+teabOcnpi0VGYU0RdaWh8zG22dtlrlmMHSTNXNBqMwponW7Qxr5AB32m4vfD0giF7E5sXfoeFAG/bbfc5B20mqNOREB+a0tp2i7K133SVCbWmlKdodLm0FhNgulzzb9kbXLmW9Icnui/mdXf8ASWsiA/IC0r2DpVpcAAyVZNm0+KBae/YEHG67zjLM61FQVWVVDamBkcUbntDgA4SW2e+GlbSe1cfF0x0lEWO8OqfIwhwcahwtINo2AWLsEBERAUK3lJd1XUK3lJd1AouUi3VdQouUi3VdAREQEREBERAREQEREBERAUK3lJd1XUK3lJd1AouUi3VdeGjrKUUsQMoBA2hXxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLqFbyku6mNpOK1QrKylNLKBKCSNgQf/Z',
  left: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDM0NTlERDIyOTMxMUU4OTIxMDhENEU2OTEzNkI2QyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDM0NTlEQzIyOTMxMUU4OTIxMDhENEU2OTEzNkI2QyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyRURCNTg2NEM0NDExMUU3OURCQUE5NEE2OUNCNjRGOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyRURCNTg2NUM0NDExMUU3OURCQUE5NEE2OUNCNjRGOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB4AAEBAAMBAQEAAAAAAAAAAAAAAwUGBwQCAQEBAAAAAAAAAAAAAAAAAAAAABAAAAUBBQQFCgUFAAAAAAAAAAECAwQFEXJTFAYhEjQHUTITdDYxQXGxIsJzs8M1YZFCFRaBUmKSVBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A6DDhxTitGbRGZltMXyUTCSELhGrouAhkomEkMlEwki4AIZKJhJDJRMJIuACGSiYSQyUTCSLgAhkomEkMlEwki4AIZKJhJDJRMJIuACGSiYSQyUTCSLgAhkomEkQmQ4pRXTJoiMi2GPcITeEdugELhGrouIQuEaui4AAAAAAAAAAAAAAAAAAAAAITeEdui4hN4R26AQuEaui4hC4Rq6LgAAAAOX6k1XrHTuoiflsIRTjI0R46fajvN2273aWW9r6uiwb/AKgqblFoc+rNNJechtdqhlZmlKj3kpsUadpdYYvT1Sa1xp1cirwWUtOPOMLipNS0WN7tiyUv2iV7XmAevT2qaRqVjfgO7khJWvQ3bCdR+Nn6k/5EM0OTV/lxUqQ/+56YdcfabPfSySrJLVxSbN8i/MfdC5pzIqih6kjm+lHsqlNFuPpsxWjsJX9LDAdWH6krVEXSdgx9KrdKrbXa0uW3I6UJOxxN5CrFF+QyKOun0kA0zResZep59RiSYzbCYTZLQps1GajNw29u96BuI5Vyl+8134KPnqHVQAAAAEJvCO3RcQm8I7dAIXCNXRcQhcI1dFwAAABgNc+Dq33b6iBiuVnhIu+SPcGV1z4OrfdvqIGL5WEf8SLvkj3AG5jT+YdGpcnT1QqzsVH7hEbJbMpPsrt30JsWZdYrD843Gw+ga7rwj/h1Z+An5rYDlNH0ZXqtSm67RVpUonXGuyS4bTyTaMtqVbC229IybOs9eaZcJmrtOPNt/pntH5CPGRZ6xuXK7wg33uT60jcyIl2NuES0Ge1CiJSfyPYA4doTU8DTdRnyag24puc2lCTZIlbhk4bhmojMtm3zDqVI1lp2uSERKfKUqUsjNLDjakKMklvK8pWbCIc35fUKl1+pVmNVGO2bZbStmxSkGhRvKSZpNJl5h0Ci6GpFAqZ1OnuPEs0Kb7JxRLSRKs8h7pH5gGzAAAAhN4R26LiE3hHboBC4Rq6LiELhGrouAAAAMBrnwdW+7fUQOVafY1y5Tt7TqpJU/tVlYypJI7XZv7FbbfIOq658HVvu31EDFcrPCRd8ke4A1LK81v75v+7Y8dXj8xEUySqsqlHTiQWaJxaDRubxWbxFt61g7aNe134OrPwE/NbAY7ld4Qb73J9aRuiOun0kNL5XeEG+9yfWkbojrp9JAOUcpfvNd+Cj56h1Ucq5S/ea78FHz1DqoAAAACE3hHbouITeEdugELhGrouIQuEaui4AAAAwGufB1b7t9RAxXKzwkXfJHuDY6/TV1miT6S24TS5jXZJdURmST3kqtMiujx6RoDumqN+1vPpkL7d17tEEaSsc3dlh2+TdAZ0a7rzZo2smeAn5rY2IfLjbbqFNPIS42rYpCyJSTL8UqtIwGn8rTI9Ht2f9cn1pG6I66fSQk0yzHR2cdpDLdpnuNpJCbT8p2JIiFEnYoj6DtAcp5S/ea78FHz1Dqo1DRujZOl51Qlvy25KZqCQlKEmk02OG5ae8Z9I28AAAABCbwjt0XEJvCO3QCFwjV0XEIXCNXRcAAAAAAAAAAAAAAAAAAAAAEJvCO3RcQm8I7dAIXCNXRceGHMilFaI3SIyLaQvnYmKkBcBDOxMVIZ2JipAXAQzsTFSGdiYqQFwEM7ExUhnYmKkBcBDOxMVIZ2JipAXAQzsTFSGdiYqQFwEM7ExUhnYmKkBcQm8I7dDOxMVIhMmRTiukTpGZlsIB/9k=',
  right: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MEM1REEzMDIyOTMxMUU4OEU0MkM5RTVDNzEwRTQ2QiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MEM1REEyRjIyOTMxMUU4OEU0MkM5RTVDNzEwRTQ2QiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0MDE1NzE1Q0M0NDExMUU3QTIyMEE2QzU5RUQxREZBRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MDE1NzE1REM0NDExMUU3QTIyMEE2QzU5RUQxREZBRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB6AAEBAQEBAQEAAAAAAAAAAAAAAwcGAQQFAQEAAAAAAAAAAAAAAAAAAAAAEAABBAADBQQHBQUJAAAAAAAAAQIDBBEFBhJyUxQ0ITETs0FRcSIyBzex0XOEFmHSkxVVkcFCUjNUZJQXEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDQadOqtWJViRVVO1S/JVOE0Uuki3S4EOSqcJo5KpwmlwBDkqnCaOSqcJpcAQ5KpwmjkqnCaXAEOSqcJo5KpwmlwBDkqnCaOSqcJpcAQ5KpwmjkqnCaXAEOSqcJpC5TqpVlVIkRUTsU+4hd6SXdAUuki3S5Cl0kW6XAAAAAAAAAAAAAAAAAELvSS7pchd6SXdAUuki3S5Cl0kW6XAAAAclnGsp8r1ZT02yoyWO1y+NhXqjm+O5Wrg1Ew93D1nWmV6t+qGU/kPMcBqgwVe4GbfNTMsxoWsobQtzVUlinWRIZHRo5UexEV2wqY4YgaVgvqGC+oyL9L/Mzv52ft/5rv3h+lvmZ/vZ/+6794DXcF9R5gqGFX01rluawZLbzGy27Z8PwmNtPc1fGcrGYu2vWhouiMp1Rlkl9dRzvmbK2JK3iTrPgrVft4Yquz3oB2AAAELvSS7pchd6SXdAUuki3S5Cl0kW6XAAAAZXq36oZT+Q8xxqKSxOldA2RqzNRHOiRybaIvcqt78FMu1b9UMp/IeY4DVDLPm91uSfhT+ZGamZZ83utyT8KfzIwNST4U9ifYenifCnsT7D0DK9Z/UnJ/ZR85xqq96mVaz+pOT+yj5zjVV71A8AAAhd6SXdLkLvSS7oCl0kW6XIUuki3S4AAAZtq/RmpLOcTaiyez40rtnw4Y3LDNG1jUajWOxRHd3rQ4t+cZmmpqGZalSXmaEldJ0fHsS+FC7aTFvu4uwVe30m+mS65qw3/AJjZfSsoroLEdKGVEXBdh73tXBfR3gaZlWc5ZncHMZXZZYYnxtauD2b7F95pnXze63JPwp/MjPmzjQGe6dnXNtMWJZ2RYuRIl2bMbU7e5OyRvs/sOb1Dqe/qRKH8yjY2zQbJG6RibPibbmuxcz/C5NkDf0+FPYn2HpnCfNykiIn8rl7Ew/1G/cP/AF2l/S5f4jfuA+LWf1Jyf2UfOcaqvephOearhzfVFLULKzoo6nL7UDnIrneA9ZFwcnZ24moaV1jBquS42Go+tyiRucr3I7a8RXJ2bPq2QOlAAAhd6SXdLkLvSS7oCl0kW6XIUuki3S4AAADK9W/VDKfyHmONUOKz3SOZ5lrOjqGvJClOtyviNe5ySL4Dlc/BEaqens7QO17lxQ5XVOhcs1E19iHCnmeGLbLE916+qZqd/t7zqgBhdN8mjM1dl+psnhuQPVHSMkja9+z3eLWlXvT9n2Gp5blGjM3px38uy6nPWl+F6QtRUX0tc3DFrk9KKfoZ1keW6gpOo5lFts7Vilb2SRO/zxu9H95yGjdHZ9p3O7Uk1xG5Y33UYztS1inuuVi/ArfSveB1X6W01/SKn8Fv3H1UcqyzLFkXLqcNVZURJFhYjNpG44bWHfhifYAAAAELvSS7pchd6SXdAUuki3S5Cl0kW6XAAAAAAAAAAAAAAAAAELvSS7pchd6SXdAUuki3S58NO5VSrEiyoionahfnanFaBcEOdqcVo52pxWgXBDnanFaOdqcVoFwQ52pxWjnanFaBcEOdqcVo52pxWgXBDnanFaOdqcVoFwQ52pxWjnanFaBchd6SXdHO1OK0hcuVVqyokqKqp2IB/9k=',
  up: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RDZEMDVCNDIyOTMxMUU4QkU3Qzk5M0YyQkUzNzg3MyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RDZEMDVCMzIyOTMxMUU4QkU3Qzk5M0YyQkUzNzg3MyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5RDJEREYyNEM0MjcxMUU3OUU0REIxMThFMzRDRTQ2OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5RDJEREYyNUM0MjcxMUU3OUU0REIxMThFMzRDRTQ2OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xABzAAEBAQEBAQEAAAAAAAAAAAAAAwcGAQUEAQEAAAAAAAAAAAAAAAAAAAAAEAABAwEFBQUGBQUAAAAAAAAAAQMEAhFyUxQ0IRLSBQaUFVUHFzFxwhOFN1GSk9MWIkIjVCURAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANBhw4qxWlVpFVU2qXyUTCpELSNXS4EMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqSEyHFSK6qNIiomxT9xCbpHboCFpGrpchC0jV0uAAAAAAAAAAAAAAAAAITdI7dLkJukdugIWkaulyELSNXS4AAAAAAM+k9dc3Z6y/j1LMdYmaoj7601/M3arLVt37Ldv4GgmMT/uf9Qb+EDZ12KqA9X2r7zwAAAAAAEJukdulyE3SO3QELSNXS5CFpGrpcAAAAAAGH8+mN8u8wZE96mqpqNModrpos3lSlEVUptsS03AxLnMZib5jOw5NO+w/NobdotVLaarLUtSxQOxXzZ6fVVXJzPytfuD1Z5B/pzPytfuH1V8u+j7V/wCcv6z3GPTzo/w5f1nuMD5rXmpyF51tmmHMSpyqmhFVGrLals2/5DuTmW/L/pFqulyjl6pXQqVUr853YqLan950wAAACE3SO3S5CbpHboCFpGrpchC0jV0uAAAAAADGJ/3P+oN/CbOYxP8Auf8AUG/hA2hfavvPD1favvPAAAAAAAQm6R26XITdI7dAQtI1dLkIWkaulwAAAz7qbzKk9P8AO5PKG+XMP0sJQqOuPV0VLv0JXtpppVNlp8n1jmeERu0OcJpzvLeWyHFdkQo7ztVm844y3XUtmxLaqqVUn3Pyfw2J2drgAzX1jmeERu0OcJyD/UlT/Un8kVlul359MnLJWq0W02f079ltmw3nufk/hsTs7XAO5+T+GxOztcAGar5xzFW3uiL2hzhHrHM8Ijdoc4TSu5+T+GxOztcA7n5P4bE7O1wAZr6xzPCI3aHOE6jovrZ/qx+Yy7DaipFoorRWnKnFq31Wmxd5Es9h0Xc/J/DYnZ2uAtHhQoi1LEisx1q2VKy3Q2qon47iJaBcAACE3SO3S5CbpHboCFpGrpchC0jV0uAAAAAAAAAAAAAAAAAITdI7dLkJukdugIWkaulz8MOZFSK0iuoiom1C+diYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFyE3SO3RnYmLSQmTIqxXUR1FVU2IB//9k=',
  bottom: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1ODFDNzg4ODIyOTMxMUU4OUE3QUQ1NjRGMkM0NEVGRiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1ODFDNzg4NzIyOTMxMUU4OUE3QUQ1NjRGMkM0NEVGRiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3QTQ0Qzk1NEM0NDExMUU3ODk2M0FCOUM4MUQwRDQ5RSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3QTQ0Qzk1NUM0NDExMUU3ODk2M0FCOUM4MUQwRDQ5RSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB2AAEBAAIDAQEAAAAAAAAAAAAABwUGAgMEAQgBAQAAAAAAAAAAAAAAAAAAAAAQAAEDAgMCCwcDBQAAAAAAAAABAgMEBhEhBRIWMWHSk9NUlLRVdRdBUXEiMhM2sTMHweFScmMRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AKeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkdTetzR3XNprK7CkbqDqdsX2of2knWNG7X29r6fbjiVwglZ+cz+bP7ypewAAAAAAAAAAAAAADUr4u7dyljgola7U6hUWNrk2kZGi/M9ycfAn9jsta99OuJraeXCl1JE+ancuT8EzdCq8Pw4f1A2kAAQSs/OZ/Nn95UvZBKz85n82f3lS9gAAAAAAAAAAAAAGL1u39MuCmWm1GFHKiL9qduUkar7WO/pwEguOytXtuRaqLaqaFrtqOriRUczDNFkambFT38HGXM+KiORWuTFFyVF4FQCWWt/JckCMobiVZY0yZXomL2p/1an1f7Jn8SoU9RBVQsqKaRs0MibTJGKjmqnvRUNGuX+NaHUNur0RW0VUuKup1/YevEifQvwy4jSNLr7qs7VEoI4pGySvRq0EiK6OZVXZTYwyVV/yaoHRWfnM/mz+8qXsgErpX3k99QxI5namqyxtdtI161HzNR2CY4L7cC/gAAAAAAAAAAAAPFrNZLp+k11fCjXS00Ek0bX4q1XMarkR2CouGXvA9oI76r3F1ai5uXph6r3F1ai5uXpgLEdckEEr45JYmPfCquhe5qKrHKmyrmKvAuC4ZEh9V7i6tRc3L0w9V7i6tRc3L0wGGrPzmfzZ/eVL2fm+TUp5dVfrDmsSofULVqxEXY21f93DDHHZx4zbvVe4urUXNy9MBYgR31XuLq1FzcvTD1XuLq1FzcvTAWIGsWRcddcunVFXXRxRyRTLE1IEc1uzsNdntufn8xs4AAAAAAOEsUU8b4ZmNkikRWyRvRHNc1cla5FyVFOYAxm7du+EUXZouQN27d8IouzRcgyYAxm7du+EUXZouQN27d8IouzRcgyYAxm7du+EUXZouQN27d8IouzRcgyYAxm7du+EUXZouQN27d8IouzRcgyYA89JQ0NAx0VDTRUsbl2nMgjbG1XYYYqjETPI9AAAAAAAAAAAAAAAAAAAAAAAAAAH/9k=',
  modelMarkImg: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAmCAYAAAA820BcAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA39pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphODRkMDNjNC04MzBlLTZlNDEtOWUyYS0xOWEzYTRiNGMwNTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDgwNzJDN0NFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDgwNzJDN0JFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ4NmY1MTliLWJhMmUtYjk0ZC1iYmRjLWZhMzlhOTM0NWNmNiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmJmNDQzMjIyLTcwNTgtYmE0Yi04ZGVmLTRlNDgzYTI0MDA4NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqFeqsUAAAPDSURBVHjatFhpbExRFP5mOqglqEgZWvyQ2IoIaklaIRp7Ygvxxw+x/7BNEIkKQYJmosSPqkhERIJIJGgVKSli19RWkUa0Hbso0ui0quM77715fTPtzLxZ3km+m3fuvHe+e8+9555zx+bz+dBGXDa0I/2IuUQ2MZRwEp2JBuIzUUmUEVfg9n2ECbG1Sx44kMlsdxCziCQTNv8RxcQBDuJebOQuWx+2R4kliF3OExs4iC/mydXZXtBcrYqjEzB4KpAxHxg0CUgZCCT3ALy/gLpq4P194OUloOoW0NxotCZLsrg9L7Qld9nEvRe19QTsDiBzBTBjN9DdGXmu9V+B0oPA3WNcgCZ/r+yLRRxAcWhyl20C21Kii6KnDgGW03POUdE7/NNz4PRS4Osbf88fYhoH8LAtucvWi20Fkabo6eOB1dc4jF6xr3hDHVBIR9bofB5iNAfwQ3Gq4dVDOnEqI2ntjfiIRTqnAGtKVHuqpGk8hpm7bKP5XC46kjoAm5/E5uqQS/ACODyWe+CvaOLqMZx9hX/mWxVikayNiSUWcY5U7WoTJrapM9+CHlo4JMORDOQybLqlIuEiUbCX4dnsFU2avjLzGQqxyPC51hCLiN0R8/ya8M20a2e1KsPnwFIZNtuoZQt5hq6mjbWWPH2cURsh5P11NWWAteQ9041afyHvqqtyVlspgfa7CPlfXfX+tpY80L5XyL/r6s9aa8l/eYxanZC/09Xax9aS1zwyatVC/lRXK4usJQ+0Xy7kJbr66rJ6Elkh9d9U+63ywM4DXhLKW0WVo+9WnjXkt/P8R6uIpNQ7/sRyXH/pzhG1EEikSFYryzf2nOGkG/3khfqul7QnFYjUZgkJL9o5vcSfThX/Eu7WYsLtq2e7U/9ASp+C6fGvv3xfkGMspUQKyFcTXMmcEKe3hh0LinyWUp5nsRF/4FbKzwwOX0nduaEKSDl8ha233ifV68SVQM4uc9Xr70/A9T3Aw5NAS7PxlxYlfbt9N8OVztO0G0fHgH4pNCTfS9qV7KfU7d3VI1Pqdg+Pi9dXiSvGXW2UXBLvM3NpkFvKWZPXIzMi0bSO5AFk9jDXnGVEUwKI6X+sDyYORw7tuiSlTTypTsrkVSRuae9HR4SPZXNkEUUBRYe5m+omkh4L95LdhCE57iYEJKAI0U0siERsllyJWs0D5yK8x22PySS+bMaoPQpXNmibcH+ohKkQAy/MGrRHuYF82jG8I6hfCKcQH6MxZo9xFx8gTmnPEo4LiW/RGnHEEUbbiUztj4SqWAz8F2AAwxUsG0cxVxkAAAAASUVORK5CYII='
});

/***/ }),
/* 517 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_normalize_css__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_normalize_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__style_normalize_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_dwg_dwgMiniMap_css__ = __webpack_require__(631);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_dwg_dwgMiniMap_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__style_dwg_dwgMiniMap_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_dwg_dwg_css__ = __webpack_require__(630);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_dwg_dwg_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_dwg_dwg_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__setting_js__ = __webpack_require__(471);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__scene_js__ = __webpack_require__(469);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__camera_js__ = __webpack_require__(458);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__handle_js__ = __webpack_require__(463);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__loadFile_js__ = __webpack_require__(464);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__worker_js__ = __webpack_require__(475);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__projectInfo_js__ = __webpack_require__(466);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__geomery_js__ = __webpack_require__(462);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__controls_js__ = __webpack_require__(459);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__selectGeomery__ = __webpack_require__(470);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__event_js__ = __webpack_require__(460);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__test_js__ = __webpack_require__(473);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__floorStrong_js__ = __webpack_require__(461);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__DWGHandle_js__ = __webpack_require__(455);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__pointList_js__ = __webpack_require__(465);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__iconfont__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__iconfont___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19__iconfont__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__treeStrong_index__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__upload_index__ = __webpack_require__(474);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__DWGMiniMap__ = __webpack_require__(456);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__controls_ModelDisHeightControls_js__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__renderUpdate__ = __webpack_require__(467);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__Detector_js__ = __webpack_require__(457);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__tool_tween__ = __webpack_require__(105);





























/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'dwg',
  components: { treeStrong: __WEBPACK_IMPORTED_MODULE_20__treeStrong_index__["a" /* default */], upload: __WEBPACK_IMPORTED_MODULE_21__upload_index__["a" /* default */] },
  mixins: [__WEBPACK_IMPORTED_MODULE_4__setting_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_5__scene_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_6__camera_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_7__handle_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_8__loadFile_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_9__worker_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_10__projectInfo_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_11__geomery_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_12__controls_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_24__renderUpdate__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__selectGeomery__["a" /* default */], __WEBPACK_IMPORTED_MODULE_14__event_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_15__test_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_16__floorStrong_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_22__DWGMiniMap__["a" /* default */], __WEBPACK_IMPORTED_MODULE_17__DWGHandle_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_18__pointList_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_23__controls_ModelDisHeightControls_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_25__Detector_js__["a" /* default */]],
  data: function data() {
    return {
      rect: {},

      renderer: null,

      rendererType: '3D',

      scene: null,

      camera: null,

      controls: null,

      isPhone: false,

      isRenderFinish: false,
      clock: new window.$CCBIM.WebGL.Clock(true),

      needUpdate: true,

      physicallyCorrectLights: true,
      logarithmicDepthBuffer: true,

      preserveDrawingBuffer: true,

      isIe: false,

      isWebGL: true,

      showSettingBox: false,

      animationObj: null,

      tweenTimer: [],
      selectStage: ''
    };
  },
  mounted: function mounted() {
    this.setUserAgent();

    window.$CCBIM.render.$ccbimRun = this.run;

    window.$CCBIM.render.$ccbimUpdate = this.onResize;

    window.$CCBIM.render.$getBlodImg = this.imageToBlod;

    window.$CCBIM.render.$canvasToImage = this.canvasToImage;

    window.$CCBIM.render.$setCameraView = this.setCameraView;

    window.$CCBIM.render.$setViewInfoImg = this.setViewInfoImg;

    window.$CCBIM.render.$setGeomery = this.setGeomery;

    window.$CCBIM.render.$setModelViewInfo = this.setModelViewInfo;

    window.$CCBIM.render.$setClearColor = this.initClearColor;

    window.$CCBIM.render.$switchTexture = this.switchTexture;

    window.$CCBIM.render.$setBComType = this.$setBComType;

    window.$CCBIM.render.$delModelMark = this.delDwgMark;

    window.$CCBIM.render.$bounceModelMark = this.bounceModelMark;

    window.$CCBIM.render.$disposeRender = this.disposeRenderDWG;

    window.$CCBIM.render.$updateBComInfo = this.updateBComInfo;

    window.$CCBIM.render.$addModelMarkRequest = this.addModelMarkRequest;

    window.$CCBIM.render.$modelMarkListRequest = this.modelMarkListRequest;

    window.$CCBIM.render.$removeModelMarkRequest = this.removeModelMarkRequest;

    window.$CCBIM.render.$getIntersectsFirstEntCenterPt = this.getIntersectsFirstEntCenterPt;

    window.$CCBIM.render.$getCADIntersects = this.getCADIntersects;
    window.$CCBIM.render.$computeCADIntersects = this.computeCADIntersects;

    window.$CCBIM.render.GetIsPhone = this.GetIsPhone;

    window.$CCBIM.render.GetNormalGeoCount = this.GetNormalGeoCount;

    window.$CCBIM.render.$addModelMark = this.addModelMark;
    window.$CCBIM.render.$setCADLabel = this.setCADLabel;
    window.$CCBIM.render.onBeforeUpdate = this.onBeforeUpdate;
    window.$CCBIM.render.onAfterUpdate = this.onAfterUpdate;
    window.$CCBIM.render.sortRefGeometr = this.sortRefGeometr;
    window.$CCBIM.render.addRefGeometr = this.addRefGeometr;
    window.$CCBIM.render.haveNeedUpdate = this.haveNeedUpdate;
    window.$CCBIM.render.setNeedUpdate = this.setNeedUpdate;

    this.bindEvent();
  },

  methods: {
    setIe: function setIe() {
      if (navigator.userAgent.includes('Trident')) {
        this.isIe = true;
      }
    },
    run: function run() {
      var _this = this;

      var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setIe();
      if (!this.isIe) {
        this.getDetector();
        if (window.$CCBIM.render.$Detector.webgl) {
          this.setWidth();
          this.isWebGL = true;

          this.clearDataDWG();

          if (this.isLocalLoad) {
            this.showHandle = true;
            this.initRender();
          } else {
            this.initDefault(option);
            this.initRender(option);

            this.$nextTick(function () {
              _this.modelConstructInfo();
            });
          }
        } else {
          this.isWebGL = false;
        }
      }
    },
    initDefault: function initDefault(option) {
      this.textureType = option.textureType || this.textureType;
    },
    setUserAgent: function setUserAgent() {
      var ua = navigator.userAgent.toLowerCase();
      if (ua.match('ipad|iphone|android')) {
        this.isPhone = true;
      } else {
        this.isPhone = false;
      }
    },
    GetIsPhone: function GetIsPhone() {
      return this.isPhone;
    },
    initRender: function initRender() {
      var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      window.$CCBIM.WebGLRenderer = new window.$CCBIM.WebGL.WebGLRenderer({
        antialias: this.antialias,
        precision: this.perceision,
        logarithmicDepthBuffer: this.logarithmicDepthBuffer,
        preserveDrawingBuffer: this.preserveDrawingBuffer });
      this.initClearColor(option.clearColor || this.clearColor);
      window.$CCBIM.WebGLRenderer.setPixelRatio(window.devicePixelRatio);
      if (option.width) {
        this.rect.w = option.width;
        this.rect.h = option.height;
      }
      window.$CCBIM.WebGLRenderer.setSize(this.rect.w, this.rect.h);

      if (this.$refs.model) {
        this.$refs.model.appendChild(window.$CCBIM.WebGLRenderer.domElement);
        this.needUpdate = true;
      }
    },
    disposeRenderDWG: function disposeRenderDWG() {
      this.isRenderFinish = false;
      this.ccbimAxiosAll.forEach(function (item) {
        item.cancel('CCBIM-model by the user.');
      });
      if (this.modelEdgeWorker) {
        this.modelEdgeWorker.terminate();
      }
      if (window.$CCBIM.WebGLRenderer) {
        this.progress = 0;
        this.loaded = 0;
        this.needUpdate = false;
        window.cancelAnimationFrame(this.animationObj);
        if (window.$CCBIM.controller) {
          window.$CCBIM.controller.dispose();
        }
        window.$CCBIM.scene.children.forEach(function (x) {
          return window.$CCBIM.scene.remove(x);
        });
        window.$CCBIM.scene.autoUpdate = false;
        this.projectMap.clear();
        this.projectMate.clear();
        this.clearDataDWG();
        this.initScene();
        if (this.$refs.model) {
          this.$refs.model.removeChild(window.$CCBIM.WebGLRenderer.domElement);
        }
        window.$CCBIM.WebGLRenderer.dispose();
      }
    },
    clearDataDWG: function clearDataDWG() {
      this.projectFile = [];
      window.$CCBIM.octreeInfo = [];
      window.$CCBIM.mRefTriangleArr.clear();
      window.$CCBIM.userModelGroupMap.clear();
      window.$CCBIM.RefGeomeryMap.clear();
      window.$CCBIM.floorPlanGraph = [];
      window.$CCBIM.sortRef = [];
      this.projectLayerList.clear();
    },
    initClearColor: function initClearColor(color) {
      this.needUpdate = true;
      window.$CCBIM.scene.background = new window.$CCBIM.WebGL.Color(color);
    },
    setCADLabel: function setCADLabel(labelInfo) {
      this.cadLabelText = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(labelInfo));
    },
    animate: function animate() {
      if (this.isNeedUpdate) {
        if (!this.needUpdate) {
          this.animationObj = requestAnimationFrame(this.animate);
          return;
        }
      }

      if (this.startTween) {
        this.tweenTimer.push(setInterval(function () {
          window.$CCBIM.controller.update();
          __WEBPACK_IMPORTED_MODULE_26__tool_tween__["a" /* default */].update();
        }, 0));
      } else {
        window.$CCBIM.controller.update();
        __WEBPACK_IMPORTED_MODULE_26__tool_tween__["a" /* default */].update();
      }

      if (window.$CCBIM.scene && window.$CCBIM.camera && window.$CCBIM.WebGLRenderer) {
        window.$CCBIM.WebGLRenderer.render(window.$CCBIM.scene, window.$CCBIM.camera);
      }

      window.$CCBIM.controller.isAutoRotation = this.isAutoRotation;

      if (this.isRenderFinish) {
        if (this.isOpenMiniMap && this.rendererType === 'DWG' && !this.isPhone) {
          this.updateMiniMap();
        }

        this.computePointPosition();

        if (this.isMeasureHeight) {
          this.computeLabelPosition();
        }

        if (this.showMap) {
          this.getCamera2dPosition();
        }
      }
      if (this.isDebug) {
        var delta = this.clock.getDelta();
        this.stats.update(delta);
        this.GUI.updateDisplay();
      }

      this.animationObj = requestAnimationFrame(this.animate);
    }
  },
  destroyed: function destroyed() {
    console.log('');
    this.disposeRenderDWG();
  }
});

/***/ }),
/* 518 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_Model_roam_css__ = __webpack_require__(628);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_Model_roam_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__style_Model_roam_css__);




/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'roam',
  data: function data() {
    return {
      showRoamBox: {
        show: false
      },

      checkedRoamTip: false,

      isGravity: false,

      showRoamImg: false,
      moveSpeed: 1,

      isMobile: false,

      phoneWalkTip: true
    };
  },
  mounted: function mounted() {
    this.setUserAgent();
    window.$CCBIM.render.showRoamBox = this.showRoamBox;
    window.$CCBIM.render.isGravity = this.isGravity;
    window.$CCBIM.render.moveSpeed = 20;
  },

  watch: {
    isGravity: function isGravity() {
      window.$CCBIM.render.isGravity = this.isGravity;
    }
  },
  methods: {
    setUserAgent: function setUserAgent() {
      var ua = navigator.userAgent.toLowerCase();
      if (ua.match('ipad|iphone|android')) {
        this.isMobile = true;
      } else {
        this.isMobile = false;
      }
    },
    exitWalk: function exitWalk() {
      window.$CCBIM.render.$closeWalk();
      window.$CCBIM.render.$exitFullscreen();
      this.phoneWalkTip = true;
    },
    startMoveTop: function startMoveTop() {
      window.$CCBIM.render.onBeforeUpdate();
      window.$CCBIM.controller.moveTop = true;
      window.$CCBIM.controller.moveBottom = false;
    },
    endMoveTop: function endMoveTop() {
      window.$CCBIM.render.onBeforeUpdate();
      window.$CCBIM.controller.moveTop = false;
    },
    startMoveBottom: function startMoveBottom() {
      window.$CCBIM.render.onBeforeUpdate();
      window.$CCBIM.controller.moveTop = false;
      window.$CCBIM.controller.moveBottom = true;
    },
    endMoveBottom: function endMoveBottom() {
      window.$CCBIM.render.onBeforeUpdate();
      window.$CCBIM.controller.moveBottom = false;
    },
    openTree: function openTree() {
      this.$emit('phoneOpenTree');
    },
    haveRoamBox: function haveRoamBox() {
      var orientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
      if (orientation === 'portrait') {
        this.phoneWalkTip = true;
      } else {
        this.phoneWalkTip = false;
      }
      if (!this.isMobile) {
        this.showRoamImg = true;
      }
      if (JSON.parse(localStorage.getItem('showRoamBox')) === false) {
        if (!this.isMobile) {
          this.showRoamBox.show = true;
        }
      }
      this.localShowRoamBox();
    },
    setRoamTip: function setRoamTip(val) {
      localStorage.setItem('showRoamBox', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(val.target.checked));
      this.checkedRoamTip = val.target.checked;
    },
    localShowRoamBox: function localShowRoamBox() {
      var isShow = JSON.parse(localStorage.getItem('showRoamBox'));
      if (isShow === null) {
        localStorage.setItem('showRoamBox', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(false));
      } else if (isShow === false) {
        this.checkedRoamTip = false;
      } else if (isShow === true) {
        this.checkedRoamTip = true;
      }
    },
    moveSpeedAdd: function moveSpeedAdd() {
      if (this.moveSpeed < 8) {
        this.moveSpeed++;
        window.$CCBIM.controller.moveSpeed *= this.moveSpeed;
        window.$CCBIM.render.moveSpeed = window.$CCBIM.controller.moveSpeed;
      }
    },
    moveSpeedSub: function moveSpeedSub() {
      if (this.moveSpeed > 1) {
        window.$CCBIM.controller.moveSpeed /= this.moveSpeed;
        window.$CCBIM.render.moveSpeed = window.$CCBIM.controller.moveSpeed;
        this.moveSpeed--;
      }
    }
  }
});

/***/ }),
/* 519 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_Model_setting_css__ = __webpack_require__(629);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_Model_setting_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__style_Model_setting_css__);




/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'setting',
  data: function data() {
    return {
      stripWidthAll: 240,

      stripWidth: 0,
      stripWidthOld: 0,

      isStripDown: false,

      checkedBorder: false,
      checkedBorderOld: false,

      showBorder: '',

      checkedShadow: false,
      checkedShadowOld: false,

      showShadow: '',

      checkedTexture: true,

      checkedColor: false,

      saveRadioEffect: 2,
      saveRadioEffectOld: 2,

      checkedSystemDefault: true,

      checkedSoftwarePower: false,

      saveRadioAntialias: 1,
      saveRadioAntialiasOld: 1,

      showSettingBox: {
        show: false
      }
    };
  },
  mounted: function mounted() {
    window.$CCBIM.render.showSettingBox = this.showSettingBox;
    this.localRadioEffect();
  },

  methods: {
    stripDown: function stripDown(event) {
      this.isStripDown = true;
      this.stripWidth = event.offsetX;
      window.$CCBIM.render.propertyPer = this.stripWidth / this.stripWidthAll;
    },
    stripMove: function stripMove(event) {
      if (this.isStripDown) {
        this.stripWidth = event.offsetX;
      }
    },
    stripUp: function stripUp() {
      this.isStripDown = false;
      window.$CCBIM.render.propertyPer = this.stripWidth / this.stripWidthAll;
    },
    switchShadow: function switchShadow(val) {
      if (val) {
        this.showShadow = '';
        window.$CCBIM.projectManager.setBottomShadow();
        this.checkedShadow = true;
      } else {
        this.showShadow = '';
        window.$CCBIM.projectManager.removeBottomShadow();
        this.checkedShadow = false;
      }
    },
    switchBorder: function switchBorder(val) {
      var _this = this;

      this.debounce(function () {
        if (val) {
          _this.showBorder = '';
          window.$CCBIM.projectManager.setEntLineMode();
          _this.checkedBorder = true;
        } else {
          _this.showBorder = '';
          window.$CCBIM.projectManager.removeEntLineMode();
          _this.checkedBorder = false;
        }
      }, 500)();
    },
    debounce: function debounce(fn, delay) {
      var timer = void 0;

      return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timer);

        timer = setTimeout(function () {
          fn.apply(context, args);
        }, delay);
      };
    },
    radioEffect: function radioEffect(val) {
      this.saveRadioEffect = parseInt(val);
      if (this.saveRadioEffect === 1) {
        this.checkedColor = true;
        this.checkedTexture = false;

        window.$CCBIM.projectManager.setEntColorMode();
      } else if (this.saveRadioEffect === 2) {
        this.checkedColor = false;
        this.checkedTexture = true;

        window.$CCBIM.projectManager.setEntMapMode();
      }
    },
    radioAntialias: function radioAntialias(val) {
      this.saveRadioAntialias = parseInt(val);
      if (this.saveRadioAntialias === 1) {
        this.checkedSystemDefault = true;
        this.checkedSoftwarePower = false;
      } else if (this.saveRadioAntialias === 2) {
        this.checkedSystemDefault = false;
        this.checkedSoftwarePower = true;
      }
    },
    localRadioEffect: function localRadioEffect() {
      if (JSON.parse(localStorage.getItem('stripWidth'))) {
        var width = JSON.parse(localStorage.getItem('stripWidth'));
        this.stripWidth = width;
        this.stripWidthOld = width;
      } else {
        this.stripWidth = this.stripWidthAll;
        this.stripWidthOld = this.stripWidthAll;
      }
      window.$CCBIM.render.propertyPer = this.stripWidth / this.stripWidthAll;

      if (JSON.parse(localStorage.getItem('switchBorder'))) {
        this.checkedBorder = true;
        this.checkedBorderOld = true;
        this.showBorder = '';
      } else {
        this.checkedBorder = false;
        this.checkedBorderOld = false;
        this.showBorder = '';
      }

      if (JSON.parse(localStorage.getItem('switchShadow'))) {
        this.checkedShadow = true;
        this.checkedShadowOld = true;
        this.showShadow = '';
      } else {
        this.checkedShadow = false;
        this.checkedShadowOld = false;
        this.showShadow = '';
      }

      if (JSON.parse(localStorage.getItem('switchTexture')) === 1) {
        this.checkedColor = true;
        this.checkedTexture = false;
        this.saveRadioEffect = 1;
        this.saveRadioEffectOld = 1;
      } else if (JSON.parse(localStorage.getItem('switchTexture')) === 2) {
        this.checkedColor = false;
        this.checkedTexture = true;
        this.saveRadioEffect = 2;
        this.saveRadioEffectOld = 2;
      }

      if (JSON.parse(localStorage.getItem('switchAntialias')) === 1) {
        this.checkedSystemDefault = true;
        this.checkedSoftwarePower = false;
        this.saveRadioAntialias = 1;
        this.saveRadioAntialiasOld = 1;
      } else if (JSON.parse(localStorage.getItem('switchAntialias')) === 2) {
        this.checkedSystemDefault = false;
        this.checkedSoftwarePower = true;
        this.saveRadioAntialias = 2;
        this.saveRadioAntialiasOld = 2;
      }
    },
    closeSetting: function closeSetting() {
      this.stripWidth = this.stripWidthOld;
      window.$CCBIM.render.propertyPer = this.stripWidth / this.stripWidthAll;
      this.switchBorder(this.checkedBorderOld);
      this.switchShadow(this.checkedShadowOld);
      this.radioEffect(this.saveRadioEffectOld);
      this.radioAntialias(this.saveRadioAntialiasOld);
      this.showSettingBox.show = false;
    },
    saveSetting: function saveSetting() {
      var antialiasChange = this.saveRadioAntialiasOld;
      window.$CCBIM.render.propertyPer = this.stripWidth / this.stripWidthAll;
      this.stripWidthOld = this.stripWidth;
      localStorage.setItem('stripWidth', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.stripWidth));
      this.saveRadioEffectOld = this.saveRadioEffect;
      localStorage.setItem('switchTexture', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.saveRadioEffect));
      this.saveRadioAntialiasOld = this.saveRadioAntialias;
      localStorage.setItem('switchAntialias', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.saveRadioAntialias));
      this.checkedShadowOld = this.checkedShadow;
      localStorage.setItem('switchShadow', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.checkedShadow));
      this.checkedBorderOld = this.checkedBorder;
      localStorage.setItem('switchBorder', __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.checkedBorder));
      this.showSettingBox.show = false;

      if (antialiasChange !== this.saveRadioAntialiasOld) {
        window.location.reload();
      }
    }
  }
});

/***/ }),
/* 520 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__);




/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'TreeItem',
  props: {
    data: { type: Object, required: true },
    allowTransition: { type: Boolean, default: true },
    onItemCheckedClick: {
      type: Function, default: function _default() {
        return false;
      }
    },
    onItemTextClick: {
      type: Function, default: function _default() {
        return false;
      }
    },
    klass: String
  },
  data: function data() {
    return {
      model: this.data,
      maxHeight: 0,
      height: 24
    };
  },

  watch: {
    data: function data(newValue) {
      this.model = newValue;
    },

    'model.opened': {
      handler: function handler(val, oldVal) {
        this.handleGroupMaxHeight();
      },
      deep: true
    }
  },
  computed: {
    isFolder: function isFolder() {
      return this.model.children && this.model.children.length;
    },
    classes: function classes() {
      return [{ 'tree-node': true }, { 'tree-open': this.model.opened }, { 'tree-closed': !this.model.opened }, { 'tree-leaf': !this.isFolder }, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({}, this.klass, !!this.klass)];
    },
    anchorClasses: function anchorClasses() {
      return [{ 'tree-anchor': true }, { 'tree-selected': this.model.selected }];
    },
    groupStyle: function groupStyle() {
      return {
        'position': this.model.opened ? '' : 'relative',
        'max-height': this.allowTransition ? this.maxHeight + 'px' : '',
        'transition-duration': this.allowTransition ? Math.ceil(this.model.children.length / 100) * 300 + 'ms' : '',
        'transition-property': this.allowTransition ? 'max-height' : '',
        'display': this.model.opened ? 'block' : 'none'
      };
    }
  },
  methods: {
    handleItemToggle: function handleItemToggle(e) {
      if (this.isFolder) {
        this.model.opened = !this.model.opened;
      }
    },
    handleGroupMaxHeight: function handleGroupMaxHeight() {
      if (this.allowTransition) {
        var length = 0;
        var childHeight = 0;
        if (this.model.opened) {
          length = this.$children.length;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(this.$children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var children = _step.value;

              childHeight += children.maxHeight;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
        this.maxHeight = length * this.height + childHeight;
        if (this.$parent.$options._componentTag === 'tree-item') {
          this.$parent.handleGroupMaxHeight();
        }
      }
    },
    handleItemClick: function handleItemClick(e) {
      this.model.selected = !this.model.selected;
      this.onItemCheckedClick(this, this.model, e);
    },
    itemTextClick: function itemTextClick(e) {
      this.onItemTextClick(this, this.model, e);
    }
  },
  mounted: function mounted() {
    this.handleGroupMaxHeight();
  }
});

/***/ }),
/* 521 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_Model_floorStrong_css__ = __webpack_require__(625);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_Model_floorStrong_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__style_Model_floorStrong_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tree_item_vue__ = __webpack_require__(638);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tree_item_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__tree_item_vue__);







/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'tree',
  components: {
    TreeItem: __WEBPACK_IMPORTED_MODULE_3__tree_item_vue___default.a
  },
  props: {
    data: { type: Array },
    allowTransition: { type: Boolean, default: true },
    klass: String
  },
  computed: {
    classes: function classes() {
      return [{ 'tree': true }, { 'tree-default': true }, { 'tree-checkbox-selection': true }, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({}, this.klass, !!this.klass)];
    },
    containerClasses: function containerClasses() {
      return [{ 'tree-container-ul': true }, { 'tree-children': true }];
    }
  },
  methods: {
    handleParentNodeOpen: function handleParentNodeOpen(node) {
      if (node.parent !== undefined) {
        node.parent.opened = true;
        this.handleParentNodeOpen(node.parent);
      }
    },
    handleRecursionNodeDom: function handleRecursionNodeDom(node, func) {
      if (func(node) !== false) {
        if (node.$children && node.$children.length > 0) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(node.$children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var childNode = _step.value;

              if (!childNode.disabled) {
                this.handleRecursionNodeDom(childNode, func);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
    },
    handleRecursionNodeChildren: function handleRecursionNodeChildren(node, func) {
      if (func(node) !== false) {
        if (node.children && node.children.length > 0) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(node.children), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var childNode = _step2.value;

              childNode.parent = node;
              this.handleRecursionNodeChildren(childNode, func);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }
    },
    handleBrotherNode: function handleBrotherNode(oriNode) {
      if (oriNode.$parent.model !== undefined) {
        oriNode.$parent.model.selected = true;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(oriNode.$parent.$children), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var childNode = _step3.value;

            if (!childNode.model.selected) {
              oriNode.$parent.model.selected = false;
            }
            this.handleBrotherNode(oriNode.$parent);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    },
    onItemCheckedClick: function onItemCheckedClick(oriNode, oriItem, e) {
      this.handleBatchSelectItems(oriItem);
      this.handleBrotherNode(oriNode);
      this.$emit('item-checked-click', oriItem);
    },
    onItemTextClick: function onItemTextClick(oriNode, oriItem, e) {
      this.$emit('item-text-click', oriItem, oriNode);
    },
    handleBatchSelectItems: function handleBatchSelectItems(oriItem) {
      this.handleRecursionNodeChildren(oriItem, function (node) {
        node.selected = oriItem.selected;
      });
    }
  }
});

/***/ }),
/* 522 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'fileUpload',
  data: function data() {
    return {
      showPopout: false,
      tipText: 'gantt'
    };
  },

  watch: {},
  methods: {
    decideShowGantt: function decideShowGantt() {
      var _this = this;

      if (this.$parent.showGantt) {
        this.$parent.showGantt = false;
        this.tipText = 'gantt';
      } else {
        var data = {
          'fileId': this.$parent.version
        };
        this.$ccbimAxios({
          method: 'post',
          url: 'http://116.62.247.182/front/progress/findmapp',
          data: this.$qs.stringify(data)
        }).then(function (res) {
          var data = res.data;

          console.log(data);

          if (data.result === '') {
            _this.showPopout = true;
          } else {
            _this.getProjectJson(data.result);
          }
        });
      }
    },
    setFileName: function setFileName() {
      this.$refs.fileName.innerHTML = this.$refs.pbimFileupload.value;
    },
    uploadProject: function uploadProject() {
      var _this2 = this;

      this.showPopout = false;
      var formData = new FormData();
      var fileData = this.$refs.pbimFileupload.files[0];
      if (fileData) {
        formData.append('file', fileData);
        formData.append('modelId', this.$parent.version);
        console.log(formData);
        this.$ccbimAxios({
          method: 'post',
          url: 'http://116.62.247.182/front/progress/imp',
          data: formData
        }).then(function (res) {
          var data = res.data;

          if (data.errorMsg) {
            _this2.errorMsg = data.errorMsg;
            alert(_this2.errorMsg);
          } else {
            _this2.getProjectJson(data.file.fileId);
          }
        });
      }
    },
    getProjectJson: function getProjectJson(fileId) {
      var _this3 = this;

      this.$ccbimAxios({
        method: 'get',
        url: 'http://116.62.247.182/front/progress/load?fileId=' + fileId
      }).then(function (res) {
        var data = res.data;

        if (data.errorMsg) {
          _this3.errorMsg = data.errorMsg;
        } else {
          console.log(data);
          _this3.$parent.ganttTreeData = data.treeData;
          _this3.$emit('getShowGantt', true);
          _this3.tipText = 'gantt';
        }
      });
    }
  }
});

/***/ }),
/* 523 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tool_tween__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_iconfont_js__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_iconfont_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__components_iconfont_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_normalize_css__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_normalize_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_normalize_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__style_Model_model_css__ = __webpack_require__(626);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__style_Model_model_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__style_Model_model_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__style_Model_modelMap_css__ = __webpack_require__(627);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__style_Model_modelMap_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__style_Model_modelMap_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__classlib_Detector_js__ = __webpack_require__(498);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__classlib_Devices_js__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_setting_index__ = __webpack_require__(472);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_roam_index__ = __webpack_require__(468);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__handle_js__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__setting_js__ = __webpack_require__(512);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__camera_js__ = __webpack_require__(496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__event_js__ = __webpack_require__(506);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__pointList_js__ = __webpack_require__(510);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__generalMiniMap_js__ = __webpack_require__(508);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__controls_js__ = __webpack_require__(505);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__floorStrong_js__ = __webpack_require__(507);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__components_treeStrong_index__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__renderUpdate_js__ = __webpack_require__(511);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__viewBox_js__ = __webpack_require__(514);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__clipping_js__ = __webpack_require__(504);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__controls_ModelDisHeightControls_js__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__test_js__ = __webpack_require__(513);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__classlib_ProjectManager_js__ = __webpack_require__(501);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__classlib_SceneManager_js__ = __webpack_require__(502);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__classlib_FileLoadeContext_js__ = __webpack_require__(499);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__classlib_WebGLContext_js__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__classlib_FileIndex_js__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__classlib_FileLoader_js__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__classlib_ActionManager__ = __webpack_require__(497);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__flatBuffers_sceneGraph_BIMDataFBInterface_js__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__flatBuffers_sceneGraph_ComponentFBInterface_js__ = __webpack_require__(494);





































var animationObj = null;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'model',
  components: { settingModel: __WEBPACK_IMPORTED_MODULE_8__components_setting_index__["a" /* default */], roam: __WEBPACK_IMPORTED_MODULE_9__components_roam_index__["a" /* default */], treeStrong: __WEBPACK_IMPORTED_MODULE_18__components_treeStrong_index__["a" /* default */] },
  mixins: [__WEBPACK_IMPORTED_MODULE_10__handle_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_11__setting_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_13__event_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_12__camera_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_16__controls_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_17__floorStrong_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_19__renderUpdate_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_23__test_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_20__viewBox_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_21__clipping_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_22__controls_ModelDisHeightControls_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_14__pointList_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_15__generalMiniMap_js__["a" /* default */]],
  data: function data() {
    return {
      isRenderFinish: false,

      isIe: false,

      isWebGL: true,

      tweenTimer: [],

      clockDelta: null,

      rect: {},

      isPhone: false,

      basicProgress: 0,

      entInfoProgress: 0,

      errorMsg: '',

      ccbimAxiosAll: [],

      cloudUrl: null,

      selectedGEO: {},

      worldCoordinate: [],

      showBComInfo: false
    };
  },

  props: {
    width: {
      type: Number,
      default: 0
    },

    version: '',

    urlIp: ''
  },
  watch: {
    width: function width(widthValue) {
      this.onResize(widthValue);
    }
  },
  mounted: function mounted() {
    var _this = this;

    window.onresize = function () {
      return _this.onResize();
    };

    window.$CCBIM.render.$ccbimRun = this.run;

    window.$CCBIM.render.onBeforeUpdate = this.onBeforeUpdate;
    window.$CCBIM.render.onAfterUpdate = this.onAfterUpdate;
    window.$CCBIM.render.haveNeedUpdate = this.haveNeedUpdate;
    window.$CCBIM.render.setNeedUpdate = this.setNeedUpdate;

    window.$CCBIM.render.GetNormalGeoCount = this.GetNormalGeoCount;
    window.$CCBIM.render.sortRefGeometr = this.sortRefGeometr;

    window.$CCBIM.render.GetIsPhone = this.GetIsPhone;
    window.$CCBIM.render.addGeometry = this.addGeometry;
    window.$CCBIM.render.isDebug = this.isDebug;

    window.$CCBIM.render.$updateBComInfo = this.updateBComInfo;

    window.$CCBIM.render.$setShowSettingBox = this.setShowSettingBox;

    window.$CCBIM.render.setModelEdge = this.setModelEdge;

    window.$CCBIM.render.$setViewInfoImg = this.setViewInfoImg;

    window.$CCBIM.render.$setModelViewInfo = this.setModelViewInfo;

    window.$CCBIM.render.$setCameraView = this.setCameraView;

    window.$CCBIM.render.$setSelectGeometry = this.setSelectGeometry;

    window.$CCBIM.render.$setEntVisibleFromFloorComtype = this.setEntVisibleFromFloorComtype;

    window.$CCBIM.render.$delModelMark = this.delModelMark;

    window.$CCBIM.render.$bounceModelMark = this.bounceModelMark;

    window.$CCBIM.render.$closeWalk = this.closeWalk;

    window.$CCBIM.render.$launchFullscreen = this.launchFullscreen;

    window.$CCBIM.render.$exitFullscreen = this.exitFullscreen;

    window.$CCBIM.render.$disposeRender = this.disposeRender;

    window.$CCBIM.render.$addModelMarkRequest = this.addModelMarkRequest;

    window.$CCBIM.render.$modelMarkListRequest = this.modelMarkListRequest;

    window.$CCBIM.render.$removeModelMarkRequest = this.removeModelMarkRequest;
  },

  methods: {
    run: function run() {
      var _this2 = this;

      var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var detector = new __WEBPACK_IMPORTED_MODULE_6__classlib_Detector_js__["a" /* default */]();
      window.$CCBIM.device = new __WEBPACK_IMPORTED_MODULE_7__classlib_Devices_js__["a" /* default */]();

      this.isIe = detector.isIe();
      if (this.isIe) {
        return false;
      }

      this.isPhone = window.$CCBIM.device.getIsPhone();

      if (detector.webgl) {
        this.isWebGL = true;

        window.$CCBIM.device.setDevicesWidthHeight(this.$refs.model);
        var rect = window.$CCBIM.device.getDevicesWidthHeight();
        if (option.width) {
          rect.w = option.width;
          rect.wHalf = rect.w / 2;
        }
        if (option.height) {
          rect.h = option.height;
          rect.hHalf = rect.h / 2;
        }
        option.width = rect.w;
        option.height = rect.h;
        option.dom = this.$refs.model;
        if (JSON.parse(localStorage.getItem('switchAntialias')) === 2) {
          option.antialias = false;
        }
        if (window.$CCBIM.device.is360ByUserActivationProperty()) {
          option.useOffScreenCanvas = false;
        }

        window.$CCBIM.webglContext = new __WEBPACK_IMPORTED_MODULE_27__classlib_WebGLContext_js__["a" /* default */]();
        window.$CCBIM.webglContext.initialize(option);
        this.rect = window.$CCBIM.device.getDevicesWidthHeight();

        var version = {};
        version['versionId'] = this.version;
        var CancelToken = this.$ccbimAxios.CancelToken;
        var source = CancelToken.source();
        this.ccbimAxiosAll.push(source);
        this.$ccbimAxios({
          method: 'post',
          url: this.urlIp + '/front/bimfile/modelConstructInfoCors.htm',
          cancelToken: source.token,
          data: this.$qs.stringify(version)
        }).then(function (res) {
          var data = res.data;

          if (data.success) {
            if (data.result.jsons.length === 0) {
              _this2.errorMsg = '';
              return;
            }

            var textureType = _this2.ccbimTextureType;
            if (JSON.parse(localStorage.getItem('switchTexture')) === 1) {
              textureType = 1;
            }

            var fileLoaderContext = new __WEBPACK_IMPORTED_MODULE_26__classlib_FileLoadeContext_js__["a" /* default */](textureType, _this2.isSimColorMode, _this2.simColorModeColor);

            var cloudURL = void 0;
            var headFile = void 0;
            var fileLoader = new __WEBPACK_IMPORTED_MODULE_29__classlib_FileLoader_js__["a" /* default */](_this2.$ccbimAxios);
            for (var i = 0, len = data.result.jsons.length; i < len; i++) {
              var result = data.result.jsons[i];
              if (!cloudURL) {
                cloudURL = result.URI.split('.com/')[0] + '.com/';
              }
              var fileIndex = new __WEBPACK_IMPORTED_MODULE_28__classlib_FileIndex_js__["a" /* default */]();
              fileIndex.setType(result.resultType);
              fileIndex.setURL(result.URI);
              fileIndex.setFileSize(result.FileSize);
              fileLoader.addFileIndex(fileIndex);
              var fileType = fileIndex.getType();
              if (fileType === 9 || fileType === 13) {
                headFile = fileIndex;
              }
            }
            fileLoader.setCloudURL(cloudURL);

            if (headFile) {
              if (headFile.getType() === 9) {
                var bimOldInterface = new __WEBPACK_IMPORTED_MODULE_31__flatBuffers_sceneGraph_BIMDataFBInterface_js__["a" /* default */](fileLoader, textureType, _this2.isSimColorMode, _this2.simColorModeColor);
                var componentsOldInterface = new __WEBPACK_IMPORTED_MODULE_32__flatBuffers_sceneGraph_ComponentFBInterface_js__["a" /* default */]();
                fileLoaderContext.initialize({
                  fileLoader: fileLoader,
                  bufferDataInterface: bimOldInterface,
                  sceneDataInterface: bimOldInterface,
                  componentsDataInterface: componentsOldInterface
                });
              } else if (headFile.getType() === 13) {
                fileLoaderContext.initialize({
                  fileLoader: fileLoader
                });
              }

              console.log('Head protocol type.' + headFile.getType().toString());
            } else {
              _this2.errorMsg = '';
              return;
            }

            window.$CCBIM.projectManager = new __WEBPACK_IMPORTED_MODULE_24__classlib_ProjectManager_js__["a" /* default */]();
            window.$CCBIM.projectManager.initialize({
              fileLoadContext: fileLoaderContext
            });

            var switchShadow = false;
            if (JSON.parse(localStorage.getItem('switchShadow'))) {
              switchShadow = true;
            }
            var switchBorder = _this2.isModelEdge;
            if (JSON.parse(localStorage.getItem('switchBorder'))) {
              switchBorder = true;
            }

            window.$CCBIM.sceneManager = new __WEBPACK_IMPORTED_MODULE_25__classlib_SceneManager_js__["a" /* default */](_this2.modelEdgeColor);
            window.$CCBIM.sceneManager.initialize({
              fileLoadContext: fileLoaderContext,
              webglContext: window.$CCBIM.webglContext,
              switchBottomShadow: switchShadow,
              switchGeometryWire: switchBorder
            });

            var sceneFileLoader = window.$CCBIM.sceneManager.getFileLoadContext().getFileLoader();
            sceneFileLoader.loadFile(headFile).then(function (res) {
              window.$CCBIM.sceneManager.loadHead(res.data, function (progress) {
                _this2.basicProgress = progress;
              }).then(function () {
                var sceneData = window.$CCBIM.sceneManager.getSceneData();

                _this2.view = {
                  position: sceneData.viewPosition,
                  target: sceneData.viewTarget,
                  up: sceneData.viewUp
                };

                _this2.setTrackballControls();

                _this2.setCameraUp(_this2.view.up);
                _this2.setCameraPosition(_this2.view.position);
                var bndBoxMax = sceneData.bndBoxMax;
                var bndBoxMin = sceneData.bndBoxMin;

                var bndBoxCenter = new window.$CCBIM.WebGL.Vector3((bndBoxMax[0] + bndBoxMin[0]) / 2, (bndBoxMax[1] + bndBoxMin[1]) / 2, (bndBoxMax[2] + bndBoxMin[2]) / 2);
                window.$CCBIM.webglContext.camera.lookAt(bndBoxCenter);

                window.$CCBIM.webglContext.renderer.render(window.$CCBIM.webglContext.scene, window.$CCBIM.webglContext.camera);
                setTimeout(function () {
                  _this2.dispatchLoading();
                });

                _this2.renderFinish();

                if (_this2.isDebug) {
                  _this2.initTest();
                }
              });
              window.$CCBIM.projectManager.loadProject(res.data);
            });
          } else {
            _this2.errorMsg = data.errorMsg;
          }
        }).catch(function (thrown) {
          if (_this2.$ccbimAxios.isCancel(thrown)) {
            console.log('Request canceled', thrown.message);
          } else {}
        });
        window.$CCBIM.actionManager = new __WEBPACK_IMPORTED_MODULE_30__classlib_ActionManager__["a" /* default */](this.$refs.model);
        this.animate();
      } else {
        this.isWebGL = false;
      }
    },
    renderFinish: function renderFinish() {
      var _this3 = this;

      this.initBox();
      this.isRenderFinish = true;

      window.$CCBIM.render.rendererType = '3D';

      this.setHandle();
      this.handleList = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this.handle3DList), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this.handleList));

      if (this.isHandle) {
        this.showHandle = this.isHandle;
      } else {
        this.showHandle = false;
      }

      var loader = new window.$CCBIM.WebGL.FontLoader();
      loader.load(this.webGlFontUrl, function (font) {
        window.$CCBIM.render.webGlFont = font;
        _this3.isUseWebGlFont = true;
      });
    },
    dispatchLoading: function dispatchLoading() {
      var _this4 = this;

      window.$CCBIM.sceneManager.realTimeLoading(function (progress) {
        _this4.entInfoProgress = progress;
      }, function () {
        if (_this4.floorTree.length === 0) {
          _this4.initFloorTree();

          _this4.$emit('render');
        }

        for (var i = 0; i < _this4.modelMark.length; i++) {
          _this4.addModelMark(_this4.modelMark[i]);
        }

        _this4.setStagesVisible();
      });
    },
    animate: function animate() {
      if (this.isNeedUpdate) {
        if (window.$CCBIM.sceneManager && !window.$CCBIM.sceneManager.getNeedUpdate()) {
          animationObj = requestAnimationFrame(this.animate);
          return;
        }
      }

      animationObj = requestAnimationFrame(this.animate);

      if (this.startTween) {
        this.tweenTimer.push(setInterval(function () {
          if (window.$CCBIM.controller) {
            window.$CCBIM.controller.update();
          }
          __WEBPACK_IMPORTED_MODULE_1__tool_tween__["a" /* default */].update();
        }, 0));
      } else {
        if (window.$CCBIM.controller) {
          window.$CCBIM.controller.update();
        }
        __WEBPACK_IMPORTED_MODULE_1__tool_tween__["a" /* default */].update();
      }

      var delta = 0;
      if (this.clockDelta === null) {
        this.clockDelta = new window.$CCBIM.WebGL.Clock(true);
      } else {
        delta = this.clockDelta.getDelta();
      }

      if (window.$CCBIM.controller) {
        window.$CCBIM.controller.isAutoRotation = this.isAutoRotation;
      }

      if (window.$CCBIM.sceneManager) {
        window.$CCBIM.sceneManager.fitCameraFtustum();
      }

      if (window.$CCBIM.composer) {
        window.$CCBIM.composer.render();
      } else {
        window.$CCBIM.webglContext.renderer.render(window.$CCBIM.webglContext.scene, window.$CCBIM.webglContext.camera);
      }

      if (window.$CCBIM.viewBox) {
        window.$CCBIM.viewBox.rendererBox.render(window.$CCBIM.viewBox.sceneBox, window.$CCBIM.viewBox.cameraBox);
        this.setCameraBox();
        window.$CCBIM.viewBox.controllerBox.update();
      }

      delta = this.clockDelta.getDelta();
      if (delta > 0.1) {
        console.log(delta);
        window.$CCBIM.isNeedHide = true;
      } else {
        window.$CCBIM.isNeedHide = false;
      }

      if (this.isDebug && this.stats) {
        this.stats.update(delta);
        this.GUI.updateDisplay();
      }

      if (this.isRenderFinish) {
        this.computePointPosition();
      }

      if (this.isMeasureHeight) {
        this.computeLabelPosition();
      }

      if (this.showMap) {
        this.getCamera2dPosition();
      }
    },
    disposeRender: function disposeRender() {
      this.isRenderFinish = false;
      this.basicProgress = 0;
      this.entInfoProgress = 0;
      if (window.$CCBIM.controller) {
        window.$CCBIM.controller.dispose();
      }

      window.cancelAnimationFrame(animationObj);

      if (window.$CCBIM.webglContext) {
        if (this.$refs.model && this.$refs.model.children.length > 0) {
          this.$refs.model.removeChild(window.$CCBIM.webglContext.renderer.domElement);
        }
        window.$CCBIM.webglContext.renderer.dispose();
      }
      if (window.$CCBIM.viewBox) {
        if (this.$refs.viewBox) {
          this.$refs.viewBox.removeChild(window.$CCBIM.viewBox.rendererBox.domElement);
        }
        window.$CCBIM.viewBox = null;
      }
      this.clearData();
    },
    clearData: function clearData() {
      if (window.$CCBIM.webglContext) {
        var sceneNodeArray = window.$CCBIM.sceneManager.getSceneNodeArray();
        for (var i = 0, il = sceneNodeArray.length; i < il; i++) {
          sceneNodeArray[i].clearData();
        }
        window.$CCBIM.sceneManager.clearData();
        window.$CCBIM.webglContext.scene.removeAll();
      }
      this.floorTree = [];

      this.pointSaveListMap.clear();
      this.pointListMap.clear();
      this.pointList = [];
    },
    onResize: function onResize(widthValue) {
      var _this5 = this;

      if (window.$CCBIM.sceneManager) {
        window.$CCBIM.sceneManager.setNeedUpdate(true);
      }
      this.$nextTick(function () {
        window.$CCBIM.device.setDevicesWidthHeight(_this5.$refs.model);
        if (widthValue) {
          window.$CCBIM.device.setRenderWidth(widthValue);
        }
        window.$CCBIM.device.resize();
      });
    }
  },
  destroyed: function destroyed() {
    console.log('');
    this.disposeRender();
  }
});

/***/ }),
/* 524 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_normalize_css__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_normalize_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__style_normalize_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_panorama_css__ = __webpack_require__(632);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_panorama_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_panorama_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__loadPanoramaFile_js__ = __webpack_require__(515);







var panoramaScene = {
  camera: null,
  scene: null,
  scene2: null,
  renderer: null,
  raycaster: null,

  raycasterTarget: {
    x: 0,
    y: 0
  },

  jumpHotArray: [],

  pageTimer: {},

  isUserInteracting: false,

  initX: 0,
  initY: 0,

  scaleStart: [],

  onMouseDownMouseX: 0,

  onMouseDownMouseY: 0,
  lon: 0,
  onMouseDownLon: 0,
  lat: 0,
  onMouseDownLat: 0,
  phi: 0,
  theta: 0,
  rect: null,

  panoramaMaterialMap: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a(),

  jumpHotMaterialMap: new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a()
};
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'panorama',
  mixins: [__WEBPACK_IMPORTED_MODULE_4__loadPanoramaFile_js__["a" /* default */]],
  data: function data() {
    return {
      box: [],

      panoramaImg: [],

      panorama: {},

      jumpHot: [],

      panoramaId: '',

      isLoading: true,

      showMenuList: true,
      menuShow: true,
      pointShow: true,
      menuHover: false,
      pointHover: false,

      isPhone: false,

      isNew: false
    };
  },

  props: {},
  watch: {
    box: {
      handler: function handler(status) {
        this.box = status;
      },

      deep: true
    },
    panoramaImg: {
      handler: function handler(status) {
        var _this = this;

        this.panoramaImg = status;
        this.removePoint();
        this.addSkyBox().then(function () {
          for (var i = 0; i < _this.jumpHot.length; i++) {
            _this.addPoint(i);
          }
          _this.isLoading = false;
        });
      },

      deep: true
    }
  },
  mounted: function mounted() {
    window.$CCBIM.render.$panoramaRun = this.panoramaConstructInfo;

    this.setUserAgent();
    this.setWidth();
  },

  methods: {
    setCamera: function setCamera() {
      panoramaScene.camera = new window.$CCBIM.WebGL.PerspectiveCamera(75, panoramaScene.rect.w / panoramaScene.rect.h, 1, 50000);
      panoramaScene.camera.target = new window.$CCBIM.WebGL.Vector3(0, 0, 0);
      panoramaScene.camera.lookAt(panoramaScene.camera.target);
    },
    setCameraTarget: function setCameraTarget(array) {
      if (array) {
        var oldTargetXZVer = new window.$CCBIM.WebGL.Vector3(1, 0, 0);
        var newTargetXZVer = new window.$CCBIM.WebGL.Vector3(array[0], 0, array[1]);
        var xRotAngle = newTargetXZVer.angleTo(oldTargetXZVer) / Math.PI * 180;
        newTargetXZVer.cross(oldTargetXZVer);
        if (newTargetXZVer.y > 0) {
          panoramaScene.lon = -xRotAngle;
        } else {
          panoramaScene.lon = xRotAngle;
        }
        panoramaScene.onMouseDownLon = panoramaScene.lon;
        if (Math.abs(array[2]) > 2500) {
          var oldTargetYZVer = new window.$CCBIM.WebGL.Vector3(0, 1, 0);
          var newTargetYZVer = new window.$CCBIM.WebGL.Vector3(0, array[2], array[1]);
          var yRotAngle = newTargetYZVer.angleTo(oldTargetYZVer) / Math.PI * 180;
          newTargetYZVer.cross(oldTargetYZVer);
          if (newTargetYZVer.x < 0) {
            if (array[2] === 3000) {
              panoramaScene.lat = 360 - -yRotAngle;
            } else {
              panoramaScene.lat = -yRotAngle;
            }
          } else {
            panoramaScene.lat = yRotAngle;
          }
          panoramaScene.onMouseDownLat = panoramaScene.lat;
        }
      }
      this.cameraMove();
    },
    panoramaInit: function panoramaInit() {
      panoramaScene.renderer = new window.$CCBIM.WebGL.WebGLRenderer();
      panoramaScene.renderer.autoClear = false;
      panoramaScene.renderer.setPixelRatio(window.devicePixelRatio);
      panoramaScene.renderer.setSize(panoramaScene.rect.w, panoramaScene.rect.h);
      panoramaScene.renderer.setClearColor(0xffffff);
      this.$refs.panorama.appendChild(panoramaScene.renderer.domElement);

      panoramaScene.scene = new window.$CCBIM.WebGL.Scene();
      panoramaScene.scene2 = new window.$CCBIM.WebGL.Scene();
      panoramaScene.raycaster = new window.$CCBIM.WebGL.Raycaster();
      this.setCamera();

      var al = new window.$CCBIM.WebGL.AmbientLight(0xFFFFFFFF);
      al.name = 'AmbientLight';
      panoramaScene.scene.add(al);

      window.addEventListener('resize', this.onWindowResize, false);

      this.$refs.panorama.addEventListener('mousedown', this.onDocumentMouseDown, false);
      this.$refs.panorama.addEventListener('mousemove', this.onDocumentMouseMove, false);
      this.$refs.panorama.addEventListener('mouseup', this.onDocumentMouseUp, false);
      this.$refs.panorama.addEventListener('wheel', this.onDocumentMouseWheel, false);

      this.$refs.panorama.addEventListener('touchstart', this.onDocumentTouchStart, false);
      this.$refs.panorama.addEventListener('touchmove', this.onDocumentTouchMove, false);
      this.$refs.panorama.addEventListener('touchend', this.onDocumentTouchEnd, false);
      this.$emit('render');
    },
    addSkyBox: function addSkyBox() {
      var _this2 = this;

      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve) {
        var skyBox = null;
        if (panoramaScene.panoramaMaterialMap.has(_this2.panoramaId)) {
          panoramaScene.scene.children.forEach(function (item) {
            if (item.userData.skyBox) {
              panoramaScene.scene.remove(item);
            }
          });

          skyBox = new window.$CCBIM.WebGL.Mesh(new window.$CCBIM.WebGL.BoxGeometry(_this2.box[0], _this2.box[1], _this2.box[2]), panoramaScene.panoramaMaterialMap.get(_this2.panoramaId));
          skyBox.userData.skyBox = true;

          skyBox.geometry.scale(-1, 1, 1);
          panoramaScene.scene.add(skyBox);

          var skyTimer = setInterval(function () {
            var imgNum = 0;
            skyBox.material.forEach(function (item) {
              if (item.opacity < 1) {
                item.opacity = item.opacity + 0.1;
              } else {
                imgNum++;
                if (imgNum === 6) {
                  clearInterval(skyTimer);

                  resolve();
                }
              }
            });
          }, 100);
          _this2.animate();
        } else {
          var loader = new window.$CCBIM.WebGL.TextureLoader();
          __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.all(_this2.panoramaImg.map(function (val) {
            return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
              loader.load(val, function (texture) {
                resolve(new window.$CCBIM.WebGL.MeshBasicMaterial({
                  map: texture,
                  transparent: true,
                  opacity: 0.7
                }));
              });
            });
          })).then(function (materials) {
            panoramaScene.panoramaMaterialMap.set(_this2.panoramaId, materials);

            panoramaScene.scene.children.forEach(function (item) {
              if (item.userData.skyBox) {
                panoramaScene.scene.remove(item);
              }
            });

            skyBox = null;
            skyBox = new window.$CCBIM.WebGL.Mesh(new window.$CCBIM.WebGL.BoxGeometry(_this2.box[0], _this2.box[1], _this2.box[2]), materials);
            skyBox.userData.skyBox = true;

            skyBox.geometry.scale(-1, 1, 1);
            panoramaScene.scene.add(skyBox);

            var skyTimer = setInterval(function () {
              var imgNum = 0;
              skyBox.material.forEach(function (item) {
                if (item.opacity < 1) {
                  item.opacity = item.opacity + 0.1;
                } else {
                  imgNum++;
                  if (imgNum === 6) {
                    clearInterval(skyTimer);

                    resolve();
                  }
                }
              });
            }, 100);
            _this2.animate();
          });
        }
      });
    },
    addPoint: function addPoint(index) {
      var _this3 = this;

      var pointGeometry = new window.$CCBIM.WebGL.PlaneGeometry(170, 170);
      var materialMap = '';
      if (panoramaScene.jumpHotMaterialMap.get(this.jumpHot[index].img[0])) {
        materialMap = panoramaScene.jumpHotMaterialMap.get(this.jumpHot[index].img[0]);
      } else {
        panoramaScene.jumpHotMaterialMap.set(this.jumpHot[index].img[0], new window.$CCBIM.WebGL.TextureLoader().load(this.jumpHot[index].img[0]));
        materialMap = new window.$CCBIM.WebGL.TextureLoader().load(this.jumpHot[index].img[0]);
      }
      var pointMaterial = new window.$CCBIM.WebGL.MeshBasicMaterial({
        map: materialMap,
        transparent: true,
        opacity: 0.7
      });
      var point = new window.$CCBIM.WebGL.Mesh(pointGeometry, pointMaterial);

      point.userData.target = this.jumpHot[index].target;
      point.position.set(-this.jumpHot[index].position[0], this.jumpHot[index].position[2], this.jumpHot[index].position[1]);
      panoramaScene.scene2.add(point);

      var pointGeometryText = new window.$CCBIM.WebGL.PlaneGeometry(300, 100);
      var materialMapText = '';
      if (panoramaScene.jumpHotMaterialMap.get(this.jumpHot[index].targetPic)) {
        materialMapText = panoramaScene.jumpHotMaterialMap.get(this.jumpHot[index].targetPic);
      } else {
        panoramaScene.jumpHotMaterialMap.set(this.jumpHot[index].targetPic, new window.$CCBIM.WebGL.TextureLoader().load(this.jumpHot[index].targetPic));
        materialMapText = new window.$CCBIM.WebGL.TextureLoader().load(this.jumpHot[index].targetPic);
      }
      var pointMaterialText = new window.$CCBIM.WebGL.MeshLambertMaterial({
        map: materialMapText,
        transparent: true,
        needsUpdate: true
      });
      var labelText = new window.$CCBIM.WebGL.Mesh(pointGeometryText, pointMaterialText);
      labelText.position.set(0, -160, 0);
      point.add(labelText);

      var num = 0;
      var materialMapInterval = '';
      panoramaScene.pageTimer['timer' + index] = setInterval(function () {
        if (num < _this3.jumpHot[index].img.length) {
          if (panoramaScene.jumpHotMaterialMap.get(_this3.jumpHot[index].img[num])) {
            materialMapInterval = panoramaScene.jumpHotMaterialMap.get(_this3.jumpHot[index].img[num]);
          } else {
            panoramaScene.jumpHotMaterialMap.set(_this3.jumpHot[index].img[num], new window.$CCBIM.WebGL.TextureLoader().load(_this3.jumpHot[index].img[num]));
            materialMapInterval = new window.$CCBIM.WebGL.TextureLoader().load(_this3.jumpHot[index].img[num]);
          }
          point.material.map = materialMapInterval;
          num++;
        } else {
          num = 0;
        }
      }, 150);

      panoramaScene.jumpHotArray.push(point);
    },
    removePoint: function removePoint() {
      for (var each in panoramaScene.pageTimer) {
        if (panoramaScene.pageTimer.hasOwnProperty(each)) {
          clearInterval(panoramaScene.pageTimer[each]);
        }
      }

      panoramaScene.jumpHotArray.forEach(function (item) {
        panoramaScene.scene2.remove(item);
      });
      panoramaScene.jumpHotArray = [];
    },
    pointLookToCamera: function pointLookToCamera() {
      for (var i = 0; i < panoramaScene.scene2.children.length; i++) {
        panoramaScene.scene2.children[i].rotation.x = panoramaScene.camera.rotation.x;
        panoramaScene.scene2.children[i].rotation.y = panoramaScene.camera.rotation.y;
        panoramaScene.scene2.children[i].rotation.z = panoramaScene.camera.rotation.z;
      }
    },
    onWindowResize: function onWindowResize() {
      var _this4 = this;

      this.$nextTick(function () {
        _this4.setWidth();
        panoramaScene.camera.aspect = panoramaScene.rect.w / panoramaScene.rect.h;
        panoramaScene.camera.updateProjectionMatrix();
        panoramaScene.renderer.setSize(panoramaScene.rect.w, panoramaScene.rect.h);
      });
    },
    onDocumentMouseDown: function onDocumentMouseDown(event) {
      var _this5 = this;

      event.preventDefault();
      event.stopPropagation();
      panoramaScene.isUserInteracting = true;
      panoramaScene.onMouseDownMouseX = event.offsetX;
      panoramaScene.onMouseDownMouseY = event.offsetY;
      panoramaScene.onMouseDownLon = panoramaScene.lon;
      panoramaScene.onMouseDownLat = panoramaScene.lat;

      panoramaScene.raycasterTarget.x = event.offsetX / panoramaScene.rect.w * 2 - 1;
      panoramaScene.raycasterTarget.y = -(event.offsetY / panoramaScene.rect.h) * 2 + 1;

      panoramaScene.raycaster.setFromCamera(panoramaScene.raycasterTarget, panoramaScene.camera);
      var intersects = panoramaScene.raycaster.intersectObjects(panoramaScene.jumpHotArray);
      if (intersects.length > 0) {
        this.panorama.panoramaArray.forEach(function (item) {
          item.current = false;
          if (item.id === intersects[0].object.userData.target) {
            item.current = true;
            _this5.isLoading = true;
            _this5.jumpHot = item.jumpHot;
            _this5.panoramaImg = item.panoramaImg;
            _this5.panoramaId = item.id;
            _this5.setCameraTarget(item.cameraTarget);
          }
        });
      }
    },
    onDocumentTouchStart: function onDocumentTouchStart(event) {
      panoramaScene.isUserInteracting = true;
      panoramaScene.onMouseDownMouseX = event.targetTouches[0].pageX;
      panoramaScene.onMouseDownMouseY = event.targetTouches[0].pageY;
      panoramaScene.onMouseDownLon = panoramaScene.lon;
      panoramaScene.onMouseDownLat = panoramaScene.lat;

      panoramaScene.initX = event.target.offsetLeft;
      panoramaScene.initY = event.target.offsetTop;

      if (event.touches.length >= 2) {
        panoramaScene.scaleStart = event.touches;
      }
    },
    onDocumentMouseMove: function onDocumentMouseMove(event) {
      event.preventDefault();
      event.stopPropagation();
      if (panoramaScene.isUserInteracting === true) {
        panoramaScene.lon = (panoramaScene.onMouseDownMouseX - event.offsetX) * 0.1 + panoramaScene.onMouseDownLon;
        panoramaScene.lat = (event.offsetY - panoramaScene.onMouseDownMouseY) * 0.1 + panoramaScene.onMouseDownLat;

        this.cameraMove();
      }

      panoramaScene.raycasterTarget.x = event.offsetX / panoramaScene.rect.w * 2 - 1;
      panoramaScene.raycasterTarget.y = -(event.offsetY / panoramaScene.rect.h) * 2 + 1;

      panoramaScene.raycaster.setFromCamera(panoramaScene.raycasterTarget, panoramaScene.camera);
      var intersects = panoramaScene.raycaster.intersectObjects(panoramaScene.jumpHotArray);
      if (intersects.length > 0) {
        panoramaScene.renderer.domElement.style.cursor = 'pointer';
      } else {
        panoramaScene.renderer.domElement.style.cursor = 'auto';
      }
    },
    onDocumentTouchMove: function onDocumentTouchMove(event) {
      event.preventDefault();
      event.stopPropagation();
      if (event.touches.length === 1 && panoramaScene.isUserInteracting) {
        panoramaScene.lon = (panoramaScene.onMouseDownMouseX - event.targetTouches[0].pageX) * 0.3 + panoramaScene.onMouseDownLon;
        panoramaScene.lat = (event.targetTouches[0].pageY - panoramaScene.onMouseDownMouseY) * 0.3 + panoramaScene.onMouseDownLat;

        this.cameraMove();
      }

      if (event.touches.length >= 2 && panoramaScene.isUserInteracting) {
        var now = event.touches;

        var scale = this.getDistance(now[0], now[1]) / this.getDistance(panoramaScene.scaleStart[0], panoramaScene.scaleStart[1]);
        event.scale = scale.toFixed(2);

        var fov = void 0;
        if (scale > 1) {
          fov = panoramaScene.camera.fov + -50 * 0.05;
        } else {
          fov = panoramaScene.camera.fov + 50 * 0.05;
        }
        panoramaScene.camera.fov = Math.max(45, Math.min(80, fov));
        panoramaScene.camera.updateProjectionMatrix();
      }
    },
    onDocumentMouseUp: function onDocumentMouseUp(event) {
      event.preventDefault();
      event.stopPropagation();
      panoramaScene.isUserInteracting = false;
    },
    onDocumentTouchEnd: function onDocumentTouchEnd() {
      panoramaScene.isUserInteracting = false;
    },
    onDocumentMouseWheel: function onDocumentMouseWheel(event) {
      event.preventDefault();
      event.stopPropagation();
      var fov = panoramaScene.camera.fov + event.deltaY * 0.05;
      panoramaScene.camera.fov = Math.max(45, Math.min(80, fov));
      panoramaScene.camera.updateProjectionMatrix();
    },
    cameraMove: function cameraMove() {

      panoramaScene.lat = Math.max(-85, Math.min(85, panoramaScene.lat));
      panoramaScene.phi = (90 - panoramaScene.lat) * (Math.PI / 180);
      panoramaScene.theta = panoramaScene.lon * (Math.PI / 180);

      panoramaScene.camera.target.x = Math.sin(panoramaScene.phi) * Math.cos(panoramaScene.theta);
      panoramaScene.camera.target.y = Math.cos(panoramaScene.phi);
      panoramaScene.camera.target.z = Math.sin(panoramaScene.phi) * Math.sin(panoramaScene.theta);
      panoramaScene.camera.lookAt(panoramaScene.camera.target);
    },
    menuClick: function menuClick(e) {
      var _this6 = this;

      this.panorama.panoramaArray.forEach(function (item) {
        item.current = false;
        if (item.id === e.id) {
          item.current = true;
          _this6.isLoading = true;
          _this6.jumpHot = item.jumpHot;
          _this6.panoramaImg = item.panoramaImg;
          _this6.panoramaId = item.id;
          _this6.setCameraTarget(item.cameraTarget);
        }
      });
    },
    showHiddenPoint: function showHiddenPoint() {
      panoramaScene.jumpHotArray.forEach(function (item) {
        item.visible = !item.visible;
      });
      this.pointShow = !this.pointShow;
      this.pointHover = false;
    },
    showHiddenMenu: function showHiddenMenu() {
      this.showMenuList = !this.showMenuList;
      this.menuShow = this.showMenuList;
      this.menuHover = false;
    },
    animate: function animate() {
      requestAnimationFrame(this.animate);
      this.pointLookToCamera();
      panoramaScene.renderer.clear();
      panoramaScene.renderer.render(panoramaScene.scene, panoramaScene.camera);
      panoramaScene.renderer.clearDepth();
      panoramaScene.renderer.render(panoramaScene.scene2, panoramaScene.camera);
    },
    getDistance: function getDistance(p1, p2) {
      var x = p2.pageX - p1.pageX;
      var y = p2.pageY - p1.pageY;
      return Math.sqrt(x * x + y * y);
    },
    setWidth: function setWidth() {
      panoramaScene.rect = this.$refs.panorama.getBoundingClientRect();
      panoramaScene.rect.w = panoramaScene.rect.right - panoramaScene.rect.left;
      panoramaScene.rect.h = window.innerHeight - panoramaScene.rect.top;
    },
    setUserAgent: function setUserAgent() {
      var ua = navigator.userAgent.toLowerCase();
      if (ua.match('ipad|iphone|android')) {
        this.isPhone = true;
      } else {
        this.isPhone = false;
      }
    }
  }
});

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(531), __esModule: true };

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(534), __esModule: true };

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(542), __esModule: true };

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(544), __esModule: true };

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(47);
__webpack_require__(571);
module.exports = __webpack_require__(5).Array.from;


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(48);
__webpack_require__(47);
module.exports = __webpack_require__(569);


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(48);
__webpack_require__(47);
module.exports = __webpack_require__(570);


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(5);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(74);
__webpack_require__(47);
__webpack_require__(48);
__webpack_require__(573);
__webpack_require__(589);
__webpack_require__(588);
__webpack_require__(587);
module.exports = __webpack_require__(5).Map;


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(574);
module.exports = __webpack_require__(5).Math.sign;


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(575);
module.exports = Math.pow(2, -52);


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(576);
module.exports = __webpack_require__(5).Number.parseInt;


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(577);
module.exports = __webpack_require__(5).Object.assign;


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(578);
var $Object = __webpack_require__(5).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(579);
var $Object = __webpack_require__(5).Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(580);
var $Object = __webpack_require__(5).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(581);
module.exports = __webpack_require__(5).Object.keys;


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(582);
module.exports = __webpack_require__(5).Object.setPrototypeOf;


/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(74);
__webpack_require__(47);
__webpack_require__(48);
__webpack_require__(583);
__webpack_require__(590);
__webpack_require__(591);
module.exports = __webpack_require__(5).Promise;


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(74);
__webpack_require__(47);
__webpack_require__(48);
__webpack_require__(584);
__webpack_require__(594);
__webpack_require__(593);
__webpack_require__(592);
module.exports = __webpack_require__(5).Set;


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(585);
__webpack_require__(74);
__webpack_require__(595);
__webpack_require__(596);
module.exports = __webpack_require__(5).Symbol;


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(47);
__webpack_require__(48);
module.exports = __webpack_require__(127).f('iterator');


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(74);
__webpack_require__(48);
__webpack_require__(586);
__webpack_require__(598);
__webpack_require__(597);
module.exports = __webpack_require__(5).WeakMap;


/***/ }),
/* 548 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(56);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(58);
var toLength = __webpack_require__(84);
var toAbsoluteIndex = __webpack_require__(567);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16);
var isArray = __webpack_require__(202);
var SPECIES = __webpack_require__(13)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(551);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(83);
var getWeak = __webpack_require__(70).getWeak;
var anObject = __webpack_require__(23);
var isObject = __webpack_require__(16);
var anInstance = __webpack_require__(78);
var forOf = __webpack_require__(56);
var createArrayMethod = __webpack_require__(111);
var $has = __webpack_require__(41);
var validate = __webpack_require__(60);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(24);
var createDesc = __webpack_require__(72);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(71);
var gOPS = __webpack_require__(118);
var pIE = __webpack_require__(82);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 556 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(81);
var descriptor = __webpack_require__(72);
var setToStringTag = __webpack_require__(73);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(42)(IteratorPrototype, __webpack_require__(13)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 558 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var macrotask = __webpack_require__(216).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(68)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(58);
var gOPN = __webpack_require__(209).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(41);
var toObject = __webpack_require__(59);
var IE_PROTO = __webpack_require__(122)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(6);
var core = __webpack_require__(5);
var fails = __webpack_require__(40);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(10).parseInt;
var $trim = __webpack_require__(566).trim;
var ws = __webpack_require__(215);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(16);
var anObject = __webpack_require__(23);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(31)(Function.call, __webpack_require__(208).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(124);
var defined = __webpack_require__(80);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
var defined = __webpack_require__(80);
var fails = __webpack_require__(40);
var spaces = __webpack_require__(215);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(124);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(23);
var get = __webpack_require__(128);
module.exports = __webpack_require__(5).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(79);
var ITERATOR = __webpack_require__(13)('iterator');
var Iterators = __webpack_require__(57);
module.exports = __webpack_require__(5).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(31);
var $export = __webpack_require__(6);
var toObject = __webpack_require__(59);
var call = __webpack_require__(203);
var isArrayIter = __webpack_require__(201);
var toLength = __webpack_require__(84);
var createProperty = __webpack_require__(554);
var getIterFn = __webpack_require__(128);

$export($export.S + $export.F * !__webpack_require__(204)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(548);
var step = __webpack_require__(205);
var Iterators = __webpack_require__(57);
var toIObject = __webpack_require__(58);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(116)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(197);
var validate = __webpack_require__(60);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(112)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(6);

$export($export.S, 'Math', { sign: __webpack_require__(558) });


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(6);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
var $parseInt = __webpack_require__(563);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(6);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(206) });


/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(81) });


/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(20), 'Object', { defineProperties: __webpack_require__(207) });


/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(20), 'Object', { defineProperty: __webpack_require__(24).f });


/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(59);
var $keys = __webpack_require__(71);

__webpack_require__(562)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(6);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(564).set });


/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(69);
var global = __webpack_require__(10);
var ctx = __webpack_require__(31);
var classof = __webpack_require__(79);
var $export = __webpack_require__(6);
var isObject = __webpack_require__(16);
var aFunction = __webpack_require__(67);
var anInstance = __webpack_require__(78);
var forOf = __webpack_require__(56);
var speciesConstructor = __webpack_require__(214);
var task = __webpack_require__(216).set;
var microtask = __webpack_require__(559)();
var newPromiseCapabilityModule = __webpack_require__(117);
var perform = __webpack_require__(211);
var userAgent = __webpack_require__(568);
var promiseResolve = __webpack_require__(212);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(13)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(83)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(73)($Promise, PROMISE);
__webpack_require__(213)(PROMISE);
Wrapper = __webpack_require__(5)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(204)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(197);
var validate = __webpack_require__(60);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(112)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(10);
var has = __webpack_require__(41);
var DESCRIPTORS = __webpack_require__(20);
var $export = __webpack_require__(6);
var redefine = __webpack_require__(119);
var META = __webpack_require__(70).KEY;
var $fails = __webpack_require__(40);
var shared = __webpack_require__(123);
var setToStringTag = __webpack_require__(73);
var uid = __webpack_require__(85);
var wks = __webpack_require__(13);
var wksExt = __webpack_require__(127);
var wksDefine = __webpack_require__(126);
var enumKeys = __webpack_require__(555);
var isArray = __webpack_require__(202);
var anObject = __webpack_require__(23);
var isObject = __webpack_require__(16);
var toObject = __webpack_require__(59);
var toIObject = __webpack_require__(58);
var toPrimitive = __webpack_require__(125);
var createDesc = __webpack_require__(72);
var _create = __webpack_require__(81);
var gOPNExt = __webpack_require__(560);
var $GOPD = __webpack_require__(208);
var $GOPS = __webpack_require__(118);
var $DP = __webpack_require__(24);
var $keys = __webpack_require__(71);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(209).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(82).f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(69)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(42)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(10);
var each = __webpack_require__(111)(0);
var redefine = __webpack_require__(119);
var meta = __webpack_require__(70);
var assign = __webpack_require__(206);
var weak = __webpack_require__(553);
var isObject = __webpack_require__(16);
var validate = __webpack_require__(60);
var NATIVE_WEAK_MAP = __webpack_require__(60);
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(112)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(120)('Map');


/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(121)('Map');


/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(6);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(198)('Map') });


/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(6);
var core = __webpack_require__(5);
var global = __webpack_require__(10);
var speciesConstructor = __webpack_require__(214);
var promiseResolve = __webpack_require__(212);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(6);
var newPromiseCapability = __webpack_require__(117);
var perform = __webpack_require__(211);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(120)('Set');


/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(121)('Set');


/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(6);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(198)('Set') });


/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(126)('asyncIterator');


/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(126)('observable');


/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(120)('WeakMap');


/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(121)('WeakMap');


/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, "/**/\n.ccBIM .leftTreeModel {\n  position: absolute;\n  z-index: 1;\n  left: 10px;\n  top: 5%;\n  min-width: 265px;\n  border-radius: 4px;\n  background-color: rgba(0,0,0,0.6);\n  color: #fff;\n  border: 1px solid #fff;\n  height: 80%;\n  opacity: 1;\n  animation: treeLeftToRight 200ms ease-out;\n  -moz-animation: treeLeftToRight 200ms ease-out;\t/* Firefox */\n  -webkit-animation: treeLeftToRight 200ms ease-out;\t/* Safari  Chrome */\n  -o-animation: treeLeftToRight 200ms ease-out;\t/* Opera */\n}\n.ccBIM .showAllComType {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  background-color: #666;\n  color: #fff;\n  padding: 5px 10px;\n  font-size: 14px;\n  cursor: pointer;\n  top: 5%;\n}\n.ccBIM .leftTreeModel .header {\n  height: 39px;\n  border-bottom: 1px #ccc solid;\n  display: flex;\n  align-items: center;\n  padding: 0 10px;\n}\n.ccBIM .leftTreeModel .header .selectOn{\n  font-size: 14px;\n  padding-left: 10px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n}\n.ccBIM .leftTreeModel .header .selectOn .selectIcon{\n  width: 14px;\n  height: 14px;\n  color: #fff;\n  fill: currentColor;\n  margin-left: 14px;\n}\n.ccBIM .leftTreeModel .header .selectList {\n  position: absolute;\n  list-style: none;\n  background-color: #000;\n  z-index: 1;\n  font-size: 12px;\n  border: 1px solid #fff;\n  margin-top: 5px;\n}\n.ccBIM .leftTreeModel .header .selectList li{\n  cursor: pointer;\n  padding: 5px 60px 5px 10px;\n}\n.ccBIM .leftTreeModel .header .selectList li:hover{\n  background-color: #00b589;\n}\n.ccBIM .leftTreeModel .header .selectList li:last-child{\n  margin-bottom: 0;\n}\n.ccBIM .leftTreeModel .tree-close {\n  width: 20px;\n  height: 20px;\n  color: #fff;\n  fill: currentColor;\n  position: absolute;\n  right: 6px;\n  top: 10px;\n  cursor: pointer;\n}\n.ccBIM .leftTreeModel .searchBox {\n  border-bottom: 1px #ccc solid;\n  margin: 5px 10px;\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n.ccBIM .leftTreeModel .searchBox .txtSearch {\n  width: 100%;\n  background: transparent;\n  border: 0;\n  color: #fff;\n  height: 28px;\n  line-height: 28px;\n  outline: 0;\n  padding: 0 8px;\n}\n.ccBIM input::-webkit-input-placeholder{\n  color: #fff;\n}\n.ccBIM input::-moz-placeholder{   /* Mozilla Firefox 19+ */\n  color: #fff;\n}\n.ccBIM input:-moz-placeholder{    /* Mozilla Firefox 4 to 18 */\n  color: #fff;\n}\n.ccBIM input:-ms-input-placeholder{  /* Internet Explorer 10-11 */\n  color: #fff;\n}\n.ccBIM .leftTreeModel .tree-search {\n  width: 18px;\n  height: 18px;\n  color: #fff;\n  fill: currentColor;\n  cursor: pointer;\n}\n@keyframes treeLeftToRight\n{\n  from {left: -265px; opacity: 0;}\n  to {left: 10px; opacity: 1;}\n}\n@-moz-keyframes treeLeftToRight /* Firefox */\n{\n  from {left: -265px; opacity: 0;}\n  to {left: 10px; opacity: 1;}\n}\n@-webkit-keyframes treeLeftToRight /* Safari  Chrome */\n{\n  from {left: -265px; opacity: 0;}\n  to {left: 10px; opacity: 1;}\n}\n@-o-keyframes treeLeftToRight /* Opera */\n{\n  from {left: -265px; opacity: 0;}\n  to {left: 10px; opacity: 1;}\n}\n.ccBIM .tree-children,\n.ccBIM .tree-container-ul,\n.ccBIM .tree-node {\n  display: block;\n  margin: 0;\n  padding: 0;\n  list-style-type: none;\n  list-style-image: none\n}\n\n.ccBIM .tree-children {\n  overflow: hidden\n}\n\n.ccBIM .tree-anchor,\n.ccBIM .tree-node {\n  white-space: nowrap\n}\n\n.ccBIM .tree-anchor {\n  display: inline-block;\n  color: #000;\n  padding: 0 8px 0 1px;\n  vertical-align: top;\n  font-size: 14px;\n  cursor: pointer;\n  margin-left: -10px;\n}\n\n.ccBIM .tree-anchor:focus {\n  outline: 0\n}\n\n.ccBIM .tree-anchor{\n  text-decoration: none;\n  color: inherit\n}\n\n.ccBIM .tree-anchor:hover {\n  background-color: #333;\n}\n\n.ccBIM .tree-icon,\n.ccBIM .tree-icon:empty {\n  display: inline-block;\n  text-decoration: none;\n  margin: 0;\n  padding: 0;\n  vertical-align: top;\n  text-align: center\n}\n\n.ccBIM .tree-ocl {\n  cursor: pointer\n}\n\n.ccBIM .tree-leaf>.tree-ocl {\n  cursor: default\n}\n\n\n.ccBIM .tree-anchor>.tree-themeicon-hidden,\n.ccBIM .tree-hidden,\n.ccBIM .tree-node.tree-hidden {\n  display: none\n}\n\n.ccBIM .tree-anchor > .colorBox {\n  width: 12px;\n  height: 12px;\n  display: inline-block;\n  border: 1px #c8cccb solid;\n}\n\n.ccBIM .tree {\n  text-align: left;\n  padding: 0 20px 0 5px;\n  height: calc(100% - 80px);\n  overflow-y: auto;\n}\n/**/\n.ccBIM .tree::-webkit-scrollbar {/**/\n  width: 8px;     /**/\n  height: 8px;\n}\n.ccBIM .tree::-webkit-scrollbar-thumb {/**/\n  border-radius: 15px;\n  -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);\n  background: #999;\n}\n.ccBIM .tree::-webkit-scrollbar-thumb:hover {\n  background: #efefef;\n  cursor: pointer;\n}\n.ccBIM .tree::-webkit-scrollbar-track {/**/\n  -webkit-box-shadow: inset 0 0 5px #666;\n  border-radius: 15px;\n  background: #666;\n}\n\n.ccBIM .tree-default .tree-icon,\n.ccBIM .tree-default .tree-node {\n  background-repeat: no-repeat;\n  background-color: transparent\n}\n\n.ccBIM .tree-default .tree-anchor,\n.ccBIM .tree-default .tree-animated{\n  transition: background-color .15s, box-shadow .15s\n}\n\n.ccBIM .tree-default .tree-context {\n  background: #333;\n  border: 0;\n  box-shadow: none\n}\n\n.ccBIM .tree-default .tree-selected {\n  border: 0;\n  box-shadow: none\n}\n\n.ccBIM .tree-default .tree-search {\n  font-style: italic;\n  color: #8b0000;\n  font-weight: 700\n}\n\n.ccBIM .tree-default .tree-no-checkboxes .tree-checkbox {\n  display: none !important\n}\n\n.ccBIM .tree-default.tree-checkbox-no-clicked .tree-selected {\n  background: transparent;\n  box-shadow: none\n}\n\n.ccBIM .tree-default>.tree-striped {\n  min-width: 100%;\n  display: inline-block;\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAMAAAB/qqA+AAAABlBMVEUAAAAAAAClZ7nPAAAAAnRSTlMNAMM9s3UAAAAXSURBVHjajcEBAQAAAIKg/H/aCQZ70AUBjAATb6YPDgAAAABJRU5ErkJggg==\") 0 0 repeat\n}\n\n.ccBIM .tree-default .tree-node {\n  min-height: 24px;\n  line-height: 24px;\n  margin-left: 20px;\n  min-width: 24px\n}\n\n.ccBIM .tree-default .tree-anchor,\n.ccBIM .tree-default .tree-icon {\n  line-height: 24px;\n  height: 24px\n}\n\n.ccBIM .tree-default .tree-icon {\n  width: 24px\n}\n\n.ccBIM .tree-default .tree-icon:empty {\n  width: 24px;\n  height: 24px;\n  line-height: 24px\n}\n\n.ccBIM .tree-default .tree-icon,\n.ccBIM .tree-default .tree-node {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAABgCAYAAABsS6soAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACbBJREFUeNrsnX+IHFcBx9/szaZerrU/rmpCcmmLAVuFinjFhFLECmf+EEVrWlNThNo/iiBEaJSribW1EjSSNEY9/6iKxBZK8Q+10nSxAckfScmJtZAm1fzRJA2pUm1yOe9wd3bH9+Zuzunc3GV3frw3O+/zCY+5mbvL25l9893Pe/NuxvF9X4AQjuP0/DsjI2v8s2fPOaZecxXrpz2Wu82XCdX+zpx5I9NOODS4ajSGqkB7pM3rbC81mkG2TyDqhyp9+OgsZWh/GCAGiAHS5o0c+zzOOQwQA8MAgfMPA8QAMUDAADFADAwDBM4/DBADxAABA8QAMTAMEDj/MEAMsB8NsNFopG6kY2Njmd/YqtaPAQrhdvuDo6OjPdc0OTmZW6oUXX+aA7lu3drMM9E59l2fyGmCg/ozcupP96yXi+/L8vnYt34ny/j6jz/zqmEDzNTO3KIadZqTpuz1x9ERfpF97yWwKlc/GONpWW5L2P4ZWW6U5cOmXlgef4bp8v6mR5cBQnnoxqrS2FqJuW2Z790qDXGTtMCDVhjgUqaVd3enXzAdfsq0ejEzqD7j4+Pndu3atUZjlc/LEIwHkSfL72V5UIbjP8tsgFwFzmiAHAUoUfj9Wy7WGKjaSRCrz6kA1GCABKCtBggQCb9pubiuZC/r0SL/c2NjgPELDNF1Hd3h5S5w6OyOh2OAaZdpu71Lrce7wzrqjx37wusn6MaDpezmRrfNysWV8e1Vx9gYYDRk5sPISToBiiIp5EyMh4Uncdplyn3vep+Lrj/r8YFsQajCTi6bcnXQtvDLywDpAgP0ETHzU4sVNoZfxADNB6CyAtNXI7kaCjaGoK3hVxoDtHUKTBkg9AlBW8MvLwNkIjRAD5RpkrPN4ZeXAfYUgDr+vKzM9Rved6vrB2O8IcvalL+7Q4MB6rkKbLqra3NXm2Of740FqL8n7pflJ7IMX+bnrp1fvj2/VH8e97OyGyC3wwKwlH6/HRbPBQYAawMwj9fMPEAA6Eu4IzQAYIAYIABggBggAGg0MNNggACAAWKAAIABYoBaMX1XaNvrBwwQAwQADBADxMAwQMAAMUAAwAAxQAwMAwQMEAMEAAwQA8TAMEDAADFAAAwQAwQMDAMEDBCglDQaDU/M3fo8LJcVg7CMjY25OdSf+iSR9TtlrT8vA3zoG9/yRz9yqzj599fFqdPnxfobVgfbjx9/RTz7zFOFambW/Oq6caR5Hkeet1I3Xf9yBqTjQd+WH39H1t9LbyUISll/J8f9Fyn2X1Sl/uVY//4R8dwfjwTB981tD4jHHp97WNMVV75HhwHqeSZIrw26iAcYma4/CR3hl6ZBF/EQI4P1O5p/DxLY+pVtiefUi4cOz3+1emFbGH7qd3798ycKeR+0PxUOzBmg5ZQmALv5EKjyE/QOPLl30ba254kLF6fEj3/6pDh16uqFn7v7i1sLtcA8DDDzRRCbH1Wp2wBtO9mgdyYmJgqvY+Bjv31HWXH7H8Tw8HXa9zUPA+QqcA4GyFGAMrB//34xPT1tzf7mcRWYLnCfGyCAYt++faLZbFq1z8bGAOPd3ui6jiuvy3W709YfjuWlXeZhkt3+//Fub3Q97ZW/LPXHjj9pVCC7d+8Oltu3b1/YtnfvXuF53qLtlhigvqvASSEzH0aOzsafFHLqpMxSf3iSp13mZZLd/P/R/cy631nrB3NBqMJuz549ot1uWxd+Rg0QAMygQi60wHCpO/zaL302cfv09JQdBlhGI8BKwMYQ1Bl+8/P5lhx+WjU8FCz/+pdj4r4Hvh5MgQm3VdYAdYz5AcEPySGou9v73R3bFm3b+fgTQdDdvvHBYH3Llh+JV08eEJ+88w7xhbs2ix/+4HvVNkCAgknb0HOfolSmeZcmxvxuuunGRe/D5nu+5A+t3SRefvm4+M/sYTE0eIf44M33iRcPHRDXvPva6hig6UnPtk+6Nn3yGay/NAEIi9n6tS3i2V8ejHSFD4vTp18PusAXpt4urN48DJC7wUDp4W4w5b4bjNGuQcb8IgABLKXfA1AZYNZpaAQgAAForQHyt8AA0LcGmPlDAAMEwAAxQAAADBAAMEAMEAAAAwQADBADBADAAAEAA8QAAQAwQADAADFAAAAMEAAwQAwQAAADBAAMEAMEAMAA+4+64wxG11u+P6ut7qGB9z780I6vJn2v0Wj87ciRI0/zDgEGWNEA/O8ttwQv9ooTJ5wsP5Mp/FbWrvJmOteodXdl7YKY6VzSFYIbN268V4bcU/HtszOz4uLURTExMfGo5Duc2mBDAOZxR+hCusCjv3F8VYoOwm6354kKv7fe+tdrqohm7UOefB/iVqiTtueJmdlZIV+PkOH3iIQABCvI46lwuQdgkcEXtbp42EXXi7C/AGl/ruuuUV++8OeD4s03/3FIrZsMwZrrivoKN3hS0NSlKfHtnTsJQbCCPMYAcw3AaPhN3uUXEkJJIagl/GL86rlflCIE1c4OvWulGLlhRJw5c1acOPma2Lz57kfq9fonOEUAA1ye3B6MriP8oiFnMvyiIahQIbhq1fvuFCs6F2QIFn1hZNGzUJUFrhwcFCPrRoTX9AIjHB0dXc0pAhYYYKZzvusADAMuKdx0hl9SCJoIv6QQvP764Q/IA3qpMNtbYtRabR1w6+Lqq+rBmCCPA4dIm8EA8+wCx8f4TIRf3PyS1ivanH3R8TtLdYUVA9IGVQGwxAD1BGA03MLQK0P4LXdhRAdf/vT94lMf3SRUFziYFlMgbn1AHXA/7AeHZe4Lf3EaAlQY7QaYFIJlCD9TIRgNP8/zzhU9J9CR/3yVdNIB/XZb+LK7q0qn0xbtdmeu+zsHnWDAAIvoAsfDrgzmZyIE4+EnO51niwy/DRs2BJPWZcj57Y4X9ITbal0Wv6O8cK5nrELQxwEBAywmAKOhpzP8lgq7brbnhjS8wPQkOsNPcfTo0SDUW03PaTZbotXyhKxbeHLZbLVkkUu5XZWODElOD8AAL0/q0XIT4ddNwBUdgmqcT13tDb92PaHtT+GkAfqtTqtWi39uOfMCGI4QNjFAwAALDUAbUUGn5vktTHWZ6Wi9GUK73Vbz/ZyOGgOUiefLLxynFkx1GKjXAp9XLUJNiQGwxAD1zAOE/4egqbqPHTt2/uEdj6nAU77nB3O81BhgcFMLNR3QXxj/m5ycPM+7BRjg8nA7rPBA9MGEUflpFdyNpu66ouV5wnVdZ67/Oxd7XnTsT41XCjHLOwtVNsCsd4MhAPsoAAHgnXBHaACw1gDpAmOAABggBggAGCAGiAECYIAYIABggBggAEAC/xNgABT+eKeUWyLUAAAAAElFTkSuQmCC\")\n}\n\n.ccBIM .tree-default .tree-node {\n  background-position: -292px -4px;\n  background-repeat: repeat-y\n}\n\n.ccBIM .tree-default .tree-last {\n  background: transparent\n}\n\n.ccBIM .tree-default .tree-open>.tree-ocl {\n  background-position: -132px -4px\n}\n\n.ccBIM .tree-default .tree-closed>.tree-ocl {\n  background-position: -100px -4px\n}\n\n.ccBIM .tree-default .tree-leaf>.tree-ocl {\n  background-position: -68px -4px\n}\n\n.ccBIM .tree-default .tree-checkbox {\n  background-position: -164px -4px\n}\n\n.ccBIM .tree-default .tree-checkbox:hover {\n  background-position: -164px -36px\n}\n\n.ccBIM .tree-default.tree-checkbox-selection .tree-selected>.tree-checkbox,\n.ccBIM .tree-default .tree-checked>.tree-checkbox {\n  background-position: -228px -4px\n}\n\n.ccBIM .tree-default.tree-checkbox-selection .tree-selected>.tree-checkbox:hover,\n.ccBIM .tree-default .tree-checked>.tree-checkbox:hover {\n  background-position: -228px -36px\n}\n\n.ccBIM .tree-default .tree-anchor>.tree-undetermined {\n  background-position: -196px -4px\n}\n\n.ccBIM .tree-default .tree-anchor>.tree-undetermined:hover {\n  background-position: -196px -36px\n}\n\n.ccBIM .tree-default .tree-checkbox-disabled {\n  opacity: .8;\n  filter: url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg'><filter id='tree-grayscale'><feColorMatrix type='matrix' values='0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0'/></filter></svg>#tree-grayscale\");\n  -webkit-filter: grayscale(100%)\n}\n\n.ccBIM .tree-default>.tree-striped {\n  background-size: auto 48px\n}\n\n.ccBIM .tree-default .tree-themeicon-custom {\n  background-color: transparent;\n  background-image: none;\n  background-position: 0 0\n}\n\n.ccBIM .tree-default .tree-file {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAABgCAYAAABsS6soAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACbBJREFUeNrsnX+IHFcBx9/szaZerrU/rmpCcmmLAVuFinjFhFLECmf+EEVrWlNThNo/iiBEaJSribW1EjSSNEY9/6iKxBZK8Q+10nSxAckfScmJtZAm1fzRJA2pUm1yOe9wd3bH9+Zuzunc3GV3frw3O+/zCY+5mbvL25l9893Pe/NuxvF9X4AQjuP0/DsjI2v8s2fPOaZecxXrpz2Wu82XCdX+zpx5I9NOODS4ajSGqkB7pM3rbC81mkG2TyDqhyp9+OgsZWh/GCAGiAHS5o0c+zzOOQwQA8MAgfMPA8QAMUDAADFADAwDBM4/DBADxAABA8QAMTAMEDj/MEAMsB8NsNFopG6kY2Njmd/YqtaPAQrhdvuDo6OjPdc0OTmZW6oUXX+aA7lu3drMM9E59l2fyGmCg/ozcupP96yXi+/L8vnYt34ny/j6jz/zqmEDzNTO3KIadZqTpuz1x9ERfpF97yWwKlc/GONpWW5L2P4ZWW6U5cOmXlgef4bp8v6mR5cBQnnoxqrS2FqJuW2Z790qDXGTtMCDVhjgUqaVd3enXzAdfsq0ejEzqD7j4+Pndu3atUZjlc/LEIwHkSfL72V5UIbjP8tsgFwFzmiAHAUoUfj9Wy7WGKjaSRCrz6kA1GCABKCtBggQCb9pubiuZC/r0SL/c2NjgPELDNF1Hd3h5S5w6OyOh2OAaZdpu71Lrce7wzrqjx37wusn6MaDpezmRrfNysWV8e1Vx9gYYDRk5sPISToBiiIp5EyMh4Uncdplyn3vep+Lrj/r8YFsQajCTi6bcnXQtvDLywDpAgP0ETHzU4sVNoZfxADNB6CyAtNXI7kaCjaGoK3hVxoDtHUKTBkg9AlBW8MvLwNkIjRAD5RpkrPN4ZeXAfYUgDr+vKzM9Rved6vrB2O8IcvalL+7Q4MB6rkKbLqra3NXm2Of740FqL8n7pflJ7IMX+bnrp1fvj2/VH8e97OyGyC3wwKwlH6/HRbPBQYAawMwj9fMPEAA6Eu4IzQAYIAYIABggBggAGg0MNNggACAAWKAAIABYoBaMX1XaNvrBwwQAwQADBADxMAwQMAAMUAAwAAxQAwMAwQMEAMEAAwQA8TAMEDAADFAAAwQAwQMDAMEDBCglDQaDU/M3fo8LJcVg7CMjY25OdSf+iSR9TtlrT8vA3zoG9/yRz9yqzj599fFqdPnxfobVgfbjx9/RTz7zFOFambW/Oq6caR5Hkeet1I3Xf9yBqTjQd+WH39H1t9LbyUISll/J8f9Fyn2X1Sl/uVY//4R8dwfjwTB981tD4jHHp97WNMVV75HhwHqeSZIrw26iAcYma4/CR3hl6ZBF/EQI4P1O5p/DxLY+pVtiefUi4cOz3+1emFbGH7qd3798ycKeR+0PxUOzBmg5ZQmALv5EKjyE/QOPLl30ba254kLF6fEj3/6pDh16uqFn7v7i1sLtcA8DDDzRRCbH1Wp2wBtO9mgdyYmJgqvY+Bjv31HWXH7H8Tw8HXa9zUPA+QqcA4GyFGAMrB//34xPT1tzf7mcRWYLnCfGyCAYt++faLZbFq1z8bGAOPd3ui6jiuvy3W709YfjuWlXeZhkt3+//Fub3Q97ZW/LPXHjj9pVCC7d+8Oltu3b1/YtnfvXuF53qLtlhigvqvASSEzH0aOzsafFHLqpMxSf3iSp13mZZLd/P/R/cy631nrB3NBqMJuz549ot1uWxd+Rg0QAMygQi60wHCpO/zaL302cfv09JQdBlhGI8BKwMYQ1Bl+8/P5lhx+WjU8FCz/+pdj4r4Hvh5MgQm3VdYAdYz5AcEPySGou9v73R3bFm3b+fgTQdDdvvHBYH3Llh+JV08eEJ+88w7xhbs2ix/+4HvVNkCAgknb0HOfolSmeZcmxvxuuunGRe/D5nu+5A+t3SRefvm4+M/sYTE0eIf44M33iRcPHRDXvPva6hig6UnPtk+6Nn3yGay/NAEIi9n6tS3i2V8ejHSFD4vTp18PusAXpt4urN48DJC7wUDp4W4w5b4bjNGuQcb8IgABLKXfA1AZYNZpaAQgAAForQHyt8AA0LcGmPlDAAMEwAAxQAAADBAAMEAMEAAAAwQADBADBADAAAEAA8QAAQAwQADAADFAAAAMEAAwQAwQAAADBAAMEAMEAMAA+4+64wxG11u+P6ut7qGB9z780I6vJn2v0Wj87ciRI0/zDgEGWNEA/O8ttwQv9ooTJ5wsP5Mp/FbWrvJmOteodXdl7YKY6VzSFYIbN268V4bcU/HtszOz4uLURTExMfGo5Duc2mBDAOZxR+hCusCjv3F8VYoOwm6354kKv7fe+tdrqohm7UOefB/iVqiTtueJmdlZIV+PkOH3iIQABCvI46lwuQdgkcEXtbp42EXXi7C/AGl/ruuuUV++8OeD4s03/3FIrZsMwZrrivoKN3hS0NSlKfHtnTsJQbCCPMYAcw3AaPhN3uUXEkJJIagl/GL86rlflCIE1c4OvWulGLlhRJw5c1acOPma2Lz57kfq9fonOEUAA1ye3B6MriP8oiFnMvyiIahQIbhq1fvuFCs6F2QIFn1hZNGzUJUFrhwcFCPrRoTX9AIjHB0dXc0pAhYYYKZzvusADAMuKdx0hl9SCJoIv6QQvP764Q/IA3qpMNtbYtRabR1w6+Lqq+rBmCCPA4dIm8EA8+wCx8f4TIRf3PyS1ivanH3R8TtLdYUVA9IGVQGwxAD1BGA03MLQK0P4LXdhRAdf/vT94lMf3SRUFziYFlMgbn1AHXA/7AeHZe4Lf3EaAlQY7QaYFIJlCD9TIRgNP8/zzhU9J9CR/3yVdNIB/XZb+LK7q0qn0xbtdmeu+zsHnWDAAIvoAsfDrgzmZyIE4+EnO51niwy/DRs2BJPWZcj57Y4X9ITbal0Wv6O8cK5nrELQxwEBAywmAKOhpzP8lgq7brbnhjS8wPQkOsNPcfTo0SDUW03PaTZbotXyhKxbeHLZbLVkkUu5XZWODElOD8AAL0/q0XIT4ddNwBUdgmqcT13tDb92PaHtT+GkAfqtTqtWi39uOfMCGI4QNjFAwAALDUAbUUGn5vktTHWZ6Wi9GUK73Vbz/ZyOGgOUiefLLxynFkx1GKjXAp9XLUJNiQGwxAD1zAOE/4egqbqPHTt2/uEdj6nAU77nB3O81BhgcFMLNR3QXxj/m5ycPM+7BRjg8nA7rPBA9MGEUflpFdyNpu66ouV5wnVdZ67/Oxd7XnTsT41XCjHLOwtVNsCsd4MhAPsoAAHgnXBHaACw1gDpAmOAABggBggAGCAGiAECYIAYIABggBggAEAC/xNgABT+eKeUWyLUAAAAAElFTkSuQmCC\") -100px -68px no-repeat\n}\n\n.ccBIM .tree-default .tree-folder {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAABgCAYAAABsS6soAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACbBJREFUeNrsnX+IHFcBx9/szaZerrU/rmpCcmmLAVuFinjFhFLECmf+EEVrWlNThNo/iiBEaJSribW1EjSSNEY9/6iKxBZK8Q+10nSxAckfScmJtZAm1fzRJA2pUm1yOe9wd3bH9+Zuzunc3GV3frw3O+/zCY+5mbvL25l9893Pe/NuxvF9X4AQjuP0/DsjI2v8s2fPOaZecxXrpz2Wu82XCdX+zpx5I9NOODS4ajSGqkB7pM3rbC81mkG2TyDqhyp9+OgsZWh/GCAGiAHS5o0c+zzOOQwQA8MAgfMPA8QAMUDAADFADAwDBM4/DBADxAABA8QAMTAMEDj/MEAMsB8NsNFopG6kY2Njmd/YqtaPAQrhdvuDo6OjPdc0OTmZW6oUXX+aA7lu3drMM9E59l2fyGmCg/ozcupP96yXi+/L8vnYt34ny/j6jz/zqmEDzNTO3KIadZqTpuz1x9ERfpF97yWwKlc/GONpWW5L2P4ZWW6U5cOmXlgef4bp8v6mR5cBQnnoxqrS2FqJuW2Z790qDXGTtMCDVhjgUqaVd3enXzAdfsq0ejEzqD7j4+Pndu3atUZjlc/LEIwHkSfL72V5UIbjP8tsgFwFzmiAHAUoUfj9Wy7WGKjaSRCrz6kA1GCABKCtBggQCb9pubiuZC/r0SL/c2NjgPELDNF1Hd3h5S5w6OyOh2OAaZdpu71Lrce7wzrqjx37wusn6MaDpezmRrfNysWV8e1Vx9gYYDRk5sPISToBiiIp5EyMh4Uncdplyn3vep+Lrj/r8YFsQajCTi6bcnXQtvDLywDpAgP0ETHzU4sVNoZfxADNB6CyAtNXI7kaCjaGoK3hVxoDtHUKTBkg9AlBW8MvLwNkIjRAD5RpkrPN4ZeXAfYUgDr+vKzM9Rved6vrB2O8IcvalL+7Q4MB6rkKbLqra3NXm2Of740FqL8n7pflJ7IMX+bnrp1fvj2/VH8e97OyGyC3wwKwlH6/HRbPBQYAawMwj9fMPEAA6Eu4IzQAYIAYIABggBggAGg0MNNggACAAWKAAIABYoBaMX1XaNvrBwwQAwQADBADxMAwQMAAMUAAwAAxQAwMAwQMEAMEAAwQA8TAMEDAADFAAAwQAwQMDAMEDBCglDQaDU/M3fo8LJcVg7CMjY25OdSf+iSR9TtlrT8vA3zoG9/yRz9yqzj599fFqdPnxfobVgfbjx9/RTz7zFOFambW/Oq6caR5Hkeet1I3Xf9yBqTjQd+WH39H1t9LbyUISll/J8f9Fyn2X1Sl/uVY//4R8dwfjwTB981tD4jHHp97WNMVV75HhwHqeSZIrw26iAcYma4/CR3hl6ZBF/EQI4P1O5p/DxLY+pVtiefUi4cOz3+1emFbGH7qd3798ycKeR+0PxUOzBmg5ZQmALv5EKjyE/QOPLl30ba254kLF6fEj3/6pDh16uqFn7v7i1sLtcA8DDDzRRCbH1Wp2wBtO9mgdyYmJgqvY+Bjv31HWXH7H8Tw8HXa9zUPA+QqcA4GyFGAMrB//34xPT1tzf7mcRWYLnCfGyCAYt++faLZbFq1z8bGAOPd3ui6jiuvy3W709YfjuWlXeZhkt3+//Fub3Q97ZW/LPXHjj9pVCC7d+8Oltu3b1/YtnfvXuF53qLtlhigvqvASSEzH0aOzsafFHLqpMxSf3iSp13mZZLd/P/R/cy631nrB3NBqMJuz549ot1uWxd+Rg0QAMygQi60wHCpO/zaL302cfv09JQdBlhGI8BKwMYQ1Bl+8/P5lhx+WjU8FCz/+pdj4r4Hvh5MgQm3VdYAdYz5AcEPySGou9v73R3bFm3b+fgTQdDdvvHBYH3Llh+JV08eEJ+88w7xhbs2ix/+4HvVNkCAgknb0HOfolSmeZcmxvxuuunGRe/D5nu+5A+t3SRefvm4+M/sYTE0eIf44M33iRcPHRDXvPva6hig6UnPtk+6Nn3yGay/NAEIi9n6tS3i2V8ejHSFD4vTp18PusAXpt4urN48DJC7wUDp4W4w5b4bjNGuQcb8IgABLKXfA1AZYNZpaAQgAAForQHyt8AA0LcGmPlDAAMEwAAxQAAADBAAMEAMEAAAAwQADBADBADAAAEAA8QAAQAwQADAADFAAAAMEAAwQAwQAAADBAAMEAMEAMAA+4+64wxG11u+P6ut7qGB9z780I6vJn2v0Wj87ciRI0/zDgEGWNEA/O8ttwQv9ooTJ5wsP5Mp/FbWrvJmOteodXdl7YKY6VzSFYIbN268V4bcU/HtszOz4uLURTExMfGo5Duc2mBDAOZxR+hCusCjv3F8VYoOwm6354kKv7fe+tdrqohm7UOefB/iVqiTtueJmdlZIV+PkOH3iIQABCvI46lwuQdgkcEXtbp42EXXi7C/AGl/ruuuUV++8OeD4s03/3FIrZsMwZrrivoKN3hS0NSlKfHtnTsJQbCCPMYAcw3AaPhN3uUXEkJJIagl/GL86rlflCIE1c4OvWulGLlhRJw5c1acOPma2Lz57kfq9fonOEUAA1ye3B6MriP8oiFnMvyiIahQIbhq1fvuFCs6F2QIFn1hZNGzUJUFrhwcFCPrRoTX9AIjHB0dXc0pAhYYYKZzvusADAMuKdx0hl9SCJoIv6QQvP764Q/IA3qpMNtbYtRabR1w6+Lqq+rBmCCPA4dIm8EA8+wCx8f4TIRf3PyS1ivanH3R8TtLdYUVA9IGVQGwxAD1BGA03MLQK0P4LXdhRAdf/vT94lMf3SRUFziYFlMgbn1AHXA/7AeHZe4Lf3EaAlQY7QaYFIJlCD9TIRgNP8/zzhU9J9CR/3yVdNIB/XZb+LK7q0qn0xbtdmeu+zsHnWDAAIvoAsfDrgzmZyIE4+EnO51niwy/DRs2BJPWZcj57Y4X9ITbal0Wv6O8cK5nrELQxwEBAywmAKOhpzP8lgq7brbnhjS8wPQkOsNPcfTo0SDUW03PaTZbotXyhKxbeHLZbLVkkUu5XZWODElOD8AAL0/q0XIT4ddNwBUdgmqcT13tDb92PaHtT+GkAfqtTqtWi39uOfMCGI4QNjFAwAALDUAbUUGn5vktTHWZ6Wi9GUK73Vbz/ZyOGgOUiefLLxynFkx1GKjXAp9XLUJNiQGwxAD1zAOE/4egqbqPHTt2/uEdj6nAU77nB3O81BhgcFMLNR3QXxj/m5ycPM+7BRjg8nA7rPBA9MGEUflpFdyNpu66ouV5wnVdZ67/Oxd7XnTsT41XCjHLOwtVNsCsd4MhAPsoAAHgnXBHaACw1gDpAmOAABggBggAGCAGiAECYIAYIABggBggAEAC/xNgABT+eKeUWyLUAAAAAElFTkSuQmCC\") -260px -4px no-repeat\n}\n\n.ccBIM .tree-default>.tree-container-ul>.tree-node {\n  margin-left: 0;\n  margin-right: 0\n}\n\n.ccBIM .tree-default .tree-ellipsis {\n  overflow: hidden\n}\n\n.ccBIM .tree-default .tree-ellipsis .tree-anchor {\n  width: calc(100% - 29px);\n  text-overflow: ellipsis;\n  overflow: hidden\n}\n\n.ccBIM .tree-default .tree-ellipsis.tree-no-icons .tree-anchor {\n  width: calc(100% - 5px)\n}\n", ""]);

// exports


/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, "/*viewBox*/\n.ccBIM .pbim-viewHome{\n  position: absolute;\n  top: 30px;\n  right: 115px;\n  cursor: pointer;\n}\n.ccBIM .pbim-viewHome img{\n  width: 20px;\n}\n.ccBIM .pbim-viewBox{\n  width: 90px;\n  height: 90px;\n  position: absolute;\n  top: 20px;\n  right: 20px;\n}\n\n/*-*/\n.ccBIM .pbim-dialog{\n  position: absolute;\n  left: 20px;\n  top: 20px;\n  max-width: 1000px;\n  z-index: 2;\n}\n.ccBIM .pbim-dialog >div{\n  background: #fff;\n  border-radius: 3px;\n  box-shadow: 0 0 5px #e7e7e7;\n  margin-right: 20px;\n  margin-bottom: 14px;\n}\n.ccBIM .pbim-dialog-title{\n  height: 30px;\n  line-height:30px;\n  padding: 8px 15px;\n  color: #333;\n  border-bottom: 1px #ddd solid;\n}\n.ccBIM .pbim-dialog-x{\n  font-size: 20px;\n  float: right;\n  cursor: pointer;\n}\n.ccBIM .pbim-dialog-x:hover{\n  color: #00b589;\n}\n.ccBIM .pbim-dialog-body{\n  padding: 15px;\n  border-radius: 3px;\n  overflow: auto;\n  max-height: 28rem;\n}\n.ccBIM .pbim-dialog-body .stageSelect {\n  margin-bottom: 10px;\n  width: 100%;\n  height: 25px;\n}\n.ccBIM .pbim-dialog-body .clipping-tip{\n  margin-bottom: 15px;\n  font-size: 15px;\n}\n.ccBIM .pbim-dialog-body .clipping-help{\n  background: #999;\n  border: 1px solid #999;\n}\n.ccBIM .pbim-dialog-body .helpHover{\n  background: #00b589;\n  border: 1px solid #00b589;\n}\n.ccBIM .pbim-dialog-body button{\n  width: 97px;\n  background: #00b589;\n  color: #fff;\n  border: 1px solid #00b589;\n  padding: 3px 10px;\n  cursor: pointer;\n  font-size: 14px;\n  border-radius: 3px;\n}\n.ccBIM .pbim-dialog-body button:hover{\n  background: #05775b;\n}\n.ccBIM .pbim-info-com{\n  padding: 5px 15px 5px 15px;\n  font-size: 0.875rem;\n  line-height: 20px;\n}\n\n/**/\n.ccBIM .componentCutBox {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 320px;\n  height: 150px;\n  border-radius: 10px;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.ccBIM .componentCutBox p {\n  color: #fff;\n  text-align: center;\n  height: 100px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.ccBIM .componentCutBox .button-box {\n  color: #fff;\n  display: flex;\n  justify-content: space-around;\n  border-top: 1px solid;\n  align-items: center;\n  height: 48px;\n}\n.ccBIM .componentCutBox .button-box span {\n  width: 50%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n}\n.ccBIM .componentCutBox .button-box span:nth-child(1) {\n  border-right: 1px solid #fff;\n  border-bottom-left-radius: 10px;\n}\n.ccBIM .componentCutBox .button-box span:nth-child(2) {\n  border-bottom-right-radius: 10px;\n}\n.ccBIM .componentCutBox .button-box span:hover {\n  background-color: rgba(0, 0, 0, 0.7);\n}\n", ""]);

// exports


/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, ".ccBIM .canvasParent {\n  position: absolute;\n  right: 10px;\n  bottom: 70px;\n  overflow: hidden;\n  z-index: 2;\n  width: 280px;\n  height: 325px;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.ccBIM .canvasParent.center {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  width: 600px;\n  height: 500px;\n}\n.ccBIM .canvasParent .topTip {\n  display: flex;\n  justify-content: space-between;\n  margin-top: 7px;\n}\n.ccBIM .canvasParent .topTip .floorSelect {\n  width: 172px;\n  height: 30px;\n  font-size: 16px;\n  border: 1px solid #979797;\n  color: #fff;\n  padding: 0 8px;\n  background: rgba(0, 0, 0, 0.6);\n  outline: 0;\n  border-radius: 3px;\n  margin-left: 9px;\n}\n\n.ccBIM .canvasParent .topTip .canvasButton {\n  display: flex;\n  align-items: center;\n}\n.ccBIM .canvasParent .topTip .canvasButton .icon {\n  width: 1.5em;\n  height: 1.5em;\n  color: #fff;\n  cursor: pointer;\n  margin-right: 8px;\n}\n.ccBIM .canvasParent .topTip .canvasButton .icon.small {\n  font-size: 12px;\n}\n.ccBIM .canvasParent .circle {\n  width: 12px;\n  height: 12px;\n  border-radius: 100%;\n  background-color: red;\n  position: absolute;\n  left: 0;\n  top: 0;\n  display: none;\n}\n.ccBIM .canvasParent .circle::after {\n  content: \"\";\n  width: 0;\n  height: 0;\n  position: absolute;\n  top: -8px;\n  border-left: solid 6px transparent;\n  border-right: solid 6px transparent;\n  border-bottom: solid 6px red;\n}\n", ""]);

// exports


/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, "/**/\n.ccBIM .roam-box {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 320px;\n  height: 150px;\n  border-radius: 10px;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.ccBIM .roam-box .roam-title {\n  color: #fff;\n  font-size: 14px;\n  padding: 0 20px;\n  border-bottom: 1px solid #eee;\n  line-height: 32px;\n}\n.ccBIM .roam-box .roam-title .roam-close{\n  width: 20px;\n  height: 20px;\n  position: absolute;\n  right: 10px;\n  top: 6px;\n  cursor: pointer;\n  color: #fff;\n  fill: currentColor\n}\n.ccBIM .roam-box .roam-content {\n  font-size: 14px;\n  color: #fff;\n  padding: 15px 18px;\n}\n.ccBIM .roam-box .roam-content p {\n  margin-top: 10px;\n  display: flex;\n}\n.ccBIM .roam-box .roam-content p input {\n  margin-top: 4px;\n}\n.ccBIM .modeChange {\n  position: absolute;\n  bottom: 100px;\n  left: 50%;\n  transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.5);\n  color: #fff;\n  padding: 6px 20px;\n  border-radius: 6px;\n  font-size: 14px;\n  display: flex;\n}\n.ccBIM .modeChange .roam-speed {\n  width: 20px;\n  height: 20px;\n  color: #fff;\n  fill: currentColor;\n  cursor: pointer;\n}\n.ccBIM .modeChange .speed-value {\n  margin: 0 15px;\n}\n.ccBIM .modeChange .gravity-box {\n  margin-left: 15px;\n}\n.ccBIM .modeChange .gravity-check {\n  float: right;\n  margin-top: 4px;\n}\n/**/\n.ccBIM .roamCross {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n.ccBIM .roamCrossW {\n  width: 40px;\n  height: 1px;\n  background-color: rgb(255, 215, 0);\n}\n.ccBIM .roamCrossH {\n  width: 1px;\n  height: 40px;\n  background-color: rgb(255, 215, 0);\n  position: absolute;\n  left: 20px;\n  top: -20px;\n}\n.ccBIM .roamPerson canvas{\n  cursor: url('data:image/x-icon;base64,AAABAAEAICAAAAEAIACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAABMLAAATCwAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjYytjY2OAY2Nj1WNjY6tjY2NC////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2MrY2NjgGNjY9VjY2PAWF9k/0NWZf8uTWb/Kz5N/1xeYP9jY2OB////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2NjllhfZP9DVmX/Lk1m/yU6Sv8jSWb/I0lm/yNJZv8QLEL/FzFF/0dQWP9jY2OW////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/I0lm/yNJZv8jSWb/ECxC/zhPYP9iWlP/jGVG/7NtNf9sSCv/LzU6/2NjY/9jY2NX////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY/84T2D/YlpT/4xlRv+KUSP/ynYz/8p2M//KdjP/ynYz/4pRI/+KUSP/gFUz/21eU/9jY2OW////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2Nj/8p2M//KdjP/ynYz/4pRI//KdjP/ynYz/8p2M//KdjP/ilEj/4pRI/+KUSP/ilEj/2NjY/////8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/ynYz/8p2M//KdjP/ilEj/8p2M//KdjP/ynYz/8p2M/+KUSP/ilEj/4pRI/+KUSP/Y2Nj/////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY//KdjP/ynYz/8p2M/+KUSP/ynYz/8p2M//KdjP/ynYz/4pRI/+KUSP/ilEj/4pRI/9jY2P/////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2Nj/8p2M//KdjP/ynYz/4pRI//KdjP/ynYz/8p2M//KdjP/ilEj/4pRI/+KUSP/ilEj/2NjY/////8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/ynYz/8p2M//KdjP/ilEj/8p2M//KdjP/ynYz/8p2M/+KUSP/ilEj/4pRI/+KUSP/Y2Nj/////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY//KdjP/ynYz/8p2M/+KUSP/ynYz/8p2M//KdjP/ynYz/4pRI/+KUSP/ilEj/4pRI/9jY2P/////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2Nj/8p2M//KdjP/ynYz/4pRI//KdjP/ynYz/8p2M//KdjP/ilEj/4pRI/8/mq3/cWlR/2NjY/////8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/ynYz/8p2M//KdjP/ynYz/8p2M//KdjP/ynYz/8p2M/+KUSP/Vtbt/yay2v8mstr/Y2Nj/////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2NjlmNjY//KdjP/ynYz/8p2M//KdjP/ynYz/8p2M//KdjP/ynYz/4pRI/9W1u3/JrLa/yay2v9jY2P/////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/JrLa/8p2M//KdjP/ynYz/8p2M//KdjP/ynYz/8p2M//KdjP/ilEj/1bW7f8mstr/JrLa/2NjY/////8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY/8mstr/ynYz/8p2M//KdjP/ynYz/8p2M//KdjP/ynYz/8p2M/+KUSP/Vtbt/yay2v8mstr/Y2Nj/////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2Nj/yay2v/CfD//ynYz/6aUbf+YoIT/iKyc/3q4s//KdjP/XdDi/zSJm/9W1u3/JrLa/yay2v9jY2P/////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/JrLa/1bW7f/KdjP/Vtbt/1bW7f9W1u3/Vtbt/8p2M/9W1u3/GJzC/1bW7f8mstr/JrLa/2NjY/////8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY/8mstr/Vtbt/8p2M/9W1u3/Vtbt/1bW7f9W1u3/ynYz/1bW7f8YnML/Vtbt/yay2v8mstr/Y2Nj/////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2Nj/yay2v9W1u3/ynYz/1bW7f9W1u3/Vtbt/1bW7f/KdjP/Vtbt/xicwv8YnML/G6HI/yKs1P9jY2P/////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2P/JrLa/1bW7f/KdjP/Vtbt/1bW7f9W1u3/Vtbt/8p2M/+7gkr/oJRx/36cj/9Sn6v/KJ29/2NjY+P///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY5ZjY2P/YH+F/8p2M/+3hlL/kKaQ/2rGzv9W1u3/Yc3b/3m5tv+Rn4j/qIZb/795Pv9hcXT/Y2Njev///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2OWcGVd/4d8Z/+5rpf/4trQ/+fp6f/T29z/kJqd/2NjY+9jY2PiY2Nj72NjY4b///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2NrkJCQ/+rq6v/q6ur/6urq/+rq6v/q6ur/kZGR/2NjY2v///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY9TT09P/6urq/+rq6v/q6ur/6urq/+rq6v/T09P/Y2Nj1P///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2OCXW1x/4Lc8v9J1vr/LtP8/y7T/P9J1vr/hN30/9bl6f9jY2P6////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY+sryfH/JtL9/ybS/f8m0v3/JtL9/ybS/f8m0v3/MdL6/1GDkP9jY2Nx////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AY2Nj3C7D6P8m0v3/JtL9/ybS/f8m0v3/JtL9/ybS/f8m0v3/L8Ln/2NjY9r///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wBjY2OCRJyy/ybS/f8m0v3/JtL9/ybS/f8m0v3/JtL9/ybS/f9Em7D/Y2NjgP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjYxlhZ2n/NLna/ybS/f8m0v3/JtL9/ybS/f8m0v3/NLna/2Fnaf9jY2MX////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjY1xhZ2j/RJux/y7D6P8nz/n/LsPo/0Sbsf9hZ2j/Y2NjXP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AGNjYxhjY2OBY2Nj3GNjY/ljY2PcY2NjgWNjYxj///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//wf///AD///gAf//4AD//+AAf//gAH//4AB//+AAf//gAH//4AB//+AAf//gAH//4AB//8AAf//AAH//wAB//8AAf//AAH//wAB//8AAf//AAH//wAB///AA///4A///+AP///AD///wAf//8AH///AB///wAf//+AP///wH/8='), default !important;\n}\n.ccBIM .roam-img {\n  position: absolute;\n  left: 0;\n  bottom: 66px;\n}\n.ccBIM .roam-img .roam-img-close {\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  right: 4px;\n  top: 2px;\n  background-color: #fff;\n  cursor: pointer;\n}\n\n.ccBIM .phoneModeChange {\n  position: absolute;\n  top: 20px;\n  right: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  color: #fff;\n  font-size: 14px;\n}\n.ccBIM .phoneModeChange .exit{\n  padding: 6px;\n  background-color: #333;\n  text-align: center;\n}\n.ccBIM .phoneModeChange .speed {\n  display: flex;\n  margin: 8px 20px;\n}\n.ccBIM .phoneModeChange .speed .roam-speed {\n  width: 20px;\n  height: 20px;\n  color: #fff;\n  fill: currentColor;\n  cursor: pointer;\n}\n.ccBIM .phoneModeChange .speed .speed-value {\n  margin: 0 15px;\n}\n.ccBIM .phoneUpDown {\n  position: absolute;\n  bottom: 10%;\n  right: 5%;\n  background-color: rgba(0, 0, 0, 0.4);\n  padding: 10px 0;\n  border-radius: 24px;\n  height: 80px;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around;\n}\n.ccBIM .phoneUpDown .ccbim-icon{\n  width: 20px;\n  height: 20px;\n  color: #fff;\n  padding: 10px;\n  fill: currentColor;\n  cursor: pointer;\n}\n.ccBIM .phoneOpenTree {\n  position: absolute;\n  top: 20px;\n  left: 0;\n  background-color: rgba(0, 0, 0, 0.4);\n}\n.ccBIM .phoneOpenTree .ccbim-icon {\n  width: 20px;\n  height: 20px;\n  color: #fff;\n  fill: currentColor;\n  cursor: pointer;\n  padding: 10px;\n}\n", ""]);

// exports


/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, "/**/\n.ccBIM .setting-box {\n  width: 540px;\n  height: 330px;\n  background-color: #666;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  box-shadow: 0px 0px 10px #666;\n}\n.ccBIM .setting-tile{\n  background-color: #00b589;\n  text-align: center;\n  fill: currentColor;\n  color: #fff;\n  line-height: 40px;\n}\n.ccBIM .setting-close {\n  width: 25px;\n  height: 25px;\n  position: absolute;\n  right: 5px;\n  top: 8px;\n  cursor: pointer;\n}\n.ccBIM .setting-content {\n  color: #fff;\n  padding-top: 30px;\n  padding-left: 80px;\n  padding-right: 80px;\n}\n.ccBIM .setting-content li {\n  list-style:none;\n  margin-bottom: 20px;\n}\n.ccBIM .setting-content li .setting-way {\n  float: left;\n  margin-right: 15px;\n}\n.ccBIM .setting-content li .strip {\n  float: left;\n}\n.ccBIM .setting-content li .strip-box {\n  float: left;\n  margin-top: 6px;\n  margin-left: 6px;\n  margin-right: 6px;\n  position: relative;\n}\n.ccBIM .setting-content li .text-tip {\n  float: left;\n  font-size: 12px;\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n.ccBIM .setting-content li .strip-all {\n  width: 240px;\n  height: 10px;\n  background-color: #fff;\n  border-radius: 80px;\n  float: left;\n}\n.ccBIM .setting-content li .strip-current {\n  width: 140px;\n  height: 10px;\n  background-color: #00b589;\n  border-radius: 80px;\n  position: absolute;\n}\n.ccBIM .setting-content li .strip-btn {\n  width: 10px;\n  height: 24px;\n  border-radius: 50px;\n  background-color: #333;\n  position: absolute;\n  top: -7px;\n  cursor: pointer;\n  left: 136px;\n}\n.ccBIM .sure-save-btn {\n  background-color: #fff;\n  text-align: center;\n  width: 120px;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  border-radius: 50px;\n  cursor: pointer;\n  line-height: 25px;\n  box-shadow: 0px 0px 8px #444;\n}\n.ccBIM .sure-save-btn:hover {\n  background-color: #00b589;\n  color: #fff;\n  transition: background-color ease .3s, color ease .2s;\n}\n\n/*switch*/\n.ccBIM .setting-switch-label {\n  display: inline-flex;\n  align-items: center;\n  font-size: 14px;\n}\n.ccBIM .setting-switch-label span {\n  margin-right: 10px;\n}\n.ccBIM .setting-switch {\n  width: 30px;\n  height: 16px;\n  position: relative;\n  background-color: #fdfdfd;\n  box-shadow: #dfdfdf 0 0 0 0 inset;\n  border-radius: 20px;\n  background-clip: content-box;\n  display: inline-block;\n  -webkit-appearance: none;\n  user-select: none;\n  outline: none;\n  cursor: pointer;\n  margin: 0;\n}\n.ccBIM .setting-switch:before {\n  content: '';\n  width: 15px;\n  height: 15px;\n  position: absolute;\n  top: 0px;\n  left: 0;\n  border-radius: 20px;\n  background-color: #fff;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n}\n.ccBIM .setting-switch:checked {\n  border-color: #00b589;\n  box-shadow: #00b589 0 0 0 16px inset;\n  background-color: #00b589;\n}\n.ccBIM .setting-switch:checked:before {\n  left: 14px;\n}\n.ccBIM .setting-switch.setting-switch-anim {\n  transition: border cubic-bezier(0, 0, 0, 1) 0.4s, box-shadow cubic-bezier(0, 0, 0, 1) 0.4s;\n}\n.ccBIM .setting-switch.setting-switch-anim:before {\n  transition: left 0.3s;\n}\n.ccBIM .setting-switch.setting-switch-anim:checked {\n  box-shadow: #00b589 0 0 0 16px inset;\n  background-color: #00b589;\n  transition: border ease 0.4s, box-shadow ease 0.4s, background-color ease 1.2s;\n}\n.ccBIM .setting-switch.setting-switch-anim:checked:before {\n  transition: left 0.3s;\n}\n\n/* radio */\n.ccBIM label.setting-radios-label {\n  font-size: 14px;\n  margin-right: 15px;\n  cursor: pointer;\n}\n.ccBIM label.setting-radios-label input {\n  position: absolute;\n  opacity: 0;\n  visibility: hidden;\n}\n\n.ccBIM label.setting-radios-label .setting-radios {\n  display: inline-block;\n  position: relative;\n  width: 13px;\n  height: 13px;\n  background: #FFFFFF;\n  border: 1px solid #979797;\n  border-radius: 50%;\n  vertical-align: -2px;\n  margin-right: 5px;\n}\n\n.ccBIM label.setting-radios-label input:checked + .setting-radios:after {\n  position: absolute;\n  content: \"\";\n  width: 7px;\n  height: 7px;\n  background-color: #fff;\n  border-radius: 50%;\n  top: 3px;\n  left: 3px;\n}\n\n.ccBIM label.setting-radios-label input:checked + .setting-radios {\n  background: #00B066;\n  border: 1px solid #00B066;\n}\n\n.ccBIM label.setting-radios-label input:disabled + .setting-radios {\n  background-color: #e8e8e8;\n  border: solid 1px #979797;\n}\n\n.ccBIM label.setting-radios-label input:disabled:checked + .setting-radios:after {\n  background-color: #c1c1c1;\n}\n\n.ccBIM label.setting-radios-label.setting-radios-anim .setting-radios {\n  -webkit-transition: background-color ease-out .3s;\n  transition: background-color ease-out .3s;\n}\n\n/**/\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .35s;\n}\n.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {\n  opacity: 0;\n}\n", ""]);

// exports


/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, ".ccBIM  .pbim-dwg-coordinates{\n  position: absolute;\n  background: #fff;\n  border-radius: 4px;\n  padding: 10px;\n}\n", ""]);

// exports


/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, ".ccBIM .pbim-viewMnin-com {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n.ccBIM .pbim-viewMnin-com .icon{\n  color: #fff;\n  cursor: pointer;\n}\n.ccBIM .pbim-viewMnin-com .dwgMini{\n  display: flex;\n  text-align: right;\n  position: absolute;\n  right: 0;\n  top: -2rem;\n}\n\n.ccBIM .pbim-viewMnin-com .pbim-viewMnin{\n  border: 4px #ddd solid;\n  width: 396px;\n  height: 200px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  overflow: auto;\n}\n", ""]);

// exports


/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, "html,body {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100%;\n}\n.ccBIM {\n  position: relative;\n  overflow: hidden;\n  moz-user-select: -moz-none;\n  -moz-user-select: none;\n  -o-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.ccBIM ul, .ccBIM p, .ccBIM pre{\n  margin: 0;\n  padding: 0;\n}\n\n.ccBIM li{\n  list-style-position: inside;\n  padding-left:0\n}\n\n.ccBIM .icon {\n  width: 2em; height: 2em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n  color: #666666\n}\n.ccBIM .icon:hover {\n  color: #00b589;\n}\n\n/**/\n.ccBIM .handle-box {\n  position: absolute;\n  text-align: center;\n  bottom: 0;\n  width: 100%;\n}\n.ccBIM .handle-box .handle{\n  text-align: center;\n  height: 70px;\n  padding: 15px 0;\n  box-sizing: border-box;\n  background: #fff;\n  border-right: 1px #ededed solid;\n  box-shadow: 0 -1px 5px rgba(221, 221, 221, 0.5);\n}\n.ccBIM .handle-box .localLoad input{\n  width: 0;\n  height:0;\n  visibility: hidden;\n}\n.ccBIM .handle-box .handle div{\n  display: inline-block;\n  margin-right: 70px;\n  cursor: pointer;\n  position: relative;\n}\n.ccBIM .handle-box .handle p{\n  line-height: 16px;\n}\n.ccBIM .handle-box .handle div:last-child{\n  margin-right: 0;\n}\n.ccBIM .handle-box .handle .hover{\n  color: #00b589;\n}\n.ccBIM .handle-box .handle .hover .icon{\n  color: #00b589;\n}\n.ccBIM .handle-box .handle div .profile {\n  position: absolute;\n  left: 50%;\n  bottom: 50%;\n  transform: translate(-50%, -50%);\n  background-color: #fff;\n  border-radius: 5px;\n  box-shadow: 0 0 10px #666;\n  display: none;\n}\n.ccBIM .handle-box .handle div:hover > .profile {\n  display: block;\n}\n.ccBIM .handle-box .handle div .profile:after, .ccBIM .handle-box .handle div .profile:before {\n  border: solid transparent;\n  content: ' ';\n  height: 0;\n  top: 100%;\n  position: absolute;\n  width: 0;\n}\n\n.ccBIM .handle-box .handle div .profile:after {\n  border-width: 10px;\n  border-top-color: #fff;\n  left: 41px;\n}\n\n.ccBIM .handle-box .handle div .profile:before {\n  border-width: 11px;\n  border-top-color: #999;\n  left: 40px;\n}\n.ccBIM .handle-box .handle div .profile ul li {\n  list-style: none;\n  color: #333;\n  padding: 8px 15px;\n  width: 80px;\n}\n.ccBIM .handle-box .handle div .profile ul li.hover {\n  background-color: #00b589;\n  color: #fff;\n}\n.ccBIM .handle-box .handle div .profile ul li.disable {\n  cursor: no-drop;\n}\n.ccBIM .handle-box .handle div .profile ul li:nth-child(1) {\n  border-top-left-radius: 5px;\n  border-top-right-radius: 5px;\n  border-bottom: 1px solid #eee;\n}\n.ccBIM .handle-box .handle div .profile ul li:nth-child(2) {\n  border-bottom-left-radius: 5px;\n  border-bottom-right-radius: 5px;\n}\n\n/**/\n.ccBIM .pbim-error{\n  height: 100vh;\n  text-align: center;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: #fff;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.ccBIM .pbim-error p{\n  margin-top: 50px;\n  font-size: 20px;\n}\n.ccBIM .pbim-error a {\n  color: #00b589;\n}\n\n/**/\n.ccBIM .rightPopupMenu {\n  position: absolute;\n  background-color: rgba(0,0,0,0.3);\n  color: #fff;\n  padding: 6px 2px;\n  border-radius: 5px;\n}\n.ccBIM .rightPopupMenu ul li.contextMenu{\n  list-style: none;\n  font-size: 14px;\n  padding: 5px 15px;\n  border: 1px solid #fff;\n  border-radius: 2px;\n  text-align: center;\n  cursor: pointer;\n  background-color: rgba(0,0,0,0.3);\n}\n.ccBIM .rightPopupMenu ul li.contextMenu:hover {\n  background-color: rgba(0,0,0,0.6);\n}\n\n/**/\n.ccBIM .point-dom{\n  background-size: 100%;\n  background-repeat: no-repeat;\n  width: 31px;\n  height: 38px;\n  position: absolute;\n  line-height: 32px;\n  text-align: center;\n  opacity: .5;\n  cursor: pointer;\n  background-color: transparent!important;\n}\n.ccBIM .point-label {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  top: -120%;\n  background-color: #2997b0;\n  padding: 6px 9px;\n  color: #fff;\n  width: 80px;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  text-align: center;\n}\n.ccBIM .point-label.warning {\n  background-color: red;\n}\n.ccBIM .point-dom-color{\n  width: 27px;\n  height: 27px;\n  line-height: 32px;\n  text-align: center;\n  cursor: pointer;\n  opacity: .7;\n  border-radius: 80% 0 55% 50% / 55% 0 80% 50%;\n  border: 2px solid #fff;\n  transform: rotate(131deg);\n  background-image: none!important;\n}\n.ccBIM .point-text{\n  color: #fff;\n  position: absolute;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  top: 50%;\n}\n.ccBIM .point-image{\n  position: absolute;\n  width: 200px;\n  height: 140px;\n  background: #fff;\n  border-radius: 4px;\n  padding: 10px;\n  overflow: hidden;\n}\n.ccBIM .point-image img{\n  width: 100%;\n}\n\n/**/\n.ccBIM .pbim-progress{\n  text-align: center;\n  position: absolute;\n  left: 50%;\n  margin-left: -100px;\n  bottom: 10%;\n}\n.ccBIM .pbim-progress-com{\n  width: 200px;\n  height: 15px;\n  overflow: hidden;\n  border-radius: 10px;\n  border: 1px #00b589 solid;\n}\n.ccBIM .pbim-progress-div{\n  height: 15px;\n  font-size: 14px;\n  background-color: #00b589;\n  color: #fff;\n}\n.ccBIM .pbim-small-progress{\n  text-align: center;\n  position: absolute;\n  left: 2%;\n  bottom: 80px;\n}\n.ccBIM .pbim-small-progress-com{\n  width: 200px;\n  height: 3px;\n  overflow: hidden;\n  border-radius: 20px;\n  border: 1px #00b589 solid;\n}\n.ccBIM .pbim-small-progress-div{\n  height: 3px;\n  font-size: 14px;\n  background-color: #00b589;\n  color: #fff;\n}\n\n/**/\n.ccBIM .pbim-point-image{\n  z-index: 10;\n  position: absolute;\n  top: 0;\n  left: 0;\n  background: #fff;\n  text-align: center;\n}\n.ccBIM .pbim-point-image img{\n  height: 100%;\n  margin: 0 auto;\n  text-align: center;\n  vertical-align: middle\n}\n.ccBIM .pbim-point-image .point-x{\n  position: absolute;\n  right: 20px;\n  top: 20px;\n  line-height: 28px;\n  text-align: center;\n  width: 30px;\n  height: 30px;\n  border-radius: 50%;\n  background: #f7f7f7;\n  cursor: pointer;\n}\n\n/*!* Custom, iPhone Retina *!*/\n/*@media only screen and (min-width : 320px) { }*/\n\n/*!* Extra Small Devices, Phones *!*/\n/*@media only screen and (min-width : 480px) { }*/\n\n/*!* Small Devices, Tablets *!*/\n@media only screen and (min-width : 768px) {\n  .ccBIM .handle-box .handle div:hover{\n    color: #00b589;\n  }\n  .ccBIM .handle-box .handle div .profile ul li:hover {\n    background-color: #00b589;\n    color: #fff;\n  }\n}\n\n/* Medium Devices, Desktops */\n/*@media only screen and (min-width : 992px) { }*/\n\n/* Large Devices, Wide Screens */\n/*@media only screen and (min-width : 1200px) { }*/\n", ""]);

// exports


/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(32)(false);
// imports


// module
exports.push([module.i, ".ccBIM .panoramaMenu {\n  position: absolute;\n  bottom: 15px;\n  width: 100%;\n  display: flex;\n}\n.ccBIM .panoramaMenu .menuBtn {\n\n}\n.ccBIM .panoramaMenu .menuBtn .menuIcon {\n  width: 1.2em;\n  height: 1.2em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n  color: #FFF\n}\n.ccBIM .panoramaMenu .menuBtn .switch {\n  width: 30px;\n  height: 30px;\n  background-color: rgba(0, 0, 0, 0.3);\n  border-radius: 50%;\n  margin: 12px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.ccBIM .panoramaMenu .menuBtn .switch.on {\n  background-color: rgb(0, 181, 137);\n}\n.ccBIM .panoramaMenu .menuBtn .switch.hover {\n  background-color: rgb(7, 152, 116);\n}\n\n.ccBIM .panoramaMenu .imgList {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  overflow-x: auto;\n  overflow-y: hidden;\n  background-color: rgba(0, 0, 0, 0.3);\n}\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 2s\n}\n.fade-enter, .fade-leave-to /* .fade-leave-active, 2.1.8  */ {\n  opacity: 0\n}\n.ccBIM .panoramaMenu li {\n  height: 80px;\n  list-style: none;\n  border: 2px solid #fff;\n  margin: 6px;\n  cursor: pointer;\n}\n.ccBIM .panoramaMenu li.on {\n  border: 2px solid #e1823c;\n}\n.ccBIM .panoramaMenu li img{\n  height: 80px;\n  width: 80px;\n}\n.ccBIM .panoramaMenu li p{\n  position: relative;\n  bottom: 23px;\n  color: #fff;\n  font-size: 14px;\n  width: 80px;\n  overflow: hidden;\n  text-align: center;\n  background-color: rgba(0,0,0,0.3);\n}\n.ccBIM .panoramaMenu li span{\n  display: none;\n  position: absolute;\n  top: -30px;\n  background-color: rgba(0,0,0,0.4);\n  color: #fff;\n  width: 80px;\n  text-align: center;\n  border-radius: 4px;\n  font-size: 16px;\n  padding: 2px 0;\n}\n.ccBIM .panoramaMenu li:hover span{\n  display: block;\n}\n\n\n.ccBIM .panoramaLoading {\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.ccBIM .panoramaLoading .loading {\n  width: 4px;\n  height: 4px;\n  border-radius: 2px;\n  background: #68b2ce;\n  position: absolute;\n  animation: loading linear 0.8s infinite;\n  -webkit-animation: loading linear 0.8s infinite;\n}\n.ccBIM .panoramaLoading .loading:nth-child(1){\n  left: 24px;\n  top: 2px;\n  animation-delay:0s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(2){\n  left: 40px;\n  top: 8px;\n  animation-delay:0.1s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(3){\n  left: 47px;\n  top: 24px;\n  animation-delay:0.1s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(4){\n  left: 40px;\n  top: 40px;\n  animation-delay:0.2s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(5){\n  left: 24px;\n  top: 47px;\n  animation-delay:0.4s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(6){\n  left: 8px;\n  top: 40px;\n  animation-delay:0.5s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(7){\n  left: 2px;\n  top: 24px;\n  animation-delay:0.6s;\n}\n.ccBIM .panoramaLoading .loading:nth-child(8){\n  left: 8px;\n  top: 8px;\n  animation-delay:0.7s;\n}\n@keyframes loading {\n  0%,40%,100% {transform: scale(1);}\n  20% {transform: scale(3);}\n}\n@-webkit-keyframes loading {\n  0%,40%,100% {transform: scale(1);}\n  20% {transform: scale(3);}\n}\n", ""]);

// exports


/***/ }),
/* 608 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():"function"==typeof define&&define.amd?define("nipplejs",[],i):"object"==typeof exports?exports.nipplejs=i():t.nipplejs=i()}(window,function(){return function(t){var i={};function e(o){if(i[o])return i[o].exports;var n=i[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,e),n.l=!0,n.exports}return e.m=t,e.c=i,e.d=function(t,i,o){e.o(t,i)||Object.defineProperty(t,i,{enumerable:!0,get:o})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,i){if(1&i&&(t=e(t)),8&i)return t;if(4&i&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(e.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&i&&"string"!=typeof t)for(var n in t)e.d(o,n,function(i){return t[i]}.bind(null,n));return o},e.n=function(t){var i=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(i,"a",i),i},e.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},e.p="",e(e.s=0)}([function(t,i,e){"use strict";e.r(i);var o,n=function(t,i){var e=i.x-t.x,o=i.y-t.y;return Math.sqrt(e*e+o*o)},s=function(t){return t*(Math.PI/180)},r=function(t){return t*(180/Math.PI)},d=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.addEventListener?t.addEventListener(o,e,!1):t.attachEvent&&t.attachEvent(o,e)},a=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.removeEventListener?t.removeEventListener(o,e):t.detachEvent&&t.detachEvent(o,e)},p=function(t){return t.preventDefault(),t.type.match(/^touch/)?t.changedTouches:t},c=function(){return{x:void 0!==window.pageXOffset?window.pageXOffset:(document.documentElement||document.body.parentNode||document.body).scrollLeft,y:void 0!==window.pageYOffset?window.pageYOffset:(document.documentElement||document.body.parentNode||document.body).scrollTop}},h=function(t,i){i.top||i.right||i.bottom||i.left?(t.style.top=i.top,t.style.right=i.right,t.style.bottom=i.bottom,t.style.left=i.left):(t.style.left=i.x+"px",t.style.top=i.y+"px")},l=function(t,i,e){var o=u(t);for(var n in o)if(o.hasOwnProperty(n))if("string"==typeof i)o[n]=i+" "+e;else{for(var s="",r=0,d=i.length;r<d;r+=1)s+=i[r]+" "+e+", ";o[n]=s.slice(0,-2)}return o},u=function(t){var i={};i[t]="";return["webkit","Moz","o"].forEach(function(e){i[e+t.charAt(0).toUpperCase()+t.slice(1)]=""}),i},f=function(t,i){for(var e in i)i.hasOwnProperty(e)&&(t[e]=i[e]);return t},y=function(t,i){if(t.length)for(var e=0,o=t.length;e<o;e+=1)i(t[e]);else i(t)},m=!!("ontouchstart"in window),v=!!window.PointerEvent,g=!!window.MSPointerEvent,b={start:"mousedown",move:"mousemove",end:"mouseup"},x={};function O(){}v?o={start:"pointerdown",move:"pointermove",end:"pointerup, pointercancel"}:g?o={start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:m?(o={start:"touchstart",move:"touchmove",end:"touchend, touchcancel"},x=b):o=b,O.prototype.on=function(t,i){var e,o=t.split(/[ ,]+/g);this._handlers_=this._handlers_||{};for(var n=0;n<o.length;n+=1)e=o[n],this._handlers_[e]=this._handlers_[e]||[],this._handlers_[e].push(i);return this},O.prototype.off=function(t,i){return this._handlers_=this._handlers_||{},void 0===t?this._handlers_={}:void 0===i?this._handlers_[t]=null:this._handlers_[t]&&this._handlers_[t].indexOf(i)>=0&&this._handlers_[t].splice(this._handlers_[t].indexOf(i),1),this},O.prototype.trigger=function(t,i){var e,o=this,n=t.split(/[ ,]+/g);o._handlers_=o._handlers_||{};for(var s=0;s<n.length;s+=1)e=n[s],o._handlers_[e]&&o._handlers_[e].length&&o._handlers_[e].forEach(function(t){t.call(o,{type:e,target:o},i)})},O.prototype.config=function(t){this.options=this.defaults||{},t&&(this.options=function(t,i){var e={};for(var o in t)t.hasOwnProperty(o)&&i.hasOwnProperty(o)?e[o]=i[o]:t.hasOwnProperty(o)&&(e[o]=t[o]);return e}(this.options,t))},O.prototype.bindEvt=function(t,i){var e=this;return e._domHandlers_=e._domHandlers_||{},e._domHandlers_[i]=function(){"function"==typeof e["on"+i]?e["on"+i].apply(e,arguments):console.warn('[WARNING] : Missing "on'+i+'" handler.')},d(t,o[i],e._domHandlers_[i]),x[i]&&d(t,x[i],e._domHandlers_[i]),e},O.prototype.unbindEvt=function(t,i){return this._domHandlers_=this._domHandlers_||{},a(t,o[i],this._domHandlers_[i]),x[i]&&a(t,x[i],this._domHandlers_[i]),delete this._domHandlers_[i],this};var _=O;function w(t,i){return this.identifier=i.identifier,this.position=i.position,this.frontPosition=i.frontPosition,this.collection=t,this.defaults={size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,mode:"dynamic",zone:document.body,lockX:!1,lockY:!1},this.config(i),"dynamic"===this.options.mode&&(this.options.restOpacity=0),this.id=w.id,w.id+=1,this.buildEl().stylize(),this.instance={el:this.ui.el,on:this.on.bind(this),off:this.off.bind(this),show:this.show.bind(this),hide:this.hide.bind(this),add:this.addToDom.bind(this),remove:this.removeFromDom.bind(this),destroy:this.destroy.bind(this),resetDirection:this.resetDirection.bind(this),computeDirection:this.computeDirection.bind(this),trigger:this.trigger.bind(this),position:this.position,frontPosition:this.frontPosition,ui:this.ui,identifier:this.identifier,id:this.id,options:this.options},this.instance}w.prototype=new _,w.constructor=w,w.id=0,w.prototype.buildEl=function(t){return this.ui={},this.options.dataOnly?this:(this.ui.el=document.createElement("div"),this.ui.back=document.createElement("div"),this.ui.front=document.createElement("div"),this.ui.el.className="nipple collection_"+this.collection.id,this.ui.back.className="back",this.ui.front.className="front",this.ui.el.setAttribute("id","nipple_"+this.collection.id+"_"+this.id),this.ui.el.appendChild(this.ui.back),this.ui.el.appendChild(this.ui.front),this)},w.prototype.stylize=function(){if(this.options.dataOnly)return this;var t=this.options.fadeTime+"ms",i=function(t,i){var e=u(t);for(var o in e)e.hasOwnProperty(o)&&(e[o]=i);return e}("borderRadius","50%"),e=l("transition","opacity",t),o={};return o.el={position:"absolute",opacity:this.options.restOpacity,display:"block",zIndex:999},o.back={position:"absolute",display:"block",width:this.options.size+"px",height:this.options.size+"px",marginLeft:-this.options.size/2+"px",marginTop:-this.options.size/2+"px",background:this.options.color,opacity:".5"},o.front={width:this.options.size/2+"px",height:this.options.size/2+"px",position:"absolute",display:"block",marginLeft:-this.options.size/4+"px",marginTop:-this.options.size/4+"px",background:this.options.color,opacity:".5"},f(o.el,e),f(o.back,i),f(o.front,i),this.applyStyles(o),this},w.prototype.applyStyles=function(t){for(var i in this.ui)if(this.ui.hasOwnProperty(i))for(var e in t[i])this.ui[i].style[e]=t[i][e];return this},w.prototype.addToDom=function(){return this.options.dataOnly||document.body.contains(this.ui.el)?this:(this.options.zone.appendChild(this.ui.el),this)},w.prototype.removeFromDom=function(){return this.options.dataOnly||!document.body.contains(this.ui.el)?this:(this.options.zone.removeChild(this.ui.el),this)},w.prototype.destroy=function(){clearTimeout(this.removeTimeout),clearTimeout(this.showTimeout),clearTimeout(this.restTimeout),this.trigger("destroyed",this.instance),this.removeFromDom(),this.off()},w.prototype.show=function(t){var i=this;return i.options.dataOnly?i:(clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.addToDom(),i.restCallback(),setTimeout(function(){i.ui.el.style.opacity=1},0),i.showTimeout=setTimeout(function(){i.trigger("shown",i.instance),"function"==typeof t&&t.call(this)},i.options.fadeTime),i)},w.prototype.hide=function(t){var i=this;return i.options.dataOnly?i:(i.ui.el.style.opacity=i.options.restOpacity,clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.removeTimeout=setTimeout(function(){var e="dynamic"===i.options.mode?"none":"block";i.ui.el.style.display=e,"function"==typeof t&&t.call(i),i.trigger("hidden",i.instance)},i.options.fadeTime),i.options.restJoystick&&i.restPosition(),i)},w.prototype.restPosition=function(t){var i=this;i.frontPosition={x:0,y:0};var e=i.options.fadeTime+"ms",o={};o.front=l("transition",["top","left"],e);var n={front:{}};n.front={left:i.frontPosition.x+"px",top:i.frontPosition.y+"px"},i.applyStyles(o),i.applyStyles(n),i.restTimeout=setTimeout(function(){"function"==typeof t&&t.call(i),i.restCallback()},i.options.fadeTime)},w.prototype.restCallback=function(){var t={};t.front=l("transition","none",""),this.applyStyles(t),this.trigger("rested",this.instance)},w.prototype.resetDirection=function(){this.direction={x:!1,y:!1,angle:!1}},w.prototype.computeDirection=function(t){var i,e,o,n=t.angle.radian,s=Math.PI/4,r=Math.PI/2;if(n>s&&n<3*s&&!t.lockX?i="up":n>-s&&n<=s&&!t.lockY?i="left":n>3*-s&&n<=-s&&!t.lockX?i="down":t.lockY||(i="right"),t.lockY||(e=n>-r&&n<r?"left":"right"),t.lockX||(o=n>0?"up":"down"),t.force>this.options.threshold){var d,a={};for(d in this.direction)this.direction.hasOwnProperty(d)&&(a[d]=this.direction[d]);var p={};for(d in this.direction={x:e,y:o,angle:i},t.direction=this.direction,a)a[d]===this.direction[d]&&(p[d]=!0);if(p.x&&p.y&&p.angle)return t;p.x&&p.y||this.trigger("plain",t),p.x||this.trigger("plain:"+e,t),p.y||this.trigger("plain:"+o,t),p.angle||this.trigger("dir dir:"+i,t)}return t};var T=w;function k(t,i){return this.nipples=[],this.idles=[],this.actives=[],this.ids=[],this.pressureIntervals={},this.manager=t,this.id=k.id,k.id+=1,this.defaults={zone:document.body,multitouch:!1,maxNumberOfNipples:10,mode:"dynamic",position:{top:0,left:0},catchDistance:200,size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,lockX:!1,lockY:!1},this.config(i),"static"!==this.options.mode&&"semi"!==this.options.mode||(this.options.multitouch=!1),this.options.multitouch||(this.options.maxNumberOfNipples=1),this.updateBox(),this.prepareNipples(),this.bindings(),this.begin(),this.nipples}k.prototype=new _,k.constructor=k,k.id=0,k.prototype.prepareNipples=function(){var t=this.nipples;t.on=this.on.bind(this),t.off=this.off.bind(this),t.options=this.options,t.destroy=this.destroy.bind(this),t.ids=this.ids,t.id=this.id,t.processOnMove=this.processOnMove.bind(this),t.processOnEnd=this.processOnEnd.bind(this),t.get=function(i){if(void 0===i)return t[0];for(var e=0,o=t.length;e<o;e+=1)if(t[e].identifier===i)return t[e];return!1}},k.prototype.bindings=function(){this.bindEvt(this.options.zone,"start"),this.options.zone.style.touchAction="none",this.options.zone.style.msTouchAction="none"},k.prototype.begin=function(){var t=this.options;if("static"===t.mode){var i=this.createNipple(t.position,this.manager.getIdentifier());i.add(),this.idles.push(i)}},k.prototype.createNipple=function(t,i){var e=c(),o={},n=this.options;if(t.x&&t.y)o={x:t.x-(e.x+this.box.left),y:t.y-(e.y+this.box.top)};else if(t.top||t.right||t.bottom||t.left){var s=document.createElement("DIV");s.style.display="hidden",s.style.top=t.top,s.style.right=t.right,s.style.bottom=t.bottom,s.style.left=t.left,s.style.position="absolute",n.zone.appendChild(s);var r=s.getBoundingClientRect();n.zone.removeChild(s),o=t,t={x:r.left+e.x,y:r.top+e.y}}var d=new T(this,{color:n.color,size:n.size,threshold:n.threshold,fadeTime:n.fadeTime,dataOnly:n.dataOnly,restJoystick:n.restJoystick,restOpacity:n.restOpacity,mode:n.mode,identifier:i,position:t,zone:n.zone,frontPosition:{x:0,y:0}});return n.dataOnly||(h(d.ui.el,o),h(d.ui.front,d.frontPosition)),this.nipples.push(d),this.trigger("added "+d.identifier+":added",d),this.manager.trigger("added "+d.identifier+":added",d),this.bindNipple(d),d},k.prototype.updateBox=function(){this.box=this.options.zone.getBoundingClientRect()},k.prototype.bindNipple=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},k.prototype.pressureFn=function(t,i,e){var o=this,n=0;clearInterval(o.pressureIntervals[e]),o.pressureIntervals[e]=setInterval(function(){var e=t.force||t.pressure||t.webkitForce||0;e!==n&&(i.trigger("pressure",e),o.trigger("pressure "+i.identifier+":pressure",e),n=e)}.bind(o),100)},k.prototype.onstart=function(t){var i=this,e=i.options,o=t;t=p(t),i.updateBox();return y(t,function(n){i.actives.length<e.maxNumberOfNipples?i.processOnStart(n):o.type.match(/^touch/)&&(Object.keys(i.manager.ids).forEach(function(e){if(Object.values(o.touches).findIndex(function(t){return t.identifier===e})<0){var n=[t[0]];n.identifier=e,i.processOnEnd(n)}}),i.actives.length<e.maxNumberOfNipples&&i.processOnStart(n))}),i.manager.bindDocument(),!1},k.prototype.processOnStart=function(t){var i,e=this,o=e.options,s=e.manager.getIdentifier(t),r=t.force||t.pressure||t.webkitForce||0,d={x:t.pageX,y:t.pageY},a=e.getOrCreate(s,d);a.identifier!==s&&e.manager.removeIdentifier(a.identifier),a.identifier=s;var p=function(i){i.trigger("start",i),e.trigger("start "+i.id+":start",i),i.show(),r>0&&e.pressureFn(t,i,i.identifier),e.processOnMove(t)};if((i=e.idles.indexOf(a))>=0&&e.idles.splice(i,1),e.actives.push(a),e.ids.push(a.identifier),"semi"!==o.mode)p(a);else{if(!(n(d,a.position)<=o.catchDistance))return a.destroy(),void e.processOnStart(t);p(a)}return a},k.prototype.getOrCreate=function(t,i){var e,o=this.options;return/(semi|static)/.test(o.mode)?(e=this.idles[0])?(this.idles.splice(0,1),e):"semi"===o.mode?this.createNipple(i,t):(console.warn("Coudln't find the needed nipple."),!1):e=this.createNipple(i,t)},k.prototype.processOnMove=function(t){var i=this.options,e=this.manager.getIdentifier(t),o=this.nipples.get(e);if(!o)return console.error("Found zombie joystick with ID "+e),void this.manager.removeIdentifier(e);o.identifier=e;var d,a,p,c,l,u,f,y,m=o.options.size/2,v={x:t.pageX,y:t.pageY},g=n(v,o.position),b=(d=v,a=o.position,p=a.x-d.x,c=a.y-d.y,r(Math.atan2(c,p))),x=s(b),O=g/m,_={distance:g,position:v};g>m&&(g=m,l=o.position,u=g,y={x:0,y:0},f=s(f=b),y.x=l.x-u*Math.cos(f),y.y=l.y-u*Math.sin(f),v=y);var w=v.x-o.position.x,T=v.y-o.position.y;i.lockX&&(T=0),i.lockY&&(w=0),o.frontPosition={x:w,y:T},i.dataOnly||h(o.ui.front,o.frontPosition);var k={identifier:o.identifier,position:v,force:O,pressure:t.force||t.pressure||t.webkitForce||0,distance:g,angle:{radian:x,degree:b},raw:_,instance:o,lockX:i.lockX,lockY:i.lockY};(k=o.computeDirection(k)).angle={radian:s(180-b),degree:180-b},o.trigger("move",k),this.trigger("move "+o.id+":move",k)},k.prototype.processOnEnd=function(t){var i=this,e=i.options,o=i.manager.getIdentifier(t),n=i.nipples.get(o),s=i.manager.removeIdentifier(n.identifier);n&&(e.dataOnly||n.hide(function(){"dynamic"===e.mode&&(n.trigger("removed",n),i.trigger("removed "+n.id+":removed",n),i.manager.trigger("removed "+n.id+":removed",n),n.destroy())}),clearInterval(i.pressureIntervals[n.identifier]),n.resetDirection(),n.trigger("end",n),i.trigger("end "+n.id+":end",n),i.ids.indexOf(n.identifier)>=0&&i.ids.splice(i.ids.indexOf(n.identifier),1),i.actives.indexOf(n)>=0&&i.actives.splice(i.actives.indexOf(n),1),/(semi|static)/.test(e.mode)?i.idles.push(n):i.nipples.indexOf(n)>=0&&i.nipples.splice(i.nipples.indexOf(n),1),i.manager.unbindDocument(),/(semi|static)/.test(e.mode)&&(i.manager.ids[s.id]=s.identifier))},k.prototype.onDestroyed=function(t,i){this.nipples.indexOf(i)>=0&&this.nipples.splice(this.nipples.indexOf(i),1),this.actives.indexOf(i)>=0&&this.actives.splice(this.actives.indexOf(i),1),this.idles.indexOf(i)>=0&&this.idles.splice(this.idles.indexOf(i),1),this.ids.indexOf(i.identifier)>=0&&this.ids.splice(this.ids.indexOf(i.identifier),1),this.manager.removeIdentifier(i.identifier),this.manager.unbindDocument()},k.prototype.destroy=function(){for(var t in this.unbindEvt(this.options.zone,"start"),this.nipples.forEach(function(t){t.destroy()}),this.pressureIntervals)this.pressureIntervals.hasOwnProperty(t)&&clearInterval(this.pressureIntervals[t]);this.trigger("destroyed",this.nipples),this.manager.unbindDocument(),this.off()};var E=k;function P(t){var i,e=this;return e.ids={},e.index=0,e.collections=[],e.config(t),e.prepareCollections(),d(window,"resize",function(t){clearTimeout(i),i=setTimeout(function(){var t,i=c();e.collections.forEach(function(e){e.forEach(function(e){t=e.el.getBoundingClientRect(),e.position={x:i.x+t.left,y:i.y+t.top}})})},100)}),e.collections}P.prototype=new _,P.constructor=P,P.prototype.prepareCollections=function(){var t=this;t.collections.create=t.create.bind(t),t.collections.on=t.on.bind(t),t.collections.off=t.off.bind(t),t.collections.destroy=t.destroy.bind(t),t.collections.get=function(i){var e;return t.collections.every(function(t){return!(e=t.get(i))}),e}},P.prototype.create=function(t){return this.createCollection(t)},P.prototype.createCollection=function(t){var i=new E(this,t);return this.bindCollection(i),this.collections.push(i),i},P.prototype.bindCollection=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},P.prototype.bindDocument=function(){this.binded||(this.bindEvt(document,"move").bindEvt(document,"end"),this.binded=!0)},P.prototype.unbindDocument=function(t){Object.keys(this.ids).length&&!0!==t||(this.unbindEvt(document,"move").unbindEvt(document,"end"),this.binded=!1)},P.prototype.getIdentifier=function(t){var i;return t?void 0===(i=void 0===t.identifier?t.pointerId:t.identifier)&&(i=this.latest||0):i=this.index,void 0===this.ids[i]&&(this.ids[i]=this.index,this.index+=1),this.latest=i,this.ids[i]},P.prototype.removeIdentifier=function(t){var i={};for(var e in this.ids)if(this.ids[e]===t){i.id=e,i.identifier=this.ids[e],delete this.ids[e];break}return i},P.prototype.onmove=function(t){return this.onAny("move",t),!1},P.prototype.onend=function(t){return this.onAny("end",t),!1},P.prototype.oncancel=function(t){return this.onAny("end",t),!1},P.prototype.onAny=function(t,i){var e,o=this,n="processOn"+t.charAt(0).toUpperCase()+t.slice(1);i=p(i);return y(i,function(t){e=o.getIdentifier(t),y(o.collections,function(t,i,e){e.ids.indexOf(i)>=0&&(e[n](t),t._found_=!0)}.bind(null,t,e)),t._found_||o.removeIdentifier(e)}),!1},P.prototype.destroy=function(){this.unbindDocument(!0),this.ids={},this.index=0,this.collections.forEach(function(t){t.destroy()}),this.off()},P.prototype.onDestroyed=function(t,i){if(this.collections.indexOf(i)<0)return!1;this.collections.splice(this.collections.indexOf(i),1)};var I=new P;i.default={create:function(t){return I.create(t)},factory:I}}]).default});

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// full library entry point.


module.exports = __webpack_require__(614);


/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};


/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = module.exports = __webpack_require__(613);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = __webpack_require__(220);
protobuf.decoder          = __webpack_require__(219);
protobuf.verifier         = __webpack_require__(224);
protobuf.converter        = __webpack_require__(218);

// Reflection
protobuf.ReflectionObject = __webpack_require__(61);
protobuf.Namespace        = __webpack_require__(75);
protobuf.Root             = __webpack_require__(133);
protobuf.Enum             = __webpack_require__(27);
protobuf.Type             = __webpack_require__(135);
protobuf.Field            = __webpack_require__(49);
protobuf.OneOf            = __webpack_require__(86);
protobuf.MapField         = __webpack_require__(129);
protobuf.Service          = __webpack_require__(134);
protobuf.Method           = __webpack_require__(131);

// Runtime
protobuf.Message          = __webpack_require__(130);
protobuf.wrappers         = __webpack_require__(225);

// Utility
protobuf.types            = __webpack_require__(62);
protobuf.util             = __webpack_require__(11);

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);


/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(136);
protobuf.BufferWriter = __webpack_require__(619);
protobuf.Reader       = __webpack_require__(132);
protobuf.BufferReader = __webpack_require__(616);

// Utility
protobuf.util         = __webpack_require__(33);
protobuf.rpc          = __webpack_require__(222);
protobuf.roots        = __webpack_require__(221);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Set up buffer utility according to the environment
protobuf.Writer._configure(protobuf.BufferWriter);
configure();


/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = module.exports = __webpack_require__(612);

protobuf.build = "full";

// Parser
protobuf.tokenize         = __webpack_require__(223);
protobuf.parse            = __webpack_require__(615);
protobuf.common           = __webpack_require__(611);

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);


/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = __webpack_require__(223),
    Root      = __webpack_require__(133),
    Type      = __webpack_require__(135),
    Field     = __webpack_require__(49),
    MapField  = __webpack_require__(129),
    OneOf     = __webpack_require__(86),
    Enum      = __webpack_require__(27),
    Service   = __webpack_require__(134),
    Method    = __webpack_require__(131),
    types     = __webpack_require__(62),
    util      = __webpack_require__(11);

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            obj.comment = cmnt(); // try block-type comment
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && typeof obj.comment !== "string")
                obj.comment = cmnt(trailingLine); // try line-type comment if no block
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            token = peek();
            if (fqTypeRefRe.test(token)) {
                name += token;
                next();
            }
        }
        skip("=");
        parseOptionValue(parent, name);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            do {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                if (peek() === "{")
                    parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        parseOptionValue(parent, name + "." + token);
                    else
                        setOption(parent, name + "." + token, readValue(true));
                }
                skip(",", true);
            } while (!skip("}", true));
        } else
            setOption(parent, name, readValue(true));
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */


/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(132);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(33);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */


/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(33);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(33);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(136);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(33);

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */


/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(622);
var parse = __webpack_require__(621);
var formats = __webpack_require__(226);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(227);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(227);
var formats = __webpack_require__(226);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(624);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 624 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(599);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./floorStrong.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./floorStrong.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(600);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./model.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./model.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(601);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./modelMap.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./modelMap.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(602);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./roam.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./roam.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(603);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./setting.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./setting.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(604);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./dwg.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./dwg.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(605);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./dwgMiniMap.css", function() {
			var newContent = require("!!../../../node_modules/_css-loader@0.28.11@css-loader/index.js!./dwgMiniMap.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(607);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(34)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/_css-loader@0.28.11@css-loader/index.js!./panorama.css", function() {
			var newContent = require("!!../../node_modules/_css-loader@0.28.11@css-loader/index.js!./panorama.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 633 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 634 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACBElEQVRYR+3WP6hOcRzH8deNGPwtFsVikJTBwmAQ+TNRpIhBBlkoI6WQUhYpFt1BMmC5g0giwsSiDDJZsOqmDPK37+371PHc8zznOec83G7d3/T0nN/5/d7fz/fz/X7PiCleI1N8v7YAKzOA900DaQOwGs/y4k141wSiKcA6PMFnzMF8bMHruhBNADbiIT4gIp+VMCuwAx/xBgtLYM7hbPH/ugDbcRdvM+LxPGxxQqzBXqwqATiDVgB7cAcvsBNfuyKcl8pswD6MdT3/3QbgCK7hPgLke49cz02FtuEwbhT2NQY4hQu4jYP4VWG02biJ/TiOq7m/EcAVHMMojiIOGWSFt0KxUO4iTuJLGvDSICaMA67jUFneBiHIPedxOlMR7o/K+VkFEBKG2XZn1BF9mxUKhpJhyjDnj34AHRNtzXxH3oexQslQ9BF24Vvn0GIfWIAHWJ9OvzeMmwtnRPVEQK+yYU2UcQdgCZ4ihkvUePz+F2tzlnLMjWjd4wGwDM+xtGk/r0kaCj/Gp2jlARAmi7x0JlpsOIATNQ+u2n4Zt/ASa1PlsQBYlAMlJlusKJfo23XnRBVAdyNaHhVRdsn/ApgAnpYAf83zEt17PR94FlSloGoe9PLOUAEmfVgMYN4ZgBkFpp8C4fSyVfp5XaiCWu/164T9enu/Mqz13rAHTtVAmvT8Dzwqk+krV625AAAAAElFTkSuQmCC"

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(517),
  /* template */
  __webpack_require__(643),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(518),
  /* template */
  __webpack_require__(646),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(519),
  /* template */
  __webpack_require__(650),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(520),
  /* template */
  __webpack_require__(644),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(521),
  /* template */
  __webpack_require__(649),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(522),
  /* template */
  __webpack_require__(647),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(523),
  /* template */
  __webpack_require__(645),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(43)(
  /* script */
  __webpack_require__(524),
  /* template */
  __webpack_require__(648),
  /* scopeId */
  null,
  /* cssModules */
  null
)

module.exports = Component.exports


/***/ }),
/* 643 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "ccBIM"
  }, [_c('div', {
    staticClass: "handle-box"
  }, [(_vm.isLocalLoad) ? _c('div', {
    staticClass: "localLoad"
  }, [_c('label', [_c('input', {
    attrs: {
      "type": "file",
      "multiple": "multiple"
    },
    on: {
      "change": function($event) {
        if ($event.target !== $event.currentTarget) { return null; }
        return _vm.localLoad($event)
      }
    }
  }), _vm._v(" "), _c('svg', {
    staticClass: "icon",
    attrs: {
      "aria-hidden": "true"
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-upload"
    }
  })]), _vm._v(" "), _c('p', [_vm._v("")])])]) : _vm._e(), _vm._v(" "), (_vm.showHandle) ? _c('div', {
    staticClass: "handle"
  }, _vm._l((_vm.handleList), function(item) {
    return (item.show) ? _c('div', {
      class: {
        hover: item.hover
      },
      on: {
        "click": function($event) {
          return _vm.handleClick(item)
        }
      }
    }, [_c('svg', {
      staticClass: "icon",
      attrs: {
        "aria-hidden": "true"
      }
    }, [_c('use', {
      attrs: {
        "xlink:href": item.href
      }
    })]), _vm._v(" "), _c('p', [_vm._v(_vm._s(item.name))])]) : _vm._e()
  }), 0) : _vm._e()]), _vm._v(" "), (_vm.ccbimImage) ? _c('div', {
    staticClass: "pbim-point-image",
    style: ({
      'width': ((_vm.rect.w) + "px"),
      'line-height': ((_vm.rect.h) + "px"),
      'height': ((_vm.rect.h) + "px")
    })
  }, [_c('div', {
    staticClass: "point-x",
    on: {
      "click": function($event) {
        _vm.ccbimImage = ''
      }
    }
  }, [_c('i', {
    staticClass: "iconfont icon-x"
  })]), _vm._v(" "), _c('img', {
    attrs: {
      "src": _vm.ccbimImage
    }
  })]) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showFloorDiv),
      expression: "showFloorDiv"
    }],
    staticClass: "leftTreeModel"
  }, [_c('div', {
    staticClass: "header"
  }, [_c('span', {
    staticStyle: {
      "font-size": "14px"
    }
  }, [_vm._v("")]), _vm._v(" "), (_vm.stagesAll.length > 1) ? _c('div', {
    staticClass: "stageSelect"
  }, [_c('div', {
    staticClass: "selectOn",
    on: {
      "click": function($event) {
        _vm.showStagesAll = !_vm.showStagesAll
      }
    }
  }, [_c('span', [_vm._v(_vm._s(_vm.stageSelectOn ? _vm.stageSelectOn.stagename : _vm.stagesAll[0].stagename))]), _vm._v(" "), _c('svg', {
    staticClass: "selectIcon"
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-xiala"
    }
  })])]), _vm._v(" "), _c('ul', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showStagesAll),
      expression: "showStagesAll"
    }],
    staticClass: "selectList"
  }, _vm._l((_vm.stagesAll), function(item) {
    return _c('li', {
      on: {
        "click": function($event) {
          return _vm.controlStages(item)
        }
      }
    }, [_vm._v(_vm._s(item.stagename))])
  }), 0)]) : _vm._e(), _vm._v(" "), _c('svg', {
    staticClass: "tree-close",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.closeFloorDiv
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "searchBox"
  }, [_c('svg', {
    staticClass: "tree-search",
    attrs: {
      "title": ""
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-sousuo"
    }
  })]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.searchText),
      expression: "searchText"
    }],
    staticClass: "txtInput txtSearch",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.searchText)
    },
    on: {
      "keyup": function($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) { return null; }
        return _vm.inputSearch($event)
      },
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.searchText = $event.target.value
      }
    }
  }), _vm._v(" "), _c('svg', {
    staticClass: "tree-search",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.inputSearch
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-huiche"
    }
  })])]), _vm._v(" "), _c('treeStrong', {
    ref: "treeStrong",
    attrs: {
      "data": _vm.floorTree,
      "show-checkbox": "",
      "multiple": "",
      "whole-row": ""
    },
    on: {
      "item-checked-click": _vm.itemCheckedClick
    }
  })], 1), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isShowAllComType),
      expression: "isShowAllComType"
    }],
    staticClass: "showAllComType",
    on: {
      "click": function($event) {
        return _vm.showAllOpacityComType(true)
      }
    }
  }, [_vm._v("")]), _vm._v(" "), _c('div', {
    ref: "viewMap",
    staticClass: "pbim-viewMnin-com",
    style: ({
      bottom: (_vm.miniMapDomBottom + "px")
    })
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showMini),
      expression: "showMini"
    }],
    staticClass: "dwgMini",
    on: {
      "mouseenter": function($event) {
        _vm.showMini = true
      },
      "mouseleave": _vm.miniHandle
    }
  }, [_c('svg', {
    staticClass: "icon",
    attrs: {
      "aria-hidden": "true",
      "title": ""
    },
    on: {
      "click": _vm.resetDwgView
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-chongz"
    }
  })]), _vm._v(" "), (_vm.miniMapDom) ? _c('svg', {
    staticClass: "icon",
    attrs: {
      "aria-hidden": "true",
      "title": ""
    },
    on: {
      "click": function($event) {
        return _vm.miniMapDomShowHidden(false)
      }
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-shouqi"
    }
  })]) : _vm._e(), _vm._v(" "), (!_vm.miniMapDom) ? _c('svg', {
    staticClass: "icon",
    attrs: {
      "aria-hidden": "true",
      "title": ""
    },
    on: {
      "click": function($event) {
        return _vm.miniMapDomShowHidden(true)
      }
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-zhankai"
    }
  })]) : _vm._e()]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.miniMapDom),
      expression: "miniMapDom"
    }],
    ref: "viewMini",
    staticClass: "pbim-viewMnin",
    on: {
      "click": _vm.miniMapHandle,
      "mouseenter": function($event) {
        _vm.showMini = true
      },
      "mouseleave": function($event) {
        _vm.showMini = false
      }
    }
  })]), _vm._v(" "), (_vm.isCoordinate) ? _c('div', {
    staticClass: "pbim-dwg-coordinates",
    style: ({
      'top': ((_vm.client.mouseY) + "px"),
      'left': ((_vm.client.mouseX) + "px")
    })
  }, [_c('p', [_vm._v("x:" + _vm._s(_vm.client.coordinateX))]), _vm._v(" "), _c('p', [_vm._v("y:" + _vm._s(_vm.client.coordinateY))])]) : _vm._e(), _vm._v(" "), (_vm.showMark) ? _c('div', [_vm._l((_vm.pointList), function(item) {
    return _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.show),
        expression: "item.show"
      }],
      staticStyle: {
        "position": "absolute"
      },
      style: ({
        'left': ((item.left) + "px"),
        'top': ((item.top) + "px")
      })
    }, [(item.labelText) ? _c('label', {
      staticClass: "point-label",
      class: {
        warning: item.warning
      },
      attrs: {
        "title": item.labelText
      }
    }, [_vm._v(_vm._s(item.labelText))]) : _vm._e(), _vm._v(" "), _c('div', {
      class: [item.color ? 'point-dom-color' : 'point-dom'],
      style: ({
        'background-image': ("url(" + (item.iconImg) + ")"),
        'background-color': ("" + (item.color))
      }),
      on: {
        "mouseenter": function($event) {
          return _vm.showPointImage(item, $event)
        },
        "mouseleave": function($event) {
          _vm.isShowPointImage = false
        },
        "click": function($event) {
          return _vm.clickPointImg(item)
        }
      }
    }), _vm._v(" "), (item.iconText) ? _c('span', {
      staticClass: "point-text"
    }, [_vm._v(_vm._s(item.iconText))]) : _vm._e()])
  }), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isShowPointImage),
      expression: "isShowPointImage"
    }],
    staticClass: "point-image",
    style: ({
      top: (_vm.pointImageTop + "px"),
      left: (_vm.pointImageLeft + "px")
    })
  }, [(_vm.isPointImageSrc) ? _c('img', {
    attrs: {
      "src": _vm.pointImageSrc
    }
  }) : _vm._e(), _vm._v(" "), (_vm.isPointTextContent) ? _c('span', [_vm._v(_vm._s(_vm.pointTextContent))]) : _vm._e()])], 2) : _vm._e(), _vm._v(" "), (_vm.errorMsg) ? _c('div', {
    staticClass: "pbim-error"
  }, [_c('div', {
    staticClass: "noModelImgBox"
  }, [_c('img', {
    attrs: {
      "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK8AAADDCAYAAAD0pEFUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCOUVGQUNBQjVEOEYxMUU4OEE4RTkwNTA4RURGMzhFNiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCOUVGQUNBQzVEOEYxMUU4OEE4RTkwNTA4RURGMzhFNiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI5RUZBQ0E5NUQ4RjExRTg4QThFOTA1MDhFREYzOEU2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI5RUZBQ0FBNUQ4RjExRTg4QThFOTA1MDhFREYzOEU2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+79ZNvAAAFgxJREFUeNrsnQtwnFd1x88+9LQeq6clrR67eku2LCchcajtcUjjITQtnTCFTqAzJBkKpaUNtEAeDdCGdBICDbQxEBgGWlqSQhgyZBxKm5BA7JA6hBC/bcmWrNeu3rJkPazXbs//7l3580ayZXm1+3275585+XY/raXv8dv7nXvuuefagsEgicytp599PnLXe/X2OePOO26/Lamui1PQsKQ+sxy8ySa7cCCSlle03rqZrVa/LtHbj+rtKbaXBF6RWfX3GmCjvqW3Lwm8IjPr9w2v9+ntTvF5RSJpeUUx0qRcAoHXqnq/XAKBV1peC8smI2wi6bCJRAKvSCTwiqTDFj0tkx21aiVbxpTIZPCKEkdmaIjMAq9D21wC3uQs3nyS7S62PWxP8s2bSXC2c9nGk6Xl9ertqQSCNoU3f872IFup3v0426f4Z1/k7fcY4oUEhXcr26+SpcN2q7ZEgNbG9qf88hjb1wFuYb6Lrt/aQnkuNEhUwfZt/ByfY0u0TjOeoA/rbcLDizt6n7Zci4N7C29+w/ZfbLU52Vm0c9t1tHvXdqr1VtKt79pB22+4lnKyNuDjdfpzb/K/S6Te6D1sO/Q2od2GfLafsLn1+71sf8w2ajFor+XNo2y78T4jI51aGuupuqqcbDbbRZ+tdJdSRVkJdXT30pET7TQ9PdOK8+bf8SpvH2BX4hULg9uiW13S2xfYDicavID1dt3aug378Y09pEF4lq3P5NBiZgP8V7gJttSUFGqqr6GGGg85HCs/NQF0TVUFeSvc1N7ZRUdPnqLZ2bnt8BP5d/4cfjJD/FuLgfu3GtgM/R7bA9rnfzyR4E01RBhWijykmhhaTMP5HNtHcJwAtb66ipobagkAr9pns9sZdK8C+cSpTjrJNjc/D9//3fw3fszbzzPEJ0ze0u6i0HSklmV+DoD/me1O7ef/KpotcUwTc5aJDcJt+KlucaH9K7kNZhik4OPPptDM3U+xZaEF9VaWU0tTHWVmZFz175+dm6PjbR3U1nGGFhcXsQvRiP9g+wc+/26TfYEjG5x7IlpeaEa3vP/Cthjtexlvn3dUw3pIvzelv8s3Ck+Bj+sbUYh95aUltGVTA+VmZ0Xt76SlptLWzY3UUOtV/nBHV48zEAggPvwhPoYneftPfOMHTdgCL2rXAD7uProQ592ZiD5vJMBfNrw2E7SIxnxQ+7Ue7CsqyFeAFebnrdvfzUhPo+u3bqamumo6fLyNunp9qfyE/Bv+0d18TGjFvsIQnzUhxAD1L9l+oLeH1/OPmWWQ4nmz3QWG5D28eYQN0QDKzcmm1k2N5C4pjtkxZG3IpHe+Yys1cyfw0LGT1OsfQDOPWcQf5+N7jLdPMMTTJrt0P9RPqR+u9x8yC7ydFIOg9iqhvVFDexPeZ2Zm0JamevJUuN8W9oqV8MXZeeM7aGTsLB08epIGhobzdUTmHj5e+JnfYYjNMrS+qN2rxWSBdzEWJ3sZaBvhU1IohGeD/9ncUEP11R4VFTCDCvJcdPOObdQ/OKxaYoYZw84Yxfs0H/8X8LhmiAMmONS3YvFHkj6rjG96GXrzFEqccTodDtVhamR/80rCXrFUSXGhsl5/P0PcRuMT55Ab8n22e/l80Or9lCGO5/yu8Vj8kaSdw8Y32YWbrUM8GWrgwFNJmxvrVIfJKsL96+rxqY7d5PSS+/s6fGMG+MV1vH5r/rfRCpUlHbx80TN0T/h+PImxD0O2W5obKDuUc2BJBQIBOn2mh46ebKeZ87Ph3b/QEB9IxHuZNPDqsNeHtYtQiX0biwpo66ZGys9zJcx5YnDj5OkzdLz9NM3NzYd3YyAIQ85HBF7rgfteHUFoxvs8Vw61NjdS6caihD3nufl5OtHeoUBeWFBpw+jIPcX2BYa4Q+A1P7RIdvkSG7Yqbgr3AG5CvMJesdb52TnlSpzq7FauBYVmq3yX7SGG2C/wmg/aZt3SqvL36WmptIk7YrXcITNL2CvWmp6eocMn2qmzu5f0PUfewRNsjzHEIwJv/KGt1D4tfFu70+lUQ6yNtV7CaxHRxLlJFZno7ltqdDHMjLyErzLEkwJv7KEt0NEDRBEy0LrW6rBXWlqqELuMRs+Oq4EO/8BQeBdeYJAGE0RnBd71hxZhL8zM/SybC35sOOwF/1Z0eQ0OjzLEJ2hoZCy8C6mXD7H9u9kniFoSXoYWPsDd2kVQM3MROUAEAZEE0ZXL1z9IB7klPjs+Ed51ku3zbM/EebQuMeDFzFzevE8/3hqwDzFaxGoRsxVdncBCD/vCh9gnPjc5Fd79JtvnGOCfCbxrB/cmCmVSbcN7jIaFw16i6EPc0dVDR06coumZpfooSDLHBNH9Au+VgYuW9oHwe7S2N2/fRikpEkFYT2G07pX/e0NlsRn0KAN8vxmOzypBzwcv6imPnaW9L7yshkD16JEoykIU4sVXXjOCG65mdJ9ZjtES8Bo7DNdsbqDcnCw1cvTWkRP03P+8rKaOzwvEUdHw6Bj9Yt9r9Mtfv67Caay+onzXnlt23DBktmO13HO3kF0G2MjYOHX29NHY+DkVr8Q4PvJw62s8ps3DNbMQZcB17Otfmt85nO/K2bu1uWGzw2H/hBmP2bJOY0FerrLRsxPU0Q2IJ9TI0YlTHaoWAiw1VSC+nM5NTYVG3Hr94WHjybzc7P9uba5vSHE67zTzsVu+x8OtgzK0wIAYjzpMG0cBD7TCaI0xpUd0sWZmztORk+0qB1hDO5ubnfUSQ+tJS02xxFJZCdNd59aCrmtppLMTgNinJivCF0ZKYJ23khrralSCTrIrVNjkNLV1dC0VNsnekPlqa3OdOyM9/T1WOpeEizW5crLpWu7UjZ+bVC3x8OhZOt7eoW5WnbdKJeqkW2iaT7SEqAxKSsGtmp9XndvghsyMN7Y01hVnbcjYZcVzSthAKSrZXLOpgSYmpxTEGLvHjUNhuxpPBTVzS4xqjoku5PC28xf3aJsq5qf2cQt7tKWxxsXX6Horn1vCR/lRC3drcz13TKYVxIPDo8G202dsSM5WENfXRKXOmNmkRskulFFV+9ht6thUX52V78rdlAjnmDRDVOzXUWtTHU1OTds6e3zUPzQS5BbJhg4L6ug219cSP0YT4lyRq3v42En11IFSU1N8TTWe9OLC/OpEuqdJN76KVMmWxlqqrnTbOnr6aGBwJMitsA1j+d6KclWm1KrplBgVQ2bYWGhwgVKczuH66qqU0o2FZYk46SlpkwPQyrY0AOJyWye7E2iJT3f12PCoRWmnTfwzq0yFhz+PnFzk5qqb6nBM1Hoq7OWlxYWJPFcv6TNbNnCnbXNDDdVUuRliH/kGhwOd3b32M9wqV5WXKYhzoljGNJqKHBVz2O3TeKJUuktykmGunqRlaXEPnP3eavJWuu3sEwd9A0NBBtje1etTaZeAGAXvzCA1KnYsNA8NHTO7zTZXVV4a9FSUZTodjqS5ZwLv2yBOo+Y6rw0tGCDmVi3IANsBSnnpRjUvzpUbn9kakaNi7BIsVJSVBGsq3anJmB4q8K4gjMY11XoY4rIQxP7BQI+v38GmqqJv5k6fXldt3RU5KsZebMC9sShQXVXuTOZRQ4H3MkJeRGONx+atcDvO9PqCvQxxr7/fgQqNKDSNehAF61QuaplRMdpYmL9Y46lwsK9uT/Z7I/CuGuIUaqiuYojLGGJ/sMc3sMguhROdJUz+hDsRrVL/y42K8RckUOspt+dkbXDI3RB41yTkCtd7K22e8lJnV19/sLuvf8E/MJSCGCtq5gJirFuxFi03KubKyQ7WeipsebnZdrn6Am/UIK5jqBjilK5eQOxf6B8cTsG0meLCAgXxlcxojhwVy9qQGcTvL8x32eRqC7zrohSnk/hxbqsqL0nhVjjQxRAPDo+kvrR/RLXAgBgt8kqKHBXLzEinmqpygG8TagXemEHM0NmryktTATH7xfNDI6NpL796QPnCgNhYUjVyVAwdw+oqN7n5MzbBVuCNywV1OJA3Ya90l6Rxpy5wpsc3Nzw6lo4JjYhK1FVXqcIe4VExxGe95WVUUbYxaStYCrwmhNhbUWavLCtJ7/EPBDp7+mZHxs5mjPw2tPYf1iuucpcQt9SUTKNiAq+F5HDYiTt1dm5ZM7gVZoh9dqfTQduva5WiKQLv29XrH1SPZWSO8eNbJaTHHWJ2CdwlxXYkxOO1WcBF+f/uvgHy6VKnTXUeKlrHpWkF3ktocmqajp/qVK8RdvIPDqsp8h72K/OlguSSULSlqzfkey8GLqw7eKy9k3ZtE3jjouUq56BACQzz2jwVZVRUkEfJ2p+fnjlPaiYJf6kDuk5dmqpvYVM5FFaqGpqQs4cL811q1nCkMKP44LE25U6wH6rir/YkCUuhZCmgRWguqFBV04PUdlYveYVoR723SuCNlxAjxazhUDkon6qkE6mp6Rk62tZBp7t6ucdfqhJs0LFKRKEYC3cUaXjs7NL1SdXrc4TXaUO0o7y0WF0LK1UZStjubrgcFFpbQDw8MkbBZfy+kx1dhLlslWUlKtaakiALr+DJg/NGEZZwqwpI4Ragkwah0xjL877ckq9Xuqxrwsdq4Odi6jtaWz1r+G1+HdIN0Qqf4Q5MObfCiFBYMU8WZzXA54eWFlP9w9DiqRIMXIAW54bZIeUWf+IkTaARfi7mqtV6yrmX3f+2XjaERO+uPj8h4byU/WF07jItUJgEHS//wDB/+XyqQwYhHAdwA8HAUi4wzgW+Poap4+zru9m+wXYr288ptIpTn8B7GaWnpVFDTRV5K8sY0gFlkREKwNA3MKRin0WF+RgpM0WsOFKLiwH1JcQX7rzO+7UraG0U4JY2fF6oWYEv4kY+F5PkTXyPbbd+jYUeMSXlJoF3lUJKI7K3MDzb5wcA/SpUFPkYRu8clu/KVRCbIVYMKPGl6+YnRLhVRUtr09AuLCwuRV5wzIi+mEzvvMx7gXdVFwA5BgxwBfu5SE+E3xt+9BqF0qmwnOwNKpEGLXKs2zBEB9DKYgRxIVThMQQtt6ZwgYILAd1ZdTG0pZSXa9pBmdcMLW/4vcC7VsEHRMisjA0tLTo9ExeWc1rSxLkpOni8XYGBkqqxegz72KfFyKFe/Fp3tGzqfZANRwG3wGNSFydCH2H7lsHn/ZjAGwWFIYAhVoxOEKqvRwrxY4ShYtW6YeYwQLWrljbk76rj5Tdl3AFDR8xCtdawyuZV1wIWeC8hY6wYLfGQIVYMaGJZcT2c67vU8vJ7PCUArVXCelcaxxV4oyDEilt1rLibO0pYWA8uRizDaE21HpU0E+T/wrHoZF84Zl3hXWlEJdrfwFgJj2VAFA8hmWhXQZ60JMankVwCkcB7aT1MobDpw3LJRVaD956IrUhkGXj3RGxFIstEG+7XJhJZA16rRhVE4jaIRAKvSCTwigRekUjgXYMiE8ZFAq8VpBK69v/mIB0/dYZmzs/K3RN4LaNr2Z4JsHr9A/TqGwfpaNtpmlpm1oMo+po5b77rbJmUyN07t73Fmw+8sO9AE2/vDQaDH/INDDsxa7YYkyQr3WqioSi6whR65DIP6CLYrIDAu3aIj/PmTob4H3n7WfYl7uILm4aLW5TvUhDnmnS5VSsJM0U6e/w0MrZUNgudjf9ke8wsx2izSmG14eHhZfczxKgB8HdsH2VTk7cww9db4TZdVUhMT9/3+u/UzIedN1xjyuuM2SKdvT4an5gM78KLb7N9lRuOXuwoLCwUeKMBrwFiLPjwSba/olAdANNN/TYrvGCgX1famdRLaOGSsz3BtoehHTV+XuCNMrwGiAHuX1Mo/VJd5eysDQri4jhMVzczvJgu7+sPTfc/P7sUvcHkyMfZvsPQTi337wTedYLXADFcCEyp/jRbKfZhGg8gLikqiEvlGLPAGy5aAgvXL2MdY/sy2w8Y2vlL/XuBd53hNUCcxpu70blj82AfVnZHfYMy1OeN4Qo88YYXAzyoDNRnKFrCOsD2KNtzDO2qIgkCb4zgNUCMqbYfpFBecQP2Yeo6po67S4vVVPJEhRcVgOAaYImDwIXigv/L9ggD+8sr/X0Cb4zhNUAMSv+E7QG2VuzDFHJMJUed2vVcVirW8KLizxlDNXQKxWh/zPYlhvbNtf5egTdO8BoghtP7hxriG7EPS0yh2DJsPVbriRW8qPCDSj+o+BP2GNi+D5+WoW2/2t8v8MYZ3giQb9EQvwvvscAfCnugAF9aFMvcrye8uIuI0aKlRYUfLZRFR00wxGh90fpbZoFXKuaQGrV7kTcvMsS/B4gXFxf/oKvPb+vxD6i1gAExOnlmFBof+LLwaacuxGixNixitF/ncxtL1Psm8F4M8a/hSjDEaBYf4M7N+xhge2//oKqU7jVRpfTlCkuzuti+wvZdPpfpRL9fAu/yEP+ON+/XSUD3c+t2h29gyIn6vRuLChTEWXFKAlqusDTrKDphbE/zsS8ky30Sn3d1PrGXN/exfZhN+Q+oHQaIryQJ6Gp8XvzbbhSW7h9Sa2dooSjzI2x7GdqY3UjpsFkIXgPESALCiB2SgFTTi3L/1ZVlq6rTuxZ44cd2hWO0oXuF/6Eg86MM7CvxuA4CrwXhNUAcTgL6BJuiViUBMcSFea6owIsK7MjuGroQo0Vz+yO2x3Ruc9wk8FoYXgPELg0wQC7AvhydBLTcmhWrgRcx2s6ePmM1dkxh+Dd0xBja02Y4b4E3AeA1QJylXYmlJKAsrG8ckQS0ErwqRsstbOfF62CA3m+yfY2h7TfT+Qq8CQSvAWLE0ZAE9BlaSgJKVyvzYOE+rOZjhDegY7RdDK1hLh5itF9j+wZDO27G8xR4ExBeA8QYlvsztntJJwEB2LKSIuro6lOLUyMhqLuv3xij7aQLMVpTzyoVeBMYXgPESAL6AIXCbK0rfOwQhWK0P7JKjFbgTQJ4DRDD6f0jtqdIz7Nj7adQHu3PYhmjFXgF3rVCfBfcArZZBjbdquch8IpEVykptCcSeEUigVckEnhFAq9IJPCKRAKvSCTwigRekUjgFYmuRDJ7OEJPP/v8Pt7sWMVH999x+2075YpJy2tF2eQSxPkGSGKOSFpekUh83jX7oFcq8Vml5RWfVRSnG/jUT/bKVYivqii0gtHNbJi4iaLPT1Ko3L7Iym5DggvTgvaQLh2ltYVCNdH+lULryy3KZRK3wWz6IoXms2Wu4NJgKa5n2BxyqQReM+khtgdX8bnbdcssWsFtkEBv/IU6/CgV1a393UrDz/5CW6x1WLswRqHGRIv4vKKwsDL1rYYO2o36dYVcGnEbzCzUItsdEVnws93GNi2XR+A1M7hocd9Y4ZH9MblEl5bkNoik5RWJBF6RSOAVCbwikcArEgm8IpHAKxJ4RSKBVyQSeEUCr0gk8IpEAq9IJPCKBF6RSOAViQRekcArEgm8IpHAKxIJvCKBVyQSeEUigVck8IpEAq9IJPCKRAKvSOAViQRekUjgFQm8IpHAKxIJvCKRwCsSeEUigVckEnhFAq9IJPCKRAKvSCTwigRekUjgFYkEXpHAKxIJvCKRwCsSrUL/L8AAKAA98WjsSD0AAAAASUVORK5CYII="
    }
  }), _vm._v(" "), _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v(_vm._s(_vm.errorMsg))])])]) : _vm._e(), _vm._v(" "), (_vm.isIe) ? _c('div', {
    staticClass: "pbim-error"
  }, [_vm._m(0)]) : _vm._e(), _vm._v(" "), (!_vm.isWebGL) ? _c('div', {
    staticClass: "pbim-error"
  }, [_vm._m(1)]) : _vm._e(), _vm._v(" "), (this.progress < 100 && this.progress > 0) ? _c('div', {
    staticClass: "pbim-progress"
  }, [_c('div', {
    staticClass: "pbim-progress-com"
  }, [_c('div', {
    staticClass: "pbim-progress-div",
    style: ({
      width: ((this.progress) + "%")
    })
  }, [_vm._v(_vm._s(this.progress) + "%")])])]) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isRightPopupMenu),
      expression: "isRightPopupMenu"
    }],
    staticClass: "rightPopupMenu",
    style: ({
      top: (_vm.showBComInfoTop + "px"),
      left: (_vm.showBComInfoLeft + "px")
    })
  }, [_c('ul', {
    ref: "rightPopupMenu",
    on: {
      "click": function($event) {
        $event.stopPropagation();
        _vm.isRightPopupMenu = false
      }
    }
  }, [(_vm.rendererType === '3D') ? _c('li', {
    staticClass: "contextMenu",
    on: {
      "click": function($event) {
        return _vm.getHandleInfo(_vm.selectedGEO.floorid, _vm.selectedGEO.handle)
      }
    }
  }, [_vm._v("")]) : _vm._e(), _vm._v(" "), _vm._t("contextMenu"), _vm._v(" "), (_vm.rendererType === '3D') ? _c('li', {
    staticClass: "contextMenu",
    on: {
      "click": function($event) {
        return _vm.popupMenuFilterComponent(_vm.selectedGEO.floorid, _vm.selectedGEO.comType, true, false)
      }
    }
  }, [_vm._v("")]) : _vm._e(), _vm._v(" "), (_vm.rendererType === '3D') ? _c('li', {
    staticClass: "contextMenu",
    on: {
      "click": function($event) {
        return _vm.popupMenuFilterComponent(_vm.selectedGEO.floorid, _vm.selectedGEO.comType, false, true)
      }
    }
  }, [_vm._v("")]) : _vm._e()], 2)]), _vm._v(" "), _c('div', {
    ref: "model",
    class: {
      roamPerson: _vm.isOpenWalk
    },
    staticStyle: {
      "display": "grid"
    },
    on: {
      "dblclick": _vm.onDblclick,
      "mouseup": _vm.onModelMouseUp,
      "mousemove": _vm.onModelMouseMove,
      "contextmenu": function($event) {
        $event.preventDefault();
        return _vm.showRightPopupMenu($event)
      },
      "mousedown": _vm.onModelMouseDown,
      "touchmove": _vm.ontouchMove,
      "touchend": _vm.onTouchEnd
    }
  })])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v("\n      CCBIMIEIE,\n      "), _c('a', {
    attrs: {
      "href": "http://www.firefox.com.cn/",
      "target": "_blank"
    }
  }, [_vm._v("")]), _vm._v(",\n      "), _c('a', {
    attrs: {
      "href": "https://www.google.com/chrome/",
      "target": "_blank"
    }
  }, [_vm._v("Chrome")]), _vm._v("\n      \n    ")])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v("\n      webGL\n      "), _c('a', {
    attrs: {
      "href": "http://www.firefox.com.cn/",
      "target": "_blank"
    }
  }, [_vm._v("")]), _vm._v(",\n      "), _c('a', {
    attrs: {
      "href": "https://www.google.com/chrome/",
      "target": "_blank"
    }
  }, [_vm._v("Chrome")]), _vm._v("\n      \n    ")])
}]}

/***/ }),
/* 644 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('li', {
    class: _vm.classes,
    attrs: {
      "role": "treeitem"
    }
  }, [_c('i', {
    staticClass: "tree-icon tree-ocl",
    attrs: {
      "role": "presentation"
    },
    on: {
      "click": _vm.handleItemToggle
    }
  }), _vm._v(" "), _c('div', {
    class: _vm.anchorClasses,
    on: {
      "click": _vm.itemTextClick
    }
  }, [_c('i', {
    staticClass: "tree-icon tree-checkbox",
    attrs: {
      "role": "presentation"
    },
    on: {
      "click": function($event) {
        $event.stopPropagation();
        return _vm.handleItemClick($event)
      }
    }
  }), _vm._v(" "), (_vm.model.color) ? _c('span', {
    staticClass: "colorBox",
    style: ({
      backgroundColor: _vm.model.color
    })
  }) : _vm._e(), _vm._v(" "), _c('span', {
    domProps: {
      "innerHTML": _vm._s(_vm.model.text)
    }
  })]), _vm._v(" "), (_vm.isFolder) ? _c('ul', {
    ref: "group",
    staticClass: "tree-children",
    style: (_vm.groupStyle),
    attrs: {
      "role": "group"
    }
  }, _vm._l((_vm.model.children), function(child, index) {
    return (_vm.model.opened) ? _c('tree-item', {
      key: index,
      attrs: {
        "data": child,
        "allow-transition": _vm.allowTransition,
        "on-item-checked-click": _vm.onItemCheckedClick,
        "on-item-text-click": _vm.onItemTextClick,
        "klass": index === _vm.model.children.length - 1 ? 'tree-last' : ''
      }
    }) : _vm._e()
  }), 1) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "ccBIM",
    attrs: {
      "id": "CCBIMModel"
    },
    on: {
      "contextmenu": function($event) {
        $event.preventDefault();
      }
    }
  }, [_c('div', {
    staticClass: "handle-box"
  }, [(_vm.showHandle) ? _c('div', {
    staticClass: "handle"
  }, _vm._l((_vm.handleList), function(item) {
    return (item.show) ? _c('div', {
      class: {
        hover: item.hover
      },
      on: {
        "click": function($event) {
          return _vm.handleClick(item)
        }
      }
    }, [_c('svg', {
      staticClass: "icon",
      attrs: {
        "aria-hidden": "true"
      }
    }, [_c('use', {
      attrs: {
        "xlink:href": item.href
      }
    })]), _vm._v(" "), _c('p', [_vm._v(_vm._s(item.name))]), _vm._v(" "), (item.action) ? _c('div', {
      staticClass: "profile"
    }, [_c('ul', _vm._l((item.action), function(list) {
      return _c('li', {
        class: {
          hover: list.hover, disable: list.disable
        },
        on: {
          "click": function($event) {
            return _vm.clickProfile(list, item)
          }
        }
      }, [_vm._v(_vm._s(list.name))])
    }), 0)]) : _vm._e()]) : _vm._e()
  }), 0) : _vm._e()]), _vm._v(" "), (_vm.ccbimImage) ? _c('div', {
    staticClass: "pbim-point-image",
    style: ({
      'width': ((_vm.rect.w) + "px"),
      'line-height': ((_vm.rect.h) + "px"),
      'height': ((_vm.rect.h) + "px")
    })
  }, [_c('div', {
    staticClass: "point-x",
    on: {
      "click": function($event) {
        _vm.ccbimImage = ''
      }
    }
  }, [_c('i', {
    staticClass: "iconfont icon-x"
  })]), _vm._v(" "), _c('img', {
    attrs: {
      "src": _vm.ccbimImage
    }
  })]) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "pbim-dialog"
  }, [(_vm.showClipping) ? _c('div', [_c('div', {
    staticClass: "pbim-dialog-title"
  }, [_c('span', [_vm._v("")]), _vm._v(" "), _c('span', {
    staticClass: "pbim-dialog-x",
    on: {
      "click": _vm.closeClipping
    }
  }, [_vm._v("x")])]), _vm._v(" "), _c('div', {
    staticClass: "pbim-dialog-body"
  }, [_c('p', {
    staticClass: "clipping-tip"
  }, [_vm._v("")]), _vm._v(" "), _c('button', {
    staticClass: "clipping-help",
    class: {
      helpHover: _vm.showClippingHelp
    },
    on: {
      "click": _vm.clippingHelpHandle
    }
  }, [_vm._v(_vm._s(_vm.assignmentLine))]), _vm._v(" "), _c('button', {
    on: {
      "click": _vm.resetClipping
    }
  }, [_vm._v("")])])]) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showBComInfo),
      expression: "showBComInfo"
    }]
  }, [_c('div', {
    staticClass: "pbim-dialog-title"
  }, [_c('span', [_vm._v("")]), _vm._v(" "), _c('span', {
    staticClass: "pbim-dialog-x",
    on: {
      "click": _vm.closeBComInfoDiv
    }
  }, [_vm._v("x")])]), _vm._v(" "), _c('div', {
    staticClass: "pbim-dialog-body"
  }, _vm._l((_vm.selectedGEO.userData), function(key) {
    return _c('div', {
      staticClass: "pbim-info-com"
    }, [_c('p', [_c('b', {
      staticClass: "info-name"
    }, [_vm._v(_vm._s(key.strName) + "")]), _vm._v(" "), _c('span', {
      staticClass: "info-type"
    }, [_vm._v(_vm._s(key.strValue))])])])
  }), 0)])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showFloorDiv),
      expression: "showFloorDiv"
    }],
    staticClass: "leftTreeModel"
  }, [_c('div', {
    staticClass: "header"
  }, [_c('span', {
    staticStyle: {
      "font-size": "14px"
    }
  }, [_vm._v("")]), _vm._v(" "), (_vm.stagesAll.length > 1) ? _c('div', {
    staticClass: "stageSelect"
  }, [_c('div', {
    staticClass: "selectOn",
    on: {
      "click": function($event) {
        _vm.showStagesAll = !_vm.showStagesAll
      }
    }
  }, [_c('span', [_vm._v(_vm._s(_vm.stageSelectOn ? _vm.stageSelectOn.name : _vm.stagesAll[0].name))]), _vm._v(" "), _c('svg', {
    staticClass: "selectIcon"
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-xiala"
    }
  })])]), _vm._v(" "), _c('ul', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showStagesAll),
      expression: "showStagesAll"
    }],
    staticClass: "selectList"
  }, _vm._l((_vm.stagesAll), function(item) {
    return _c('li', {
      on: {
        "click": function($event) {
          return _vm.controlStages(item)
        }
      }
    }, [_vm._v(_vm._s(item.name))])
  }), 0)]) : _vm._e(), _vm._v(" "), _c('svg', {
    staticClass: "tree-close",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.closeFloorDiv
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "searchBox"
  }, [_c('svg', {
    staticClass: "tree-search",
    attrs: {
      "title": ""
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-sousuo"
    }
  })]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.searchText),
      expression: "searchText"
    }],
    staticClass: "txtInput txtSearch",
    attrs: {
      "type": "text",
      "placeholder": ""
    },
    domProps: {
      "value": (_vm.searchText)
    },
    on: {
      "keyup": function($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) { return null; }
        return _vm.inputSearch($event)
      },
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.searchText = $event.target.value
      }
    }
  }), _vm._v(" "), _c('svg', {
    staticClass: "tree-search",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.inputSearch
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-huiche"
    }
  })])]), _vm._v(" "), _c('treeStrong', {
    ref: "treeStrong",
    attrs: {
      "data": _vm.floorTree
    },
    on: {
      "item-checked-click": _vm.itemCheckedClick,
      "item-text-click": _vm.itemTextClick
    }
  })], 1), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isShowAllComType),
      expression: "isShowAllComType"
    }],
    staticClass: "showAllComType",
    on: {
      "click": function($event) {
        return _vm.showAllOpacityComType()
      }
    }
  }, [_vm._v("")]), _vm._v(" "), (_vm.showMark) ? _c('div', [_vm._l((_vm.pointList), function(item) {
    return _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: (item.show),
        expression: "item.show"
      }],
      staticStyle: {
        "position": "absolute"
      },
      style: ({
        'left': ((item.left) + "px"),
        'top': ((item.top) + "px")
      }),
      on: {
        "click": function($event) {
          return _vm.clickPointImg(item)
        }
      }
    }, [(item.labelText) ? _c('label', {
      staticClass: "point-label",
      class: {
        warning: item.warning
      },
      attrs: {
        "title": item.labelText
      }
    }, [_vm._v(_vm._s(item.labelText))]) : _vm._e(), _vm._v(" "), _c('div', {
      class: [item.color ? 'point-dom-color' : 'point-dom'],
      style: ({
        'background-image': ("url(" + (item.iconImg) + ")"),
        'background-color': ("" + (item.color))
      }),
      on: {
        "mouseenter": function($event) {
          return _vm.showPointImage(item, $event)
        },
        "mouseleave": function($event) {
          _vm.isShowPointImage = false
        }
      }
    }), _vm._v(" "), (item.iconText) ? _c('span', {
      staticClass: "point-text"
    }, [_vm._v(_vm._s(item.iconText))]) : _vm._e()])
  }), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isShowPointImage),
      expression: "isShowPointImage"
    }],
    staticClass: "point-image",
    style: ({
      top: (_vm.pointImageTop + "px"),
      left: (_vm.pointImageLeft + "px")
    })
  }, [(_vm.isPointImageSrc) ? _c('img', {
    attrs: {
      "src": _vm.pointImageSrc
    }
  }) : _vm._e(), _vm._v(" "), (_vm.isPointTextContent) ? _c('span', [_vm._v(_vm._s(_vm.pointTextContent))]) : _vm._e()])], 2) : _vm._e(), _vm._v(" "), (_vm.errorMsg) ? _c('div', {
    staticClass: "pbim-error"
  }, [_c('div', {
    staticClass: "noModelImgBox"
  }, [_c('img', {
    attrs: {
      "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK8AAADDCAYAAAD0pEFUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCOUVGQUNBQjVEOEYxMUU4OEE4RTkwNTA4RURGMzhFNiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCOUVGQUNBQzVEOEYxMUU4OEE4RTkwNTA4RURGMzhFNiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI5RUZBQ0E5NUQ4RjExRTg4QThFOTA1MDhFREYzOEU2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI5RUZBQ0FBNUQ4RjExRTg4QThFOTA1MDhFREYzOEU2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+79ZNvAAAFgxJREFUeNrsnQtwnFd1x88+9LQeq6clrR67eku2LCchcajtcUjjITQtnTCFTqAzJBkKpaUNtEAeDdCGdBICDbQxEBgGWlqSQhgyZBxKm5BA7JA6hBC/bcmWrNeu3rJkPazXbs//7l3580ayZXm1+3275585+XY/raXv8dv7nXvuuefagsEgicytp599PnLXe/X2OePOO26/Lamui1PQsKQ+sxy8ySa7cCCSlle03rqZrVa/LtHbj+rtKbaXBF6RWfX3GmCjvqW3Lwm8IjPr9w2v9+ntTvF5RSJpeUUx0qRcAoHXqnq/XAKBV1peC8smI2wi6bCJRAKvSCTwiqTDFj0tkx21aiVbxpTIZPCKEkdmaIjMAq9D21wC3uQs3nyS7S62PWxP8s2bSXC2c9nGk6Xl9ertqQSCNoU3f872IFup3v0426f4Z1/k7fcY4oUEhXcr26+SpcN2q7ZEgNbG9qf88hjb1wFuYb6Lrt/aQnkuNEhUwfZt/ByfY0u0TjOeoA/rbcLDizt6n7Zci4N7C29+w/ZfbLU52Vm0c9t1tHvXdqr1VtKt79pB22+4lnKyNuDjdfpzb/K/S6Te6D1sO/Q2od2GfLafsLn1+71sf8w2ajFor+XNo2y78T4jI51aGuupuqqcbDbbRZ+tdJdSRVkJdXT30pET7TQ9PdOK8+bf8SpvH2BX4hULg9uiW13S2xfYDicavID1dt3aug378Y09pEF4lq3P5NBiZgP8V7gJttSUFGqqr6GGGg85HCs/NQF0TVUFeSvc1N7ZRUdPnqLZ2bnt8BP5d/4cfjJD/FuLgfu3GtgM/R7bA9rnfzyR4E01RBhWijykmhhaTMP5HNtHcJwAtb66ipobagkAr9pns9sZdK8C+cSpTjrJNjc/D9//3fw3fszbzzPEJ0ze0u6i0HSklmV+DoD/me1O7ef/KpotcUwTc5aJDcJt+KlucaH9K7kNZhik4OPPptDM3U+xZaEF9VaWU0tTHWVmZFz175+dm6PjbR3U1nGGFhcXsQvRiP9g+wc+/26TfYEjG5x7IlpeaEa3vP/Cthjtexlvn3dUw3pIvzelv8s3Ck+Bj+sbUYh95aUltGVTA+VmZ0Xt76SlptLWzY3UUOtV/nBHV48zEAggPvwhPoYneftPfOMHTdgCL2rXAD7uProQ592ZiD5vJMBfNrw2E7SIxnxQ+7Ue7CsqyFeAFebnrdvfzUhPo+u3bqamumo6fLyNunp9qfyE/Bv+0d18TGjFvsIQnzUhxAD1L9l+oLeH1/OPmWWQ4nmz3QWG5D28eYQN0QDKzcmm1k2N5C4pjtkxZG3IpHe+Yys1cyfw0LGT1OsfQDOPWcQf5+N7jLdPMMTTJrt0P9RPqR+u9x8yC7ydFIOg9iqhvVFDexPeZ2Zm0JamevJUuN8W9oqV8MXZeeM7aGTsLB08epIGhobzdUTmHj5e+JnfYYjNMrS+qN2rxWSBdzEWJ3sZaBvhU1IohGeD/9ncUEP11R4VFTCDCvJcdPOObdQ/OKxaYoYZw84Yxfs0H/8X8LhmiAMmONS3YvFHkj6rjG96GXrzFEqccTodDtVhamR/80rCXrFUSXGhsl5/P0PcRuMT55Ab8n22e/l80Or9lCGO5/yu8Vj8kaSdw8Y32YWbrUM8GWrgwFNJmxvrVIfJKsL96+rxqY7d5PSS+/s6fGMG+MV1vH5r/rfRCpUlHbx80TN0T/h+PImxD0O2W5obKDuUc2BJBQIBOn2mh46ebKeZ87Ph3b/QEB9IxHuZNPDqsNeHtYtQiX0biwpo66ZGys9zJcx5YnDj5OkzdLz9NM3NzYd3YyAIQ85HBF7rgfteHUFoxvs8Vw61NjdS6caihD3nufl5OtHeoUBeWFBpw+jIPcX2BYa4Q+A1P7RIdvkSG7Yqbgr3AG5CvMJesdb52TnlSpzq7FauBYVmq3yX7SGG2C/wmg/aZt3SqvL36WmptIk7YrXcITNL2CvWmp6eocMn2qmzu5f0PUfewRNsjzHEIwJv/KGt1D4tfFu70+lUQ6yNtV7CaxHRxLlJFZno7ltqdDHMjLyErzLEkwJv7KEt0NEDRBEy0LrW6rBXWlqqELuMRs+Oq4EO/8BQeBdeYJAGE0RnBd71hxZhL8zM/SybC35sOOwF/1Z0eQ0OjzLEJ2hoZCy8C6mXD7H9u9kniFoSXoYWPsDd2kVQM3MROUAEAZEE0ZXL1z9IB7klPjs+Ed51ku3zbM/EebQuMeDFzFzevE8/3hqwDzFaxGoRsxVdncBCD/vCh9gnPjc5Fd79JtvnGOCfCbxrB/cmCmVSbcN7jIaFw16i6EPc0dVDR06coumZpfooSDLHBNH9Au+VgYuW9oHwe7S2N2/fRikpEkFYT2G07pX/e0NlsRn0KAN8vxmOzypBzwcv6imPnaW9L7yshkD16JEoykIU4sVXXjOCG65mdJ9ZjtES8Bo7DNdsbqDcnCw1cvTWkRP03P+8rKaOzwvEUdHw6Bj9Yt9r9Mtfv67Caay+onzXnlt23DBktmO13HO3kF0G2MjYOHX29NHY+DkVr8Q4PvJw62s8ps3DNbMQZcB17Otfmt85nO/K2bu1uWGzw2H/hBmP2bJOY0FerrLRsxPU0Q2IJ9TI0YlTHaoWAiw1VSC+nM5NTYVG3Hr94WHjybzc7P9uba5vSHE67zTzsVu+x8OtgzK0wIAYjzpMG0cBD7TCaI0xpUd0sWZmztORk+0qB1hDO5ubnfUSQ+tJS02xxFJZCdNd59aCrmtppLMTgNinJivCF0ZKYJ23khrralSCTrIrVNjkNLV1dC0VNsnekPlqa3OdOyM9/T1WOpeEizW5crLpWu7UjZ+bVC3x8OhZOt7eoW5WnbdKJeqkW2iaT7SEqAxKSsGtmp9XndvghsyMN7Y01hVnbcjYZcVzSthAKSrZXLOpgSYmpxTEGLvHjUNhuxpPBTVzS4xqjoku5PC28xf3aJsq5qf2cQt7tKWxxsXX6Horn1vCR/lRC3drcz13TKYVxIPDo8G202dsSM5WENfXRKXOmNmkRskulFFV+9ht6thUX52V78rdlAjnmDRDVOzXUWtTHU1OTds6e3zUPzQS5BbJhg4L6ug219cSP0YT4lyRq3v42En11IFSU1N8TTWe9OLC/OpEuqdJN76KVMmWxlqqrnTbOnr6aGBwJMitsA1j+d6KclWm1KrplBgVQ2bYWGhwgVKczuH66qqU0o2FZYk46SlpkwPQyrY0AOJyWye7E2iJT3f12PCoRWmnTfwzq0yFhz+PnFzk5qqb6nBM1Hoq7OWlxYWJPFcv6TNbNnCnbXNDDdVUuRliH/kGhwOd3b32M9wqV5WXKYhzoljGNJqKHBVz2O3TeKJUuktykmGunqRlaXEPnP3eavJWuu3sEwd9A0NBBtje1etTaZeAGAXvzCA1KnYsNA8NHTO7zTZXVV4a9FSUZTodjqS5ZwLv2yBOo+Y6rw0tGCDmVi3IANsBSnnpRjUvzpUbn9kakaNi7BIsVJSVBGsq3anJmB4q8K4gjMY11XoY4rIQxP7BQI+v38GmqqJv5k6fXldt3RU5KsZebMC9sShQXVXuTOZRQ4H3MkJeRGONx+atcDvO9PqCvQxxr7/fgQqNKDSNehAF61QuaplRMdpYmL9Y46lwsK9uT/Z7I/CuGuIUaqiuYojLGGJ/sMc3sMguhROdJUz+hDsRrVL/y42K8RckUOspt+dkbXDI3RB41yTkCtd7K22e8lJnV19/sLuvf8E/MJSCGCtq5gJirFuxFi03KubKyQ7WeipsebnZdrn6Am/UIK5jqBjilK5eQOxf6B8cTsG0meLCAgXxlcxojhwVy9qQGcTvL8x32eRqC7zrohSnk/hxbqsqL0nhVjjQxRAPDo+kvrR/RLXAgBgt8kqKHBXLzEinmqpygG8TagXemEHM0NmryktTATH7xfNDI6NpL796QPnCgNhYUjVyVAwdw+oqN7n5MzbBVuCNywV1OJA3Ya90l6Rxpy5wpsc3Nzw6lo4JjYhK1FVXqcIe4VExxGe95WVUUbYxaStYCrwmhNhbUWavLCtJ7/EPBDp7+mZHxs5mjPw2tPYf1iuucpcQt9SUTKNiAq+F5HDYiTt1dm5ZM7gVZoh9dqfTQduva5WiKQLv29XrH1SPZWSO8eNbJaTHHWJ2CdwlxXYkxOO1WcBF+f/uvgHy6VKnTXUeKlrHpWkF3ktocmqajp/qVK8RdvIPDqsp8h72K/OlguSSULSlqzfkey8GLqw7eKy9k3ZtE3jjouUq56BACQzz2jwVZVRUkEfJ2p+fnjlPaiYJf6kDuk5dmqpvYVM5FFaqGpqQs4cL811q1nCkMKP44LE25U6wH6rir/YkCUuhZCmgRWguqFBV04PUdlYveYVoR723SuCNlxAjxazhUDkon6qkE6mp6Rk62tZBp7t6ucdfqhJs0LFKRKEYC3cUaXjs7NL1SdXrc4TXaUO0o7y0WF0LK1UZStjubrgcFFpbQDw8MkbBZfy+kx1dhLlslWUlKtaakiALr+DJg/NGEZZwqwpI4Ragkwah0xjL877ckq9Xuqxrwsdq4Odi6jtaWz1r+G1+HdIN0Qqf4Q5MObfCiFBYMU8WZzXA54eWFlP9w9DiqRIMXIAW54bZIeUWf+IkTaARfi7mqtV6yrmX3f+2XjaERO+uPj8h4byU/WF07jItUJgEHS//wDB/+XyqQwYhHAdwA8HAUi4wzgW+Poap4+zru9m+wXYr288ptIpTn8B7GaWnpVFDTRV5K8sY0gFlkREKwNA3MKRin0WF+RgpM0WsOFKLiwH1JcQX7rzO+7UraG0U4JY2fF6oWYEv4kY+F5PkTXyPbbd+jYUeMSXlJoF3lUJKI7K3MDzb5wcA/SpUFPkYRu8clu/KVRCbIVYMKPGl6+YnRLhVRUtr09AuLCwuRV5wzIi+mEzvvMx7gXdVFwA5BgxwBfu5SE+E3xt+9BqF0qmwnOwNKpEGLXKs2zBEB9DKYgRxIVThMQQtt6ZwgYILAd1ZdTG0pZSXa9pBmdcMLW/4vcC7VsEHRMisjA0tLTo9ExeWc1rSxLkpOni8XYGBkqqxegz72KfFyKFe/Fp3tGzqfZANRwG3wGNSFydCH2H7lsHn/ZjAGwWFIYAhVoxOEKqvRwrxY4ShYtW6YeYwQLWrljbk76rj5Tdl3AFDR8xCtdawyuZV1wIWeC8hY6wYLfGQIVYMaGJZcT2c67vU8vJ7PCUArVXCelcaxxV4oyDEilt1rLibO0pYWA8uRizDaE21HpU0E+T/wrHoZF84Zl3hXWlEJdrfwFgJj2VAFA8hmWhXQZ60JMankVwCkcB7aT1MobDpw3LJRVaD956IrUhkGXj3RGxFIstEG+7XJhJZA16rRhVE4jaIRAKvSCTwigRekUjgXYMiE8ZFAq8VpBK69v/mIB0/dYZmzs/K3RN4LaNr2Z4JsHr9A/TqGwfpaNtpmlpm1oMo+po5b77rbJmUyN07t73Fmw+8sO9AE2/vDQaDH/INDDsxa7YYkyQr3WqioSi6whR65DIP6CLYrIDAu3aIj/PmTob4H3n7WfYl7uILm4aLW5TvUhDnmnS5VSsJM0U6e/w0MrZUNgudjf9ke8wsx2izSmG14eHhZfczxKgB8HdsH2VTk7cww9db4TZdVUhMT9/3+u/UzIedN1xjyuuM2SKdvT4an5gM78KLb7N9lRuOXuwoLCwUeKMBrwFiLPjwSba/olAdANNN/TYrvGCgX1famdRLaOGSsz3BtoehHTV+XuCNMrwGiAHuX1Mo/VJd5eysDQri4jhMVzczvJgu7+sPTfc/P7sUvcHkyMfZvsPQTi337wTedYLXADFcCEyp/jRbKfZhGg8gLikqiEvlGLPAGy5aAgvXL2MdY/sy2w8Y2vlL/XuBd53hNUCcxpu70blj82AfVnZHfYMy1OeN4Qo88YYXAzyoDNRnKFrCOsD2KNtzDO2qIgkCb4zgNUCMqbYfpFBecQP2Yeo6po67S4vVVPJEhRcVgOAaYImDwIXigv/L9ggD+8sr/X0Cb4zhNUAMSv+E7QG2VuzDFHJMJUed2vVcVirW8KLizxlDNXQKxWh/zPYlhvbNtf5egTdO8BoghtP7hxriG7EPS0yh2DJsPVbriRW8qPCDSj+o+BP2GNi+D5+WoW2/2t8v8MYZ3giQb9EQvwvvscAfCnugAF9aFMvcrye8uIuI0aKlRYUfLZRFR00wxGh90fpbZoFXKuaQGrV7kTcvMsS/B4gXFxf/oKvPb+vxD6i1gAExOnlmFBof+LLwaacuxGixNixitF/ncxtL1Psm8F4M8a/hSjDEaBYf4M7N+xhge2//oKqU7jVRpfTlCkuzuti+wvZdPpfpRL9fAu/yEP+ON+/XSUD3c+t2h29gyIn6vRuLChTEWXFKAlqusDTrKDphbE/zsS8ky30Sn3d1PrGXN/exfZhN+Q+oHQaIryQJ6Gp8XvzbbhSW7h9Sa2dooSjzI2x7GdqY3UjpsFkIXgPESALCiB2SgFTTi3L/1ZVlq6rTuxZ44cd2hWO0oXuF/6Eg86MM7CvxuA4CrwXhNUAcTgL6BJuiViUBMcSFea6owIsK7MjuGroQo0Vz+yO2x3Ruc9wk8FoYXgPELg0wQC7AvhydBLTcmhWrgRcx2s6ePmM1dkxh+Dd0xBja02Y4b4E3AeA1QJylXYmlJKAsrG8ckQS0ErwqRsstbOfF62CA3m+yfY2h7TfT+Qq8CQSvAWLE0ZAE9BlaSgJKVyvzYOE+rOZjhDegY7RdDK1hLh5itF9j+wZDO27G8xR4ExBeA8QYlvsztntJJwEB2LKSIuro6lOLUyMhqLuv3xij7aQLMVpTzyoVeBMYXgPESAL6AIXCbK0rfOwQhWK0P7JKjFbgTQJ4DRDD6f0jtqdIz7Nj7adQHu3PYhmjFXgF3rVCfBfcArZZBjbdquch8IpEVykptCcSeEUigVckEnhFAq9IJPCKRAKvSCTwigRekUjgFYmuRDJ7OEJPP/v8Pt7sWMVH999x+2075YpJy2tF2eQSxPkGSGKOSFpekUh83jX7oFcq8Vml5RWfVRSnG/jUT/bKVYivqii0gtHNbJi4iaLPT1Ko3L7Iym5DggvTgvaQLh2ltYVCNdH+lULryy3KZRK3wWz6IoXms2Wu4NJgKa5n2BxyqQReM+khtgdX8bnbdcssWsFtkEBv/IU6/CgV1a393UrDz/5CW6x1WLswRqHGRIv4vKKwsDL1rYYO2o36dYVcGnEbzCzUItsdEVnws93GNi2XR+A1M7hocd9Y4ZH9MblEl5bkNoik5RWJBF6RSOAVCbwikcArEgm8IpHAKxJ4RSKBVyQSeEUCr0gk8IpEAq9IJPCKBF6RSOAViQRekcArEgm8IpHAKxIJvCKBVyQSeEUigVck8IpEAq9IJPCKRAKvSOAViQRekUjgFQm8IpHAKxIJvCKRwCsSeEUigVckEnhFAq9IJPCKRAKvSCTwigRekUjgFYkEXpHAKxIJvCKRwCsSrUL/L8AAKAA98WjsSD0AAAAASUVORK5CYII="
    }
  }), _vm._v(" "), _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v(_vm._s(_vm.errorMsg))])])]) : _vm._e(), _vm._v(" "), (_vm.isIe) ? _c('div', {
    staticClass: "pbim-error"
  }, [_vm._m(0)]) : _vm._e(), _vm._v(" "), (!_vm.isWebGL) ? _c('div', {
    staticClass: "pbim-error"
  }, [_vm._m(1)]) : _vm._e(), _vm._v(" "), (this.basicProgress < 100 && this.basicProgress > 0) ? _c('div', {
    staticClass: "pbim-progress"
  }, [_c('div', {
    staticClass: "pbim-progress-com"
  }, [_c('div', {
    staticClass: "pbim-progress-div",
    style: ({
      width: ((this.basicProgress) + "%")
    })
  }, [_vm._v(_vm._s(this.basicProgress) + "%")])])]) : _vm._e(), _vm._v(" "), (this.entInfoProgress < 100 && this.entInfoProgress > 0) ? _c('div', {
    staticClass: "pbim-small-progress"
  }, [_c('div', {
    staticClass: "pbim-small-progress-com"
  }, [_c('div', {
    staticClass: "pbim-small-progress-div",
    style: ({
      width: ((this.entInfoProgress) + "%")
    })
  })])]) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showMap),
      expression: "showMap"
    }],
    staticClass: "canvasParent",
    class: {
      center: _vm.isActive
    }
  }, [_c('div', {
    staticClass: "topTip"
  }, [_c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.selected),
      expression: "selected"
    }],
    staticClass: "floorSelect",
    on: {
      "change": [function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }, _vm.selectFloor]
    }
  }, _vm._l((_vm.selectFloorPlanGraph), function(item, index) {
    return _c('option', {
      key: index,
      domProps: {
        "value": index
      }
    }, [_vm._v(_vm._s(item.floorName))])
  }), 0), _vm._v(" "), _c('div', {
    staticClass: "canvasButton"
  }, [(_vm.scaleBig) ? _c('svg', {
    staticClass: "icon small",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.zoomMap
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-fangda"
    }
  })]) : _c('svg', {
    staticClass: "icon small",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.shrinkMap
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-suoxiao"
    }
  })]), _vm._v(" "), _c('svg', {
    staticClass: "icon",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.closeMap
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })])])]), _vm._v(" "), _c('div', {
    staticStyle: {
      "position": "relative"
    }
  }, [_c('canvas', {
    ref: "mapCanvas",
    attrs: {
      "width": _vm.mapCanvasWidth,
      "height": _vm.mapCanvasHeight
    },
    on: {
      "mousemove": _vm.canvasMove,
      "dblclick": _vm.canvasDoubleClick
    }
  }), _vm._v(" "), _c('div', {
    ref: "circleLocation",
    staticClass: "circle"
  })])]), _vm._v(" "), _c('settingModel'), _vm._v(" "), _c('roam', {
    ref: "roamBox",
    on: {
      "phoneOpenTree": _vm.phoneOpenTree
    }
  }), _vm._v(" "), _c('div', {
    ref: "roamLocation",
    staticClass: "roam-box",
    staticStyle: {
      "width": "auto",
      "height": "auto",
      "display": "none"
    }
  }, [_c('div', {
    staticClass: "roam-title",
    staticStyle: {
      "text-align": "center"
    }
  }, [_vm._v("")]), _vm._v(" "), _vm._m(2)]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showComponentCut),
      expression: "showComponentCut"
    }],
    staticClass: "componentCutBox"
  }, [_c('p', [_vm._v("")]), _vm._v(" "), _c('div', {
    staticClass: "button-box"
  }, [_c('span', {
    on: {
      "click": _vm.performComponentCut
    }
  }, [_vm._v("")]), _vm._v(" "), _c('span', {
    on: {
      "click": function($event) {
        _vm.showComponentCut = false
      }
    }
  }, [_vm._v("")])])]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isRightPopupMenu),
      expression: "isRightPopupMenu"
    }],
    staticClass: "rightPopupMenu",
    style: ({
      top: (_vm.showBComInfoTop + "px"),
      left: (_vm.showBComInfoLeft + "px")
    })
  }, [_c('ul', {
    ref: "rightPopupMenu",
    on: {
      "click": function($event) {
        $event.stopPropagation();
        _vm.isRightPopupMenu = false
      }
    }
  }, [_c('li', {
    staticClass: "contextMenu",
    on: {
      "click": function($event) {
        return _vm.getHandleInfo()
      }
    }
  }, [_vm._v("")]), _vm._v(" "), _vm._t("contextMenu"), _vm._v(" "), _c('li', {
    staticClass: "contextMenu",
    on: {
      "click": function($event) {
        return _vm.popupMenuFilterComponent(true)
      }
    }
  }, [_vm._v("")]), _vm._v(" "), _c('li', {
    staticClass: "contextMenu",
    on: {
      "click": function($event) {
        return _vm.popupMenuFilterComponent(false)
      }
    }
  }, [_vm._v("")])], 2)]), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (!_vm.isOpenWalk),
      expression: "!isOpenWalk"
    }]
  }, [(_vm.isRenderFinish) ? _c('div', {
    staticClass: "pbim-viewHome",
    on: {
      "click": _vm.toHome
    }
  }, [_c('img', {
    attrs: {
      "src": __webpack_require__(634)
    }
  })]) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "viewBox",
    staticClass: "pbim-viewBox",
    on: {
      "click": _vm.boxHandle
    }
  })]), _vm._v(" "), (_vm.isOpenWalk && _vm.isPhone) ? _c('div', {
    staticStyle: {
      "width": "120px",
      "height": "120px",
      "position": "absolute",
      "left": "5%",
      "bottom": "10%",
      "z-index": "0"
    },
    attrs: {
      "id": "phone_joystick"
    }
  }) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "model",
    class: {
      roamPerson: _vm.isOpenWalk
    },
    staticStyle: {
      "display": "grid"
    },
    on: {
      "contextmenu": function($event) {
        $event.preventDefault();
      },
      "dblclick": _vm.onDblclick,
      "mouseup": _vm.onModelMouseUp,
      "mousedown": _vm.onModelMouseDown,
      "mousemove": _vm.onModelMouseMove,
      "touchstart": _vm.onTouchStart,
      "touchend": _vm.onTouchEnd,
      "touchmove": _vm.onTouchMove
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v("\n      CCBIMIEIE,\n      "), _c('a', {
    attrs: {
      "href": "http://www.firefox.com.cn/",
      "target": "_blank"
    }
  }, [_vm._v("")]), _vm._v(",\n      "), _c('a', {
    attrs: {
      "href": "https://www.google.com/chrome/",
      "target": "_blank"
    }
  }, [_vm._v("Chrome")]), _vm._v("\n      \n    ")])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v("\n      webGL\n      "), _c('a', {
    attrs: {
      "href": "http://www.firefox.com.cn/",
      "target": "_blank"
    }
  }, [_vm._v("")]), _vm._v(",\n      "), _c('a', {
    attrs: {
      "href": "https://www.google.com/chrome/",
      "target": "_blank"
    }
  }, [_vm._v("Chrome")]), _vm._v("\n      \n    ")])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "roam-content"
  }, [_c('span', [_vm._v("")])])
}]}

/***/ }),
/* 646 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('transition', {
    attrs: {
      "name": "fade"
    }
  }, [(_vm.showRoamBox.show) ? _c('div', {
    staticClass: "roam-box"
  }, [_c('div', {
    staticClass: "roam-title"
  }, [_vm._v("\n        "), _c('svg', {
    staticClass: "roam-close",
    attrs: {
      "title": ""
    },
    on: {
      "click": function($event) {
        _vm.showRoamBox.show = false
      }
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "roam-content"
  }, [_c('span', [_vm._v("WASDQEshift+/-F9")]), _vm._v(" "), _c('p', [_c('input', {
    attrs: {
      "type": "checkbox"
    },
    domProps: {
      "checked": _vm.checkedRoamTip
    },
    on: {
      "click": _vm.setRoamTip
    }
  }), _vm._v("")])])]) : _vm._e()]), _vm._v(" "), (_vm.$parent.isOpenWalk && !_vm.isMobile) ? _c('div', {
    staticClass: "modeChange"
  }, [_c('span', [_vm._v("")]), _vm._v(" "), _c('svg', {
    staticClass: "roam-speed",
    on: {
      "click": _vm.moveSpeedSub
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-jian"
    }
  })]), _vm._v(" "), _c('span', {
    staticClass: "speed-value"
  }, [_vm._v(_vm._s(_vm.moveSpeed) + "x")]), _vm._v(" "), _c('svg', {
    staticClass: "roam-speed",
    on: {
      "click": _vm.moveSpeedAdd
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-jia"
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "gravity-box"
  }, [_c('span', [_vm._v("")]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.isGravity),
      expression: "isGravity"
    }],
    staticClass: "gravity-check",
    attrs: {
      "type": "checkbox"
    },
    domProps: {
      "checked": Array.isArray(_vm.isGravity) ? _vm._i(_vm.isGravity, null) > -1 : (_vm.isGravity)
    },
    on: {
      "change": function($event) {
        var $$a = _vm.isGravity,
          $$el = $event.target,
          $$c = $$el.checked ? (true) : (false);
        if (Array.isArray($$a)) {
          var $$v = null,
            $$i = _vm._i($$a, $$v);
          if ($$el.checked) {
            $$i < 0 && (_vm.isGravity = $$a.concat([$$v]))
          } else {
            $$i > -1 && (_vm.isGravity = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))
          }
        } else {
          _vm.isGravity = $$c
        }
      }
    }
  })])]) : _vm._e(), _vm._v(" "), (_vm.showRoamImg) ? _c('div', {
    staticClass: "roam-img"
  }, [_c('svg', {
    staticClass: "roam-img-close",
    attrs: {
      "title": ""
    },
    on: {
      "click": function($event) {
        _vm.showRoamImg = false
      }
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })]), _vm._v(" "), _c('img', {
    attrs: {
      "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARUAAAC0CAYAAAC62bgdAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA25pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1NzUxQ0JGNEMzQkFFNjExQUU3REUwRTgzRjQzRkExQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3Q0RDOEIwRENEQzkxMUU4QjMxMEJGQkQ3M0VBNTlFQSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3Q0RDOEIwQ0NEQzkxMUU4QjMxMEJGQkQ3M0VBNTlFQSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpmMjc2YzI2My04Zjg1LWQwNDYtOWIxNi0yNmNkZTY5ZTRjNzIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NTc1MUNCRjRDM0JBRTYxMUFFN0RFMEU4M0Y0M0ZBMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz59LkJgAAAVuElEQVR42uydC2wVVf7HT8u9dAsFw4J/S8urPMpjKWyXFelaFHknBSUmAgUFIVGTXQgmSwlJBSNIJOBuTJbdpBgNorQi1qCIylMWJLwW+l/QUnnZQqnFIoS3tJW79zfrdIdhZu6ZmTNz5858P8nNvXfu3Dm/Oed3vud3zpyZkxSJRGYzxkYzAECQeNCh454PkaBcuXIFWQxAgGjTpo0jxw2Hw5nJyF4AgEggKgAAiAoAwBmampqS7O4HUQEAtAhFYWFh14MHD6Ya7XfgwIFU2k9PWCAqAACJcDgcmT9/fsNLL72UricsJCiLFi1KLyoqaqD9tfZJikQipbxXf0aNGlW4Y8eOMvmz+nf5N63/KP/Lc2z1vjxp89oEQNBp06bNg0aRCAnHq6++Wj906NBb6u1Lly6tf+ihh27pCJO9SIUqrPyye5JKUVALhJbI6KUt0iYAgggJBgmHMmLhERSZkJ3EtSIDveiCJ7rh+QwAcFdYpk6devn999/vwCMo3KKiFTWYqei8XaBYYmXnvwAA88JCgvLmm292eu655y7yCAq3qKjHOpQVV+u7unLHEgNlt0fvP2qx4BEeCAwA1qEuD0UoUUH5kd4HDhx4WznGooflMRWtsQyjMRDlb/LLTvcGYycAOCso8mDt7NmzL6vHWISOqchiYBQ5GFV0p0UA0QkA4gRFjkyUYyzqq0K2x1SMLvV6QRzQ/QFArKAox1h4hMX0mIqdKEXrv3oixTNvBS4AgDhohuzKlSvvNxIMWVhWrFhxf1lZ2TmtCXCWLilbGYzl2c9M1IOxFADEQgKhJxRqYTHaz/JArVIA9Gaz2hErvdm5eoLiVDcMgKAJi939ks2IiFEFtissRoIS69hak+zQPQIgPpi69wcA4A+M7v2xGenYm6YPAEhMbt68eciJ495333149AEAQCwQFQAARAUAAFEBAEBUAAAAogIAgKgAACAqAAAAUQEAuEEgZtRWVFSk79u3r/f58+fTm5qawm6kGQ6HmzIzM+vz8vJO5ebm1sPVUB5Bwff3/qxfv37wmTNnBuTn57Pu3buz1q1bu5JuY2Mjq6mpYV999RXr2bNn5ZQpU/4Nd0N5WGXx4sXSDbJLlizx9J34vp+mTy0iOfC0adNYnz59XHNggtKiNCltsoFsQYSC8kD3J8GhEJtaxJSUFGUYzDp06MBSU1NZcrJYTb1z5w67desWu3z5Mj1FS9pGaZMNZEvQw26UB0Ql4aE++4QJE+5y4IyMDOHOK0PHbdu2rVRB6urqWhy5R48e7PPPP+8cdGdDeVjr8uht82pXyNfdHxoEVIbY1CI65cBqZ6a0lJWnubk58I+ZQHkgUvEd1GL5MS2Uhz/LQxmJJMpAre8jFa0Wy4jly5ezNWvW3LWNvs+YMUPqm8vs2rWLzZ0711ZawFweHTx4kBUXF0tlQa9Vq1ZJXRon0gIQFWHk5OSww4cP37VN/n7q1KmWbdXV1WzIkCHIMJcgEScRGTNmDFu7dq30SktLY6+99po0CAsgKp6lX79+jObsnD59WvpOLaE8h+fs2bN3CQ0N9gF3KC8vZ3PmzGEjRoxo2fbss8+yvn37so8//jgQeUDdnkTo+kBUVPTq1UuavFNVVSV9P3HihPR94sSJ7NixY3cJTXZ2NjLMBUjgKb8pilQzdOjQeyJLAFHxHNStkQVk//797JFHHpEimMrKSmlcRRYauhQKnOfHH3+U3rUGWjt27MiCshLEjh07+tALopKADBgwQBIQ6qvTOwlK7969pd8OHDggjaeMHz8eGeUSJByEcqBcKTgk8H4n2sg9sGfPniG7d+8eQp8hKgmGHGZv375dclgSFGolR44cKQkKhdvdunVDRrncJZWjRxKXDRs2SN1QuiLk9wHz6Hm227hxY/6dO3foPr2k6OfhtA2ikkCQgFC0smnTJslh5bCbBmZ37twphdty5ALc4ZlnnpGu/tBVoJ9++knatnDhQklUxo4d69vzvnHjRnjdunWPNjU1tcwYpAmE77333qP0G0QlgRg2bFiLkMgMHjy4pXuEiW3uQgOydPWHxrjmzZsnCX7Xrl2l3+jyslbXKNH5+eefk955553h165duycquX79ejv6jfbxou2YqqwBXbpUXr4kaJo3OTCIn7DQSwmJCUWPfhT5Dz74YEh9fb3u+An9RvsUFhb+C6ICgMCuakFBgS/P7RexkARDfWOh1+eroPsDAICouMm2bdukF0B5AHR/hDjw1q1bW77TvScA5eE2iTI9H5GKSQemz2ghUR4AoiLEgeHIKA8AURHuwHBklAfgA2MqKqifLvfVi4qK7vpt5cqVyCCUB0CkAgCAqAAA0P1JBGgdGDPPKrUTXlNaAOWBSMXnuHnjmR9vckN5AEQqKujBS06shKfVKuKBzCgPG/YmHT169P8qKysz6urqOl29ejWtsbFRevxB69atG9u3b389IyPj4oABA+oGDRr0QzT/IhCVOEEr1NHDfdxcZhOgPHihRxls3ry57969e3PpmT0DBw6UHg7WqVMnVlb230m1hYWFv7p48eKvvvvuu06HDh3qR9sffvjh/y8oKKhq1apVBKISJ0f+4YcfUKNRHp5iy5Ytvb/88ssH8/Ly6K5kSUi0aNeunfTKysqSBIceqblt27bfFhcX//axxx47NG7cuFMQFQACzrp1637X0NDQd8GCBSwzM9PUf+kZvlOnTmXDhw+n5/08GI1i2k+fPv1IPM/H1wO14XC4KdoX9URrHAqFmoNeeVAe9xIVgiFJSUl958+fb1pQlNB/6RhR+tIxISoOEc3o+pqamrjbQQ/M7tKly/dBFxWUx70RSlTcsmfNmiUtGi9AtNns2bNJMLPp2BAVB4j2T0/t3buX3b59O242UNpkA9kSdFFBefyPzz77LPvSpUt9aV1okQPUdCw6Jh178+bN2RAVweTm5tZnZWVVlpaWspMnTzI3Q29Ki9KktMkGsiXoooLyaLElmdbxocofK0K5ExXB6r/+lQ3ctk160ec7MUSZjjlz5kwSzyGUltvnR2uJlPp9lbeKior0ffv29a6trU1vbm52ZWmDaAjaFA2x66lFhKCgPJR89NFHA1NTU3OefPLJmPsenzuX3Txz5q5tbXr2ZP3/9jeedOiS+rFoOl+7dW60RlMgRAUAr0BzUYqLi6cuXbqUtW/f3nDfs//4B2vYvJm17dePdf/zn6VtNX/5C7tRVcXuLyhg3f74R8P/X716lS1atIgtW7bsfbfmsJCo4IZCAFzkyJEjnfv37x9TUIjr33wjvXf9059YSnq69KLPyt+MoDRonarDhw+7uvA3RAUAFzl+/HgGVXQeblVXS++p3buziokTpVfqLwvcyb/FggSsqqqqM0QFAJ9y4cKFjt2jImGKpCSWu2mT9DILpRVN89dunqOQGbXywNv58+fTaa1XNwyniVQ074Fn4A322bNPNEE7XyVXrlxpqzcF3zDPolEKYVZYKK1ommkJJSrr168ffObMmQH5+flswoQJdBelK4Y3NjaGa2pqun7xxRddT5w4UTllypR/wz7x9okmaOerhhZbt7JMq5UoReo6RdNSLvDu+e4PtTjkINOmTWN9+vRxzUEISovSpLTJBrIF9om1z4kIJUjnq0UkEkmyMtlNHlMxXcGjaVGaCROpUAhLLU5KSooyzHT1VnZKm2wgW9RhLeyzZ59ogna+dqFBWRqQpZccqbQM3v4yYOtFbJUi9YmVg07kIBkZGaxt27aOPHiHjknHpjSUMxF7RDO4tra2M+wTa59ogna+dkn7zW+k93N//ztrvHiRNV64IH1W/uZFbEUqNMimDGGpxXH6KV6ys1Ba8nM4yGGam5tDsE+sfQ6MJwTqfO1Ck9tuHD8uTXb7Ztaslu00ozbWxLeEjVS0BoVcCw0tpAX74pMWztc62cuXs18/+ihrjNp/u00b1nHkSNbX4+sdCVVrs63OmjVr2M6dO1lJSYnpQrfSwpn5z+nTp9mGDRtYZWWl9J1uKR8xYoRn7KOb0ZTQhKphw4Zx2+hGhCDShuLiYnbu3Ll7tvOWixfO1wqtot23rAUL2LbVq6Xvf3j+ec/bHLcQkAbQSFDoXoEDBw6YqrBOQwN7r7zyiuSwCxculL6T8HnJRnWF2rVrFysvL2cNDQ3sqaeeYn5kzpw5bOjQoQx4m7jJNwkJCcr48eM9txYu3SJPyBWW+uMkLl6GbH3xxRfZpk2bpCgLgMCJCgkJCUq/fv2ksNZLFaFLly4trX8i0atXL6kbVFVVBc/2Gc9Huz3PJ0DXJ27dHxIQEhISFKoIFLEcOXJE+uwF6BIkdS3efvtttn//fump5YkSdqelpbGbN2/6smKtWrXqnm0vv/yyZ/wGxFFUSEBISGRnoIhl/fr10rRtr4zSU3di8ODBbPv27ZIzk6hQn97rfPvtt9LyDX4EYyoQFU1ogHb37t10k9M9VzC8NmBLYyk06Dl69Gg2b948dvDgQU879bFjx6R8zc3NhWeD4IiK7PjqsJWiARpn8YKokHjQa/r06ZKwXLp0Sdru5bkONP5D3TXqtlH3DYDAiApVVhpMVPeDKQIgYaHxlnj3kckWujRL0QlBXTWqrDk5OZ4qPBIRehGUp37vHmiNqSRKt1RmxYoVZW4vFh9N09+ioucA5Bxr1671TOEXFBRIL6/ipbxyg2XLliEESBDw5DcAAEQFAABR0cVrs2kTEeQh8BKheFeGrVu3sjFjxngyc4qKiu76vtKjd4dSHhJezceglQcilTgLChAnLIhYQGAjFbWgKFsgtD7WWu0gRSwAopJQEYpRiy9XZKq0Y8eORVcI5QG8ICqRSMTTGSI7p54jJ4IDez2Pg1Yedlm8eHGh8vuSJUvKvGxvcjycxOutqJ6NieDAfqxkiVweiFTi1Pp4cRxFbaPXHFiZZ0HoBni9PIBDokLrrPA+CzRWWMuTlpP2KW1Uf/aKfXZabSv2icbr5RFPysrKfn/8+PE+Rt2h/v37nywsLPyXr0WFbpSidVasOImVtJy2z46NbtlntdV2+6a2RCyPeDJ58uTDJSUl7evr6x/Q+j09Pf0C7eP7MRV6QLTZFsGKk1AalJYb9lltgd20z0qrbcU+0Xi9POJJq1atIjNnztyTlpZ2Tf0bbZsxY8ZXtI/vRYWWlqyrq2M3btxwxFnomHRsSkNexhL2uWefaIJ2vmaJRnFNTz/99D/D4XCL8fR5+vTp/4wKS2MgxlRkR5FXgvMisA/nm0hkZGRcmzRp0p4PP/zwMfr+xBNP7MnMzLzmZZtDKDYAvE1OTs6FqPAepvlHgwYNuuB1e22JCoVijY2Nd62PG6/WLhQKNcM+sfaJJmjnK5JRo0adTBRbbY2pRMOw+pqamrifRHV1Na3V8z3sE2ufaIJ2vkHFVqSSl5d3asuWLV27devGUlJS4nICt2/fZnv37mXjxo07BfvE2ieaoJ2vXdTT89V4dbq+rUglNze3Pisrq7K0tFRaKjQa2rpmOKVFaVLaZAPZAvvE2ieaoJ1vUEmKRCKltGSGHSoqKtL37dvXu7a2Nr25uTnsSogVCjVFQ9h6av1iOQjss2efaIJ2vkGCVp4QIioAACCLCh58DQDwzpgKAABAVAAAEBUAAEQlrrzwwguFWp+t/N/OPnb291s52PmPvE1UHtr1j3jkSyL5XMiPDlxSUlLG85vRf2JB+9P/ef7Hu5/fUOeRlpObyRee4+kd34p/OOWnovLDrq+p05fz165NIT85sFYrpCciZjNLz4H1CkG93agC+FFw9MrBqDyMKgSPsxv934p/OCkoPOVuFLVZPYZ6fx7RDWykoleA6nfeyqDOZLXz8RzLTHp+jFLMiIe6BVcLs1ZexiqHWCJlxT9ERShW/MeKjfFosHzZ/VG3jHpOrFUAVkJsIDYcV0c1emVgpbHg9Q8nI2m9bkY8hEBENBSI7o9WVKEXelp1KCNHtxK6B11YYgmI2fCct7zdilR4xnV4umI83e1YA9Faoq3XLbPSqIb85rx6Ia5WS2jHkXjFQ1RBJXJ5xGqZeSpWrLESK+UTyz+c6o7b8S+z+RAPkoPgzHK3xswgIBAbnfAOKNK7svz0REbeT/ky2m7HP0SPMYmIiHnzMpaoOlEHQn5zYr0BP73frPTNg3h5WEQlMhoY5RGdWPubGZiN5R+JEo3zDubGOjeRkXTI705sJBp6rZhT4S+kxlyUyTNm5qR/JIqfG/mulS4dLinbdFI7Ib1bheTXLpHWWIPR706KvRfLyOy5a0UbZq68icqDUNDEhDdjeQd1rU4aClrkotV94Znlqo4m/CYmRld5tM7d6GqOGV9UHi9WBG82j/CQJgCAMPCQJgCAcCAqAACICgAAogIAgKgAAABEBQAAUQEAQFQAAACiAgCAqAAAICoAAIgKAABAVAAAEBUAAESFn9dff30gshMAIOwhTZ9++mkOvc+fP//reJyI2SdX8ewfa9Er5TbedEUua2nlaV3xfGyi3TIyu4Kh6LwHLouKHWHhXTrUy47B4/xWFhrnfUKalg28eWZFFO1WYitlG+vRinoPtDZ7jsBDomJVWKxUFCdWVjPbahrZblSpzT613+l1oq0ur2lWNMzYp2cDb5pWBBx4VFTc6gqJWGfWrsDoraPi9MJhoteJttrlsBKJWukC8fhBPP0BuCAqZoXFLQfgXRNFrxLEeliymQcQW1021cl1orWOZSRaZlfb411H2MoSp6K6WMDDomJGWPRaXaOFwEQ6kVa6WpXAqELwdNnMdPuMKqVexBJrf7NRDI/g8FZ0o/zREzKjfbTKC5FKAETFqa6QFSeyu26ymTECnmU77XQhtATP7jrRVhcMFxUtijo2j5CBBBcVXmHRC7ONQnyRImJ2wSqeCMSJCqRc+5en4ouywU73J9ays7HstLqglpPjWiAOotKhQ4fr5eXlnyYnJ0fifZJOVO5YYyU8C36LqJSi1om2cjWNt/tjpQvqhTE44BFRKSgo+Pro0aOdz5071/GTTz7JnDRpUq3VimO0XYQAWOlW8YwHaHVHRNslep1oN6+euCEKEB6fiAoJSlFR0bGNGzdefuONN4ZHI5UBvKJixTGM+tAi+uYiLn2aucojyk43L62LFHkeAYZYBEhUZEGhz48//vj50tLSqxSt7Ny584GRI0de4BUPPefRu0IjqpLzRAZmruRYTdvMPiLXiea1RS9qc/pcjbpWepMitT5DkJzHsbWU33333Z5vvfXWQ9nZ2d+vXr16F7IaAP/j6FrKkydPru7Ro0dDfn7+WWQ1AIhUAADAW5EKACCYQFQAABAVAABEBQAAUQEAAIgKAACiAgCAqAAAAEQFAABRAQBAVAAAEBUAAICoAAAgKgAAiAoAAEBUAAAQFQAARAUAACAqAACICgAAogIACC70NP3Z0ffRyAoAgAC2/0eAAQCcQOt8NFc6rAAAAABJRU5ErkJggg=="
    }
  })]) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.$parent.isOpenWalk),
      expression: "$parent.isOpenWalk"
    }],
    staticClass: "roamCross"
  }, [_c('div', {
    staticClass: "roamCrossW"
  }), _vm._v(" "), _c('div', {
    staticClass: "roamCrossH"
  })]), _vm._v(" "), (_vm.$parent.isOpenWalk && _vm.isMobile) ? _c('div', {
    staticClass: "phoneModeChange"
  }, [_c('div', {
    staticClass: "exit",
    on: {
      "click": _vm.exitWalk
    }
  }, [_vm._v("")]), _vm._v(" "), _c('div', {
    staticClass: "speed"
  }, [_c('span', [_vm._v("")]), _vm._v(" "), _c('svg', {
    staticClass: "roam-speed",
    on: {
      "click": _vm.moveSpeedSub
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-jian"
    }
  })]), _vm._v(" "), _c('span', {
    staticClass: "speed-value"
  }, [_vm._v(_vm._s(_vm.moveSpeed) + "x")]), _vm._v(" "), _c('svg', {
    staticClass: "roam-speed",
    on: {
      "click": _vm.moveSpeedAdd
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-jia"
    }
  })])])]) : _vm._e(), _vm._v(" "), (_vm.$parent.isOpenWalk && _vm.isMobile) ? _c('div', {
    staticClass: "phoneUpDown"
  }, [_c('div', {
    on: {
      "touchstart": _vm.startMoveTop,
      "touchend": _vm.endMoveTop
    }
  }, [_c('svg', {
    staticClass: "ccbim-icon"
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-shang"
    }
  })])]), _vm._v(" "), _c('div', {
    on: {
      "touchstart": _vm.startMoveBottom,
      "touchend": _vm.endMoveBottom
    }
  }, [_c('svg', {
    staticClass: "ccbim-icon",
    staticStyle: {
      "-moz-transform": "rotate(180deg)",
      "-o-transform": "rotate(180deg)",
      "-webkit-transform": "rotate(180deg)",
      "transform": "rotate(180deg)"
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-shang"
    }
  })])])]) : _vm._e(), _vm._v(" "), (_vm.$parent.isOpenWalk && _vm.isMobile) ? _c('div', {
    staticClass: "phoneOpenTree"
  }, [_c('svg', {
    staticClass: "ccbim-icon",
    on: {
      "click": _vm.openTree
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-shuzhuangtu"
    }
  })])]) : _vm._e(), _vm._v(" "), _c('transition', {
    attrs: {
      "name": "fade"
    }
  }, [(_vm.$parent.isOpenWalk && _vm.isMobile && _vm.phoneWalkTip) ? _c('div', {
    staticClass: "roam-box",
    staticStyle: {
      "height": "auto"
    }
  }, [_c('div', {
    staticClass: "roam-title"
  }, [_vm._v("\n        "), _c('svg', {
    staticClass: "roam-close",
    attrs: {
      "title": ""
    },
    on: {
      "click": function($event) {
        _vm.phoneWalkTip = false
      }
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "roam-content"
  }, [_c('span', [_vm._v("")])])]) : _vm._e()])], 1)
},staticRenderFns: []}

/***/ }),
/* 647 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "upload-box"
  }, [_c('span', {
    staticClass: "isShowGantt",
    on: {
      "click": _vm.decideShowGantt
    }
  }, [_vm._v(_vm._s(_vm.tipText))]), _vm._v(" "), (_vm.showPopout) ? _c('div', {
    staticClass: "popout"
  }, [_c('p', [_vm._v("Project")]), _vm._v(" "), _c('input', {
    ref: "pbimFileupload",
    attrs: {
      "id": "pbim-fileupload",
      "type": "file"
    },
    on: {
      "change": _vm.setFileName
    }
  }), _vm._v(" "), _c('label', {
    attrs: {
      "for": "pbim-fileupload"
    }
  }, [_vm._v("")]), _c('span', {
    ref: "fileName"
  }), _vm._v(" "), _c('div', {
    staticClass: "popout-button"
  }, [_c('button', {
    on: {
      "click": _vm.uploadProject
    }
  }, [_vm._v("")]), _vm._v(" "), _c('button', {
    on: {
      "click": function($event) {
        _vm.showPopout = false
      }
    }
  }, [_vm._v("")])])]) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 648 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "ccBIM"
  }, [(_vm.panoramaErrorMsg) ? _c('div', {
    staticClass: "pbim-error"
  }, [_c('div', {
    staticClass: "noModelImgBox"
  }, [_c('img', {
    attrs: {
      "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK8AAADDCAYAAAD0pEFUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCOUVGQUNBQjVEOEYxMUU4OEE4RTkwNTA4RURGMzhFNiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCOUVGQUNBQzVEOEYxMUU4OEE4RTkwNTA4RURGMzhFNiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI5RUZBQ0E5NUQ4RjExRTg4QThFOTA1MDhFREYzOEU2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI5RUZBQ0FBNUQ4RjExRTg4QThFOTA1MDhFREYzOEU2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+79ZNvAAAFgxJREFUeNrsnQtwnFd1x88+9LQeq6clrR67eku2LCchcajtcUjjITQtnTCFTqAzJBkKpaUNtEAeDdCGdBICDbQxEBgGWlqSQhgyZBxKm5BA7JA6hBC/bcmWrNeu3rJkPazXbs//7l3580ayZXm1+3275585+XY/raXv8dv7nXvuuefagsEgicytp599PnLXe/X2OePOO26/Lamui1PQsKQ+sxy8ySa7cCCSlle03rqZrVa/LtHbj+rtKbaXBF6RWfX3GmCjvqW3Lwm8IjPr9w2v9+ntTvF5RSJpeUUx0qRcAoHXqnq/XAKBV1peC8smI2wi6bCJRAKvSCTwiqTDFj0tkx21aiVbxpTIZPCKEkdmaIjMAq9D21wC3uQs3nyS7S62PWxP8s2bSXC2c9nGk6Xl9ertqQSCNoU3f872IFup3v0426f4Z1/k7fcY4oUEhXcr26+SpcN2q7ZEgNbG9qf88hjb1wFuYb6Lrt/aQnkuNEhUwfZt/ByfY0u0TjOeoA/rbcLDizt6n7Zci4N7C29+w/ZfbLU52Vm0c9t1tHvXdqr1VtKt79pB22+4lnKyNuDjdfpzb/K/S6Te6D1sO/Q2od2GfLafsLn1+71sf8w2ajFor+XNo2y78T4jI51aGuupuqqcbDbbRZ+tdJdSRVkJdXT30pET7TQ9PdOK8+bf8SpvH2BX4hULg9uiW13S2xfYDicavID1dt3aug378Y09pEF4lq3P5NBiZgP8V7gJttSUFGqqr6GGGg85HCs/NQF0TVUFeSvc1N7ZRUdPnqLZ2bnt8BP5d/4cfjJD/FuLgfu3GtgM/R7bA9rnfzyR4E01RBhWijykmhhaTMP5HNtHcJwAtb66ipobagkAr9pns9sZdK8C+cSpTjrJNjc/D9//3fw3fszbzzPEJ0ze0u6i0HSklmV+DoD/me1O7ef/KpotcUwTc5aJDcJt+KlucaH9K7kNZhik4OPPptDM3U+xZaEF9VaWU0tTHWVmZFz175+dm6PjbR3U1nGGFhcXsQvRiP9g+wc+/26TfYEjG5x7IlpeaEa3vP/Cthjtexlvn3dUw3pIvzelv8s3Ck+Bj+sbUYh95aUltGVTA+VmZ0Xt76SlptLWzY3UUOtV/nBHV48zEAggPvwhPoYneftPfOMHTdgCL2rXAD7uProQ592ZiD5vJMBfNrw2E7SIxnxQ+7Ue7CsqyFeAFebnrdvfzUhPo+u3bqamumo6fLyNunp9qfyE/Bv+0d18TGjFvsIQnzUhxAD1L9l+oLeH1/OPmWWQ4nmz3QWG5D28eYQN0QDKzcmm1k2N5C4pjtkxZG3IpHe+Yys1cyfw0LGT1OsfQDOPWcQf5+N7jLdPMMTTJrt0P9RPqR+u9x8yC7ydFIOg9iqhvVFDexPeZ2Zm0JamevJUuN8W9oqV8MXZeeM7aGTsLB08epIGhobzdUTmHj5e+JnfYYjNMrS+qN2rxWSBdzEWJ3sZaBvhU1IohGeD/9ncUEP11R4VFTCDCvJcdPOObdQ/OKxaYoYZw84Yxfs0H/8X8LhmiAMmONS3YvFHkj6rjG96GXrzFEqccTodDtVhamR/80rCXrFUSXGhsl5/P0PcRuMT55Ab8n22e/l80Or9lCGO5/yu8Vj8kaSdw8Y32YWbrUM8GWrgwFNJmxvrVIfJKsL96+rxqY7d5PSS+/s6fGMG+MV1vH5r/rfRCpUlHbx80TN0T/h+PImxD0O2W5obKDuUc2BJBQIBOn2mh46ebKeZ87Ph3b/QEB9IxHuZNPDqsNeHtYtQiX0biwpo66ZGys9zJcx5YnDj5OkzdLz9NM3NzYd3YyAIQ85HBF7rgfteHUFoxvs8Vw61NjdS6caihD3nufl5OtHeoUBeWFBpw+jIPcX2BYa4Q+A1P7RIdvkSG7Yqbgr3AG5CvMJesdb52TnlSpzq7FauBYVmq3yX7SGG2C/wmg/aZt3SqvL36WmptIk7YrXcITNL2CvWmp6eocMn2qmzu5f0PUfewRNsjzHEIwJv/KGt1D4tfFu70+lUQ6yNtV7CaxHRxLlJFZno7ltqdDHMjLyErzLEkwJv7KEt0NEDRBEy0LrW6rBXWlqqELuMRs+Oq4EO/8BQeBdeYJAGE0RnBd71hxZhL8zM/SybC35sOOwF/1Z0eQ0OjzLEJ2hoZCy8C6mXD7H9u9kniFoSXoYWPsDd2kVQM3MROUAEAZEE0ZXL1z9IB7klPjs+Ed51ku3zbM/EebQuMeDFzFzevE8/3hqwDzFaxGoRsxVdncBCD/vCh9gnPjc5Fd79JtvnGOCfCbxrB/cmCmVSbcN7jIaFw16i6EPc0dVDR06coumZpfooSDLHBNH9Au+VgYuW9oHwe7S2N2/fRikpEkFYT2G07pX/e0NlsRn0KAN8vxmOzypBzwcv6imPnaW9L7yshkD16JEoykIU4sVXXjOCG65mdJ9ZjtES8Bo7DNdsbqDcnCw1cvTWkRP03P+8rKaOzwvEUdHw6Bj9Yt9r9Mtfv67Caay+onzXnlt23DBktmO13HO3kF0G2MjYOHX29NHY+DkVr8Q4PvJw62s8ps3DNbMQZcB17Otfmt85nO/K2bu1uWGzw2H/hBmP2bJOY0FerrLRsxPU0Q2IJ9TI0YlTHaoWAiw1VSC+nM5NTYVG3Hr94WHjybzc7P9uba5vSHE67zTzsVu+x8OtgzK0wIAYjzpMG0cBD7TCaI0xpUd0sWZmztORk+0qB1hDO5ubnfUSQ+tJS02xxFJZCdNd59aCrmtppLMTgNinJivCF0ZKYJ23khrralSCTrIrVNjkNLV1dC0VNsnekPlqa3OdOyM9/T1WOpeEizW5crLpWu7UjZ+bVC3x8OhZOt7eoW5WnbdKJeqkW2iaT7SEqAxKSsGtmp9XndvghsyMN7Y01hVnbcjYZcVzSthAKSrZXLOpgSYmpxTEGLvHjUNhuxpPBTVzS4xqjoku5PC28xf3aJsq5qf2cQt7tKWxxsXX6Horn1vCR/lRC3drcz13TKYVxIPDo8G202dsSM5WENfXRKXOmNmkRskulFFV+9ht6thUX52V78rdlAjnmDRDVOzXUWtTHU1OTds6e3zUPzQS5BbJhg4L6ug219cSP0YT4lyRq3v42En11IFSU1N8TTWe9OLC/OpEuqdJN76KVMmWxlqqrnTbOnr6aGBwJMitsA1j+d6KclWm1KrplBgVQ2bYWGhwgVKczuH66qqU0o2FZYk46SlpkwPQyrY0AOJyWye7E2iJT3f12PCoRWmnTfwzq0yFhz+PnFzk5qqb6nBM1Hoq7OWlxYWJPFcv6TNbNnCnbXNDDdVUuRliH/kGhwOd3b32M9wqV5WXKYhzoljGNJqKHBVz2O3TeKJUuktykmGunqRlaXEPnP3eavJWuu3sEwd9A0NBBtje1etTaZeAGAXvzCA1KnYsNA8NHTO7zTZXVV4a9FSUZTodjqS5ZwLv2yBOo+Y6rw0tGCDmVi3IANsBSnnpRjUvzpUbn9kakaNi7BIsVJSVBGsq3anJmB4q8K4gjMY11XoY4rIQxP7BQI+v38GmqqJv5k6fXldt3RU5KsZebMC9sShQXVXuTOZRQ4H3MkJeRGONx+atcDvO9PqCvQxxr7/fgQqNKDSNehAF61QuaplRMdpYmL9Y46lwsK9uT/Z7I/CuGuIUaqiuYojLGGJ/sMc3sMguhROdJUz+hDsRrVL/y42K8RckUOspt+dkbXDI3RB41yTkCtd7K22e8lJnV19/sLuvf8E/MJSCGCtq5gJirFuxFi03KubKyQ7WeipsebnZdrn6Am/UIK5jqBjilK5eQOxf6B8cTsG0meLCAgXxlcxojhwVy9qQGcTvL8x32eRqC7zrohSnk/hxbqsqL0nhVjjQxRAPDo+kvrR/RLXAgBgt8kqKHBXLzEinmqpygG8TagXemEHM0NmryktTATH7xfNDI6NpL796QPnCgNhYUjVyVAwdw+oqN7n5MzbBVuCNywV1OJA3Ya90l6Rxpy5wpsc3Nzw6lo4JjYhK1FVXqcIe4VExxGe95WVUUbYxaStYCrwmhNhbUWavLCtJ7/EPBDp7+mZHxs5mjPw2tPYf1iuucpcQt9SUTKNiAq+F5HDYiTt1dm5ZM7gVZoh9dqfTQduva5WiKQLv29XrH1SPZWSO8eNbJaTHHWJ2CdwlxXYkxOO1WcBF+f/uvgHy6VKnTXUeKlrHpWkF3ktocmqajp/qVK8RdvIPDqsp8h72K/OlguSSULSlqzfkey8GLqw7eKy9k3ZtE3jjouUq56BACQzz2jwVZVRUkEfJ2p+fnjlPaiYJf6kDuk5dmqpvYVM5FFaqGpqQs4cL811q1nCkMKP44LE25U6wH6rir/YkCUuhZCmgRWguqFBV04PUdlYveYVoR723SuCNlxAjxazhUDkon6qkE6mp6Rk62tZBp7t6ucdfqhJs0LFKRKEYC3cUaXjs7NL1SdXrc4TXaUO0o7y0WF0LK1UZStjubrgcFFpbQDw8MkbBZfy+kx1dhLlslWUlKtaakiALr+DJg/NGEZZwqwpI4Ragkwah0xjL877ckq9Xuqxrwsdq4Odi6jtaWz1r+G1+HdIN0Qqf4Q5MObfCiFBYMU8WZzXA54eWFlP9w9DiqRIMXIAW54bZIeUWf+IkTaARfi7mqtV6yrmX3f+2XjaERO+uPj8h4byU/WF07jItUJgEHS//wDB/+XyqQwYhHAdwA8HAUi4wzgW+Poap4+zru9m+wXYr288ptIpTn8B7GaWnpVFDTRV5K8sY0gFlkREKwNA3MKRin0WF+RgpM0WsOFKLiwH1JcQX7rzO+7UraG0U4JY2fF6oWYEv4kY+F5PkTXyPbbd+jYUeMSXlJoF3lUJKI7K3MDzb5wcA/SpUFPkYRu8clu/KVRCbIVYMKPGl6+YnRLhVRUtr09AuLCwuRV5wzIi+mEzvvMx7gXdVFwA5BgxwBfu5SE+E3xt+9BqF0qmwnOwNKpEGLXKs2zBEB9DKYgRxIVThMQQtt6ZwgYILAd1ZdTG0pZSXa9pBmdcMLW/4vcC7VsEHRMisjA0tLTo9ExeWc1rSxLkpOni8XYGBkqqxegz72KfFyKFe/Fp3tGzqfZANRwG3wGNSFydCH2H7lsHn/ZjAGwWFIYAhVoxOEKqvRwrxY4ShYtW6YeYwQLWrljbk76rj5Tdl3AFDR8xCtdawyuZV1wIWeC8hY6wYLfGQIVYMaGJZcT2c67vU8vJ7PCUArVXCelcaxxV4oyDEilt1rLibO0pYWA8uRizDaE21HpU0E+T/wrHoZF84Zl3hXWlEJdrfwFgJj2VAFA8hmWhXQZ60JMankVwCkcB7aT1MobDpw3LJRVaD956IrUhkGXj3RGxFIstEG+7XJhJZA16rRhVE4jaIRAKvSCTwigRekUjgXYMiE8ZFAq8VpBK69v/mIB0/dYZmzs/K3RN4LaNr2Z4JsHr9A/TqGwfpaNtpmlpm1oMo+po5b77rbJmUyN07t73Fmw+8sO9AE2/vDQaDH/INDDsxa7YYkyQr3WqioSi6whR65DIP6CLYrIDAu3aIj/PmTob4H3n7WfYl7uILm4aLW5TvUhDnmnS5VSsJM0U6e/w0MrZUNgudjf9ke8wsx2izSmG14eHhZfczxKgB8HdsH2VTk7cww9db4TZdVUhMT9/3+u/UzIedN1xjyuuM2SKdvT4an5gM78KLb7N9lRuOXuwoLCwUeKMBrwFiLPjwSba/olAdANNN/TYrvGCgX1famdRLaOGSsz3BtoehHTV+XuCNMrwGiAHuX1Mo/VJd5eysDQri4jhMVzczvJgu7+sPTfc/P7sUvcHkyMfZvsPQTi337wTedYLXADFcCEyp/jRbKfZhGg8gLikqiEvlGLPAGy5aAgvXL2MdY/sy2w8Y2vlL/XuBd53hNUCcxpu70blj82AfVnZHfYMy1OeN4Qo88YYXAzyoDNRnKFrCOsD2KNtzDO2qIgkCb4zgNUCMqbYfpFBecQP2Yeo6po67S4vVVPJEhRcVgOAaYImDwIXigv/L9ggD+8sr/X0Cb4zhNUAMSv+E7QG2VuzDFHJMJUed2vVcVirW8KLizxlDNXQKxWh/zPYlhvbNtf5egTdO8BoghtP7hxriG7EPS0yh2DJsPVbriRW8qPCDSj+o+BP2GNi+D5+WoW2/2t8v8MYZ3giQb9EQvwvvscAfCnugAF9aFMvcrye8uIuI0aKlRYUfLZRFR00wxGh90fpbZoFXKuaQGrV7kTcvMsS/B4gXFxf/oKvPb+vxD6i1gAExOnlmFBof+LLwaacuxGixNixitF/ncxtL1Psm8F4M8a/hSjDEaBYf4M7N+xhge2//oKqU7jVRpfTlCkuzuti+wvZdPpfpRL9fAu/yEP+ON+/XSUD3c+t2h29gyIn6vRuLChTEWXFKAlqusDTrKDphbE/zsS8ky30Sn3d1PrGXN/exfZhN+Q+oHQaIryQJ6Gp8XvzbbhSW7h9Sa2dooSjzI2x7GdqY3UjpsFkIXgPESALCiB2SgFTTi3L/1ZVlq6rTuxZ44cd2hWO0oXuF/6Eg86MM7CvxuA4CrwXhNUAcTgL6BJuiViUBMcSFea6owIsK7MjuGroQo0Vz+yO2x3Ruc9wk8FoYXgPELg0wQC7AvhydBLTcmhWrgRcx2s6ePmM1dkxh+Dd0xBja02Y4b4E3AeA1QJylXYmlJKAsrG8ckQS0ErwqRsstbOfF62CA3m+yfY2h7TfT+Qq8CQSvAWLE0ZAE9BlaSgJKVyvzYOE+rOZjhDegY7RdDK1hLh5itF9j+wZDO27G8xR4ExBeA8QYlvsztntJJwEB2LKSIuro6lOLUyMhqLuv3xij7aQLMVpTzyoVeBMYXgPESAL6AIXCbK0rfOwQhWK0P7JKjFbgTQJ4DRDD6f0jtqdIz7Nj7adQHu3PYhmjFXgF3rVCfBfcArZZBjbdquch8IpEVykptCcSeEUigVckEnhFAq9IJPCKRAKvSCTwigRekUjgFYmuRDJ7OEJPP/v8Pt7sWMVH999x+2075YpJy2tF2eQSxPkGSGKOSFpekUh83jX7oFcq8Vml5RWfVRSnG/jUT/bKVYivqii0gtHNbJi4iaLPT1Ko3L7Iym5DggvTgvaQLh2ltYVCNdH+lULryy3KZRK3wWz6IoXms2Wu4NJgKa5n2BxyqQReM+khtgdX8bnbdcssWsFtkEBv/IU6/CgV1a393UrDz/5CW6x1WLswRqHGRIv4vKKwsDL1rYYO2o36dYVcGnEbzCzUItsdEVnws93GNi2XR+A1M7hocd9Y4ZH9MblEl5bkNoik5RWJBF6RSOAVCbwikcArEgm8IpHAKxJ4RSKBVyQSeEUCr0gk8IpEAq9IJPCKBF6RSOAViQRekcArEgm8IpHAKxIJvCKBVyQSeEUigVck8IpEAq9IJPCKRAKvSOAViQRekUjgFQm8IpHAKxIJvCKRwCsSeEUigVckEnhFAq9IJPCKRAKvSCTwigRekUjgFYkEXpHAKxIJvCKRwCsSrUL/L8AAKAA98WjsSD0AAAAASUVORK5CYII="
    }
  }), _vm._v(" "), _c('p', {
    staticStyle: {
      "user-select": "text"
    }
  }, [_vm._v(_vm._s(_vm.panoramaErrorMsg))])])]) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "panorama",
    staticStyle: {
      "display": "grid"
    }
  }), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.isLoading),
      expression: "isLoading"
    }],
    staticClass: "panoramaLoading"
  }, [_c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  }), _vm._v(" "), _c('div', {
    staticClass: "loading"
  })]), _vm._v(" "), (_vm.isNew) ? _c('div', {
    staticClass: "panoramaMenu"
  }, [_c('div', {
    staticClass: "menuBtn"
  }, [_c('div', {
    staticClass: "switch",
    class: {
      on: _vm.menuShow, hover: _vm.menuHover
    },
    attrs: {
      "title": ""
    },
    on: {
      "mouseenter": function($event) {
        _vm.menuHover = true
      },
      "mouseleave": function($event) {
        _vm.menuHover = false
      },
      "click": function($event) {
        return _vm.showHiddenMenu()
      }
    }
  }, [_c('svg', {
    staticClass: "menuIcon",
    attrs: {
      "aria-hidden": "true"
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-caidan-copy"
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "switch",
    class: {
      on: _vm.pointShow, hover: _vm.pointHover
    },
    attrs: {
      "title": ""
    },
    on: {
      "mouseenter": function($event) {
        _vm.pointHover = true
      },
      "mouseleave": function($event) {
        _vm.pointHover = false
      },
      "click": function($event) {
        return _vm.showHiddenPoint()
      }
    }
  }, [_c('svg', {
    staticClass: "menuIcon",
    attrs: {
      "aria-hidden": "true"
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-yanjing"
    }
  })])])]), _vm._v(" "), _c('transition', {
    attrs: {
      "name": "fade"
    }
  }, [_c('ul', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: (_vm.showMenuList),
      expression: "showMenuList"
    }],
    staticClass: "imgList"
  }, _vm._l((_vm.panorama.panoramaArray), function(item) {
    return _c('li', {
      class: {
        on: item.current
      },
      on: {
        "click": function($event) {
          return _vm.menuClick(item)
        }
      }
    }, [_c('span', {
      staticClass: "hoverName"
    }, [_vm._v(_vm._s(item.curCameraName))]), _vm._v(" "), _c('img', {
      staticClass: "on",
      attrs: {
        "src": item.previewImg
      }
    }), _vm._v(" "), _c('p', [_vm._v(_vm._s(item.curCameraName))])])
  }), 0)])], 1) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 649 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: _vm.classes,
    attrs: {
      "role": "tree"
    }
  }, [_c('ul', {
    class: _vm.containerClasses,
    attrs: {
      "role": "group"
    }
  }, _vm._l((_vm.data), function(child, index) {
    return _c('tree-item', {
      key: index,
      attrs: {
        "data": child,
        "allow-transition": _vm.allowTransition,
        "on-item-checked-click": _vm.onItemCheckedClick,
        "on-item-text-click": _vm.onItemTextClick,
        "klass": index === _vm.data.length - 1 ? 'tree-last' : ''
      }
    })
  }), 1)])
},staticRenderFns: []}

/***/ }),
/* 650 */
/***/ (function(module, exports) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('transition', {
    attrs: {
      "name": "fade"
    }
  }, [(_vm.showSettingBox.show) ? _c('div', {
    staticClass: "setting-box"
  }, [_c('div', {
    staticClass: "setting-tile"
  }, [_vm._v("\n      \n      "), _c('svg', {
    staticClass: "setting-close",
    attrs: {
      "title": ""
    },
    on: {
      "click": _vm.closeSetting
    }
  }, [_c('use', {
    attrs: {
      "xlink:href": "#icon-guanbi"
    }
  })])]), _vm._v(" "), _c('ul', {
    staticClass: "setting-content"
  }, [_c('li', {
    staticClass: "clear"
  }, [_c('div', {
    staticClass: "setting-way"
  }, [_vm._v("")]), _vm._v(" "), _c('div', {
    staticStyle: {
      "float": "left"
    }
  }, [_c('div', [_c('span', {
    staticStyle: {
      "float": "left"
    }
  }, [_vm._v("")]), _vm._v(" "), _c('div', {
    staticClass: "strip-box"
  }, [_c('div', {
    staticClass: "strip",
    on: {
      "mousedown": function($event) {
        $event.stopPropagation();
        return _vm.stripDown($event)
      },
      "mouseup": function($event) {
        $event.stopPropagation();
        return _vm.stripUp($event)
      },
      "mousemove": function($event) {
        $event.stopPropagation();
        return _vm.stripMove($event)
      }
    }
  }, [_c('div', {
    staticClass: "strip-all"
  }), _vm._v(" "), _c('div', {
    staticClass: "strip-current",
    style: ({
      width: _vm.stripWidth + 'px'
    })
  })]), _vm._v(" "), _c('div', {
    staticClass: "strip-btn",
    style: ({
      left: _vm.stripWidth - 4 + 'px'
    }),
    on: {
      "mousedown": function($event) {
        _vm.isStripDown = true
      },
      "mouseup": function($event) {
        _vm.isStripDown = false
      }
    }
  })]), _vm._v(" "), _c('span', {
    staticStyle: {
      "float": "left"
    }
  }, [_vm._v("")])]), _vm._v(" "), _c('p', {
    staticClass: "text-tip"
  }, [_vm._v("")])])]), _vm._v(" "), _c('li', {
    staticClass: "clear"
  }, [_c('div', {
    staticClass: "setting-way"
  }, [_vm._v("")]), _vm._v(" "), _c('label', {
    staticClass: "setting-switch-label"
  }, [_c('span', {
    staticStyle: {
      "width": "42px"
    }
  }, [_vm._v(_vm._s(_vm.showBorder))]), _c('input', {
    staticClass: "setting-switch setting-switch-anim",
    attrs: {
      "type": "checkbox"
    },
    domProps: {
      "checked": _vm.checkedBorder
    },
    on: {
      "change": function($event) {
        return _vm.switchBorder($event.target.checked)
      }
    }
  })])]), _vm._v(" "), _c('li', {
    staticClass: "clear"
  }, [_c('div', {
    staticClass: "setting-way"
  }, [_vm._v("")]), _vm._v(" "), _c('label', {
    staticClass: "setting-switch-label"
  }, [_c('span', {
    staticStyle: {
      "width": "42px"
    }
  }, [_vm._v(_vm._s(_vm.showShadow))]), _c('input', {
    staticClass: "setting-switch setting-switch-anim",
    attrs: {
      "type": "checkbox"
    },
    domProps: {
      "checked": _vm.checkedShadow
    },
    on: {
      "change": function($event) {
        return _vm.switchShadow($event.target.checked)
      }
    }
  })])]), _vm._v(" "), _c('li', {
    staticClass: "clear"
  }, [_c('div', {
    staticClass: "setting-way"
  }, [_vm._v("")]), _vm._v(" "), _c('label', {
    staticClass: "setting-radios-label setting-radios-anim"
  }, [_c('input', {
    attrs: {
      "type": "radio",
      "name": "effect",
      "value": "2"
    },
    domProps: {
      "checked": _vm.checkedTexture
    },
    on: {
      "change": function($event) {
        return _vm.radioEffect($event.target.value)
      }
    }
  }), _c('i', {
    staticClass: "setting-radios"
  }), _vm._v("\n        ")]), _vm._v(" "), _c('label', {
    staticClass: "setting-radios-label setting-radios-anim"
  }, [_c('input', {
    attrs: {
      "type": "radio",
      "name": "effect",
      "value": "1"
    },
    domProps: {
      "checked": _vm.checkedColor
    },
    on: {
      "change": function($event) {
        return _vm.radioEffect($event.target.value)
      }
    }
  }), _c('i', {
    staticClass: "setting-radios"
  }), _vm._v("\n        ")])]), _vm._v(" "), _c('li', {
    staticClass: "clear"
  }, [_c('div', {
    staticClass: "setting-way"
  }, [_vm._v("")]), _vm._v(" "), _c('label', {
    staticClass: "setting-radios-label setting-radios-anim"
  }, [_c('input', {
    attrs: {
      "type": "radio",
      "name": "antialias",
      "value": "1"
    },
    domProps: {
      "checked": _vm.checkedSystemDefault
    },
    on: {
      "change": function($event) {
        return _vm.radioAntialias($event.target.value)
      }
    }
  }), _c('i', {
    staticClass: "setting-radios"
  }), _vm._v("\n        ")]), _vm._v(" "), _c('label', {
    staticClass: "setting-radios-label setting-radios-anim"
  }, [_c('input', {
    attrs: {
      "type": "radio",
      "name": "antialias",
      "value": "2"
    },
    domProps: {
      "checked": _vm.checkedSoftwarePower
    },
    on: {
      "change": function($event) {
        return _vm.radioAntialias($event.target.value)
      }
    }
  }), _c('i', {
    staticClass: "setting-radios"
  }), _vm._v("\n        ")])])]), _vm._v(" "), _c('div', {
    staticClass: "sure-save-btn",
    on: {
      "click": _vm.saveSetting
    }
  }, [_vm._v("")])]) : _vm._e()])
},staticRenderFns: []}

/***/ }),
/* 651 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 652 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(231);


/***/ })
/******/ ]);
});